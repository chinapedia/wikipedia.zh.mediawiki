{{redirect|死結|有關繩結上的死結|單結}}
{{multiple issues|
{{expand|time=2015-03-22T23:24:15+00:00}}
{{expert|time=2015-03-22T23:24:15+00:00}}
{{Refimprove|time=2021-04-12T12:11:19+00:00}}
}}
{{NoteTA
|G1 = IT
|1 = zh-hans:循环; zh-hant:循環;
}}
[[File:Process_deadlock.svg|thumb]]

'''死锁'''（{{lang-en|deadlock}}），又譯為'''-{zh-cn:死结; zh-tw:死鎖;}-'''，計算機科學名詞。當兩個以上的運算單元，雙方都在等待對方停止執行，以取得系統資源，但是沒有一方提前退出時，就稱為死結<ref name=coulouris>{{cite book|last=Coulouris|first=George|publisher=Pearson|year=2012|title=Distributed Systems Concepts and Design|url=https://archive.org/details/distributedsyste0000coul_e0z4|page=[https://archive.org/details/distributedsyste0000coul_e0z4/page/716 716]|isbn=978-0-273-76059-7}}</ref>。在多工[[作業系統|作業系統]]中，作業系統為了協調不同线程，能否取得系統資源時，為了讓系統正常運作，必須要解決這個問題。另一種相似的情況稱為「活锁」。

== 简介 ==
例如，一个[[进程|进程]] p1占用了显示器，同时又必须使用打印机，而打印机被进程p2占用，p2又必须使用显示器，这样就形成了死锁。
因為p1必須等待p2釋出打印機才能夠完成工作並釋出螢幕，同時p2也必須等待p1釋出顯示器才能完成工作並釋出打印機，形成循環等待的死結。

== 起因 ==
如果系统中只有一个进程，当然不会产生死锁。如果每个进程仅需求一种系统资源，也不会产生死锁。不过这只是理想状态，在现实中是可遇不可求的。

死锁的四个条件是：
*'''禁止抢占'''（no preemption）：系統資源不能被强制从一个进程中退出。

*'''持有和等待'''（hold and wait）：一个进程可以在等待时持有系统资源。

*'''互斥'''（mutual exclusion）：資源只能同時分配給一個行程，無法多個行程共用。

*'''循环等待'''（circular waiting）：一系列进程互相持有其他进程所需要的资源。

死锁只有在四个条件同时满足时發生，预防死锁必須至少破坏其中一項。

== 預防 ==
系統也可以尝试回避死锁。因为在理论上，死锁总是可能产生的，所以操作系统尝试监视所有进程，使其没有死锁。

== 消除 ==
最简单的消除死锁的办法是重启系统。更好的办法是终止一个进程的运行。

同样也可以把一个或多个进程回滚到先前的某个状态。如果一个进程被多次回滚，迟迟不能占用必需的系统资源，可能会导致[[饥饿_(操作系统)|资源匮乏]]。

== 活結 ==
'''活結'''（{{lang|en|livelock}}），與死結相似，死結是行程都在等待對方先釋放資源；活結則是行程彼此釋放資源又同時占用對方釋放的資源。當此情況持續發生時，儘管資源的狀態不斷改變，但每個行程都無法取得所需資源，使得事情沒有任何進展。

== 範例 ==
假設兩人正好面對面碰上對方：
*死結：兩人互不相讓，都在等對方先讓開。
*活結：兩人互相禮讓，卻恰巧站到同一側，再次讓開，又站到同一側，同樣的情況不斷重複下去導致雙方都無法通過。
== 参见 ==
*[[競爭危害|競爭危害]]

==参考文献==
{{reflist}}

{{并发计算}}

[[Category:操作系統技術|Category:操作系統技術]]
[[Category:協同控制|Category:協同控制]]
[[Category:程式錯誤|Category:程式錯誤]]