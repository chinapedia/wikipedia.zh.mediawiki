{{multiple issues|
{{expand|time=2015-03-22T23:24:15+00:00}}
{{expert|time=2015-03-22T23:24:15+00:00}}
{{unreferenced|time=2015-03-22T23:24:15+00:00}}
}}
{{NoteTA
|G1 = IT
}}
[[File:Process_deadlock.svg|thumb]]
'''死锁'''（{{lang-en|Deadlock}}），又譯為'''-{zh-cn:死结; zh-tw:死鎖;}-'''，計算機科學名詞。當兩個以上的運算單元，雙方都在等待對方停止執行，以取得系統資源，但是沒有一方提前退出時，就稱為死結。在多工作業系統中，作業系統為了協調不同行程，能否取得系統資源時，為了讓系統運作，必須要解決這個問題。

这里指的是[[进程|进程]]死锁，是个計算機技术名词。它是[[操作系统|操作系统]]或软件运行的一种状态：在多工系統下，当一个或多个进程等待系统资源，而资源又被进程本身或其他进程占用时，就形成了死锁。有个变种叫[[活锁|活锁]]。

== 简介 ==
例如，一个[[进程|进程]] p1占用了显示器，同时又必须使用打印机，而打印机被进程p2占用，p2又必须使用显示器，这样就形成了死锁。
因為p1必須等待p2釋出打印機才能夠完成工作並釋出螢幕，同時p2也必須等待p1釋出顯示器才能完成工作並釋出打印機，形成循環等待的死結。

== 死锁的预防 ==
如果系统中只有一个进程，当然不会产生死锁。如果每个进程仅需求一种系统资源，也不会产生死锁。不过这只是理想状态，在现实中是可遇不可求的。

死锁的四个条件是：

'''禁止抢占''' no preemption - 系統資源不能被强制从一个进程中退出

'''持有和等待''' hold and wait - 一个进程可以在等待时持有系统资源

'''互斥''' mutual exclusion - 只有一个进程能持有一个资源

'''循环等待''' circular waiting - 一系列进程互相持有其他进程所需要的资源

死锁只有在这四个条件同时满足时出现。预防死锁就是至少破坏这四个条件其中一項，即破坏“禁止抢占”、破坏“持有等待”、破坏“资源互斥”和破坏“循环等待”。

== 死锁的避免 ==
我们也可以尝试回避死锁。因为在理论上，死锁总是可能产生的，所以操作系统尝试监视所有进程，使其没有死锁。

== 死锁的消除 ==
最简单的消除死锁的办法是重启系统。更好的办法是终止一个进程的运行。

同样也可以把一个或多个进程回滚到先前的某个状态。如果一个进程被多次回滚，迟迟不能占用必需的系统资源，可能会导致{{tsl|en|Starvation (computer science)|进程饥饿}}。

== 参见 ==
*[[競爭危害|競爭危害]]

== 外部連結 ==


[[Category:操作系統技術|Category:操作系統技術]]
[[Category:協同控制|Category:協同控制]]
[[Category:程式錯誤|Category:程式錯誤]]