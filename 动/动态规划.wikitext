{{Multiple issues|
{{refimprove|time=2018-09-28T16:50:41+00:00}}
{{Expand language|1=en|time=2020-09-27T11:57:50+00:00}}
}}
{{NoteTA
|G1 = IT
}}
'''动态规划'''（{{lang-en|Dynamic programming}}，简称{{lang|en|DP}}）是一种在[[数学|数学]]、[[管理科学|管理科学]]、[[计算机科学|计算机科学]]、[[经济学|经济学]]和[[生物信息学|生物信息学]]中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划常常适用于有重叠子问题<ref>S. Dasgupta, C.H. Papadimitriou, and U.V. Vazirani, ''''Algorithms'''', p 173, available at http://www.cs.berkeley.edu/~vazirani/algorithms.html {{Wayback|url=http://www.cs.berkeley.edu/~vazirani/algorithms.html |date=20131018100244 }}</ref>和{{Link-en|最优子结构|Optimal substructure}}性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其[[记忆化|记忆化]]存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈[[指數增長|指數增長]]时特别有用。

== 概述 ==
<!--
撰写中，未完成
-->
动态规划在查找有很多'''重叠子问题'''的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存[[递归|递归]]时的结果，因而不会在解决同样的问题时花费时间。

动态规划只能应用于有'''最优子结构'''的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。

== 适用情况 ==
# 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态規劃算法解决问题提供了重要线索。
# 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。
# 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态規劃算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。

== 实例 ==
切割钢条问题,Floyd最短路问题,最大不下降子序列,矩阵链乘,凸多边形三角剖分,0-1背包,最长公共子序列,最优二分搜索树

==== 背包问题 ====
[[背包问题|背包问题]]作为[[NP完全|NP完全]]问题，暂时不存在[[多項式時間|多项式时间算法]]。动态规划属于背包问题求解最优解的可行方法之一。此外，求解背包问题最优解还有搜索法等，近似解还有[[贪心法|贪心法]]等，分数背包问题有最优贪心解等。
背包问题具有最优子结构和重叠子问题。动态规划一般用于求解背包问题中的整数背包问题（即每种物品所选的个数必须是整数）。
解整数背包问题：
设有<math> n </math>件物品，每件价值记为<math> P_i </math>，每件重量记为<math> W_i </math>，用一个最大重量为<math> W</math>的背包，求装入物品的最大价值。
在总重量不超过''W''的前提下，我们希望总价格最高。对于''Y'' ≤ ''W''，我们将在总重量不超过''Y''的前提下，总价格所能达到的最高值定义为''A''(''Y'')。''A''(''W'')即为问题的答案。

显然，''A''(''Y'')满足：
* ''A''(0) = 0
* ''A''(''Y'') = max { ''A''(''Y - 1''), { ''p<sub>j</sub>'' + ''A''(''Y'' - ''w<sub>j</sub>'') | ''w<sub>j</sub>'' ≤ ''Y'' } }
其中，''p<sub>j</sub>''为第''j''种物品的价格。

对于特例0 1背包问题（即每件物品最多放1件，否则不放入）的问题，我们将在总重量不超过''Y''的前提下，前''j''种物品的总价格所能达到的最高值定义为''A''(''j'', ''Y'')。

''A''(''j'', ''Y'')的递推关系为：
* ''A''(0, ''Y'') = 0
* 如果''w<sub>j</sub>'' > ''Y'', ''A''(''j'', ''Y'') = ''A''(''j'' - 1, ''Y'')
* 如果''w<sub>j</sub>'' ≤ ''Y'', ''A''(''j'', ''Y'') = max { ''A''(''j'' - 1, ''Y''), ''p<sub>j</sub>'' + ''A''(''j'' - 1, ''Y'' - ''w<sub>j</sub>'')}

参考[[Pascal语言|Pascal]]代码
<syntaxhighlight lang="pascal">
for i:=1 to n do
  for v:=totv downto v[i] do
    f[v]:=max(f[v],f[v-v[i]]+p[i]);
writeln(f[totv]);
</syntaxhighlight>

参考[[C++|C++]]代码（不含include和数组声明）
<syntaxhighlight lang="c++">
#define max(x,y) (x)>(y)?(x):(y) //max宏函数，也可以自己寫或者使用algorithm
for(int i=1;i<=n;i++)
  for (v=totv;v>=v[i];v--)
    f[v]=max(f[v],f[v-v[i]]+p[i]);
printf("%d",f[totv]); //或std::cout<<f[totv];
</syntaxhighlight>

== 使用动态规划的算法 ==
* [[最长公共子序列|最长公共子序列]]
* [[Floyd-Warshall算法|Floyd-Warshall算法]]
* [[维特比算法|Viterbi算法]]
* 求解[[馬可夫決策過程|馬可夫決策過程]]下最佳策略<ref>{{cite book |author1=Richard S. Sutton |author2=Andrew G. Barto |title=Reinforcement Learning: An Introduction |date=2018 |publisher=The MIT Press |page=73 |edition=Second Edition |url=http://incompleteideas.net/book/the-book-2nd.html |access-date=2020-08-22 |archive-date=2022-01-18 |archive-url=https://web.archive.org/web/20220118121938/http://incompleteideas.net/book/the-book-2nd.html |dead-url=no }}</ref>

== 参考 ==
<references/>

== 外部链接 ==

{{算法}}
{{Authority control}}
[[Category:最优化算法|Category:最优化算法]]