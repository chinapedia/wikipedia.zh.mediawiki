{{DISPLAYTITLE:C#}}
{{NoteTA
|G1 = IT
|G2=Communication
}}
{{about|微软開發的程序设计语言|音樂上的音名|C♯ (音名)}}
{{Infobox programming language
|name = C#
|logo = [[File:C_Sharp_wordmark.svg|150px]]
|paradigm = [[結構化程式設計|结构化]]、[[面向对象的程序设计|面向对象]]、[[泛型|泛型]]
|year = {{start date and age|2000}}
|designer = [[微软|微软]]
|family = [[C語言|C]]
|developer = [[微软|微软]]
|latest release version = 10<ref>{{Cite web | url=https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10 | title=What's new in C# 10 | accessdate=2022-02-16 | archive-date=2022-02-08 | archive-url=https://web.archive.org/web/20220208222424/https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10 | dead-url=no }}</ref>
|latest release date    = {{start date and age|2021|11|08}}
| latest preview version =
| latest preview date =     
|typing =
|implementations = [[.NET_Core|.NET Core]]、[[.NET框架|.NET Framework]]、[[Mono|Mono]]、[[DotGNU|DotGNU]]
|dialects = [[Cω|Cω]]、{{tsl|en|Spec Sharp||Spec#}}、{{tsl|en|Polyphonic C sharp||Polyphonic C#}}
|influenced_by = [[C++|C++]]、[[Java|Java]]、{{tsl|en|Eiffel||Eiffel}}、[[Modula-3|Modula-3]]、[[Object_Pascal|Object Pascal]]
|influenced = [[Clojure|Clojure]]、<ref>{{cite web |url=https://web.archive.org/web/20170111184835/http://www.codequarterly.com/2011/rich-hickey/ |title=Rich Hickey Q&A by Michael Fogus |access-date=2017-01-11}}</ref> [[D語言|D語言]]、{{tsl|en|F Sharp||F#}}、[[Java|Java]] 5、[[Nemerle|Nemerle]]、{{tsl|en|Vala||Vala}}
|operating_system = [[Microsoft_Windows|Windows]]、[[Linux|Linux]]、[[MacOS|Mac OS X]] 、 {{tsl|en|Android||Android}}
|license = {{plainlist|
*Roslyn compiler: [[MIT_License|MIT License]]<ref name="auto">{{Cite web|url=https://github.com/dotnet/roslyn|title=The Roslyn .NET compiler provides C# and Visual Basic languages with rich code analysis APIs.: dotnet/roslyn|date=November 13, 2019|via=GitHub}}</ref>
*[[.NET_Core|.NET Core]]: [[MIT_License|MIT License]]<ref>{{Cite web|url=https://github.com/dotnet/coreclr|title=CoreCLR is the runtime for .NET Core. It includes the garbage collector, JIT compiler, primitive data types and low-level classes.: dotnet/coreclr|date=November 13, 2019|via=GitHub}}</ref>
}}
|website = [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/ C# Language]
|file_ext = <code>.cs</code>, <code>.csx</code>
}}
'''C#'''是[[微软|微软]]推出的一种基于[[.NET框架|.NET框架]]的、[[面向对象程序设计|面向对象]]的高级[[编程语言|编程语言]]。C#是一种由C和C++衍生出来的面向对象的编程语言。它在继承C和C++强大功能的同时去掉了一些它们的复杂特性，使其成为C语言家族中的一种高效强大的编程语言。C#以.NET框架类库作为基础，拥有类似[[Visual_Basic|Visual Basic]]的快速开发能力。C#由[[安德斯·海尔斯伯格|安德斯·海尔斯伯格]]主持开发，微软在2000年发布了这种语言，希望借助这种语言来取代[[Java|Java]]。C#已经成为[[Ecma国际|Ecma国际]]和[[国际标准组织|国际标准组织]]的标准规范。

== 命名 ==
C#的发音为“C sharp”，“#”读作“sharp”（{{IPAc-en|ʃ|ɑ:|p}}），命名启发于音乐上的音名“'''[[C♯_(音名)|C♯]]'''”，在音乐中“C♯”表示C升半音，為比C高一点的音节，且“#”形似4个加号，微软借助这样的命名，以表示C#在一些语言特性方面对C++的提升的意思。

由於[[顯示器|顯示器]]（標準[[字體|字體]]、[[瀏覽器|瀏覽器]]等）的技術限制，且大部分的[[鍵盤配置|鍵盤配置]]上不存在[[升記號|升記號]]（♯），所以[[井號|井號]]（#）被用於此[[程式語言|程式語言]]的名稱中，約定在ECMA-334 C#語言規範中<ref>{{cite book|url=http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-334.pdf|title=C# Language Specification|publisher=[[Ecma国际|Ecma International]]|edition=4th|date=June 2006|accessdate=2012-01-26|archive-url=https://web.archive.org/web/20121202194727/http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-334.pdf|archive-date=2012-12-02|dead-url=yes}}</ref>。

== 设计目标 ==
ECMA标准列出的C#设计目标：
* C#旨在设计成为一种「简单、现代、通用」，以及面向对象的程序设计语言
* 此种语言的实现，应提供对于以下软件工程要素的支持：强类型檢查、数组维度检查、未初始化的变量引用检测、[[垃圾回收_(計算機科學)|自动垃圾收集]]（Garbage Collection，指一种記憶體自動释放技术）。软件必须做到強大、持久，并具有较强-{zh-hans:的编程;zh-hant:程式開發的}-生产力。
* 此种语言为在-{zh-hans:分布式;zh-hant:分散式}-环境中的开发提供适用的组件开发应用。
* 为使程序员容易迁移到这种语言，源代码的可移植性十分重要，尤其是对于那些已熟悉C和C++的程序员而言。
* 对国际化的支持非常重要。
* C#适合为独立和嵌入式的系统编写程序，从使用复杂操作系统的大型系统到特定应用的小型系统均适用。
* 虽然C#程序在存储和操作能力需求方面具备经济性，但{{fact|此种语言在某些情況下并不能在性能和程式大小方面与C语言相抗衡。|time=2011-03-18}}

== 歷史 ==
原[[Borland|Borland]]公司的首席研发设计师[[安德斯·海尔斯伯格|安德斯·海爾斯伯格]]（Anders Hejlsberg）在微軟開發了[[Visual_J++|Visual J++]] 1.0，很快的Visual J++由1.1版本升級到6.0版。[[昇陽電腦|SUN]]公司认为Visual J++ 违反了Java开发平台的中立性，对微软提出了诉讼。2000年6月26日微软在奥兰多举行的“职业开发人员技术大会”（PDC 2000）上，發表新的语言C#。C#语言取代了Visual J++，語言本身深受Visual Basic、Java、C和C++ 的影響。

=== 版本 ===
{| class="wikitable" border="1"
|-
! rowspan="2" | 版本
! colspan="3" | 語言規格
! rowspan="2" | 日期
! rowspan="2" | [[.NET框架|.NET框架的版本]]
! rowspan="2" | [[Microsoft_Visual_Studio|Visual Studio的版本]]
|-
! [[Ecma国际|ECMA]]
! [[国际标准组织|ISO]]/[[国际电工委员会|IEC]]
! Microsoft
|-
| C# 1.0
| rowspan="2"|[http://www.ecma-international.org/publications/files/ECMA-ST-WITHDRAWN/ECMA-334,%202nd%20edition,%20December%202002.pdf 2002年12月]{{Wayback|url=http://www.ecma-international.org/publications/files/ECMA-ST-WITHDRAWN/ECMA-334,%202nd%20edition,%20December%202002.pdf |date=20100307105608 }}
| rowspan="2"|[http://www.techstreet.com/cgi-bin/pdf/free/378672/ISO+IEC+23270-2003.pdf 2003年4月]{{Wayback|url=http://www.techstreet.com/cgi-bin/pdf/free/378672/ISO+IEC+23270-2003.pdf |date=20190924215538 }}
| [http://download.microsoft.com/download/a/9/e/a9e229b9-fee5-4c3e-8476-917dee385062/CSharp%20Language%20Specification%20v1.0.doc 2002年1月]{{Wayback|url=http://download.microsoft.com/download/a/9/e/a9e229b9-fee5-4c3e-8476-917dee385062/CSharp%20Language%20Specification%20v1.0.doc |date=20101008083401 }}
| 2002年1月
|[[.NET_Framework_version_history|.NET Framework 1.0]]
|[[Microsoft_Visual_Studio|Visual Studio .NET 2002]]
|-
| C# 1.1<br/>C# 1.2
| [http://download.microsoft.com/download/5/e/5/5e58be0a-b02b-41ac-a4a3-7a22286214ff/csharp%20language%20specification%20v1.2.doc 2003年10月]{{Wayback|url=http://download.microsoft.com/download/5/e/5/5e58be0a-b02b-41ac-a4a3-7a22286214ff/csharp%20language%20specification%20v1.2.doc |date=20100702215052 }}
| 2003年4月
|{{tsl|en|.NET Framework 1.1||.NET Framework 1.1}}
|[[Visual_Studio_.NET_2003|Visual Studio .NET 2003]]
|-
| {{tsl|en|C Sharp 2.0||C# 2.0}}
| [https://web.archive.org/web/20121202194727/http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-334.pdf 2006年6月]
| [http://standards.iso.org/ittf/PubliclyAvailableStandards/c042926_ISO_IEC_23270_2006(E).zip 2006年9月]{{Wayback|url=http://standards.iso.org/ittf/PubliclyAvailableStandards/c042926_ISO_IEC_23270_2006(E).zip |date=20070217053939 }}
| [http://download.microsoft.com/download/9/8/f/98fdf0c7-2bbd-40d3-9fd1-5a4159fa8044/csharp%202.0%20specification_sept_2005.doc 2005年9月]{{Wayback|url=http://download.microsoft.com/download/9/8/f/98fdf0c7-2bbd-40d3-9fd1-5a4159fa8044/csharp%202.0%20specification_sept_2005.doc |date=20110629171737 }}
| 2005年11月
|[[.NET_Framework_2.0|.NET Framework 2.0]]
|[[Visual_Studio_2005|Visual Studio 2005]]
|-
| {{tsl|en|C Sharp 3.0||C# 3.0}}
| colspan="2" rowspan="2" {{no}}
| [http://download.microsoft.com/download/3/8/8/388e7205-bc10-4226-b2a8-75351c669b09/CSharp%20Language%20Specification.doc 2007年8月]{{Wayback|url=http://download.microsoft.com/download/3/8/8/388e7205-bc10-4226-b2a8-75351c669b09/CSharp%20Language%20Specification.doc |date=20100728042543 }}
| 2007年11月
|
.NET Framework 2.0 (Except LINQ)<ref name="danielmoth1">{{cite web |url=http://www.danielmoth.com/Blog/using-c-30-from-net-20.aspx |title=Using C# 3.0 from .NET 2.0 |publisher=Danielmoth.com |date=2007-05-13 |accessdate=2012年10月4日 |archive-date=2012-09-29 |archive-url=https://web.archive.org/web/20120929075553/http://www.danielmoth.com/Blog/Using-C-30-From-NET-20.aspx |dead-url=yes }}</ref><br/>
[[.NET_Framework_3.0|.NET Framework 3.0]] (Except LINQ)<ref name="danielmoth1"/><br/>
[[.NET_Framework_3.5|.NET Framework 3.5]]
|[[Visual_Studio_2008|Visual Studio 2008]]<br/>[[Visual_Studio_2010|Visual Studio 2010]]
|-
| {{tsl|en|C Sharp 4.0||C# 4.0}}
| 2010年4月
| 2010年4月
|[[.NET_Framework_4.0|.NET Framework 4]]
|[[Visual_Studio_2010|Visual Studio 2010]]
|-
| C# 5.0
| [https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-334.pdf 2017年12月]{{Wayback|url=https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-334.pdf |date=20190811190342 }}
| [https://standards.iso.org/ittf/PubliclyAvailableStandards/c075178_ISO_IEC_23270_2018.zip 2018年12月]{{Wayback|url=https://standards.iso.org/ittf/PubliclyAvailableStandards/c075178_ISO_IEC_23270_2018.zip |date=20191008075443 }}
| [https://www.microsoft.com/en-us/download/details.aspx?id=7029 2013年6月]{{Wayback|url=https://www.microsoft.com/en-us/download/details.aspx?id=7029 |date=20180907032308 }}
| 2012年8月
|[[.NET_Framework_4.5|.NET Framework 4.5]]
|[[Visual_Studio_2012|Visual Studio 2012]]<br/>[[Visual_Studio_2013|Visual Studio 2013]]
|-
| C# 6.0
| colspan="2" rowspan="2" {{no}}
| [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/ 草案]{{Wayback|url=https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/ |date=20180907032328 }}
| 2015年7月
| [[.NET_Framework_4.6|.NET Framework 4.6]]
|[[Visual_Studio_2015|Visual Studio 2015]]
|-
| C# 7.0
| [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-7.0/ 建议草案]
|2017年3月
|[[.NET_Framework_4.6.2|.NET Framework 4.6.2]]
|[[Microsoft_Visual_Studio|Visual Studio 2017]]
|-
| C# 7.1
| {{no}}
| {{no}}
| [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-7.1/ 建议草案]
|2017年8月
|{{tsl|en|.NET Framework 4.7||.NET Framework 4.7}}
|[[Microsoft_Visual_Studio|Visual Studio 2017]] version 15.3<ref>{{Cite web |url=https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes-v15.3#cs71 |title=存档副本 |accessdate=2018-09-06 |archive-date=2018-01-22 |archive-url=https://web.archive.org/web/20180122175222/https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes-v15.3#cs71 |dead-url=no }}</ref>
|-
| C# 7.2
| {{no}}
| {{no}}
| [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-7.2/ 建议草案]
|2017年11月
|[[.NET_Framework_4.7.1|.NET Framework 4.7.1]]
|[[Microsoft_Visual_Studio|Visual Studio 2017]] version 15.5<ref name="visualstudio.com">{{Cite web |url=https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes |title=存档副本 |accessdate=2018-09-06 |archive-date=2018-01-22 |archive-url=https://web.archive.org/web/20180122175218/https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes |dead-url=no }}</ref>
|-
| C# 7.3
| {{no}}
| {{no}}
| [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-7.3/ 建议草案]
|2018年5月
|[[.NET_Framework_4.7.2|.NET Framework 4.7.2]]
|[[Microsoft_Visual_Studio|Visual Studio 2017]] version 15.7<ref name="visualstudio.com"/>
|-
| C# 8.0
| {{no}}
| {{no}}
| [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/ 建议草案]
|2019年9月
|[[.NET_Framework_4.8|.NET Framework 4.8]]
|[[Microsoft_Visual_Studio|Visual Studio 2019]] version 16.3<ref name="visualstudio.com"/>
|-
| C# 9.0
| {{no}}
| {{no}}
| [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/records 建议草案]
|2020年9月
|[[.NET_5|.NET 5]]
|
|-
| C# 10.0<ref>{{Cite web|title=What's new in C# 10|url=https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10|access-date=2021-11-10|website=docs.microsoft.com|language=en-us}}</ref>
| {{no}}
| {{no}}
| [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/record-structs 建议草案]
| November 2021
| {{ubl|.NET 6.0|.NET 6.0.1}}
| [[Visual_Studio_2022|Visual Studio 2022]] version 17.0<ref name="visualstudio.com.2022">{{Cite web|url=https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes|title=Visual Studio 2022 version 17.0 Release Notes|website=docs.microsoft.com}}</ref>
|}

== 語言特性 ==
相對於[[C语言|C]]和[[C++|C++]]，這個語言在許多方面進行了限制和增強：
* [[指標|-{zh-hans:指针;zh-hant:指標}-]]（Pointer）只能用於不安全模式之中。大多數對象訪問透過安全的引用实现，以避免無效的調用，並且有許多-{zh-hans:算法;zh-hant:演算法}-用於-{zh-hans:验证;zh-hant:檢查}--{zh-hans:溢出;zh-hant:溢位}-，-{zh-hans:指针;zh-hant:指標}-只能用於調用值类型，以及受[[垃圾回收_(计算机科学)|垃圾收集]]控制的托管對象。
* 對象不能被顯式釋放，代替為當不存在被引用時透過垃圾回收器回收。
* 只允許[[單一繼承|單一繼承]]（single inheritance），但是一個類可以實現多個[[接口|-{zh-hans:接口;zh-hant:介面}-]]（interfaces）。
* C#比C++更加[[類型安全|類型安全]]。-{zh-hans:默认;zh-hant:預設}-的安全轉換是[[隱含轉換|隱含轉換]]，例如由短整型轉換為長整型和從衍生類轉換為基本類。而-{zh-hans:接口;zh-hant:介面}--{zh-hans:布尔型;zh-hant:布林數}-同整型，及枚舉型同整型不允許隱含轉換，非[[空指標|空-{zh-hans:指针;zh-hant:指標}-]]（透過引用相似對象）同用戶定義類型的隱含轉換字段被顯式的確定，不同於C++的複製構造函數。
* 数组-{zh-hans:声明;zh-hant:宣告的}-語法不同（"int[] a = new int[5]"而不是"int a[5]"）。
* [[枚舉|枚舉]]位於其所在的[[命名空間|命名空間]]中。
* C#中沒有[[模板_(C++)|模版]]（Template），但是在C# 2.0中引入了[[泛型|泛型]]（Generic programming），並且支持一些C++模版不支持的特性。比如泛型參數中的類型約束。另一方面，表達式不能像C++模版中被用於類型參數。
* [[屬性|屬性]]支持，使用類似訪問成員的方式調用。
* 完整的[[反射式编程|反射]]支持。

== C# 2.0的特性 ==
针对于.NET SDK 2.0（相对应于ECMA-334标准第三版），C# 的新特性有：

=== 分部類別 ===
[[分部类|分部類別]]将類別的实现分在多个文件中。该概念于C# 中首次出现，除了能将一个類別的成员分开存放，还使[[ASP.NET|ASP.NET]]中的代码后置得以实现。代码后置实现了HTML代码和后台交互代码的分离。

file1.cs:
<syntaxhighlight lang="csharp">
public partial class MyClass1
{
    public void MyMethod1()
    {
        // implementation
    }
}
</syntaxhighlight>

file2.cs:

<syntaxhighlight lang="csharp">
public partial class MyClass1
{
    public void MyMethod2()
    {
        // implementation
    }
} 
</syntaxhighlight>

分部類別这个特性允许将一个類別的编写工作分配给多个人，一人写一个文件，便于[[版本控制|版本控制]]。它又可以隔离自动生成的代码和人工书写的代码，例如设计[[窗体应用程序|窗体应用程序]]时。

=== 泛型 ===
[[泛型编程|泛型]]，或参数化类型，是被C#支持的.NET 2.0特性。不同于C++模版，.NET参数化类型是在运行时被实例化，而不是编译时，因此它可以跨语言，而C++模版却不行。C#泛型类在编译时，先生成中间代码IL，通用类型符号T只是一个占位符；在实例化类时，根据实际数据类型代替T并由即时编译器（JIT）生成本地代码，其中使用了实际的数据类型，等同于用实际类型写的普通的类。

它支持的一些特性并不被C++模版直接支持，比如约束泛型参数实现一个接口。另一方面，C# 不支持无类型的泛型参数。不像Java中的泛型，在[[通用语言架构|CLI]]虚拟机中，.NET generics使用[[具化|具化]]生成泛型参数，它允许优化和保存类型信息。<ref>{{Cite web |url=http://msdn.microsoft.com/library/default.asp?url=%2Flibrary%2Fen-us%2Fdnvs05%2Fhtml%2Fcsharp_generics.asp |title=An Introduction to C# Generics |accessdate=2020-09-25 |archive-date=2019-09-24 |archive-url=https://web.archive.org/web/20190924215539/https://msdn.microsoft.com/library?url=%2Flibrary%2Fen-us%2Fdnvs05%2Fhtml%2Fcsharp_generics.asp |dead-url=no }}</ref>

泛型类中，可以用where关键字对参数类型实现约束。例如：
<syntaxhighlight lang="csharp">
 public class Node<T, V> where T : Stack, IComparable, new(),class where V: Stack,struct
 {...}
</syntaxhighlight>
上述表示T和V必须是Stack类或其派生类，T必须继承了IComparable接口、有无参构造函数、是引用类型；V必须是值类型。

泛型不仅能作用在类上，也可单独用在类的方法上，称为“泛型方法”。

泛型类的静态成员变量在相同封闭类间共享，不同的封闭类间不共享。

泛型类中的方法重载，参数类型T和V在运行时确定，不影响这个类通过编译。C#的泛型是在实例的方法被调用时检查重载是否产生混淆，而不是在泛型类本身编译时检查。特别地，当一般方法与泛型方法具有相同的签名时，会覆盖泛型方法。

=== 静态類別 ===
静态類別它不能被实例化，并且只能有静态成员。这同很多过程语言中的[[模块_(程序设计)|模块]]概念相类似。

=== 迭代器 ===
一种新形式的[[迭代器|迭代器]]它提供了函数式编程中的[[生成器_(计算机编程)|generator]]，使用<code>yield return</code>

类似于[[Python_(消歧义)|Python]]中使用的<code>yield</code>

<syntaxhighlight lang="csharp">
// Method that takes an iterable input (possibly an array)
// and returns all even numbers.
public static IEnumerable<int> GetEven(IEnumerable<int> numbers)
{
    foreach(int i in numbers)
    {
        if (i % 2 == 0) yield return i;
    }
}
</syntaxhighlight>
注意事项：
* foreach循环时考虑线程安全性，不要试图对被遍历的集合进行remove和add等操作 
* IEnumerable接口是LINQ特性的核心接口。只有实现了IEnumerable接口的集合，才能执行相关的LINQ操作，比如select,where等

=== 匿名方法 ===
匿名方法类似于函数式编程中的[[闭包_(计算机科学)|闭包]]。<ref>{{Cite web |url=http://msdn2.microsoft.com/en-us/library/0yw3tz5k(VS.80).aspx |title=Anonymous Methods (C#) |accessdate=2008-10-24 |archive-date=2008-04-17 |archive-url=https://web.archive.org/web/20080417052304/http://msdn2.microsoft.com/en-us/library/0yw3tz5k(vs.80).aspx |dead-url=no }}</ref>匿名方法是通过使用 delegate 关键字创建委托实例来声明的。例如：


<syntaxhighlight lang="csharp">

delegate void NumberChanger(int n);
 
NumberChanger nc = delegate(int x)
{
    Console.WriteLine("Anonymous Method: {0}", x);
};



public void Foo(object parameter)
{
    // ...

    ThreadPool.QueueUserWorkItem(delegate
    {
        // anonymous delegates have full access to local variables of the enclosing method
        if(parameter == ...)
        { 
            // ... 
        }

        // ...
    });
}
</syntaxhighlight>

=== 委托的协变和逆变 ===
[[委托_(.NET)|委托]]签名的[[协变和逆变|协变和逆变]],<ref>{{Cite web |url=http://msdn2.microsoft.com/en-us/library/ms173174(VS.80).aspx |title=Covariance and Contravariance in Delegates (C#) |accessdate=2008-10-24 |archive-date=2008-10-12 |archive-url=https://web.archive.org/web/20081012164427/http://msdn2.microsoft.com/en-us/library/ms173174(VS.80).aspx |dead-url=no }}</ref>

=== 属性访问器可以被单独设置访问级别 ===
例子：

<syntaxhighlight lang="csharp">
string status = string.Empty;

public string Status
{
    get { return status; }             // anyone can get value of this property,
    protected set { status = value; }  // but only derived classes can change it
}
</syntaxhighlight>

=== 可空类型 ===
[[可空类型|可空类型]]（跟个问号，如<code>int? i = null;</code>）允许设置<code>null</code>给任何类类型。

<syntaxhighlight lang="csharp">
int? i = null;
object o = i;
if(o == null)
    Console.WriteLine("Correct behaviour - runtime version from September 2005 or later");
else
    Console.WriteLine("Incorrect behaviour - pre-release runtime (from before September 2005)");
</syntaxhighlight>

=== ??運算子 ===
（<code>??</code>）：如果左运算数表达式的值不为空值时回傳该值，如果为空值则返回右运算数表达式的值。

<syntaxhighlight lang="csharp">
object nullObj = null; 
object obj = new Object(); 
return nullObj ?? obj; // returns obj
</syntaxhighlight>

主要用作将一个可空类型赋值给不可空类型的简便语法

<syntaxhighlight lang="csharp">
int? i = null;
int j = i ?? 0; // Unless i is null, initialize j to i. Else (if i is null), initialize j to 0.
</syntaxhighlight>

== C# 3.0的特性 ==
C# 3.0发布于2007年10月17日，是.NET Framework 3.5的一部分，它的新特性灵感来自于[[函数式编程|函数式编程]]语言，如：[[Haskell|Haskell]]和[[ML语言|ML]]，并广泛地引入了[[语言集成查询|Language Integrated Query]]（LINQ）模式到通用語言運行庫中e.<ref>{{cite web
|url=http://www.regdeveloper.co.uk/2006/11/14/c-sharp_hejlsberg/
|title=C# pulling ahead of Java - Lead architect paints rosy C# picture
|author=Tim Anderson
|date=2006-11-14
|accessdate=2007-01-20
|work=Reg Developer
|publisher=[[The_Register|The Register]]
|archive-date=2007-01-21
|archive-url=https://web.archive.org/web/20070121204227/http://www.regdeveloper.co.uk/2006/11/14/c-sharp_hejlsberg/
|dead-url=no
}}</ref>

=== Linq ===
[[语言集成查询|语言集成查询]]（{{lang-en|'''L'''anguage '''In'''tegrated '''Q'''uery}}，缩写：'''LINQ'''）：<ref>{{cite web
 |url          = http://msdn.microsoft.com/data/ref/linq/
 |title        = LINQ
 |publisher    = Microsoft MSDN
 |year         = 2007
 |accessdate   = 2007-08-13
 |language     = en
 |archive-url  = https://web.archive.org/web/20070116022347/http://msdn.microsoft.com/data/ref/linq/
 |archive-date = 2007-01-16
 |dead-url     = yes
}}</ref>  上下文相关关键字"<code>from</code>, <code>where</code>, <code>select</code>"可用于查询SQL、XML、集合等。这些标识符在LINQ上下文中被作为关键字，但是它们的增加不会破坏原有的名为<code>from</code>、<code>where</code>或<code>select</code>的变量。

=== 类型初始化器 ===
<syntaxhighlight lang="csharp">
Customer c = new Customer();
c.Name = "James";
</syntaxhighlight>
可写作：
<syntaxhighlight lang="csharp">
Customer c = new Customer() { Name="James" };
</syntaxhighlight>

=== 集合初始化器 ===
<syntaxhighlight lang="csharp">MyList list = new MyList();
list.Add(1);
list.Add(2);</syntaxhighlight>
可写作
<syntaxhighlight lang="csharp">MyList list = new MyList { 1, 2 };</syntaxhighlight>
假设<code>MyList</code>实现了<code>System.Collections.IEnumerable</code>且有一个<code>Add</code>方法method<ref>{{Cite web |url=http://blogs.msdn.com/madst/archive/2006/10/10/What-is-a-collection_3F00_.aspx |title=The Mellow Musings of Dr. T : What is a collection? |accessdate=2008-10-24 |archive-date=2008-12-18 |archive-url=https://web.archive.org/web/20081218215141/http://blogs.msdn.com/madst/archive/2006/10/10/What-is-a-collection_3F00_.aspx |dead-url=no }}</ref>

=== 匿名類型 ===
<syntaxhighlight lang="csharp">var x = new { Name="James" };</syntaxhighlight>

=== 局部变量类型推断 ===
局部变量[[类型推断|类型推断]]：<syntaxhighlight lang="csharp">var x = new Dictionary<string, List<float>>();</syntaxhighlight>
等同于
<syntaxhighlight lang="csharp">Dictionary<string, List<float>> x = new Dictionary<string, List<float>>();</syntaxhighlight>
它只是一个[[语法糖|语法糖]]，这个特性被匿名类型声明时所需要

=== Lambda表达式 ===
[[Lambda表达式|Lambda表达式]]（無函式名稱的物件方法在程式語言中的表達語法）: 
<syntaxhighlight lang="csharp">
listOfFoo.Where(
    delegate(Foo x)
    {
        return x.Size > 10; 
    }
)</syntaxhighlight>
:可写作 
<syntaxhighlight lang="csharp">listOfFoo.Where(x => x.Size > 10);</syntaxhighlight>

编译器翻译Lambda表达式为强类型委托或强类型[[表达式树|表达式树]]。

注意事项：
* 如果只有一个参数，可以省略括号()，例如 item=>{Console.WriteLine("只有一个参数{0}的Lambda表达式",item); };
* 如果只有一个返回值的语句，可以省略花括号{}、return关键字、分号，例如 item => {return item % 2 == 0;};改写成：item =>item %2 == 0;
* Lambda表达式可以分配给Func，Action或Predicate委托。

=== 自动化属性 ===
编译器将自动生成私有变量和适当的getter（get访问器）和setter（set访问器），如：
<syntaxhighlight lang="csharp">
public string Name
{
    get; 
    set; 
}
</syntaxhighlight>

=== 扩展方法 ===
[[扩展方法|扩展方法]]能够使现有的类型添加方法，而无需创建心的派生类型、重新编译或以其它方式修改原始类型。

使用拓展方法，必须在一个非嵌套、非泛型的静态类中定义一个静态方法，方法第一个参数必须附加this关键字作为前缀，第一个参数不能有其它修饰符（如ref或者out），这个方法将被编译器添加到该this的类型中。

<syntaxhighlight lang="csharp">
public static class IntExtensions
{
    public static void PrintPlusOne(this int x) 
    {
        Console.WriteLine(x + 1);
    }
}
 
int foo = 0;
foo.PrintPlusOne();
</syntaxhighlight>

注意事项：
* 扩展方法只会增加编译器的工作，但不会影响程序运行性能（用继承的方式为一个类型增加特性反而会影响性能）
* 如果原来的类中有一个方法，跟扩展方法一样，那么扩展方法不会被调用，编译器也不会提示

=== 分部方法 ===
允许代码生成器生成方法声明作为扩展点，如果有人在另一个部分类实现了它才会被包含于原代码编译。<ref>{{cite web | url=http://blogs.msdn.com/vbteam/archive/2007/03/27/partial-methods.aspx | title=Partial Methods | accessdate=2007-10-06 | archive-date=2007-10-16 | archive-url=https://web.archive.org/web/20071016072302/http://blogs.msdn.com/vbteam/archive/2007/03/27/partial-methods.aspx | dead-url=no }}</ref>

# 分部方法（Partial methods）必须定义在分部类（partial classes）中 
# 定义分部方法需要用partial做修饰符 
# 分部方法不一定总是有执行内容的，也就是说定义的方法可以一句操作语句都没有 
# 分部方法返回值必须是void 
# 分部方法可以是静态（static）方法 
# 分部方法可以包含参数，参数可以包含以下修饰词：this,ref,params 
# 分部方法必须是私有（private）方法 
例子：
<syntaxhighlight lang="csharp">
partial class C
{
    static partial void M(int i); // defining declaration
}
partial class C
{
    static partial void M(int i)
    {
        dosomething();
    }
}
</syntaxhighlight>

== C# 4.0的特性 ==
=== dynamic类型===
C# 4.0新增dynamic关键字，提供動態編程（dynamic programming），把既有的靜態物件標記為動態物件，類似[[JavaScript|javascript]], [[Python_(消歧义)|Python]]或[[红宝石|Ruby]]。

dynamic关键字标记的实例被处理成一个特殊包装的object对象，取消了CLI的编译时类型检查，编译时被假定支持任何操作，但如果并不实际支持则运行时报错。

<syntaxhighlight lang="csharp">
dynamic calc = GetCalculator();
int sum = calc.Add(10, 20);
</syntaxhighlight>

=== 具名參數與可選參數 ===
<syntaxhighlight lang="csharp">
public StreamReader OpenFile(
    string path,
    int bufferSize = 1024)
{
...
}
</syntaxhighlight>
呼叫OpenFile時，順序可以完全顛倒：
<syntaxhighlight lang="csharp">
OpenFile(bufferSize: 4096, path: "foo.txt");
</syntaxhighlight>

=== 與COM组件互動 ===
在C#中打開一個[[詞_(語言)|Word]]文件：
<syntaxhighlight lang="csharp">
static void Main(string[] args) {
    Word.Application wordApplication = new   
       Word.Application() {Visible = true};     
    wordApplication.Documents.Open(@"C:\plant.docx",   
       ReadOnly: true);  
}
</syntaxhighlight>

在C#中指定[[Excel|Excel]]的某一格文字：
<syntaxhighlight lang="csharp">
excelObj.Cells[5, 5].Value = "This is sample text";
</syntaxhighlight>

=== 泛型的协变和逆变 ===
C# 4.0支援[[协变和逆变_(计算机科学)|协变和逆变]]，例如在泛型介面可以加上in、out-{zh:修饰字;zh-hk:修饰字;zh-cn:关键字}-。
<syntaxhighlight lang="csharp">
  public interface IComparer<in T>  
  {  
    int Compare(T left, T right);  
  }

  public interface IEnumerable<out T> : IEnumerable
  {
    IEnumerator<T> GetEnumerator();
  }

</syntaxhighlight>

== C# 5.0的特性 ==
#C# Evolution Matrix
#Async Feature （补充： async和await是一对语法糖，允许开发人员非常轻松的调用基于TASK的异步编程）async-await关键字并不会真的创建一个线程池任务，完成这个动作依赖于被调用方法中的函数。这一点在许多C#的中文教程中被忽略，导致许多学习的新手误以为await关键字会直接创建一个新的线程池任务。
#Caller Information

== C# 6.0的特性 ==
# 唯讀 Auto 屬性
# Auto 屬性初始設定式
# 具有運算式主體的函式成員：
# 使用靜態
# Null - 條件運算子
# 字串插值
# 例外狀況篩選條件
# nameof 運算式
# Catch 和 Finally 區塊中的 Await
# 索引初始設定式
# 集合初始設定式的擴充方法
# 改進的多載解析

== C# 7.0的特性 ==
===out 變數===
能夠直接宣告一個變數在它要傳入的地方，當成一個 out 的引數<ref>{{cite web | url=https://blogs.msdn.microsoft.com/msdntaiwan/2016/09/09/whats-new-in-c-7-0/ | title=一覽 C# 7.0 中的新功能 | accessdate=2016-09-14 | archive-date=2018-10-02 | archive-url=https://web.archive.org/web/20181002235025/https://blogs.msdn.microsoft.com/msdntaiwan/2016/09/09/whats-new-in-c-7-0/ | dead-url=no }}</ref>
===弃元===
元组/对象的解构：
 var tuple = (1, 2, 3, 4, 5);
 (_, _, _, _, var fifth) = tuple;

使用 is/switch 的模式匹配：
 var obj = CultureInfo.CurrentCulture.DateTimeFormat;
 switch (obj)
 {
  case IFormatProvider fmt:
    Console.WriteLine($"{fmt} object");
    break;
  case null:
    Console.Write("A null object reference");
    break;
  case object _:
    Console.WriteLine("Some object type without format information");
    break;
 }
 
 if (obj is object _)
 {
  ...
 }

对具有 out 参数的方法的调用：
 var point = new Point(10, 10);
 // 只要 x, 不关心 y
 point.GetCoordinates(out int x, out _);

作用域内独立使用场景：
 void Test(Dto dto)
 {
    _ = dto ?? throw new ArgumentNullException(nameof(dto));
 }

== C# 7.1的特性 ==
# async``Main方法
# default常值運算式
# 推斷的 tuple 項目名稱

== C# 7.2的特性 ==
# 具備實值型別的參考語意
# 無後置具名引數
# 數值常值中的前置底線
# private protected 存取修飾詞

== C# 8.0的特性 ==
# 可空引用类型
# await yield return可异步返回的迭代器
# Index 索引类型和Range区间类型
# 允许在声明接口时为接口成员提供默认实现
# 递归的模式匹配
# 表达式形式的Switch关键字
# 在编译器可做类型推断的情况下，允许进一步省略类型声明

== C# 9.0的特性 ==
=== 新的「Record」類型 ===
记录类型， 是一种引用类型， 默认是不可变的。 记录类型的相等判断可以通过引用或者结构进行判断的。

* 优点：记录类型是轻量级的不可变类型，可以减少大量的代码， 可以按照结构和引用进行比较；
* 缺点：需要实例化大量的对象；
<syntaxhighlight lang="csharp">
// 默认不可变的记录类型
public record Person(string Name, int Age);
// 可变记录类型
public record MutablePerson(string Name, int Age) {
 public string Name { get; set; } = Name;
 public int Age { get; set; } = Age;
}
 
var person1 = new Person("Alice", 40);
var person2 = new Person("Alice", 40);
 
Console.WriteLine(person1 == person2); // True 结构相同
Console.WriteLine(person1.Equals(person2)); // True 结构相同
Console.WriteLine(ReferenceEquals(person1, person2)); // False, 引用不同
 
// 改变默认的记录！ --> 创建一个新的记录。
var person3 = person1 with { Age = 43 };
Console.WriteLine(person3 == person1); // False 结构不同
 
// 解构 (Destruct) 一个记录， 将记录的属性提取为本地变量
var (name, age) = person3;
 
var person4 = new MutablePerson("Alice", 40);
person4.Age = 43;
 
// 记录类型也可以被继承
public record Citizen(string Name, int Age, string Country) : Person(Name, Age);
var citizen = new Citizen("Alice", 40, "China");
Console.WriteLine(person1 == citizen); // False 类型不同；
</syntaxhighlight>
=== 「init」存取子 ===
init存取子表示該屬性所屬類型僅能在建構函式(Constructor)中或是屬性初始化式子中賦予其值，如果嘗試在其他地方設定該屬性的值，在編譯時便會遭編譯器阻止。

範例如下：
在這個範例中，建立了一個<code>Student</code>類型，並且屬性<code>StudentName</code>與<code>StudentID</code>只能在初始化時賦予其值。
<syntaxhighlight lang="csharp">
public class Student
{
	public string StudentName { get; init; } = "Default Name";
	public string StudentID { get; init; } = "00000000";
	public Student()
    {
		
	}
	public Student(string studentName,string studentID)
	{
		StudentName = studentName;
		StudentID = studentID;
	}
}
</syntaxhighlight>
如果在此時撰寫以下程式碼：
<syntaxhighlight lang="csharp">
Student DemoStudent = new Student();
DemoStudent.StudentName = "Test Name";
</syntaxhighlight>
編譯器便會無法編譯並且擲回錯誤。

而如果要建立學生名稱為「Test Name」，學生ID為「0001」的學生，則需要寫成：
<syntaxhighlight lang="csharp">
Student DemoStudent = new Student() //物件初始化運算式
{
    StudentName = "Test Name";
    StudentID = "0001"
};
</syntaxhighlight>
或是
<syntaxhighlight lang="csharp">
Student DemoStudent = new Student("Test Name","0001"); //藉由類型的建構式初始化StudentName以及StudentID。
</syntaxhighlight>

=== 最上層陳述式或称顶级语句 ===
在以前的版本，開發者在撰寫最上層陳述式(如Program.cs)程式碼時，需要包含完整的namespace與class架構，因此如果要撰寫Hello World程式時，程式碼就會是：
<syntaxhighlight lang="csharp">
using System;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
</syntaxhighlight>
但是在C#9.0之後，最上層陳述式的程式碼不需要包含namespace以及class，可將其簡化為：
<syntaxhighlight lang="csharp">
using System;

Console.WriteLine("Hello World!");
//或者简化为一行语句：
System.Console.WriteLine(“Hello World!”);
</syntaxhighlight>

注意， 一个程序中， 只能有一个文件使用顶级语句， 并且顶级语句必须位于命名空间或类型定义之前！
===lambda弃元参数===
 Func<int, int, int> zero = (_, _) => 0;
 Func<int, int, int> func = delegate (int _, int _) { return 0; };

在 C# 9 之前，即便不使用的 Lambda 参数也需要给它命名。C# 9 支持弃元参数一方面简化了命名，另一方面也节省了内存分配。更重要的是它使得编程的意图更明确，让人一看就知道这个参数是不用的，增强了代码的可读性和可维护性。
===只能初始化的设置器===
Init only setters，只能通过对象初始化进行赋值的属性。
<syntaxhighlight lang="csharp">
public class InitDemo {
 public string Start { get; init; }
 public string Stop { get; init; }
}
 
// initDemo.Start = "Now"; // Error
// initDemo.End = "Tomorrow"; // Error
 
var initDemo = new InitDemo {
 Start = "Now",
 Stop = "Tomorrow"
};
</syntaxhighlight>
===函数指针===
使用 delegate* 可以声明函数指针。
<syntaxhighlight lang="csharp">
unsafe class FunctionPointer {
 static int GetLength(string s) => s.Length;
 delegate*<string, int> functionPointer = &GetLength;
}
 
public void Test() {
 Console.WriteLine(functionPointer("test")); // 4;
}
</syntaxhighlight>
===跳过本地初始化===
<syntaxhighlight lang="csharp">
[System.Runtime.CompilerServices.SkipLocalsInit]
static unsafe void DemoLocalsInit() {
 int x;
 // 注意， x 没有初始化， 输出结果不确定；
 Console.WriteLine(*&x);
} 
</syntaxhighlight>
===原生整数类型===
两个新的整数类型 nint 和 nunit ， 依赖宿主机以及编译设定。
===协变返回类型===
协变返回类型为重写方法的返回类型提供了灵活性。覆盖方法可以返回从被覆盖的基础方法的返回类型派生的类型。
 class Person { public virtual Person GetPerson() { return new Person(); } }
 class Student : Person { public override  Student GetPerson() { return new Student(); } }
===模块初始化代码===
ModuleInitializerAttribute 为组件 (assembly) 定义初始化代码， 当初始化/加载时执行， 可以类比类的静态构造函数， 但是是组件级别的。
* 必须是静态的、无参数的、无返回值的方法；
* 不能是范型方法，也不能包含在范型类中；
* 不能是私有函数，必须是公开 (public) 或者内部 (internal) 的函数；    
===静态 lambda 表达式===
static 修饰符添加到 lambda 表达式或匿名方法 。这将无法捕获局部变量或实例状态，从而防止意外捕获其他变量。
===分部方法扩展===
移除了分部方法的下述限制：
* 必须具有 void 返回类型。 
* 不能具有 out 参数。 
* 不能具有任何可访问性（隐式 private ）。 
===初始化表达式的简化===
如果创建对象的类型已知时，可以在new表达式中省略该类型。
<syntaxhighlight lang="csharp">
Point p = new(1, 1);
Dictionary<string, int> dict = new();
 
Point[] points = { new(1, 1), new (2, 2), new (3, 3) };
var list = new List<Point> { new(1, 1), new(2, 2), new(3, 3)};
</syntaxhighlight>
===在本地函数上添加标记===
<syntaxhighlight lang="csharp">
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
namespace CoreApp2
{  
    class Program
    {
        static void Main(string[] args)
        {
            [Conditional("DEBUG")]
            static void DoSomething([NotNull] string test)
            {
                System.Console.WriteLine("Do it!");
            }
            DoSomething("Doing!");
        }
   }
}
</syntaxhighlight>

===GetEnumerator 扩展===
可以为任意类型添加一个 GetEnumerator 扩展方法， 返回一个 IEnumerator 或者 IAsyncEnumerator 实例， 从而在 foreach 循环中使用。
<syntaxhighlight lang="csharp">
using System.Collections.Generic;
using System.Collections.ObjectModel;
namespace CoreApp2
{
    public static class Extensions
    {
        public static IEnumerator<T> GetEnumerator<T>(this IEnumerator<T> enumerator) => enumerator;
    }

    class Program
    {
        static void Main(string[] args)
        {
            IEnumerator<string> enumerator = new Collection<string> {"A", "B", "C"}.GetEnumerator();
            foreach (var item in enumerator)
            {
                Console.WriteLine(item);
            }
        }
    }
}</syntaxhighlight>
===模式匹配增强===
Type patterns 类型匹配，判断一个变量的类型
<syntaxhighlight lang="csharp">
object obj = new int();
var type = obj switch {
 string => "string",
 int => "int",
 _ => "obj"
};
Console.WriteLine(type); // int
</syntaxhighlight>
Relational patterns 关系匹配：
<syntaxhighlight lang="csharp">
class Person { 
        public string name; 
        public int age; 
        public Person(string a, int b) { name = a;age = b; }
        public void Deconstruct(out string a,out int b){a = name;b = age; }
    }
class Program
    {        
        static void Main(string[] args)
        {
            var person1 = new Person("Alice", 40);
            var inRange = person1 switch
            {
                (_, < 18) => "less than 18",
                (_, > 18) => "greater than 18",
                (_, 18) => "18 years old!"
            };
            Console.WriteLine(inRange); // greater than 18
         }
     }
</syntaxhighlight>
Conjunctive and patterns 逻辑合取匹配：
<syntaxhighlight lang="csharp">
// And pattern
var person1 = new Person("Alice", 40);
var ageInRange = person1 switch {
 (_, < 18) => "less than 18",
 ("Zhang Zhimin", _) and (_, >= 18) => "Alice is greater than 18"
};
Console.WriteLine(ageInRange); // Alice is greater than 18
</syntaxhighlight>
Disjunctive or patterns 逻辑析取匹配：
<syntaxhighlight lang="csharp">
// Or pattern
var person1 = new Person("Alice", 40);
var ageInRange = person1 switch {
 (_, < 18) => "less than 18",
 (_, 18) or (_, > 18) => "18 or greater"
};
Console.WriteLine(ageInRange); // 18 or greater
</syntaxhighlight>
Negated not patterns 逻辑非匹配
<syntaxhighlight lang="csharp">
// Not pattern
var person1 = new Person("Alice", 40);
var meOrNot = person1 switch {
 not ("Alice", 40) => "Not me!",
 _ => "Me :-)"
};
Console.WriteLine(meOrNot); // Me :-)
</syntaxhighlight>
Parenthesized patterns 带括号的优先级匹配：
<syntaxhighlight lang="csharp">
// Parenthesized patterns
var is10 = new IsNumber(true, 10);
var n10 = is10 switch {
 ((_, > 1 and < 5) and (_, > 5 and < 9)) or (_, 10) => "10",
 _ => "not 10"
};
Console.WriteLine(n10); // 10
</syntaxhighlight>

==C# 10.0的特性==
===record struct===
解决了 record 只能给 class 而不能给 struct 用的问题：
 record struct Point(int X, int Y);

===sealed record ToString 方法===
可以把 record 里的 ToString 方法标记成 sealed
===struct 无参构造函数===
无参构造函数使得new struct() 和 default(struct) 的语义不一样
===用with创建新的匿名类型对象===
    var x = new { A = 1, B = 2 };
    var y = x with { A = 3 };
这里 y.A 将会是 3 。
===全局的 using===
可以给整个项目启用 using，不需要每个文件都写一份。
===文件范围的 namespace===
以前写 namespace 还得带一层大括号。现在如果一个文件里只有一个 namespace 的话，直接在文件开头写：
namespace MyNamespace;
===常量字符串插值===
    const string x = "hello";
    const string y = $"{x}, world!";

===lambda的改进===

====lambda 可以带 attributes====
    f = [Foo] (x) => x; // 给 lambda 设置
    f = [return: Foo] (x) => x; // 给 lambda 返回值设置
    f = ([Foo] x) => x; // 给 lambda 参数设置
====指定返回值类型====
此前 C# 的 lambda 返回值类型靠推导，C# 10允许在参数列表之前显式指定 lambda 返回值类型：
 f = int () => 4;
====支持 ref 、in 、out 等修饰====
 f = ref int (ref int x) => ref x; // 返回一个参数的引用
==== 头等函数====
函数可以隐式转换到 delegate，于是函数上升为头等函数(first function)：
    void Foo() { Console.WriteLine("hello"); }
    var x = Foo;
    x(); // hello
====自然委托类型====
lambda 可自动创建自然委托类型，于是不再需要写出类型：
    var f = () => 1; // Func<int>
    var g = string (int x, string y) => $"{y}{x}"; // Func<int, string, string>
    var h = "test".GetHashCode; // Func<int>
====CallerArgumentExpression====
使用CallerArgumentExpression这个attribute，编译器会自动填充调用参数的表达式字符串，例如：

    void Foo(int value, [CallerArgumentExpression("value")] string? expression = null)
    {
        Console.WriteLine(expression + " = " + value);
    }

当你调用 Foo(4 + 5) 时，会输出 4 + 5 = 9。这对测试框架极其有用 
===tuple 的混合定义和使用===
    int y = 0;
    (var x, y, var z) = (1, 2, 3);
于是 y 就变成 2 了，同时还创建了两个变量 x 和 z，分别是 1 和 3 。
===接口支持抽象静态方法===
.NET 6中这个特性为preview特性。
  
===泛型 attribute===
 
===在方法上指定 AsyncMethodBuilder===

在方法上用 [AsyncMethodBuilder(...)]，来使用自己实现的 async method builder，代替自带的 Task 或者 ValueTask 的异步方法构造器。有助于实现零开销的异步方法。

===line 指示器支持行列和范围===
以前 #line 只能用来指定一个文件中的某一行，现在可以指定行列和范围：

    #line (startLine, startChar) - (endLine, endChar) charOffset "fileName"
     
    // 比如 #line (1, 1) - (2, 2) 3 "test.cs"
===嵌套属性模式匹配改进===
以前在匹配嵌套属性的时候需要这么写：

 if (a is { X: { Y: { Z: 4 } } }) { ... }

现在只需要简单的：

 if (a is { X.Y.Z: 4 }) { ... }

===改进的字符串插值===
实现接近零开销的字符串插值。

===Source Generator v2===
包括强类型的代码构建器，以及增量编译的支持等

== 程序的执行 ==
C#通常不被编译成为能够直接在[[计算机|计算机]]上执行的[[二进制|二进制]]本地代码。与[[Java编程语言|Java]]类似，它被编译成为中间代码（Microsoft Intermediate Language），然后通过[[.NET框架|.NET Framework]]的[[虚拟机|虚拟机]]——被称为[[通用語言運行庫|-{zh-hans:通用语言运行库;zh-hant:通用語言執行層}-]]——执行。

所有的.Net[[编程语言|编程语言]]都被编译成这种被称为[[通用中间语言|通用中间语言]]的中间代码。因此虽然最终的[[计算机程序|程序]]在表面上仍然与传统意义上的可执行文件都具有“.exe”的后缀名。如果计算机上没有安装.Net Framework，那么这些程序会弹出对话框，要求用户下载.net framework。

在程序执行时，.Net Framework将中间代码翻译成为二进制机器码，从而使它得到正确的运行。最终的二进制代码被存储在一个缓冲区（Buffer）中。所以一旦程序使用了相同的代码，那么将会调用缓冲区中的版本。这样如果一个.Net程序第二次被运行，那么这种翻译不需要进行第二次，速度明显加快。

== 标准化 ==
微软公司已经向[[Ecma国际|ECMA]]申请将C#作为一种标准。在2001年12月，ECMA发布了ECMA-334 C#语言规范。C#在2003年成为一个[[國際標準化組織|ISO]]标准（ISO/IEC 23270）。现在有一些独立的实现正在进行，包括：
* [[自由软件基金会|自由软件基金会]]的[http://www.dotgnu.org/ dotGNU Portable.NET]{{Wayback|url=http://www.dotgnu.org/ |date=20050816065132 }}
* [http://www.go-mono.org/ Mono]{{Wayback|url=http://www.go-mono.org/ |date=20040622233049 }}
* [[Baltie|Baltie]] - C# IDE for children and young [http://www.sgpsys.com Baltie]{{Wayback|url=http://www.sgpsys.com/ |date=20070516111326 }}

== C# 的Hello World程式 ==
下面是一個在-{zh:命令列;zh-hans:命令行;zh-hant:命令提示字元}-上輸出[[Hello_World|Hello World]]的小-{zh:程序;zh-hans:程序;zh-hant:程式}-，這種-{zh:程序;zh-hans:程序;zh-hant:程式}-通常作為開始學習-{zh:程序;zh-hans:程序;zh-hant:程式}-語言的第一個步驟： 
<syntaxhighlight lang="csharp">
using System;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}

</syntaxhighlight>

== 实现 ==
C# 有5個著名的編譯器（compilers）:
* 最標準的C# 的實作當屬[[微軟|微軟]]自己推出、並被包含在[[.NET框架|.NET Framework]]內的C# 編譯器。
* 微軟的-{zh:Rotor;zh-hans:Rotor;zh-hant:轉軸}-项目（Rotor Project，目前稱為{{tsl|en|Shared Source Common Language Infrastructure||Shared Source Common Language Infrastructure}}），提供了[[通用語言運行庫|-{zh-hans:通用语言运行库;zh-hant:通用語言執行層}-]]（''Common Language Runtime''）的實作與C# 編譯器。但是Shared Source Common Language Infrastructure在2006年的2.0版後就停止了。
* 由Novell贊助的[[Mono|Mono]] -{zh:项目;zh-hans:项目;zh-hant:專案}-提供了C# 編譯器，同時也接近百分之百地實作了[[.NET框架|.NET Framework]]-{zh:类库;zh-hans:类库;zh-hant:類別庫}-。而Mono後來衍伸出由微軟認可的第三方套件[[Xamarin|Xamarin]]。
* [[DotGNU|Dot GNU]] 專案也提供了另一個自由版本的C# 編譯器，也提供了[[.NET框架|.NET Framework]]-{zh:类库;zh-hans:类库;zh-hant:類別庫}-的實作。
* Borland提供了專案级的C# -{zh:集成;zh-hans:集成;zh-hant:整合}-開發環境，內部所使用的編譯器仍是[[微軟|微軟]][[.NET框架|.NET Framework]]所提供的C# 編譯器（這也意味著你仍須安裝[[微軟|微軟]]的[[.NET框架|.NET Framework]]）。產品：C# Builder（商業版本），Turbo C# Explorer（免費版本）。

== 参考文献 ==
{{Reflist}}

== 外部連結 ==
* {{en}}[http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csspec/html/CSharpSpecStart.asp?frame=true C# Language Specification (MSDN)]{{Wayback|url=http://msdn.microsoft.com/library/default.asp?url=%2Flibrary%2Fen-us%2Fcsspec%2Fhtml%2FCSharpSpecStart.asp%3Fframe%3Dtrue |date=20190924215540 }}
* {{en}}[https://web.archive.org/web/20121202194727/http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-334.pdf ECMA-334 C# Language Specification (.pdf)]
* {{en}}[http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=36768&ICS1=35&ICS2=60&ICS3= ISO/IEC 23270:2003 C# Language Specification]{{Wayback|url=http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=36768&ICS1=35&ICS2=60&ICS3= |date=20050904224938 }}
* {{en}}[https://code.visualstudio.com/ Visual Studio Code]{{Wayback|url=https://code.visualstudio.com/ |date=20170212025033 }}
* {{en}}[https://dotnet.microsoft.com/download Download .NET]{{Wayback|url=https://dotnet.microsoft.com/download |date=20171005081052 }}
* [http://www.microsoft.com/china/MSDN/library/langtool/VCSharp/USgetstart_vcsharp.mspx Visual C# .NET入門 (MSDN)]{{Wayback|url=http://www.microsoft.com/china/MSDN/library/langtool/VCSharp/USgetstart_vcsharp.mspx |date=20050826095237 }}
* [http://www.mono-project.com/about/index.html MCS: Mono C# 編譯器]{{Wayback|url=http://www.mono-project.com/about/index.html |date=20050401170120 }}
* [https://visualstudio.microsoft.com/zh-hant/vs/express/ Visual Studio Community]{{Wayback|url=https://visualstudio.microsoft.com/zh-hant/vs/express/ |date=20200719235442 }}
* [http://cdn.instructables.com/FHW/SGEW/HS3GUNOY/FHWSGEWHS3GUNOY.LARGE.jpg Visual C# Logo]{{Wayback|url=http://cdn.instructables.com/FHW/SGEW/HS3GUNOY/FHWSGEWHS3GUNOY.LARGE.jpg |date=20181019085104 }} 
* [http://www.tw511.com/2/13/219.html C#教學]{{Wayback|url=http://www.tw511.com/2/13/219.html |date=20191023113544 }}
* [http://kaiching.org/pydoing/c-sharp.html C# 教材目錄]{{Wayback|url=http://kaiching.org/pydoing/c-sharp.html |date=20200301142933 }}

{{-}}
{{程序設計語言|C#}}
{{DotNET}}
{{ISO}}

{{Authority control}}

[[Category:.NET編程語言|Category:.NET編程語言]]
[[Category:C語言家族|Category:C語言家族]]
[[Category:面向对象的编程语言|Category:面向对象的编程语言]]
[[Category:基于类的编程语言|Category:基于类的编程语言]]
[[Category:Ecma標準|Category:Ecma標準]]
[[Category:2000年建立的程式語言|Category:2000年建立的程式語言]]