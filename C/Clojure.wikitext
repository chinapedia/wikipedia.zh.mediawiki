{{NoteTA
|G1 = IT
|1 = zh-cn:宏; zh-tw:巨集;
}}
{{Infobox programming language
| name = Clojure
| logo = Clojure logo.svg
| logo size = 160px
| paradigm = [[多重编程范式|多重编程范型]]:
{{flatlist|
* [[代理人導向編程|代理人导向]]<ref name="reference/agents">{{cite web |url=https://clojure.org/reference/agents |website=Clojure.org |title=Agents and Asynchronous Actions |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702200626/https://clojure.org/reference/agents |dead-url=no }}</ref>
* [[并发计算|并发计算]]<ref>{{cite web |url=https://clojure.org/about/concurrent_programming |website=Clojure.org |title=Concurrent Programming |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702200222/https://clojure.org/about/concurrent_programming |dead-url=no }}</ref><ref>{{cite web |url=https://github.com/clojure/core.async |website=GitHub.com |title=core.async |last1=Hickey |first1=Rich |author2=contributors |access-date=2019-07-07 |archive-date=2019-06-16 |archive-url=https://web.archive.org/web/20190616110609/https://github.com/clojure/core.async |dead-url=no }}</ref>
* [[函数编程语言|函数式]]<ref>{{cite web |url=https://clojure.org/about/functional_programming |website=Clojure.org |title=Functional Programming |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702200218/https://clojure.org/about/functional_programming |dead-url=no }}</ref>
* [[邏輯編程|邏輯編程]]<ref>{{cite web |url=https://github.com/clojure/core.logic/ |website=GitHub.com |title=core.logic |last1=Nolen |first1=David |last2=Hickey |first2=Rich |author3=contributors |access-date=2019-07-07 |archive-date=2019-06-14 |archive-url=https://web.archive.org/web/20190614034913/https://github.com/clojure/core.logic |dead-url=no }}</ref>
* [[宏|宏]]<ref name="reference/macros">{{cite web |url=https://clojure.org/reference/macros |website=Clojure.org |title=Macros |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702200608/https://clojure.org/reference/macros |dead-url=no }}</ref>
* [[管道编程|管道编程]]<ref>{{cite web |url=https://clojure.org/guides/threading_macros |website=Clojure.org |title=Threading Macros Guide |last=Esterhazy |first=Paulus |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702202148/https://clojure.org/guides/threading_macros |dead-url=no }}</ref>
}}
| released = {{start date and age|2007}}
| designer = 里奇·希基
| latest release version = 1.10.3<ref name="release/clojure1-10-3" />
| latest release date = {{start date and age|2021|03|04|df=yes}}
| typing = {{flatlist|
* [[动态类型|动态类型]]
* [[强类型|强类型]]
}}
| implementations = 
| dialects = 
| influenced_by = {{flatlist|
* [[C_Sharp|C#]]
* [[C++|C++]]<ref>{{cite web |url=http://www.codequarterly.com/2011/rich-hickey/ |website=CodeQuarterly.com |title=Rich Hickey Q&A |last=Fogus |first=Michael |year=2011 |archive-url=https://web.archive.org/web/20170111184835/http://www.codequarterly.com/2011/rich-hickey/ |archive-date=2017-01-11 |accessdate=2019-07-08 |dead-url=no }}</ref>
* [[Common_Lisp|Common Lisp]]
* [[Erlang|Erlang]]
* [[Haskell|Haskell]]
* [[Java|Java]]
* [[Mathematica|Mathematica]]<ref>{{cite web |url=https://www.amazon.com/gp/richpub/listmania/fullview/R3LG3ZBZS4GCTH |website=Amazon.com |title=Clojure Bookshelf |last=Hickey |first=Rich |archive-url=https://web.archive.org/web/20171003001051/https://www.amazon.com/gp/richpub/listmania/fullview/R3LG3ZBZS4GCTH |archive-date=2017-10-03 |access-date=2019-07-07 |dead-url=no }}</ref>
* [[ML语言|ML]]
* [[Prolog|Prolog]]
* [[Racket|Racket]]<ref>{{cite thesis |last=Bonnaire-Sergeant |first=Ambrose |title=A Practical Optional Type System for Clojure |publisher=The University of Western Australia |year=2012}}</ref>
* [[Ruby|Ruby]]<ref>{{cite web |url=http://cdn.oreilly.com/oreilly/booksamplers/9781449394707_sampler.pdf |website=OReilly.com |title=Clojure Programming |access-date=2013-04-30 |archive-date=2015-05-21 |archive-url=https://web.archive.org/web/20150521000730/http://cdn.oreilly.com/oreilly/booksamplers/9781449394707_sampler.pdf |dead-url=no }}</ref>
* [[Scheme|Scheme]]
}}
| influenced = {{flatlist|
* [[Elixir|Elixir]]
* [[Hy_(编程语言)|Hy]]
* {{en-link|LFE (编程语言)|LFE (programming_language)|LFE}}
* Pixie<ref>{{cite web |url=https://www.pixielang.org/ |website=PixieLang.org |title=Pixie |last=Baldridge |first=Timothy |access-date=2019-07-07 |archive-date=2019-07-06 |archive-url=https://web.archive.org/web/20190706162850/http://www.pixielang.org/ |dead-url=no }}</ref>
* Rhine<ref>{{cite web |url=https://github.com/artagnon/rhine-ml |website=GitHub.org |title=Rhine |last=Ramachandra |first=Ramkumar |access-date=2019-07-07 |archive-date=2019-09-24 |archive-url=https://web.archive.org/web/20190924204656/https://github.com/artagnon/rhine-ml |dead-url=no }}</ref>
}}
| platform = {{flatlist|
* [[Java平臺|Java]]
* [[JavaScript引擎|JavaScript]]
* [[通用语言架构|.NET]]
}}
| license = [[Eclipse公共许可证|Eclipse公共许可证]]
| website = {{URL|https://clojure.org}}
| file_ext = {{flatlist|
* .clj
* .cljs
* .cljc
* .edn
}}
| wikibooks = Clojure Programming
}}

'''Clojure'''（{{IPAc-en|ˈ|k|l|oʊ|ʒ|ər}}）<ref name="interview/a-z">{{cite web |url=https://www.computerworld.com.au/article/313989/a-z_programming_languages_clojure/ |website=Computerworld.com.au |title=The A-Z of Programming Languages: Clojure |last=Edwards |first=Kathryn |date=2009-08-10 |accessdate=2019-09-11 |archive-date=2019-08-26 |archive-url=https://web.archive.org/web/20190826190240/https://www.computerworld.com.au/article/313989/a-z_programming_languages_clojure/ |dead-url=no }}</ref><ref>{{cite web |url=https://groups.google.com/d/msg/clojure/4uDxeOS8pwY/UHiYp7p1a3YJ |website=Google.com |title=meaning and pronunciation of Clojure |last=Hickey |first=Rich |date=2009-01-05}}</ref>是[[Lisp|Lisp]][[编程语言|编程语言]]在[[Java平臺|Java]]平台上的现代、[[动态语言|动态]]及[[函數程式語言|函数式]]方言。<ref name="platform/android">{{cite web |url=https://www.infoworld.com/article/2619641/clojure-inventor-hickey-now-aims-for-android.html |website=InfoWorld.com |title=Clojure inventor Hickey now aims for Android |last=Krill |first=Paul |date=2012-03-22 |accessdate=2019-07-08 |archive-date=2019-07-08 |archive-url=https://web.archive.org/web/20190708015119/https://www.infoworld.com/article/2619641/clojure-inventor-hickey-now-aims-for-android.html |dead-url=no }}</ref><ref name="clojure.org">{{cite web |url=https://clojure.org/ |title=Clojure |website=Clojure.org |access-date=2019-07-07 |archive-date=2019-07-03 |archive-url=https://web.archive.org/web/20190703235338/https://clojure.org/ |dead-url=yes }}</ref> 与其他Lisp一样，Clojure视[[同像性|代码为数据]]且拥有一套Lisp[[巨集|宏]]系统。<ref name="reference/lisps">{{cite web |url=https://clojure.org/reference/lisps |website=Clojure.org |title=Differences with other Lisps |access-date=2019-07-07 |archive-date=2019-07-08 |archive-url=https://web.archive.org/web/20190708145636/https://clojure.org/reference/lisps |dead-url=no }}</ref>Clojure的开发过程目前由[[實踐社群|社区]]驱动，<ref name="dev/dev">{{cite web |url=https://clojure.org/dev/dev |website=Clojure.org |title=Development |access-date=2019-07-07 |archive-date=2019-07-07 |archive-url=https://web.archive.org/web/20190707131449/https://clojure.org/dev/dev |dead-url=no }}</ref>其作者里奇·希基则以[[终身仁慈独裁者|终身仁慈独裁者]]的身份监督。<ref>{{cite web |url=https://gist.github.com/richhickey/1563cddea1002958f96e7ba9519972d9 |website=GitHub.com |title=Open Source is Not About You |last=Hickey |first=Rich |date=2018-11-26 |accessdate=2019-07-08 |archive-date=2019-05-26 |archive-url=https://web.archive.org/web/20190526052001/https://gist.github.com/richhickey/1563cddea1002958f96e7ba9519972d9 |dead-url=no }}</ref>

Clojure提倡[[不可變物件|不可变性]]与持久数据结构并鼓励程序员显式地管理[[标识|标识]]及其状态。<ref name="about/state">{{cite web |url=https://clojure.org/about/state |website=Clojure.org |title=Values and Change: Clojure’s approach to Identity and State |access-date=2019-07-07 |archive-date=2016-01-02 |archive-url=https://web.archive.org/web/20160102195734/http://clojure.org/state |dead-url=no }}</ref>对利用不可变值及显式时间进展构造（explicit progression-of-time constructs）进行编程的专注旨在促进更加健壮的（尤其是[[并发计算|并发]]）程序的开发。<ref name="about/rationale">{{cite web |url=https://clojure.org/about/rationale |title=Rationale |last=Hickey |first=Rich |website=Clojure.org |access-date=2019-07-07 |archive-date=2016-01-04 |archive-url=https://web.archive.org/web/20160104224634/http://clojure.org/rationale |dead-url=no }}</ref><ref name="msdn/inside-clojure">{{cite web |url=https://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Rich-Hickey-and-Brian-Beckman-Inside-Clojure/ |website=MSDN.com |title=Expert to Expert: Rich Hickey and Brian Beckman – Inside Clojure |last=Torre |first=Charles |date=2009-10-06 |accessdate=2018-11-01 |archive-date=2018-11-03 |archive-url=https://web.archive.org/web/20181103210110/https://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Rich-Hickey-and-Brian-Beckman-Inside-Clojure/ |dead-url=no }}</ref><ref name="interview/a-z" />Clojure的类型系统是完全[[類型系統|动态]]的，但人们近期也开始探索其基于渐进类型化的实现。<ref>{{cite web |url=https://github.com/clojure/core.typed |website=GitHub.com |title=core.typed |access-date=2019-07-07 |archive-date=2018-10-09 |archive-url=https://web.archive.org/web/20181009184207/https://github.com/clojure/core.typed |dead-url=no }}</ref>

对Clojure的商业支持由Cognitect公司提供。<ref>{{cite web |url=https://cognitect.com/technologies.html |website=Cognitect.com |title=Investing in A Better Way |access-date=2019-07-07 |archive-date=2019-07-05 |archive-url=https://web.archive.org/web/20190705175650/https://cognitect.com/technologies.html |dead-url=no }}</ref> 每年都会在全球范围内举办年度Clojure会议，其中最著名的是Clojure/conj<ref>{{cite web |url=http://clojure-conj.org/ |website=Clojure-Conj.org |title=Clojure/conj |access-date=2019-07-07 |archive-date=2015-09-13 |archive-url=https://web.archive.org/web/20150913103752/http://clojure-conj.org/ |dead-url=no }}</ref>。

==历史与开发过程==
{{CSS image crop |Image = Rich Hickey.jpg |bSize = 660 |cWidth = 200 |cHeight = 300 |oTop =40 |oLeft = 430 |Location= right |Description = 里奇·希基，Clojure的创造者}}
里奇·希基创造了Clojure语言。<ref name="platform/android" />此前，他开发过类似但基于[[通用语言架构|.NET]]平台的项目——dotLisp。<ref>{{cite web |url=https://groups.google.com/forum/#!topic/comp.lang.scheme/ibf6CC6V66o |website=Google.com |title=[ANN] dotLisp – a Lisp dialect for .Net |last=Hickey |first=Rich |date=2002-10-16 |accessdate=2018-11-03 |archive-date=2011-01-22 |archive-url=http://arquivo.pt/wayback/20110122130054/https://groups.google.com/forum/#!topic/comp.lang.scheme/ibf6CC6V66o |dead-url=no }}</ref>在那之前，他还尝试了三次在Lisp与[[Java|Java]]之间提供互操作：[[Common_Lisp|Common Lisp]]的Java外语接口<ref>{{cite web |url=https://sourceforge.net/projects/jfli/ |website=SourceForge.net |title=jfli |last=Hickey |first=Rich |date=2013-04-15 |accessdate=2018-11-03 |archive-date=2018-11-03 |archive-url=https://web.archive.org/web/20181103131526/https://sourceforge.net/projects/jfli/ |dead-url=no }}</ref>、Lisp的外语对象接口<ref>{{cite web |url=https://sourceforge.net/projects/foil/ |website=SourceForge.net |title=foil - Foreign Object Interface for Lisp |last=Hickey |first=Rich |date=2013-04-03 |accessdate=2018-11-03 |archive-date=2018-11-03 |archive-url=https://web.archive.org/web/20181103131439/https://sourceforge.net/projects/foil/ |dead-url=no }}</ref>以及Lisp友好的Java Servlet接口<ref>{{cite web |url=https://sourceforge.net/projects/lisplets/ |website=SourceForge.net |title=Lisplets |last=Hickey |first=Rich |date=2013-03-07 |accessdate=2018-11-03 |archive-date=2018-11-03 |archive-url=https://web.archive.org/web/20181103132836/https://sourceforge.net/projects/lisplets/ |dead-url=no }}</ref>。

在公开发布之前，里奇·希基花了大约两年半的时间开发Clojure。他在没有外部资金的情况下，将其大部分时间都专门投入到了Clojure的工作上。开发快要完成，里奇·希基向Common Lisp社区里的一些朋友发布电子邮件，宣布他完成开发了Clojure。

Clojure的开发过程在Clojure [[JIRA|JIRA]]项目网页由社区驱动并管理。<ref name="dev/dev" /><ref>{{cite web |url=https://clojure.atlassian.net/projects/CLJ |website=Atlassian.net |title=Clojure |access-date=2019-07-07 |archive-date=2019-06-23 |archive-url=https://web.archive.org/web/20190623051322/https://clojure.atlassian.net/projects/CLJ |dead-url=no }}</ref>该网站可用于提交问题报告。一般的开发讨论是在Clojure谷歌网上论坛上进行的。<ref>{{cite web |url=https://groups.google.com/forum/#!forum/clojure |website=Google.com |title=Clojure |access-date=2019-07-07 |archive-date=2011-01-22 |archive-url=http://arquivo.pt/wayback/20110122130054/https://groups.google.com/forum/#!forum/clojure |dead-url=no }}</ref> 任何人都可以提交错误报告和想法，而贡献补丁前则需要先签署Clojure贡献者协议。<ref>{{cite web |url=https://clojure.org/dev/contributor_agreement |website=Clojure.org |title=Contributor Agreement |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702201640/https://clojure.org/dev/contributor_agreement |dead-url=yes }}</ref> JIRA错误报告由一组筛选者处理，最终由里奇·希基批准更改。<ref>{{cite web |url=https://clojure.org/dev/workflow |website=Clojure.org |title=Workflow |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702201640/https://clojure.org/dev/workflow |dead-url=no }}</ref>

==设计理念==
里奇·希基开发Clojure的原因是因为他想要一款适合[[函數程式語言|函数式编程]]的现代[[Lisp|Lisp]]。该语言既需要与已建立的[[Java平臺|Java平台]]共生又需要有适合[[并发性|并发性]]的设计。<ref name="about/rationale" /><ref name="msdn/inside-clojure" /><ref>{{cite web |url=https://www.linuxjournal.com/article/10708 |website=LinuxJournal.com |title=Economy Size Geek – Interview with Rich Hickey, Creator of Clojure |last=Elmendorf |first=Dirk |date=2010-04-01 |accessdate=2018-11-03 |archive-date=2018-11-03 |archive-url=https://web.archive.org/web/20181103131452/https://www.linuxjournal.com/article/10708 |dead-url=no }}</ref><ref name="interview/a-z" />

在Clojure中，状态以[[标识|标识]]的概念为特征。<ref name="about/state" />一系列状态随着时间的推移而产生，就是标识。由于状态是不可变的值，任意数量的工作单位都可以在其上并行实施操作，并发性就成为一道管理状态到状态的变化的问题。因此，Clojure提供了几个可变的引用类型。每个引用类型都有其明确定义的语义用于控制状态之间的跃迁。<ref name="about/state" />

==语言概述==
{| class="wikitable"
! 版本
! 发布日期
! 主要功能/改进
|-
|
|2007年10月16日<ref>{{cite web |url=https://clojure.blogspot.com/2009/10/clojure-is-two.html |website=BlogSpot.com |title=Clojure is Two! |last=Hickey |first=Rich |date=2007-10-16 |accessdate=2018-11-04 |archive-date=2018-11-04 |archive-url=https://web.archive.org/web/20181104125833/https://clojure.blogspot.com/2009/10/clojure-is-two.html |dead-url=yes }}</ref>
|首次公开发布
|-
| 1.0
|2009年5月4日<ref>{{cite web |url=https://clojure.blogspot.com/2009/05/clojure-10.html |website=BlogSpot.com |title=Clojure 1.0 |last=Hickey |first=Rich |date=2009-05-04 |accessdate=2018-11-04 |archive-date=2018-11-04 |archive-url=https://web.archive.org/web/20181104125831/https://clojure.blogspot.com/2009/05/clojure-10.html |dead-url=yes }}</ref>
|首个稳定版
|-
| 1.1
|2009年12月31日<ref>{{cite web |url=https://clojure.blogspot.com/2009/12/clojure-11-release.html |website=BlogSpot.com |title=Clojure 1.1 Release |last=Hickey |first=Rich |date=2009-12-31 |accessdate=2018-11-04 |archive-date=2018-11-04 |archive-url=https://web.archive.org/web/20181104085532/https://clojure.blogspot.com/2009/12/clojure-11-release.html |dead-url=yes }}</ref>
|将来
|-
| 1.2
|2010年8月19日<ref>{{cite web |url=https://groups.google.com/forum/#!topic/clojure/tXll-vxyJpc |website=Google.com |title=Clojure 1.2 Release |last=Hickey |first=Rich |date=2010-08-19 |accessdate=2018-11-03 |archive-date=2011-01-22 |archive-url=http://arquivo.pt/wayback/20110122130054/https://groups.google.com/forum/#!topic/clojure/tXll-vxyJpc |dead-url=no }}</ref>
|协议
|-
| 1.3
|2011年9月23日<ref>{{cite web |url=https://groups.google.com/forum/#!topic/clojure/w5Nmx5rPaQs |website=Google.com |title=[ANN] Clojure 1.3 Released |last=Redinger |first=Christopher |date=2011-09-23 |accessdate=2018-11-03 |archive-date=2011-01-22 |archive-url=http://arquivo.pt/wayback/20110122130054/https://groups.google.com/forum/#!topic/clojure/w5Nmx5rPaQs |dead-url=no }}</ref>
|增强对原始类型的支持
|-
| 1.4
|2012年4月15日<ref>{{cite web |url=https://groups.google.com/forum/#!topic/clojure/H4f2nbB6gWI |website=Google.com |title=[ANN] Clojure 1.4 Released |last=Dipert |first=Alan |date=2012-04-17 |accessdate=2018-11-03 |archive-date=2011-01-22 |archive-url=http://arquivo.pt/wayback/20110122130054/https://groups.google.com/forum/#!topic/clojure/H4f2nbB6gWI |dead-url=no }}</ref>
|读取器字面量
|-
| 1.5
|2013年3月1日<ref>{{cite web |url=https://groups.google.com/forum/#!topic/clojure/kzF5O0Yfdhc |website=Google.com |title=ANN: Clojure 1.5 |last=Halloway |first=Stuart |date=2013-03-01 |accessdate=2018-11-03 |archive-date=2011-01-22 |archive-url=http://arquivo.pt/wayback/20110122130054/https://groups.google.com/forum/#!topic/clojure/kzF5O0Yfdhc |dead-url=no }}</ref>
|归纳器
|-
| 1.5.1
|2013年3月10日<ref>{{cite web |url=https://groups.google.com/forum/#!topic/clojure/PDENUpc44lY |website=Google.com |title=Clojure 1.5.1 |last=Halloway |first=Stuart |date=2013-03-10 |accessdate=2018-11-03 |archive-date=2011-01-22 |archive-url=http://arquivo.pt/wayback/20110122130054/https://groups.google.com/forum/#!topic/clojure/PDENUpc44lY |dead-url=no }}</ref>
| 修复内存泄漏
|-
| 1.6
|2014年3月25<ref>{{cite web |url=https://groups.google.com/forum/#!topic/clojure/pArFVr0fJ0w |website=Google.com |title=[ANN] Clojure 1.6 |last=Miller |first=Alex |date=2014-03-25 |accessdate=2018-11-03 |archive-date=2011-01-22 |archive-url=http://arquivo.pt/wayback/20110122130054/https://groups.google.com/forum/#!topic/clojure/pArFVr0fJ0w |dead-url=no }}</ref>
|Java API、经过改进的哈希算法
|-
| 1.7
|2015年6月30日<ref name="release/clojure-17">{{cite web |url=https://clojure.org/news/2015/06/30/clojure-17 |website=Clojure.org |title=Clojure 1.7 is now available |last=Miller |first=Alex |date=2015-06-30 |accessdate=2019-07-08 |archive-date=2019-07-05 |archive-url=https://web.archive.org/web/20190705174148/https://www.clojure.org/news/2015/06/30/clojure-17 |dead-url=yes }}</ref>
|变换归纳器、读取器条件表达式
|-
| 1.8
|2016年1月19日<ref>{{cite web |url=https://clojure.org/news/2016/01/19/clojure18 |website=Clojure.org |title=Clojure 1.8 is now available |last=Miller |first=Alex |date=2016-01-19 |accessdate=2019-07-08 |archive-date=2019-07-05 |archive-url=https://web.archive.org/web/20190705174156/https://www.clojure.org/news/2016/01/19/clojure18 |dead-url=yes }}</ref>
|附加的字符串函数、直接连接、套接字服务器
|-
| 1.9
| 2017年12月8日<ref>{{cite web |url=https://clojure.org/news/2017/12/08/clojure19 |website=Clojure.org |title=Clojure 1.9 is now available |last=Miller |first=Alex |date=2017-12-08 |accessdate=2019-07-08 |archive-date=2019-07-05 |archive-url=https://web.archive.org/web/20190705174205/https://www.clojure.org/news/2017/12/08/clojure19 |dead-url=yes }}</ref>
|集成spec、命令行工具
|-
| 1.10
| 2018年12月17日<ref>{{cite web |url=https://clojure.org/news/2018/12/17/clojure110 |website=Clojure.org |title=Clojure 1.10 release |last=Miller |first=Alex |date=2018-12-17 |accessdate=2018-12-17 |archive-date=2018-12-17 |archive-url=https://web.archive.org/web/20181217174817/https://clojure.org/news/2018/12/17/clojure110 |dead-url=yes }}</ref>
|经过改进的错误报告、Java兼容性
|-
| 1.10.1
| 2019年6月6日<ref name="release/clojure1-10-1">{{cite web |url=https://clojure.org/news/2019/06/06/clojure1-10-1 |website=Clojure.org |title=Clojure 1.10.1 release |last=Miller |first=Alex |date=2019-06-06 |accessdate=2019-06-08 |archive-date=2019-06-07 |archive-url=https://web.archive.org/web/20190607041919/https://clojure.org/news/2019/06/06/clojure1-10-1 |dead-url=yes }}</ref>
|解决Java性能回归问题并改进clojure.main的错误报告
|-
| 1.10.2
| {{start date|2021|01|26}}<ref name="release/clojure1-10-2">{{cite web |url=https://clojure.org/news/2021/01/26/clojure1-10-2 |website=Clojure.org |title=Clojure 1.10.2 release |last=Miller |first=Alex |date=2021-01-26 |access-date=2022-01-08 |archive-date=2022-05-07 |archive-url=https://web.archive.org/web/20220507055027/https://clojure.org/news/2021/01/26/clojure1-10-2 }}</ref>
| Java互操作性/兼容性改进和其他重要语言修订
|-
| {{Version |c |1.10.3}}
| {{start date|2021|03|04}}<ref name="release/clojure1-10-3">{{cite web |url=https://clojure.org/news/2021/03/04/clojure1-10-3 |website=Clojure.org |title=Clojure 1.10.3 release |last=Miller |first=Alex |date=2021-03-04 |access-date=2022-01-08 |archive-date=2022-04-18 |archive-url=https://web.archive.org/web/20220418025226/https://clojure.org/news/2021/03/04/clojure1-10-3 }}</ref>
| prepl支持读者条件
|-
| colspan=3 | {{Version|l|show=000100}}
|}
Clojure执行于[[Java平臺|Java平台]]之上，因此，与Java紧密集成并完全支持从Clojure调用[[Java|Java]]代码。<ref name="about/jvm_hosted">{{cite web |url=https://clojure.org/about/jvm_hosted |website=Clojure.org |title=Hosted on the JVM |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702200222/https://clojure.org/about/jvm_hosted |dead-url=no }}</ref><ref name="interview/a-z" /> 与此同时，也可以从Java调用Clojure代码。<ref>{{cite web |url=https://clojure.org/reference/java_interop#_calling_clojure_from_java |title=Java Interop |website=Clojure.org |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702200629/https://clojure.org/reference/java_interop#_calling_clojure_from_java |dead-url=no }}</ref> Leiningen是社区中普遍使用的项目自动化工具。Leiningen为[[Apache_Maven|Maven]]集成提供支持，处理项目包管理和依赖项。Leiningen的配置使用的则是Clojure语法。<ref>{{cite web |url=https://leiningen.org/ |website=Leiningen.org |title=Leiningen |last=Hagelberg |first=Phil |author2=contributors |access-date=2019-07-07 |archive-date=2019-07-16 |archive-url=https://web.archive.org/web/20190716051300/https://leiningen.org/ |dead-url=no }}</ref>

与其他大多数[[Lisp|Lisp]]一样，Clojure的语法建立在[[S-表达式|S-表达式]]之上。S-表达式在被编译之前先由读取器解析为数据结构。<ref name="reference/reader">{{cite web |url=https://clojure.org/reference/reader |website=Clojure.org |title=The Reader |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702191942/https://clojure.org/reference/reader |dead-url=no }}</ref><ref name="interview/a-z" /> 除了列表之外，Clojure的读取器还支持[[哈希表|映射]]、集合及[[数组|向量]]等的字面量语法。这些字面量随后会被直接编译成上述数据结构。<ref name="reference/reader" /> Clojure是[[Common_Lisp#函数名字空间|Lisp-1]]且有一套与其它Lisp不兼容的数据结构，因此，Clojure不支持与Lisp的其它方言之间的代码级兼容性。<ref name="reference/lisps" />

作为一门Lisp方言，[[子程序#函數|函数]]在Clojure中是[[頭等物件|一等公民]]。此外，Clojure还支持[[读取﹣求值﹣输出循环|读取﹣求值﹣输出循环]]以及一套宏系统。<ref name="reference/macros" /> Clojure的[[巨集|Lisp宏]]系统与[[Common_Lisp|Common Lisp]]的系统极为相似。唯一不同的是，Clojure的[[重音符#編程用途|重音符]]（称为语法引用）用[[命名空间|名字空间]]来限定符号。这有助于防止意外的名字捕获，因为Clojure禁止绑定到用名字空间限定的名字（namespace-qualified name）上。如果需要强制捕获宏扩展（capturing macro expansion，）那么就需要显示地完成该过程。Clojure不支持用户定义的读取器宏（reader macro，）但Clojure的读取器支持更具约束力的语法扩展形式。<ref>{{cite web |url=https://github.com/edn-format/edn |website=GitHub.com |title=edn |last=Hickey |first=Rich |access-date=2019-07-07 |archive-date=2019-03-02 |archive-url=https://web.archive.org/web/20190302223145/https://github.com/edn-format/edn/ |dead-url=no }}</ref> Clojure支持[[多分派|多方法]]（multimethods。）<ref>{{cite web |url=https://clojure.org/reference/multimethods |website=Clojure.org |title=Multimethods and Hierarchies |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702200617/https://clojure.org/reference/multimethods |dead-url=no }}</ref> 对于类似[[介面_(資訊科技)|接口]]的抽象，Clojure提供基于[[协议_(面向对象编程)|协议]]<ref>{{cite web |url=https://clojure.org/reference/protocols |website=Clojure.org |title=Protocols |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702200618/https://clojure.org/reference/protocols |dead-url=no }}</ref>的多态性以及基于[[记录|记录]]<ref>{{cite web |url=https://clojure.org/reference/datatypes |website=Clojure.org |title=Datatypes: deftype, defrecord and reify |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702200612/https://clojure.org/reference/datatypes |dead-url=no }}</ref>的数据类型系统。 Clojure通过这些设计来提供高性能且动态的多态性以避免所谓的“表达式问题”（"expression problem"。）

Clojure支持[[惰性求值|惰性序列]]，并鼓励[[不可變物件|不可变性]]与持久数据结构（persistent data structure。）Clojure作为一门[[函數程式語言|函数式编程语言]]将重点放在[[递归|递归]]与[[高阶函数|高阶函数]]上而不是基于[[函数副作用|副作用]]的[[迴圈|循环]]流程上。Clojure不支持自动[[尾调用|尾调用]]优化，因为JVM还不支持该项优化，<ref>{{cite web |url=https://www.youtube.com/watch?v=2y5Pv4yN0b0&t=1h02m18s |title=Stewardship: the Sobering Parts |website=YouTube.com |last=Goetz |first=Brian |date=2014-11-20 |accessdate=2018-11-04 |archive-date=2016-12-19 |archive-url=https://web.archive.org/web/20161219093717/https://www.youtube.com/watch?v=2y5Pv4yN0b0&t=1h02m18s |dead-url=no }}</ref><ref>{{cite web |url=https://blogs.oracle.com/jrose/tail-calls-in-the-vm |website=Oracle.com |title=tail calls in the VM |last=Rose |first=John |date=2007-07-12 |accessdate=2018-11-04 |archive-date=2018-11-04 |archive-url=https://web.archive.org/web/20181104091208/https://blogs.oracle.com/jrose/tail-calls-in-the-vm |dead-url=no }}</ref><ref>{{cite web |url=https://bugs.openjdk.java.net/browse/JDK-6804517 |website=Java.net |title=Some languages need to be able to perform tail calls |last=Rose |first=John |date=2009-02-11 |accessdate=2018-11-04 |archive-date=2018-11-04 |archive-url=https://web.archive.org/web/20181104125822/https://bugs.openjdk.java.net/browse/JDK-6804517 |dead-url=no }}</ref>但是，可以用<code>recur</code>关键字显式地执行该项优化。<ref>{{cite web |url=https://clojure.org/reference/special_forms#recur |website=Clojure.org |title=Special Forms |access-date=2019-07-07 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702200229/https://clojure.org/reference/special_forms#recur |dead-url=no }}</ref> 对于[[并行计算|并行]]与[[并发计算|并发]]计算，Clojure提供[[软件事务内存|软件事务内存]]、<ref>{{cite web |url=https://clojure.org/refs |website=Clojure.org |title=Refs and Transactions |access-date=2019-07-07 |archive-date=2016-01-09 |archive-url=https://web.archive.org/web/20160109195038/http://clojure.org/refs |dead-url=no }}</ref> [[响应式编程|响应式]][[个体为本模型|代理系统]]<ref name="reference/agents" />及基于[[交談循序程式|通道]]的并发编程。<ref>{{cite web |url=https://clojure.org/news/2013/06/28/clojure-clore-async-channels |website=Clojure.org |title=Clojure core.async Channels |last=Hickey |first=Rich |date=2013-06-28 |accessdate=2019-07-08 |archive-date=2019-07-05 |archive-url=https://web.archive.org/web/20190705174207/https://www.clojure.org/news/2013/06/28/clojure-clore-async-channels |dead-url=no }}</ref>

Clojure 1.7引入了读取器条件表达式从而允许在同一名字空间中嵌入Clojure与ClojureScript代码。<ref name="release/clojure-17" /><ref name="reference/reader" /> 变换归纳器的加入则提供了另一种组合变换的方法。变换归纳器可以使高阶函数（如，<code>map</code>和<code>fold</code>）更加抽象从而使之独立于其输入数据源。传统地说，这些函数一般被应用于[[串列_(抽象資料型別)|序列]]上，而变换归纳器允许这些函数被应用于通道上并让用户定义她们自己的变换归纳模型。<ref>{{cite web |url=https://www.youtube.com/watch?v=6mTbuzafcII |website=YouTube.com |title=Transducers |last=Hickey |first=Rich |date=2014-09-17 |accessdate=2018-11-04 |archive-date=2018-10-01 |archive-url=https://web.archive.org/web/20181001184936/https://www.youtube.com/watch?v=6mTbuzafcII |dead-url=no }}</ref><ref>{{cite web |url=https://blog.cognitect.com/blog/2014/8/6/transducers-are-coming |website=Cognitect.com |title=Transducers are Coming |last=Hickey |first=Rich |date=2014-08-06 |accessdate=2019-07-08 |archive-date=2019-07-07 |archive-url=https://web.archive.org/web/20190707234603/http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming |dead-url=no }}</ref><ref>{{cite web |url=https://www.youtube.com/watch?v=4KqUvG8HPYo |website=YouTube.com |title=Inside Transducers |last=Hickey |first=Rich |date=2014-11-20 |accessdate=2018-11-04 |archive-date=2018-12-07 |archive-url=https://web.archive.org/web/20181207203917/https://www.youtube.com/watch?v=4KqUvG8HPYo |dead-url=no }}</ref>

==平台==
Clojure的主要平台是[[Java平臺|Java]]<ref name="clojure.org" /><ref name="about/jvm_hosted" />但也存在其他目标平台上的实现。其中，最值得关注的是ClojureScript<ref>{{cite web |url=https://clojurescript.org |website=ClojureScript.org |title=ClojureScript |access-date=2019-07-06 |archive-date=2019-07-01 |archive-url=https://web.archive.org/web/20190701132451/https://clojurescript.org/ |dead-url=no }}</ref>（可被编译成[[ECMAScript|ECMAScript]] 3<ref>{{cite web |url=https://clojurescript.org/guides/faq-js#does-clojurescript-work-in-old-browsers |website=ClojureScript.org |title=ClojureScript – FAQ (for JavaScript developers) |access-date=2018-02-04 |archive-date=2018-02-05 |archive-url=https://web.archive.org/web/20180205184416/https://clojurescript.org/guides/faq-js#does-clojurescript-work-in-old-browsers |dead-url=no }}</ref>）和ClojureCLR<ref>{{cite web |url=https://github.com/clojure/clojure-clr |website=GitHub.com |title=ClojureCLR |access-date=2012-06-28 |archive-date=2013-08-25 |archive-url=https://web.archive.org/web/20130825013557/https://github.com/clojure/clojure-clr |dead-url=no }}</ref>（[[通用语言架构|.NET]]平台上的完整移植版，可与其生态系统互操作。）2013年对1,060名受访者进行的Clojure社区调查<ref>{{cite web |url=https://cemerick.com/2013/11/18/results-of-the-2013-state-of-clojure-clojurescript-survey/ |website=CEmerick.com |title=Results of the 2013 State of Clojure & ClojureScript survey |last=Emerick |first=Chas |date=2013-11-18 |accessdate=2018-11-04 |archive-date=2018-10-29 |archive-url=https://web.archive.org/web/20181029191758/https://cemerick.com/2013/11/18/results-of-the-2013-state-of-clojure-clojurescript-survey/ |dead-url=no }}</ref>发现，47％的受访者在使用Clojure的同时也使用ClojureScript。2014年，这一数字增长到了55％，<ref>{{cite web |url=https://cognitect.wufoo.com/reports/state-of-clojure-2014-results/ |website=WuFoo.com |title=State of Clojure 2014 Survey Results |access-date=2015-09-17 |archive-date=2015-10-19 |archive-url=https://web.archive.org/web/20151019173938/https://cognitect.wufoo.com/reports/state-of-clojure-2014-results/ |dead-url=no }}</ref>而到了2015年，则达到了66％（根据2,445名受访者）。<ref>{{cite web |url=https://blog.cognitect.com/blog/2016/1/28/state-of-clojure-2015-survey-results |website=Cognitect.com |title=State of Clojure 2015 Survey Results |last=Gehtland |first=Justin |date=2016-01-28 |accessdate=2018-11-04 |archive-date=2018-11-04 |archive-url=https://web.archive.org/web/20181104130125/https://blog.cognitect.com/blog/2016/1/28/state-of-clojure-2015-survey-results |dead-url=no }}</ref> 人气较高的ClojureScript项目包括[[React|React]]实现，如Reagent<ref>{{cite web |url=https://reagent-project.github.io/ |website=GitHub.io |title=Reagent |access-date=2019-07-06 |archive-date=2019-07-18 |archive-url=https://web.archive.org/web/20190718124913/http://reagent-project.github.io/ |dead-url=no }}</ref>、re-frame<ref>{{cite web |url=https://github.com/Day8/re-frame |website=GitHub.com |title=re-frame |access-date=2019-07-06 |archive-date=2019-07-12 |archive-url=https://web.archive.org/web/20190712104945/https://github.com/Day8/re-frame |dead-url=no }}</ref>、Rum<ref>{{cite web |url=https://github.com/tonsky/rum |website=GitHub.com |title=Rum |last=Prokopov |first=Nikita |access-date=2019-07-06 |archive-date=2019-12-22 |archive-url=https://web.archive.org/web/20191222080048/https://github.com/tonsky/rum |dead-url=no }}</ref>及Om<ref>{{cite web |url=https://github.com/omcljs/om |website=GitHub.com |title=Om |last=Nolen |first=David |access-date=2019-07-06 |archive-date=2019-06-19 |archive-url=https://web.archive.org/web/20190619012315/https://github.com/omcljs/om |dead-url=no }}</ref><ref>{{cite web |url=https://www.infoq.com/news/2014/01/om-react/ |website=InfoQ.com |title=Om: Enhancing Facebook's React with Immutability |last=Coupland |first=Tom |date=2014-01-17 |accessdate=2019-07-08 |archive-date=2019-07-06 |archive-url=https://web.archive.org/web/20190706081127/https://www.infoq.com/news/2014/01/om-react/ |dead-url=no }}</ref>。

==人气==
随着对函数式编程的兴趣的持续升温，Clojure也越来越多地受到Java平台上的软件开发人员的青睐。该语言也一度成为知名软件开发老将，如Brian Goetz<ref>{{cite web |url=https://www.twitch.tv/nipafx/clip/BloodyUglySharkFailFish |website=Twitch.tv |title=Brian Goetz' favorite non-Java JVM language (Part 1 of 3) |last=Goetz |first=Brian |date=2020-05-24 |accessdate=2020-08-07 |archive-date=2020-07-28 |archive-url=https://web.archive.org/web/20200728163728/https://www.twitch.tv/nipafx/clip/BloodyUglySharkFailFish |dead-url=no }}</ref><ref>{{cite web |url=https://www.twitch.tv/nipafx/clip/GrotesqueWonderfulPigeonEleGiggle |website=Twitch.tv |title=Brian Goetz' favorite non-Java JVM language (Part 2 of 3) |last=Goetz |first=Brian |date=2020-05-24 |accessdate=2020-08-07 |archive-date=2020-07-28 |archive-url=https://web.archive.org/web/20200728170145/https://www.twitch.tv/nipafx/clip/GrotesqueWonderfulPigeonEleGiggle |dead-url=no }}</ref><ref>{{cite web |url=https://www.twitch.tv/nipafx/clip/EphemeralAdorableWalletGingerPower |website=Twitch.tv |title=Brian Goetz' favorite non-Java JVM language (Part 3 of 3) |last=Goetz |first=Brian |date=2020-05-24 |accessdate=2020-08-07 |archive-date=2020-07-28 |archive-url=https://web.archive.org/web/20200728202004/https://www.twitch.tv/nipafx/clip/EphemeralAdorableWalletGingerPower |dead-url=no }}</ref>、Eric Evans<ref>{{cite web |url=https://www.youtube.com/watch?v=T29WzvaPNc8&t=926 |website=YouTube.com |title=Modelling Time - Eric Evans - Domain-Driven Design Europe 2018 |last=Evans |first=Eric |date=2018-08-14 |accessdate=2019-11-10 |archive-date=2019-09-30 |archive-url=https://web.archive.org/web/20190930180109/https://www.youtube.com/watch?v=T29WzvaPNc8 |dead-url=no }}</ref><ref>{{cite web |url=https://twitter.com/ericevans0/status/535742147098853376 |website=Twitter.com |title=Eric Evans on Twitter |last=Evans |first=Eric |date=2014-11-21 |access-date=2019-11-10 |archive-date=2021-06-11 |archive-url=https://web.archive.org/web/20210611133145/https://twitter.com/ericevans0/status/535742147098853376 }}</ref>、[[詹姆斯·高斯林|詹姆斯·高斯林]]<ref>{{cite web |url=https://www.youtube.com/watch?v=-ktUXFxkSkI&t=25m25s |website=YouTube.com |title=James Gostling meetup with London Java Community |date=2016-10-11 |accessdate=2019-06-08 |archive-date=2019-09-24 |archive-url=https://web.archive.org/web/20190924204632/https://www.youtube.com/watch?v=-ktUXFxkSkI&t=25m25s |dead-url=no }}</ref>、[[保罗·格雷厄姆|保罗·格雷厄姆]]<ref>{{cite web |url=https://twitter.com/paulg/status/728831131534024704 |website=Twitter.com |title=Paul Graham on Twitter |last=Graham |first=Paul |date=2016-05-06 |accessdate=2019-06-08 |archive-date=2020-01-27 |archive-url=https://web.archive.org/web/20200127045845/https://twitter.com/paulg/status/728831131534024704 |dead-url=no }}</ref>及Robert C. Martin（俗称“鲍勃大叔”）<ref>{{cite web |url=http://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html |website=CleanCoder.com |title=Why Clojure? |last=Martin |first=Robert |date=2019-08-22 |accessdate=2019-08-23 |archive-date=2019-08-23 |archive-url=https://web.archive.org/web/20190823043433/https://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html |dead-url=no }}</ref><ref>{{cite web |url=https://twitter.com/unclebobmartin/status/1068205421737857024 |website=Twitter.com |title=Unble Bob Martin on Twitter |last=Martin |first=Robert |date=2018-11-29 |accessdate=2019-06-08 |archive-date=2019-09-24 |archive-url=https://web.archive.org/web/20190924204633/https://twitter.com/unclebobmartin/status/1068205421737857024 |dead-url=no }}</ref><ref>{{cite web |url=https://cleancoders.com/video-details/clean-code-episode-53 |website=CleanCoders.com |title=Introduction To Functional Programming |last=Martin |first=Robert |date=2018-08 |accessdate=2019-07-08 |archive-date=2019-07-08 |archive-url=https://web.archive.org/web/20190708055038/https://cleancoders.com/video-details/clean-code-episode-53 |dead-url=no }}</ref><ref>{{cite web |url=https://blog.cleancoder.com/uncle-bob/2017/07/11/PragmaticFunctionalProgramming.html |website=CleanCoder.com |title=Pragmatic Functional Programming |last=Martin |first=Robert |date=2017-07-11 |accessdate=2019-07-08 |archive-date=2019-07-08 |archive-url=https://web.archive.org/web/20190708055039/https://blog.cleancoder.com/uncle-bob/2017/07/11/PragmaticFunctionalProgramming.html |dead-url=no }}</ref>等，的首选或推荐语言。

在由Snyk和Java Magazine合作编写的“JVM生态系统报告2018”（据称是“Java开发人员有史以来规模最大的调查”）中，Clojure被评为用于“主要应用程序”的第二大人气编程语言（仅次于Java）。<ref>{{cite web |url=https://snyk.io/blog/jvm-ecosystem-report-2018/ |website=Snyk.io |title=JVM Ecosystem Report 2018 |last1=Maple |first1=Simon |last2=Binstock |first2=Andrew |date=2018-10-17 |accessdate=2019-06-08 |archive-date=2019-06-08 |archive-url=https://web.archive.org/web/20190608045808/https://snyk.io/blog/jvm-ecosystem-report-2018/ |dead-url=yes }}</ref>

业内使用Clojure的公司有[[苹果公司|苹果公司]]<ref>{{cite web |url=https://twitter.com/roman01la/status/942469177444569089 |website=Twitter.com |title=Roman Liutikov on Twitter |last=Liutikov |first=Roman |date=2017-12-17 |accessdate=2018-11-02 |archive-date=2019-02-15 |archive-url=https://web.archive.org/web/20190215195019/https://twitter.com/roman01la/status/942469177444569089 |dead-url=no }}</ref><ref>{{cite web |url=https://jobs.apple.com/en-us/search?sort=relevance&search=clojure |website=Apple.com |title=Jobs at Apple |access-date=2019-07-06 |archive-date=2018-12-08 |archive-url=https://web.archive.org/web/20181208123800/https://jobs.apple.com/en-us/search?sort=relevance&search=clojure |dead-url=no }}</ref>、[[Atlassian|Atlassian]]<ref>{{cite web |url=https://www.youtube.com/watch?v=3QR8meTrh5g |website=YouTube.com |title=Realtime Collaboration with Clojure |last=Borges |first=Leonardo |date=2015-07-07 |accessdate=2019-06-08 |archive-date=2018-09-06 |archive-url=https://web.archive.org/web/20180906184735/https://www.youtube.com/watch?v=3QR8meTrh5g |dead-url=no }}</ref>、Funding Circle<ref>{{cite web |url=https://juxt.pro/blog/posts/clojure-in-fundingcircle.html |website=JUXT.pro |title=Clojure in London: Funding Circle – Lending some Clojure |last=Pither |first=Jon |date=2016-10-04 |accessdate=2018-11-02 |archive-date=2018-12-08 |archive-url=https://web.archive.org/web/20181208123306/https://juxt.pro/blog/posts/clojure-in-fundingcircle.html |dead-url=no }}</ref>、[[Netflix|Netflix]]<ref>{{cite web |url=https://thenewstack.io/the-new-stack-makers-adrian-cockcroft-on-sun-netflix-clojure-go-docker-and-more/ |website=TheNewStack.io |title=The New Stack Makers: Adrian Cockcroft on Sun, Netflix, Clojure, Go, Docker and More |last=Williams |first=Alex |date=2014-08-03 |accessdate=2019-06-08 |archive-date=2019-06-08 |archive-url=https://web.archive.org/web/20190608042313/https://thenewstack.io/the-new-stack-makers-adrian-cockcroft-on-sun-netflix-clojure-go-docker-and-more/ |dead-url=no }}</ref>、 Puppet <ref>{{cite web |url=https://puppet.com/blog/a-new-era-of-application-services-at-puppet-labs/ |website=Puppet.com |title=A New Era of Application Services at Puppet Labs |last=Price |first=Chris |date=2014-04-11 |access-date=2020-08-06 |archive-date=2019-09-03 |archive-url=https://web.archive.org/web/20190903185532/https://puppet.com/blog/a-new-era-of-application-services-at-puppet-labs |dead-url=no }}</ref>、[[沃尔玛|沃尔玛]]<ref>{{cite web |url=https://blog.cognitect.com/blog/2015/6/30/walmart-runs-clojure-at-scale |website=Cognitect.com |title=Walmart Runs Clojure at Scale |last=Phillips |first=Marc |date=2015-07-14 |accessdate=2018-11-03 |archive-date=2018-11-03 |archive-url=https://web.archive.org/web/20181103131307/https://blog.cognitect.com/blog/2015/6/30/walmart-runs-clojure-at-scale |dead-url=no }}</ref>及其他大型软件公司<ref>{{cite web |url=https://clojure.org/community/success_stories |website=Clojure.org |title=Success Stories |access-date=2018-10-27 |archive-date=2018-10-28 |archive-url=https://web.archive.org/web/20181028033614/https://clojure.org/community/success_stories |dead-url=no }}</ref>与[[美国国家航空航天局|美国国家航空航天局]]<ref>{{cite web |url=https://github.com/nasa/Common-Metadata-Repository |website=GitHub.com |title=Common-Metadata-Repository |access-date=2019-07-06 |archive-date=2019-03-22 |archive-url=https://web.archive.org/web/20190322183757/https://github.com/nasa/Common-Metadata-Repository |dead-url=no }}</ref>等政府机构。Clojure也一度被用于创意计算，包括视觉艺术、音乐、游戏和诗歌。<ref>{{cite web |url=http://radar.oreilly.com/2015/05/creative-computing-with-clojure.html |website=OReilly.com |title=Creative computing with Clojure |last=Meier |first=Carin |date=2015-05-06 |accessdate=2018-11-04 |archive-date=2018-10-29 |archive-url=https://web.archive.org/web/20181029153700/http://radar.oreilly.com/2015/05/creative-computing-with-clojure.html |dead-url=no }}</ref>

美国知名软件咨询公司ThoughtWorks在为其“技术雷达”<ref>{{cite web |url=https://www.thoughtworks.com/radar/faq |website=ThoughtWorks.com |title=Frequently Asked Questions - Technology Radar - ThoughtWorks |access-date=2019-02-10 |archive-date=2019-02-07 |archive-url=https://web.archive.org/web/20190207123920/https://www.thoughtworks.com/radar/faq |dead-url=no }}</ref>评估函数式编程语言时表达了他们对Clojure的青睐，称其为“Lisp在JVM上的简单及优雅实现”，并在2012年将其状态提升为“采用”（“ADOPT”）<ref>{{cite web |url=https://www.thoughtworks.com/radar/languages-and-frameworks/clojure |website=ThoughtWorks.com |title=Clojure - Technology Radar - ThoughtWorks |access-date=2019-02-10 |archive-date=2019-02-12 |archive-url=https://web.archive.org/web/20190212011805/https://www.thoughtworks.com/radar/languages-and-frameworks/clojure |dead-url=no }}</ref>。

越来越多的非官方和/或实验性的其他平台实现也验证了该语言的人气：
* CljPerl<ref>{{cite web |url=https://metacpan.org/pod/CljPerl |website=MetaCPAN.org |title=A Lisp on Perl |last=Hu |first=Wei |access-date=2019-07-06 |archive-date=2019-06-04 |archive-url=https://web.archive.org/web/20190604025939/https://metacpan.org/pod/CljPerl |dead-url=no }}</ref>：Clojure的[[Perl|Perl]]实现
* Clojerl<ref>{{cite web |url=https://github.com/clojerl/clojerl |website=GitHub.com |title=Clojerl |last=Facorro |first=Juan |access-date=2019-07-06 |archive-date=2019-06-20 |archive-url=https://web.archive.org/web/20190620012838/https://github.com/clojerl/clojerl |dead-url=no }}</ref>：BEAM（[[Erlang|Erlang]]虚拟机）上的Clojure
* clojure-py<ref>{{cite web |url=https://github.com/drewr/clojure-py |website=GitHub.com |title=clojure-py |last=Baldridge |first=Timothy |access-date=2019-07-06 |archive-date=2019-06-20 |archive-url=https://web.archive.org/web/20190620171649/https://github.com/drewr/clojure-py |dead-url=no }}</ref>：Clojure的纯[[Python|Python]]实现
* Ferret<ref>{{cite web |url=https://ferret-lang.org/ |website=Ferret-Lang.org |title=Ferret |last=Akkaya |first=Nurullah |access-date=2019-07-06 |archive-date=2019-07-06 |archive-url=https://web.archive.org/web/20190706075045/https://ferret-lang.org/ |dead-url=no }}</ref>：可被编译成运行于微控制器的自包含（self-contained）C++11
* Joker<ref>{{cite web |url=https://joker-lang.org/ |website=Joker-Lang.org |title=Joker |last=Bataev |first=Roman |access-date=2019-07-06 |archive-date=2019-09-24 |archive-url=https://web.archive.org/web/20190924204633/https://joker-lang.org/ |dead-url=no }}</ref>：用[[Go|Go]]实现的解释器和[[lint|linter]]
* Las3r<ref>{{cite web |url=https://github.com/aemoncannon/las3r |website=GitHub.com |title=Laz3r |last=Cannon |first=Aemon |access-date=2019-07-06 |archive-date=2019-05-11 |archive-url=https://web.archive.org/web/20190511125333/https://github.com/aemoncannon/las3r |dead-url=no }}</ref>：执行于[[ActionScript|ActionScript]]虚拟机（Adobe Flash Player平台）的Clojure子集
* Pixie<ref>{{cite web |url=http://www.pixielang.org/ |website=PixieLang.org |title=Pixie |last=Baldridge |first=Timothy |access-date=2019-07-06 |archive-date=2019-07-06 |archive-url=https://web.archive.org/web/20190706162850/http://www.pixielang.org/ |dead-url=no }}</ref>：受Clojure启发并用[[PyPy|RPython]]实现的Lisp方言
* Rouge<ref>{{cite web |url=https://github.com/ecmendenhall/rouge |website=GitHub.com |title=Rouge |last=Connor |first=Ashe |access-date=2019-07-06 |archive-date=2018-06-11 |archive-url=https://web.archive.org/web/20180611000913/https://github.com/ecmendenhall/rouge |dead-url=no }}</ref>：Clojure基于YARV的[[Ruby|Ruby]]实现

==开发工具==
Clojure的开发工具在近几年得到了显著的改善。以下是目前最具人气的[[集成开发环境|集成开发环境]]/编辑器及其Clojure插件。<ref>{{cite web |url=https://www.clojure.org/news/2019/02/04/state-of-clojure-2019 |website=Clojure.org |title="State of Clojure 2019" Results |last=Miller |first=Alex |date=2019-02-04 |accessdate=2019-07-05 |archive-date=2019-07-05 |archive-url=https://web.archive.org/web/20190705174145/https://www.clojure.org/news/2019/02/04/state-of-clojure-2019 |dead-url=no }}</ref>这些工具的结合为Clojure编程提供了出色的支持。
{| class="wikitable"
|+ 集成开发环境/编辑器及其Clojure插件
 ! 集成开发环境/编辑器
 ! Clojure插件
 |-
 | [[Atom_(文字編輯器)|Atom]]
 | Chlorine<ref>{{cite web |url=https://atom.io/packages/chlorine |website=Atom.io |title=Chlorine: Socket REPL Client for Clojure and ClojureScript |last=Szabo |first=Maurício |access-date=2019-07-05 |archive-date=2019-07-05 |archive-url=https://web.archive.org/web/20190705174145/https://atom.io/packages/chlorine |dead-url=no }}</ref>
 |-
 | [[Emacs|Emacs]]
 | CIDER<ref>{{cite web |url=https://cider.mx/ |website=CIDER.mx |title=CIDER: The Clojure Interactive Development Environment that Rocks |last=Batsov |first=Bozhidar |author2=contributors |access-date=2019-07-05 |archive-date=2019-06-08 |archive-url=https://web.archive.org/web/20190608051532/https://cider.mx/ |dead-url=no }}</ref>
 |-
 | [[IntelliJ_IDEA|IntelliJ IDEA]]
 | Clojure-Kit<ref>{{cite web |url=https://plugins.jetbrains.com/plugin/8636-clojure-kit |website=JetBrains.com |title=Clojure-Kit: Clojure and ClojureScript plugin for IntelliJ-based tools |last=Shrago |first=Greg |access-date=2019-07-05 |archive-date=2019-05-31 |archive-url=https://web.archive.org/web/20190531042220/https://plugins.jetbrains.com/plugin/8636-clojure-kit |dead-url=no }}</ref>或Cursive<ref>{{cite web |url=https://plugins.jetbrains.com/plugin/8090-cursive |website=JetBrains.com |title=Cursive: Provides full Clojure and ClojureScript language support |last=Fleming |first=Colin |access-date=2019-07-05 |archive-date=2019-05-20 |archive-url=https://web.archive.org/web/20190520010641/https://plugins.jetbrains.com/plugin/8090-cursive |dead-url=no }}</ref>（提供免费的非商业许可证）
 |-
 | Light Table<ref>{{cite web |url=http://lighttable.com/ |website=LightTable.com |title=Light Table: The Next Generation Code Editor |access-date=2019-07-05 |archive-date=2019-07-03 |archive-url=https://web.archive.org/web/20190703235337/http://lighttable.com/ |dead-url=no }}</ref>
 | （不适用）
 |-
 | [[Vim|Vim]]
 | fireplace.vim<ref>{{cite web |url=https://www.vim.org/scripts/script.php?script_id=4978 |website=VIM.org |title=fireplace.vim: Clojure REPL Support |last=Pope |first=Tim |access-date=2019-07-05 |archive-date=2019-08-22 |archive-url=https://web.archive.org/web/20190822032539/https://www.vim.org/scripts/script.php?script_id=4978 |dead-url=no }}</ref><ref>{{cite web |url=https://juxt.pro/blog/posts/vim-1.html |website=JUXT.pro |title=Clojure and Vim: An overview – It's very possible |last=Monroe |first=Dominic |date=2016-12-13 |accessdate=2019-07-15 |archive-date=2019-07-14 |archive-url=https://web.archive.org/web/20190714175704/https://juxt.pro/blog/posts/vim-1.html |dead-url=no }}</ref>, vim-iced<ref>{{cite web |url=https://liquidz.github.io/vim-iced/ |website=GitHub.com |title=vim-iced: Clojure Interactive Development Environment for Vim8/Neovim |last=Masashi |first=Iizuka |access-date=2020-03-13 |archive-date=2020-04-10 |archive-url=https://web.archive.org/web/20200410222941/https://liquidz.github.io/vim-iced/ |dead-url=no }}</ref>或Conjure（仅限Neovim）<ref>{{cite web |url=https://github.com/Olical/conjure |website=GitHub.com |title=Neovim Clojure(Script) tooling over prepl |last=Caldwell |first=Oliver |access-date=2019-11-09 |archive-date=2019-11-22 |archive-url=https://web.archive.org/web/20191122202431/https://github.com/Olical/conjure |dead-url=no }}</ref><ref>{{cite web |url=https://oli.me.uk/getting-started-with-clojure-neovim-and-conjure-in-minutes/ |website=oli.me.uk |title=Getting started with Clojure, Neovim and Conjure in minutes |last=Caldwell |first=Oliver |date=2019-11-06 |accessdate=2019-11-10 |archive-date=2019-11-11 |archive-url=https://web.archive.org/web/20191111105229/https://oli.me.uk/getting-started-with-clojure-neovim-and-conjure-in-minutes/ |dead-url=no }}</ref>
 |-
 | [[Visual_Studio_Code|Visual Studio Code]]
 | Calva<ref>{{cite web |url=https://marketplace.visualstudio.com/items?itemName=betterthantomorrow.calva |website=VisualStudio.com |title=Calva: Clojure & ClojureScript Interactive Programming |last=Strömberg |first=Peter |access-date=2019-07-05 |archive-date=2019-08-22 |archive-url=https://web.archive.org/web/20190822170948/https://marketplace.visualstudio.com/items?itemName=betterthantomorrow.calva |dead-url=no }}</ref>
 |}

除了社区提供的开发工具之外，官方的[[命令行界面|命令行界面]]工具<ref name="guides/deps_and_cli">{{cite web |url=https://clojure.org/guides/deps_and_cli |website=Clojure.org |title=Deps and CLI Guide |last=Miller |first=Alex |access-date=2019-07-08 |archive-date=2019-07-02 |archive-url=https://web.archive.org/web/20190702202154/https://clojure.org/guides/deps_and_cli |dead-url=no }}</ref>也随着Clojure 1.9一起发布并可在GNU/Linux、macOS及Windows上使用。<ref>{{cite web |url=http://blog.cognitect.com/blog/clojure19 |website=Cognitect.com |title=Clojure 1.9 |last=Miller |first=Alex |date=2017-12-08 |accessdate=2019-07-05 |archive-date=2019-07-05 |archive-url=https://web.archive.org/web/20190705175628/http://blog.cognitect.com/blog/clojure19 |dead-url=no }}</ref>

==功能示例==
以下示例均可在Clojure REPL中运行（如，使用Clojure命令行界面工具<ref name="guides/deps_and_cli" />启动的REPL或在REPL.it<ref>{{cite web |url=https://repl.it/l/clojure |website=REPL.it |title=Online Clojure REPL |access-date=2019-07-08 |archive-date=2019-07-09 |archive-url=https://web.archive.org/web/20190709020152/https://repl.it/l/clojure |dead-url=no }}</ref>上提供的在线REPL。）

===简单性===
由于强调简单性，典型的Clojure程序主要包括函数和简单的数据结构（即列表，向量，映射和集合）：
<syntaxhighlight lang="clojure">
;; 一个典型的Clojure程序的入口
(defn -main ; 函数名
  [& args] ; 参数向量 (`&`表示可变参数)
  (println "Hello, World!")) ; 函数体
</syntaxhighlight>

===REPL编程===
与其他[[Lisp|Lisp]]一样，Clojure的标志性特征之一是基于[[REPL|REPL]]的交互式编程。<ref>{{cite web |url=https://clojure.org/guides/repl/introduction |website=Clojure.org |title=Programming at the REPL: Introduction |access-date=2018-12-04 |archive-date=2018-12-04 |archive-url=https://web.archive.org/web/20181204134219/https://clojure.org/guides/repl/introduction |dead-url=no }}</ref>在以下示例中，<code>;;</code>表示一行注释的开始，而<code>;; =></code>则表示输出：

<syntaxhighlight lang="clojure">
;; 定义一个var
(def a 42)
;; => #'user/a

;; 调用名为`+`的函数
(+ a 8)
;; => 50

;; 调用名为`even?`的函数
(even? a)
;; => true

;; 定义一个函数以返回n除10之余
(defn foo [n] (rem n 10))
;; => #'user/foo

;; 调用该函数
(foo a)
;; => 2

;; 打印`rem`的文档字符串（docstring）
(doc rem)
;; =>
-------------------------
clojure.core/rem
([num div])
 remainder of dividing numerator by denominator.

;; 打印`rem`的源代码
(source rem)
;; =>
(defn rem
  "remainder of dividing numerator by denominator."
  {:added "1.0"
   :static true
   :inline (fn [x y] `(. clojure.lang.Numbers (remainder ~x ~y)))}
  [num div]
    (. clojure.lang.Numbers (remainder num div)))
</syntaxhighlight>

===运行时可用的名字===
与Clojure不同，其他语言的编译器会将程序中的名字编译掉使得它们在运行时不可用。而在Clojure中，可以用普通的数据结构对其运行时进行观察：
<syntaxhighlight lang="clojure">
;; 定义一个var
(def a 42)
;; => #'user/a

;; 以映射（map）的形式获取在`user`名字空间中捕获的（interned）所有var
(ns-publics 'user)
;; => {a #'user/a}

;; 用`#'`（读取器宏）及其关联的、名字空间限定的符号`user/a`引用该var
#'user/a
;; => #'user/a

;; 解引用该var（获取其值）
(deref #'user/a)
;; => 42

;; 定义（并附加文档字符串）一个函数以返回n除10之余
(defn foo "返回`(rem n 10)`" [n] (rem n 10))
;; => #'user/foo

;; 获取var `#'user/foo`的元数据
(meta #'user/foo)
;; =>
{:arglists ([n]),
 :doc "返回`(rem n 10)`",
 :line 1,
 :column 1,
 :file "user.clj",
 :name foo,
 :ns #namespace[user]}
</syntaxhighlight>

===代码即数据（同像性）===
与其他Lisp类似，Clojure也具有[[同像性|同像性]]（又称代码即数据）。从下面的示例中可以看到，用Clojure编写代码从而修改代码本身是非常容易的：

<syntaxhighlight lang="clojure">
;; 调用一个函数 （代码）
(+ 1 1)
;; => 2

;; 引用该函数调用
;;（将代码转换成数据，此处为含一组符号的列表）
(quote (+ 1 1))
;; => (+ 1 1)

;; 获取该列表上的首个元素
;; （视代码为数据并对其进行操作）
(first (quote (+ 1 1)))
;; => +

;; 获取该列表上的最后一个元素
;; （视代码为数据并对其进行操作）
(last (quote (+ 1 1)))
;; => 1

;; 替换原列表上的符号从而获取一个新列表
;; （视代码为数据并对其进行操作）
(map (fn [form]
       (case form
         1 'one
         + 'plus))
     (quote (+ 1 1)))
;; => (plus one one)
</syntaxhighlight>

===富有表现力的数据变换操作符===
穿梭宏（threading macro，如，<code>-></code>、<code>->></code>等）可以在语法上表达一个数据集在一系列变换间穿梭的抽象：

<syntaxhighlight lang="clojure">
(->> (range 10)
     (map inc)
     (filter even?))
;; => (2 4 6 8 10)
</syntaxhighlight>

利用变换归纳器也可以更有效地实现该过程：

<syntaxhighlight lang="clojure">
(sequence (comp (map inc)
                (filter even?))
          (range 10))
;; => (2 4 6 8 10)
</syntaxhighlight>

===标识及其状态的线程安全管理===
[[线程安全|线程安全]]的唯一序列号生成器（然而，和许多其他Lisp方言一样，Clojure内部使用其内置的<code>gensym</code>函数）：

<syntaxhighlight lang="clojure">
(def i (atom 0))

(defn generate-unique-id
  "每次调用会返回一个唯一数字ID。"
  []
  (swap! i inc))
</syntaxhighlight>

===宏===
<code lang="java">java.io.Writer</code>的一个匿名子类（不写任何内容）和一个宏（使用该类来静音其中打印的所有内容）:

<syntaxhighlight lang="clojure">
(def bit-bucket-writer
  (proxy [java.io.Writer] []
    (write [buf] nil)
    (close []    nil)
    (flush []    nil)))

(defmacro noprint
  "在对给定的`forms`求值的同时静音所有向`*out*`打印的内容。"
  [& forms]
  `(binding [*out* bit-bucket-writer]
     ~@forms))

(noprint
  (println "Hello, nobody!"))
;; => nil
</syntaxhighlight>

===Java互操作===
作为其主要设计目标之一，Clojure从一开始就将其宿主平台视为其不可分割的一部分。Clojure与Java之间出色的互操作即得益于此：

<syntaxhighlight lang="clojure">
;; 调用一个实例方法
(.toUpperCase "apple")
;; => "APPLE"

;; 调用一个静态方法
(System/getProperty "java.vm.version")
;; => "12+33"

;; 创建`java.util.HashMap`的一个实例
;; 并加入一些键值对（key-value pairs）
(doto (java.util.HashMap.)
  (.put "apple" 1)
  (.put "banana" 2))
;; => {"banana" 2, "apple" 1}

;; 创建`java.util.ArrayList`的一个实例
;; 并用`clojure.core/map`递增（increment）其元素
(def al (doto (java.util.ArrayList.)
          (.add 1)
          (.add 2)
          (.add 3)))

(map inc al)
;; => (2 3 4)

;; 利用Java Swing显示一个消息对话框
(javax.swing.JOptionPane/showMessageDialog
  nil
  "Hello, World!")
;; => nil
</syntaxhighlight>

===软件事务内存===
10个线程操纵一个共享数据结构，该结构由100个向量组成，而每个向量包含10个（最初是连续的）唯一数字。每个线程随后在两个随机向量中重复选择两个随机位置并交换它们。通过使用Clojure的[[软件事务内存|软件事务内存]]系统，对向量的所有更改都发生在事务中：

<syntaxhighlight lang="clojure">
(defn run
  [nvecs nitems nthreads niters]
  (let [vec-refs
        (->> (* nvecs nitems)
             (range)
             (into [] (comp (partition-all nitems)
                            (map vec)
                            (map ref))))

        swap
        #(let [v1 (rand-int nvecs)
               v2 (rand-int nvecs)
               i1 (rand-int nitems)
               i2 (rand-int nitems)]
          (dosync
            (let [tmp (nth @(vec-refs v1) i1)]
              (alter (vec-refs v1) assoc i1 (nth @(vec-refs v2) i2))
              (alter (vec-refs v2) assoc i2 tmp))))

        report
        #(->> vec-refs
              (into [] (comp (map deref)
                             (map (fn [v] (prn v) v))
                             cat
                             (distinct)))
              (count)
              (println "Distinct:"))]

    (report)

    (->> #(dotimes [_ niters] (swap))
         (repeat nthreads)
         (apply pcalls)
         (dorun))

    (report)))

(run 100 10 10 100000)
;; =>
[0 1 2 3 4 5 6 7 8 9]
[10 11 12 13 14 15 16 17 18 19]
  ...
[990 991 992 993 994 995 996 997 998 999]
Distinct: 1000

[382 318 466 963 619 22 21 273 45 596]
[808 639 804 471 394 904 952 75 289 778]
  ...
[484 216 622 139 651 592 379 228 242 355]
Distinct: 1000
nil
</syntaxhighlight>

==参考文献==
{{Reflist|30em}}

==延伸阅读==
{{Refbegin}}

* {{citation
| first1 = Dmitri
| last1 = Sotnikov
| year = 2020
| title = Web Development with Clojure
| publisher = [[Pragmatic_Bookshelf|Pragmatic Bookshelf]]
| edition = 3rd
| isbn = 978-1-68050-682-2
| url = https://pragprog.com/titles/dswdcloj3/
| accessdate = 2020-08-07
| archive-date = 2021-12-17
| archive-url = https://web.archive.org/web/20211217033027/https://pragprog.com/titles/dswdcloj3/
}}
* {{citation
| first1 = Russ
| last1 = Olsen
| year = 2018
| title = Getting Clojure
| publisher = [[Pragmatic_Bookshelf|Pragmatic Bookshelf]]
| isbn = 978-1-68050-300-5
| url = https://pragprog.com/titles/roclojure/
| accessdate = 2020-08-07
| archive-date = 2020-08-07
| archive-url = https://web.archive.org/web/20200807025614/https://pragprog.com/titles/roclojure/
| dead-url = no
}}
* {{citation
| first1 = Alex
| last1 = Miller
| first2 = Stuart
| last2 = Halloway
| first3 = Aaron
| last3 = Bedra
| year = 2018
| title = Programming Clojure
| publisher = [[Pragmatic_Bookshelf|Pragmatic Bookshelf]]
| edition = 3rd
| isbn = 978-1-68050-246-6
| url = https://pragprog.com/titles/shcloj3/
| accessdate = 2020-08-07
| archive-date = 2020-08-07
| archive-url = https://web.archive.org/web/20200807080531/https://pragprog.com/titles/shcloj3/
| dead-url = no
}}
* {{citation
| first1 = Amit
| last1 = Rathore
| first2 = Francis
| last2 = Avila
| year = 2015
| title = Clojure in Action
| publisher = [[Manning_Publications|Manning]]
| edition = 2nd
| isbn = 978-1-61729-152-4
}}
* {{citation
| first1 = Daniel
| last1 = Higginbotham
| year = 2015
| title = Clojure for the Brave and True
| publisher = [[No_Starch_Press|No Starch Press]]
| isbn = 978-1-59327-591-4
| url = https://www.braveclojure.com/clojure-for-the-brave-and-true/
| accessdate = 2018-11-05
| archive-date = 2018-11-29
| archive-url = https://web.archive.org/web/20181129025609/https://www.braveclojure.com/clojure-for-the-brave-and-true/
| dead-url = no
}}
* {{citation
| first1 = Julian
| last1 = Gamble
| year = 2015
| title = Clojure Recipes
| publisher = [[Pearson_Publishing|Pearson Publishing]]
| isbn = 978-0-32192-773-6
| url = http://www.informit.com/store/clojure-recipes-9780321927736
| accessdate = 2018-11-05
| archive-date = 2018-11-06
| archive-url = https://web.archive.org/web/20181106053433/http://www.informit.com/store/clojure-recipes-9780321927736
| dead-url = no
}}
* {{citation
| first1 = Ben
| last1 = Vandgrift
| first2 = Alex
| last2 = Miller
| year = 2015
| title = Clojure Applied
| publisher = [[Pragmatic_Bookshelf|Pragmatic Bookshelf]]
| isbn = 978-1-68050-074-5
| url = https://pragprog.com/titles/vmclojeco/
| accessdate = 2020-08-07
| archive-date = 2020-08-07
| archive-url = https://web.archive.org/web/20200807013200/https://pragprog.com/titles/vmclojeco/
| dead-url = no
}}
* {{citation
| first1 = Eric
| last1 = Rochester
| year = 2015
| title = Clojure Data Analysis Cookbook
| publisher = [[Packt_Publishing|Packt Publishing]]
| edition = 2nd
| isbn = 978-1-78439-029-7
| url = https://www.packtpub.com/application-development/clojure-data-analysis-cookbook-second-edition
| accessdate = 2018-11-05
| archive-date = 2018-11-05
| archive-url = https://web.archive.org/web/20181105160533/https://www.packtpub.com/application-development/clojure-data-analysis-cookbook-second-edition
| dead-url = no
}}
* {{citation
| first1 = Michael
| last1 = Fogus
| first2 = Chris
| last2 = Houser
| year = 2014
| title = The Joy of Clojure
| publisher = [[Manning_Publications|Manning]]
| edition = 2nd
| isbn = 1-617291-41-2
| url = http://www.joyofclojure.com/
| accessdate = 2018-11-05
| archive-date = 2018-10-23
| archive-url = https://web.archive.org/web/20181023083354/http://www.joyofclojure.com/
| dead-url = no
}}
* {{citation
| first1 = Ryan
| last1 = Kelker
| year = 2013
| title = Clojure for Domain-specific Languages
| publisher = [[Packt_Publishing|Packt Publishing]]
| isbn = 978-1-78216-650-4
| url = https://www.packtpub.com/application-development/clojure-domain-specific-languages
| accessdate = 2020-08-07
| archive-date = 2020-07-28
| archive-url = https://web.archive.org/web/20200728164910/https://www.packtpub.com/application-development/clojure-domain-specific-languages
| dead-url = no
}}
* {{citation
| first1 = Eric
| last1 = Rochester
| year = 2014
| title = Mastering Clojure Data Analysis
| publisher = [[Packt_Publishing|Packt Publishing]]
| isbn = 978-1-78328-413-9
| url = https://www.packtpub.com/big-data-and-business-intelligence/mastering-clojure-data-analysis
| accessdate = 2018-11-05
| archive-date = 2018-11-05
| archive-url = https://web.archive.org/web/20181105160541/https://www.packtpub.com/big-data-and-business-intelligence/mastering-clojure-data-analysis
| dead-url = no
}}
* {{citation
| first1 = Chas
| last1 = Emerick
| first2 = Brian
| last2 = Carper
| first3 = Christophe
| last3 = Grand
| date = April 19, 2012
| title = Clojure Programming
| publisher = [[O'Reilly_Media|O'Reilly Media]]
| isbn = 1-4493-9470-1
| url = http://www.clojurebook.com/
| accessdate = 2018-11-05
| archive-date = 2019-01-07
| archive-url = https://web.archive.org/web/20190107032021/http://www.clojurebook.com/
| dead-url = no
}}
* {{citation
| first1 = Luke
| last1 = VanderHart
| first2 = Stuart
| last2 = Sierra
| date = June 7, 2010
| title = Practical Clojure
| publisher = [[Apress|Apress]]
| isbn = 978-1-4302-7231-1
| url = https://www.apress.com/us/book/9781430272311
| accessdate = 2018-11-05
| archive-date = 2018-11-05
| archive-url = https://web.archive.org/web/20181105160433/https://www.apress.com/us/book/9781430272311
| dead-url = no
}}
{{Refend}}

==外部链接==
{{Official website}}

{{-}}
{{Lisp programming language}}
{{程序设计语言|Clojure}}

[[Category:動態編程語言|Category:動態編程語言]]
[[Category:函数式编程语言|Category:函数式编程语言]]
[[Category:JVM程式語言|Category:JVM程式語言]]
[[Category:LISP程式語言家族|Category:LISP程式語言家族]]
[[Category:2007年建立的程式語言|Category:2007年建立的程式語言]]