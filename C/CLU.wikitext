{{Infobox programming language
|name = CLU
|logo =
|paradigm = [[编程范型|多范型]]: [[面向对象程序设计|面向对象]], [[过程式编程|过程式]]
|released = {{Start date and age|1975}}
|designer = [[芭芭拉·利斯科夫|芭芭拉·利斯科夫]]和她的学生
|developer = [[麻省理工学院|麻省理工学院]]
|latest release version = Native CLU 1.5 ([[SPARC|SPARC]], [[VAX|VAX]]) / {{Start date and age|1989|05|26}}<ref name="Native">{{cite web |url=http://pmg.csail.mit.edu/~dcurtis/clu/ |title=CLU home page |website=Programming Methodology Group, Computer Science and Artificial Intelligence Laboratory |publisher=Massachusetts Institute of Technology |first=Dorothy |last=Curtis |date=2009-11-06 |accessdate=2016-05-26 |archive-date=2016-06-02 |archive-url=https://web.archive.org/web/20160602050527/http://pmg.csail.mit.edu/~dcurtis/clu/ |dead-url=no }}</ref><br />
Portable CLU / {{Start date and age|2009|11|06}}<ref name="Portable">{{cite web |url=ftp://ftp.lcs.mit.edu/pub/pclu |title=Index of /pub/pclu |website=Programming Methodology Group, Computer Science and Artificial Intelligence Laboratory |publisher=Massachusetts Institute of Technology |first=Dorothy |last=Curtis |date=2009-11-06 |accessdate=2016-05-26}}</ref>
|latest release date = 
|typing = [[强类型|强类型]]
|website = {{URL|www.pmg.lcs.mit.edu/CLU.html}}
|implementations = Native CLU<ref name="Native" />, Portable CLU<ref name="Portable" />, clu2c<ref name="clu2c">{{cite web |url=http://woodsheep.jp/clu2c.html |title=clu2c |website=clu2c |publisher=woodsheep.jp |first=Tetsu |last=Ushijima |date=<!--Likely embedded in downloadable target or zip files.--> |accessdate=2016-05-26 |archive-date=2016-03-04 |archive-url=https://web.archive.org/web/20160304223619/http://woodsheep.jp/clu2c.html |dead-url=no }}</ref>
|dialects =
|influenced by = [[ALGOL_60|ALGOL 60]], [[Lisp|Lisp]]<ref>{{cite web|title=A history of CLU|author=[[Barbara_Liskov|Barbara Liskov]]|url=https://pmg.csail.mit.edu/ftp.lcs.mit.edu/pub/pclu/CLU/3.Documents/clu-history.PDF|year=1992|quote=CLU looks like an Algol-like language, but its semantics is like that of Lisp: CLU objects reside in an object universe (or heap), and a variable just identifies (or refers to) an object. We decided early on to have objects in the heap, although we had numerous discussions about the cost of garbage collection. This decision greatly simplified the data abstraction mechanism ……. A language that allocates objects only on the stack is not sufficiently expressive; the heap is needed for objects whose sizes must change and for objects whose lifetime exceeds that of the procedure that creates them. …… Therefore, the choice is: just heap, or both. ……<br />One unusual aspect of CLU is that our procedures have no free (global) variables ……. The view of procedures in CLU is similar to that in Lisp: CLU procedures are not nested (except that there can be local procedures within a cluster) but instead are defined at the "top" level, and can be called from any other module. In Lisp such procedures can have free variables that are scoped dynamically, a well-known source of confusion.|access-date=2022-04-27|archive-date=2021-11-05|archive-url=https://web.archive.org/web/20211105133631/https://pmg.csail.mit.edu/ftp.lcs.mit.edu/pub/pclu/CLU/3.Documents/clu-history.PDF}}</ref>, [[Simula|Simula]]<ref>{{cite web|title=A history of CLU|author=[[Barbara_Liskov|Barbara Liskov]]|url=https://pmg.csail.mit.edu/ftp.lcs.mit.edu/pub/pclu/CLU/3.Documents/clu-history.PDF|year=1992|quote=Programming languages that existed when the concept of data abstraction arose did not support abstract data types, but some languages contained constructs that were precursors of this notion. …… The mechanism that matched the best was the class mechanism of Simula 67. A Simula class groups a set of procedures with some variables. A class can be instantiated to provide an object containing its own copies of the variables; the class contains code that initializes these variables at instantiation time. However, Simula classes did not enforce encapsulation ……, and Simula was lacking several other features needed to support data abstraction, …….|access-date=2022-04-27|archive-date=2021-11-05|archive-url=https://web.archive.org/web/20211105133631/https://pmg.csail.mit.edu/ftp.lcs.mit.edu/pub/pclu/CLU/3.Documents/clu-history.PDF}}</ref>
|influenced = [[Ada|Ada]], [[Argus_(编程语言)|Argus]], [[C++|C++]], [[Lua|Lua]], [[Python|Python]]<ref name="effbot-call-by-object">{{cite web |url=http://effbot.org/zone/call-by-object.htm |title=Call By Object |work=effbot.org |last=Lundh |first=Fredrik |quote=replace "CLU" with "Python", "record" with "instance", and "procedure" with "function or method", and you get a pretty accurate description of Python's object model. |accessdate=21 November 2017 |archive-date=2019-11-23 |archive-url=https://web.archive.org/web/20191123043655/http://effbot.org/zone/call-by-object.htm |dead-url=yes }}</ref>, [[Ruby|Ruby]], {{en-link|Sather}}, [[Swift_(程式語言)|Swift]]<ref name="lattner2014">{{cite web |url=http://nondot.org/sabre/ |title=Chris Lattner's Homepage |last=Lattner |first=Chris |date=2014-06-03 |accessdate=2014-06-03 |publisher=Chris Lattner |quote=The Swift language is the product of tireless effort from a team of language experts, documentation gurus, compiler optimization ninjas, and an incredibly important internal dogfooding group who provided feedback to help refine and battle-test ideas. Of course, it also greatly benefited from the experiences hard-won by many other languages in the field, drawing ideas from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list. |archive-date=2018-12-25 |archive-url=https://web.archive.org/web/20181225175312/http://nondot.org/sabre/ |dead-url=no }}</ref>
}}

'''CLU'''是一门[[编程语言|编程语言]]，由[[芭芭拉·利斯科夫|芭芭拉·利斯科夫]]和她的学生在1974年到1975年于[[麻省理工学院|麻省理工学院]]（MIT）创造。虽然它没有被广泛使用，但它引入了[[抽象数据类型|抽象数据类型]]<ref>{{Cite book |doi= 10.1145/800233.807045 |chapter= Programming with abstract data types |title= Proceedings of the ACM SIGPLAN symposium on Very high level languages |pages= 50–59 |year= 1974 |last1= Liskov |first1= Barbara |authorlink1= Barbara Liskov |last2= Zilles |first2= Stephen |ref= harv}}</ref>，和许多现在广泛使用的特性，而被视为[[面向对象编程|面向对象编程]]发展的重要一步。

主要贡献还包括：[[求值策略#传共享对象调用|传共享调用]]、[[迭代器|迭代器]]、多值返回（[[并行赋值|并行赋值]]形式）、[[参数化类型|参数化类型]]和[[可变类型|可变类型]]。值得注意的是它使用了具有[[构造器|构造器]]和[[方法_(计算机科学)|方法]]的[[类_(计算机科学)|类]]，但没有[[继承_(计算机科学)|继承]]。

== 聚簇 ==
CLU的语法基于了[[ALGOL|ALGOL]]，这是多数新语言设计的起点。关键增补是“聚簇”（cluster）概念，它是CLU的类型扩展系统和语言名字的根源（CLUster）<ref name=Liskov1977>{{Cite journal |url= https://web.eecs.umich.edu/~weimerw/2011-6610/reading/liskov-clu-abstraction.pdf |last1= Liskov |first1= B. |author-link1= Barbara Liskov |last2= Snyder |first2= A. |last3= Atkinson |first3= R. |last4= Schaffert |first4= C. |title= Abstraction mechanisms in CLU |doi= 10.1145/359763.359789 |journal= [[Communications_of_the_ACM|Communications of the ACM]] |volume= 20 |issue= 8 |pages= 564–576 |date= August 1977 |access-date= 2021-03-09 |archive-date= 2021-08-09 |archive-url= https://web.archive.org/web/20210809090353/https://web.eecs.umich.edu/~weimerw/2011-6610/reading/liskov-clu-abstraction.pdf }}</ref>。聚簇一般对应于面向对象语言中“类”的概念。例如，下面是CLU用来实现[[复数_(数学)|复数]]的语法：
    complex_number = <span style="color:green;font-weight: bold;">cluster</span> <span style="color:green;font-weight: bold;">is</span> add, subtract, multiply, ...
        rep = <span style="color:green;font-weight: bold;">record</span> [ real_part: <span style="color:brown;">real</span>, imag_part: <span style="color:brown;">real</span> ]
        add = <span style="color:green;font-weight: bold;">proc</span> ... <span style="color:green;font-weight: bold;">end</span> add;
        subtract = <span style="color:green;font-weight: bold;">proc</span> ... <span style="color:green;font-weight: bold;">end</span> subtract;
        multiply = <span style="color:green;font-weight: bold;">proc</span> ... <span style="color:green;font-weight: bold;">end</span> multiply;
        ...
    <span style="color:green;font-weight: bold;">end</span> complex_number;

聚簇是一个模块，它封装了除了那些在<code>is</code>子句中显式命名的成员之外的所有成员。这些成员对应于现在面向对象语言中一个类的公开成员。聚簇还定义了可以在聚簇之外引用名字的一个类型（在这个案例中是<code>complex_number</code>），但是它的表示类型（这里的<code>rep</code>）对于外部客户是隐藏的。

聚簇名字是全局的，不提供名字空间机制来组织聚簇，也不允许它们在其他聚簇内部被“局部”创建。

CLU不进行[[类型转换|隐式类型转换]]。在聚簇中，显式类型转换<code>up</code>和<code>down</code>在[[抽象类型|抽象类型]]和表示之间进行变更。有一个全体类型<code>any</code>，和一个过程<code>force[]</code>来检查一个对象是否是一个特定类型。对象可以是可变的或不可变的，后者是基础类型，比如整数、布尔值、字符和字符串<ref name=Liskov1977/>。

== 其他特征 ==
CLU类型系统的另一个关键特征是[[迭代器|迭代器]]，它一个接一个的、顺序的从一个[[集合_(计算机科学)|搜集]]返回对象<ref name=Liskov1977 />。迭代器提供了一致的[[应用编程接口|应用编程接口]]（API），而不管所用于的是什么数据。因此给<code>complex_number</code>的一个搜集的迭代器，同给<code>integer</code>的数组的迭代器，可以互换的使用。CLU迭代器的显著特征是它们被实现为[[协程|协程]]，每个值都是通过<code>yield</code>语句提供给调用者的。像CLU中这样的迭代器，现在是很多现代语言比如[[C♯|C#]]、[[Ruby|Ruby]]和[[Python|Python]]的常见特征，然而它们近来经常被称为[[生成器_(计算机编程)|生成器]]。下面是迭代器的例子：

    <span style="color:darkcyan;">% 产生从1到n的奇数</span>
    odds = <span style="color:green;font-weight: bold;">iter</span>(n:<span style="color:brown;">int</span>) <span style="color:green;font-weight: bold;">yields</span> <span style="color:brown;">int</span>
        i:<span style="color:brown;">int</span>
        i = 1
        <span style="color:green;font-weight: bold;">while</span> i < n <span style="color:green;font-weight: bold;">do</span>
            <span style="color:green;font-weight: bold;">yield</span> i
            i := i + 2
        <span style="color:green;font-weight: bold;">end</span>
    <span style="color:green;font-weight: bold;">end</span> odds  
     <span> </span>
    <span style="color:green;font-weight: bold;">for</span> i:<span style="color:brown;">int</span> <span style="color:green;font-weight: bold;">in</span> odds(13) <span style="color:green;font-weight: bold;">do</span>
        print int$unparse(i) || "\n"
    <span style="color:green;font-weight: bold;">end</span>

CLU还包括了[[异常处理|异常处理]]，它参考了在其他语言中的各种尝试；异常使用<code>signal</code>引发，并通过<code>except</code>处理。不同于具有异常处理的多数其他语言，异常不会被隐式的沿着调用链重新发起。不同之处还有，在CLU中异常被当作是正常执行流程的一部份，并作为“正常”而有效的一种类型安全的方式，用来退出循环或从函数返回；它允许用<code>except when</code>直接指定在其他条件适用时的返回值。既未捕获也未显式的重新发起的异常，被立即转换成特殊失败异常，这典型的会终止程序。

CLU经常被引证为具有类型安全的[[可变类型|可变类型]]的第一个语言，在这里叫作<code>oneof</code>，早于[[ML语言|ML]]语言拥有的叫做{{en-link|代数数据类型|Algebraic data type}}的[[标签联合|标签联合]]。

CLU中最后一个显著特征是[[并行赋值|并行赋值]]（多赋值），这里多于一个变量可以出现在[[赋值语句|赋值]]算符的左侧。例如，书写<code>x,y := y,x</code>将交换<code>x</code>和<code>y</code>的值。以相同的方式，函数可以返回多个值，比如<code>x,y,z := f(t)</code>。并行赋值（但未包括多返回值），在CLU之前已经出现在[[CPL_(程式语言)|CPL]]（1963年）之中，叫作“同时赋值”<ref>{{cite journal |first1= D. W. |last1= Barron |first2= J. N. |last2= Buxton |first3= D. F. |last3= Hartley |first4= E. |last4= Nixon |first5= C. |last5= Strachey |title= The main features of CPL |journal= Computer Journal |volume= 6 |issue= 2 |pages= 134–143 |date= 1963 |url= http://comjnl.oxfordjournals.org/cgi/reprint/6/2/134 |doi= 10.1093/comjnl/6.2.134 |access-date= 2021-03-09 |archive-date= 2012-07-07 |archive-url= https://archive.today/20120707200431/http://comjnl.oxfordjournals.org/cgi/reprint/6/2/134 }}</ref>，然而确是CLU使之流行，并被引证为对后来语言中出现的并行赋值有直接的影响。

在CLU程序中所有对象都存活在堆中，而内存管理是自动化的。

CLU支持[[泛型编程|参数化类型]]的用户定义数据抽象。它是提供类型安全限定的参数化类型的第一个语言，它使用<code>where</code>子句结构，来表达在实际类型实际参数上的约束。

== 影响 ==
CLU和[[Ada|Ada]]是[[C++|C++]]的[[模板_(C++)|模板]]的主要启发者<ref name="Stroustrup">{{cite web | first=Bjarne | last=Stroustrup | title=The C++ Programming Language (Third Edition and Special Edition) | url=http://www.stroustrup.com/ | work=Bjarne Stroustrup's homepage | date=2004-09-08 | accessdate=2020-09-21 | archive-date=2019-05-14 | archive-url=https://web.archive.org/web/20190514123147/http://www.stroustrup.com/ | dead-url=no }}</ref>。

CLU的异常处理机制影响了后来的语言如[[C++|C++]]和[[Java|Java]]<ref>{{cite web |url=http://www.mindview.net/Etc/Discussions/CheckedExceptions |archive-url=https://web.archive.org/web/20020405175011/http://www.mindview.net/Etc/Discussions/CheckedExceptions |archive-date=2002-04-05 |title=Bruce Eckel's MindView, Inc: Does Java need Checked Exceptions? |publisher=Mindview.net |accessdate=2011-12-15 |dead-url=yes }}</ref>。

{{en-link|Sather}}、[[Python|Python]]和[[C♯|C#]]所包含的[[迭代器|迭代器]]，最早出现在CLU中。

[[Perl|Perl]]和[[Lua|Lua]]采用的多赋值和从函数调用返回多个值来自CLU<ref>{{Cite book |last1= Ierusalimschy |first1= R. |last2= De Figueiredo |first2= L. H. |last3= Celes |first3= W. |doi= 10.1145/1238844.1238846 |chapter= The evolution of Lua |title= Proceedings of the third ACM SIGPLAN conference on History of programming languages – HOPL III |pages= 2-1–2-26 |year= 2007 |isbn= 978-1-59593-766-7 |url= http://www.lua.org/doc/hopl.pdf |access-date= 2020-09-21 |archive-date= 2020-08-17 |archive-url= https://web.archive.org/web/20200817041936/https://www.lua.org/doc/hopl.pdf |dead-url= no }}</ref>。

[[Python|Python]]和[[Ruby|Ruby]]从它引入了[[求值策略#传共享对象调用|传共享调用]]、<code>yield</code>语句<ref name="Appfolio">{{cite web |url=https://engineering.appfolio.com/appfolio-engineering/2019/7/3/rubys-roots-and-matzs-leadership |title=Ruby's Roots and Matz's Leadership |website=Appfolio Engineering |quote=Matz feels that blocks are the greatest invention of Ruby (I agree.) He got the idea from a 1970s language called CLU from MIT, which called them 'iterators'... |date=2019-11-08 |accessdate=2019-11-15 |archive-date=2019-11-14 |archive-url=https://web.archive.org/web/20191114183754/https://engineering.appfolio.com/appfolio-engineering/2019/7/3/rubys-roots-and-matzs-leadership |dead-url=no }}</ref>和多赋值<ref>{{Cite web|title=Functional Programming HOWTO — Python 3.8.3 documentation|url=https://docs.python.org/3/howto/functional.html|website=docs.python.org|access-date=2020-05-25|archive-date=2012-10-24|archive-url=https://web.archive.org/web/20121024163217/http://docs.python.org/howto/functional.html|dead-url=no}}</ref>。

== 参考资料 ==
{{Reflist|2}}

== 外部链接 ==
* {{Official website|www.pmg.lcs.mit.edu/CLU.html}}
* [https://pmg.csail.mit.edu/ftp.lcs.mit.edu/pub/pclu/CLU/3.Documents/clu-history.PDF A History of CLU] {{Wayback|url=https://pmg.csail.mit.edu/ftp.lcs.mit.edu/pub/pclu/CLU/3.Documents/clu-history.PDF |date=20211105133631 }} (pdf)
* [http://woodsheep.jp/clu2c.html clu2c]{{Wayback|url=http://woodsheep.jp/clu2c.html |date=20161221103210 }}: a program to compile CLU code to [[C语言|C]]
* [http://cgibin.erols.com/ziring/cgi-bin/cep/cep.pl?_key=CLU Dictionary of Programming Languages]{{Wayback|url=http://cgibin.erols.com/ziring/cgi-bin/cep/cep.pl?_key=CLU |date=20060314172855 }}
* [http://99-bottles-of-beer.net/language-clu-133.html CLU]{{Wayback|url=http://99-bottles-of-beer.net/language-clu-133.html |date=20070928030256 }} comparison at '99 bottles of beer' multi-language demo algorithm site
{{-}}
{{程序设计语言}}

[[Category:学术的编程语言|Category:学术的编程语言]]
[[Category:过程式编程语言|Category:过程式编程语言]]
[[Category:基于类的编程语言|Category:基于类的编程语言]]
[[Category:1975年建立的程式語言|Category:1975年建立的程式語言]]