{{更新|time=2021-03-06T20:25:00+08:00}}
{{noteTA
|G1=IT
}}
{{Infobox software
| name = CUDA
| screenshot = 
| developer = [[Nvidia|Nvidia]]
| released = {{Start date and age|2007|06|23}}
| latest_release_version = 11.7.0
| latest_release_date = {{Start date and age|2022|05|11}}
| operating_system = [[Windows|Windows]]、[[macOS|macOS]]、[[Linux|Linux]]
| genre = [[GPGPU|GPGPU]]
| license = [[专有软件|专有软件]]
| website = {{URL|https://developer.nvidia.com/cuda-zone}}
}}
'''CUDA'''（'''C'''ompute '''U'''nified '''D'''evice '''A'''rchitecture，'''统一计算架构'''<ref>{{Cite web |url=http://cuda.csdn.net/Contest/pro/index.aspx |title=CUDA是Compute Unified Device Architecture（统一计算架构）的简称 |accessdate=2010-02-08 |archive-date=2010-02-13 |archive-url=https://web.archive.org/web/20100213115710/http://cuda.csdn.net/Contest/pro/index.aspx |dead-url=no }}</ref>）是由英伟达[[NVIDIA|NVIDIA]]所推出的一種整合技術，是該公司對於[[GPGPU|GPGPU]]的正式名稱。透過這個技術，使用者可利用NVIDIA的[[GPU|GPU]]进行[[图像处理|图像处理]]之外的運算，亦是首次可以利用GPU作為C-编译器的开发环境。CUDA 開發套件（CUDA Toolkit ）只能將自家的CUDA C-語言（對[[OpenCL|OpenCL]]只有[[链接器|链接]]的功能<ref>{{Cite web |date=2021-05-25 |title=Nvcc compiler and OpenCL kernel |url=https://forums.developer.nvidia.com/t/nvcc-compiler-and-opencl-kernel/178868 |website=NVIDIA Developer Forums |language=zh-CN |access-date=2022-06-22}}</ref>），也就是執行於GPU的部分編譯成{{Link-en|PTX|Parallel Thread Execution}}[[中間語言|中間語言]]或是特定[[英偉達|NVIDIA]] GPU架構的[[機器碼|機器碼]]（[[NVIDIA|NVIDIA]] 官方稱為 "device code"）；而執行於[[中央处理器|中央处理器]]部分的[[C语言|C]] / [[C++|C++]]程式碼（[[NVIDIA|NVIDIA]] 官方稱為 "host code"）仍依賴於外部的編譯器，如[[Microsoft_Windows|Microsoft Windows]]下需要[[Microsoft_Visual_Studio|Microsoft Visual Studio]]；[[Linux|Linux]]下則主要依賴於[[GCC|GCC]]。<ref>{{Cite web |title=NVIDIA CUDA Compiler Driver NVCC |url=https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html |website=docs.nvidia.com |language=en-us |access-date=2022-06-22}}</ref><ref>{{Cite web |title=CUDA Installation Guide for Microsoft Windows |url=https://docs.nvidia.com/cuda/cuda-installation-guide-microsoft-windows/index.html |website=docs.nvidia.com |language=en-us |access-date=2022-06-23}}</ref><ref>{{Cite web |title=NVIDIA CUDA Installation Guide for Linux |url=https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html |website=docs.nvidia.com |language=en-us |access-date=2022-06-23}}</ref>

== 簡介 ==
[[File:CUDA_processing_flow_(En).PNG|缩略图]]
GPU不僅用於進行圖形渲染，而且用於物理運算（物理效果如碎片、煙、火、流體）如PhysX和Bullet。進一步的，GPU可以用在計算生物學與密碼學等領域的非圖形應用上。在NVIDIA收購[[AGEIA|AGEIA]]後，NVIDIA取得相關的物理加速技術，即是[[PhysX|PhysX]]物理引擎。配合CUDA技術，顯示卡可以模擬成一顆PhysX物理加速晶片<ref>{{Cite web |title=全系列GeForce 8显卡将获得PhysX物理支持 |url=http://news.mydrivers.com/1/99/99629.htm |archive-url=https://web.archive.org/web/20080417051732/http://news.mydrivers.com/1/99/99629.htm |archive-date=2008-04-17 |accessdate=2008-05-02 |dead-url=no}}</ref>。目前，全系列的[[GeForce_8|GeForce 8]]顯示核心都支援CUDA。而NVIDIA亦不會再推出任何的物理加速卡，顯示卡將會取代相關產品。

而使用CUDA技術，GPU可以用來進行通用處理（不僅僅是圖形）；這種方法被稱為GPGPU。與CPU不同的是，GPU以較慢速度並行大量執行緒，而非快速執行單一執行緒。以[[GeForce_8|GeForce 8800 GTX]]为例，其核心擁有128个内处理器。利用CUDA技術，就可以將那些内处理器做為线程处理器，以解决数据密集的计算。而各個内处理器能够交换、同步和共享数据。GeForce 8800 GTX的运算能力可达到520GFlops，如果建設[[SLI|SLI]]系统，就可以达到1TFlops。<ref name=双剑合璧：CPU+GPU异构计算完全解析>{{cite web|author=小熊在线-宁道奇|title=双剑合璧：CPU+GPU异构计算完全解析|url=http://cms.beareyes.com.cn/html/2011/06/20/application/116_10.shtml|publisher=小熊在线|accessdate=2013-06-18|deadurl=yes|archiveurl=https://archive.is/20130624134959/http://cms.beareyes.com.cn/html/2011/06/20/application/116_10.shtml|archivedate=2013-06-24}}</ref>

目前，已有軟體廠商利用CUDA技術，研發出Adobe Premiere Pro的插件。通過插件，使用者就可以利用[[顯示核心|顯示核心]]去加速[[H.264/MPEG-4_AVC|H.264/MPEG-4 AVC]]的编码速度。速度是單純利用[[CPU|CPU]]作軟體加速的7倍左右。

雖然CUDA底層是以C/C++為主，並以使用“NVCC”——NVIDIA基於LLVM的C/C++編譯器介面來進行編譯，但程式師也可以使用編譯器指令（如OpenACC）以及多種程式設計語言擴展對CUDA平臺進行操作。如Fortran程式師可以使用“CUDA Fortran”，或[[PGI|PGI]]公司的PGI CUDA Fortran 編譯器進行編譯。除了此之外CUDA平臺還支援其它計算介面，如Khronos Group的[[OpenCL|OpenCL]]，Microsoft的[[DirectCompute|DirectCompute]]，以及C++AMP。也可以透過其他語言如 Python，Perl，Java，Ruby，Lua，Haskell，MATLAB，IDL及Mathematica 的介面間接調用CUDA。

CUDA最初的CUDA軟體發展包（SDK）於2007年2月15日公佈，同時支持Microsoft Windows和Linux。而後在第二版中加入對Mac OS X的支持(但於CUDA Toolkit 10.2起放棄對macOS的支援)，取代2008年2月14日發佈的測試版。所有G8x系列及以後的NVIDIA GPUs皆支援CUDA技術，包括GeForce，Quadro和Tesla系列。CUDA與大多數標準作業系統相容。Nvidia聲明：根據二進位相容性，基於G8x系列開發的程式無需修改即可在未來所有的Nvidia顯卡上運行。

== 優點 ==

在GPUs（GPGPU）上使用圖形APIs進行傳統通用計算，CUDA技術有下列幾個優點：<ref>{{Cite web |title=CUDA C++ Programming Guide |url=https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html |website=docs.nvidia.com |language=en-us |access-date=2022-06-23}}</ref>

* 分散讀取——代碼可以從記憶體的任意位址讀取

* 統一虛擬記憶體（Unified Memory, 從 CUDA 6.0 開始）—— 將所有 CPU 和 GPU 的內存置於統一管理的[[虚拟内存|虛擬記憶體空間]]下。

* 共用記憶體（Global Memory）—— 存取快速的區域，使之在多個[[執行緒|執行緒]]間共用，有效頻寬比紋理記憶體（Texture Memory）更大。

* 與GPU之間更快的下載與回讀

* 全面支持整型與位操作，包括整型紋理查找

== 限制 ==

* CUDA不支援完整的C語言標準。它在C++編譯器上運行主機程式碼時，會使一些在C中合法（但在C++中不合法）的代碼無法編譯。

* 不支持紋理渲染（CUDA 3.2及以後版本通過在CUDA陣列中引入“表面寫操作”——底層的不透明資料結構——來進行處理）

* 受系統主線的頻寬和延遲的影響，主機與設備記憶體之間資料複製可能會導致性能下降（通過過GPU的DMA引擎處理，非同步記憶體傳輸可在一定範圍內緩解此現象）

* 當執行緒總數為數千時，執行緒應按至少32個一組來運行才能獲得最佳效果。如果每組中的32個執行緒使用相同的執行路徑，則程式分支不會顯著影響效果；在處理本質上不同的任務時，[[单指令流多数据流|单指令流多数据流]]執行模型將成為一個瓶頸（如在光線追蹤演算法中遍歷一個空間分割的資料結構）

* 只有NVIDIA的GPUs支援CUDA技術

* 由於編譯器需要使用優化技術來利用有限的資源，即使合法的C/C++有時候也會被標記並中止編譯

* CUDA（計算能力1.x）使用一個不包含遞迴、函數指標的C語言子集，外加一些簡單的擴展。而單個進程必須運行在多個不相交的記憶體空間上，這與其它C語言運行環境不同。

* CUDA（計算能力2.x）允許C++類功能的子集，如成員函數可以不是虛擬的（這個限制將在以後的某個版本中移除）[參見《CUDA C程式設計指南3.1》－附錄D.6]

* 雙精度浮點（CUDA計算能力1.3及以上）與IEEE754標準有所差異：倒數、除法、平方根僅支持舍入到最近的偶數。單精確度中不支持反常值（denormal）及sNaN（signaling NaN）；只支援兩種IEEE舍入模式（舍位與舍入到最近的偶數），這些在每條指令的基礎上指定，而非控制字碼；除法/平方根的精度比單精確度略低。

== 显卡的受支持情况 ==
{| class="wikitable" style="font-size: 85%; text-align: center; width: auto;"
|+ 不同 CUDA 版本支持的计算能力列表<ref>{{cite web|url=https://developer.nvidia.com/cuda-toolkit-archive|title=CUDA Toolkit Archive|website=NVIDIA Developer|accessdate=2020-07-16|archive-date=2020-07-09|archive-url=https://web.archive.org/web/20200709045439/https://developer.nvidia.com/cuda-toolkit-archive|dead-url=no}}</ref>
!CUDA 版本
!支持的计算能力
![[微架构|微架构]]
!style="width: 30%;" | 备注
|-
|1.0<ref>{{cite web|url=http://developer.download.nvidia.com/compute/cuda/1.0/NVIDIA_CUDA_Programming_Guide_1.0.pdf|title=NVIDIA CUDA Programming Guide. Version 1.0|date=2007-06-23|accessdate=2020-07-16|archive-date=2018-04-17|archive-url=https://web.archive.org/web/20180417120122/http://developer.download.nvidia.com/compute/cuda/1.0/NVIDIA_CUDA_Programming_Guide_1.0.pdf|dead-url=no}}</ref>
|1.0 – 1.1
|{{link-en|Tesla (微架构)|Tesla (microarchitecture)|Tesla}}
|
|-
|1.1
|1.0 – 1.1+x
|{{link-en|Tesla (微架构)|Tesla (microarchitecture)|Tesla}}
|
|-
|2.0
|1.0 – 1.1+x
|{{link-en|Tesla (微架构)|Tesla (microarchitecture)|Tesla}}
|
|-
|2.1 – 2.3.1<ref>{{cite web|url=http://developer.download.nvidia.com/compute/cuda/2_1/toolkit/docs/NVIDIA_CUDA_Programming_Guide_2.1.pdf|title=NVIDIA CUDA Programming Guide. Version 2.1|date=2008-12-08|accessdate=2020-07-16|archive-date=2020-04-06|archive-url=https://web.archive.org/web/20200406015447/http://developer.download.nvidia.com/compute/cuda/2_1/toolkit/docs/NVIDIA_CUDA_Programming_Guide_2.1.pdf|dead-url=no}}</ref><ref>{{cite web|url=http://developer.download.nvidia.com/compute/cuda/2_2/toolkit/docs/NVIDIA_CUDA_Programming_Guide_2.2.pdf|title=NVIDIA CUDA Programming Guide. Version 2.2|date=2009-04-02|accessdate=2020-07-16|archive-date=2019-03-06|archive-url=https://web.archive.org/web/20190306235024/http://developer.download.nvidia.com/compute/cuda/2_2/toolkit/docs/NVIDIA_CUDA_Programming_Guide_2.2.pdf|dead-url=no}}</ref><ref>{{cite web|url=http://developer.download.nvidia.com/compute/cuda/2_21/toolkit/docs/NVIDIA_CUDA_Programming_Guide_2.2.1.pdf|title=NVIDIA CUDA Programming Guide. Version 2.2.1|date=2009-05-26|accessdate=2020-07-16|archive-date=2019-09-25|archive-url=https://web.archive.org/web/20190925131651/http://developer.download.nvidia.com/compute/cuda/2_21/toolkit/docs/NVIDIA_CUDA_Programming_Guide_2.2.1.pdf|dead-url=no}}</ref><ref>{{cite web|url=http://developer.download.nvidia.com/compute/cuda/2_3/toolkit/docs/NVIDIA_CUDA_Programming_Guide_2.3.pdf|title=NVIDIA CUDA Programming Guide. Version 2.3.1|date=2009-08-26|accessdate=2020-07-16|archive-date=2012-02-18|archive-url=https://www.webcitation.org/65Y8BV7cJ?url=http://developer.download.nvidia.com/compute/cuda/2_3/toolkit/docs/NVIDIA_CUDA_Programming_Guide_2.3.pdf|dead-url=no}}</ref>
|1.0 – 1.3
|{{link-en|Tesla (微架构)|Tesla (microarchitecture)|Tesla}}
|
|-
|3.0 – 3.1<ref>{{cite web|url=http://developer.download.nvidia.com/compute/cuda/3_0/toolkit/docs/NVIDIA_CUDA_ProgrammingGuide.pdf|title=NVIDIA CUDA Programming Guide. Version 3.0|date=2010-02-20|accessdate=2020-07-16|archive-date=2020-07-29|archive-url=https://web.archive.org/web/20200729004044/http://developer.download.nvidia.com/compute/cuda/3_0/toolkit/docs/NVIDIA_CUDA_ProgrammingGuide.pdf|dead-url=no}}</ref><ref>{{cite web|url=http://developer.download.nvidia.com/compute/cuda/3_1/toolkit/docs/NVIDIA_CUDA_C_ProgrammingGuide_3.1.pdf|title=NVIDIA CUDA C Programming Guide. Version 3.1.1|date=2010-07-21|accessdate=2020-07-16|archive-date=2020-06-01|archive-url=https://web.archive.org/web/20200601055243/http://developer.download.nvidia.com/compute/cuda/3_1/toolkit/docs/NVIDIA_CUDA_C_ProgrammingGuide_3.1.pdf|dead-url=no}}</ref>
|1.0 – 2.0
|{{link-en|Tesla (微架构)|Tesla (microarchitecture)|Tesla}}, [[費米微架構|Fermi]]
|
|-
|3.2<ref>{{cite web|url=http://developer.download.nvidia.com/compute/cuda/3_2_prod/toolkit/docs/CUDA_C_Programming_Guide.pdf|title=NVIDIA CUDA C Programming Guide. Version 3.2|date=2010-11-09|accessdate=2020-07-16|archive-date=2020-03-02|archive-url=https://web.archive.org/web/20200302234111/http://developer.download.nvidia.com/compute/cuda/3_2_prod/toolkit/docs/CUDA_C_Programming_Guide.pdf|dead-url=no}}</ref>
|1.0 – 2.1
|{{link-en|Tesla (微架构)|Tesla (microarchitecture)|Tesla}}, [[費米微架構|Fermi]]
|
|-
|4.0 – 4.2
|1.0 – 2.1+x
|{{link-en|Tesla (微架构)|Tesla (microarchitecture)|Tesla}}, [[費米微架構|Fermi]]
|
|-
|5.0 – 5.5
|1.0 – 3.5
|{{link-en|Tesla (微架构)|Tesla (microarchitecture)|Tesla}}, [[費米微架構|Fermi]], [[开普勒微架构|Kepler]]
|
|-
|6.0
|1.0 – 3.5
|{{link-en|Tesla (微架构)|Tesla (microarchitecture)|Tesla}}, [[費米微架構|Fermi]], [[开普勒微架构|Kepler]]
|
|-
|6.5
|1.1 – 5.x
|{{link-en|Tesla (微架构)|Tesla (microarchitecture)|Tesla}}, [[費米微架構|Fermi]], [[开普勒微架构|Kepler]], {{link-en|Maxwell (微架构)|Maxwell (microarchitecture)|Maxwell}}
|最后支持计算能力 1.x ({{link-en|Tesla (微架构)|Tesla (microarchitecture)|Tesla}}) 的版本
|-
|7.0 – 7.5
|2.0 – 5.x
|[[費米微架構|Fermi]], [[开普勒微架构|Kepler]], {{link-en|Maxwell (微架构)|Maxwell (microarchitecture)|Maxwell}}
|
|-
|8.0
|2.0 – 6.x
|[[費米微架構|Fermi]], [[开普勒微架构|Kepler]], {{link-en|Maxwell (微架构)|Maxwell (microarchitecture)|Maxwell}}, [[帕斯卡微架构|Pascal]]
|最后支持计算能力 2.x ([[費米微架構|Fermi]]) 的版本；GTX 1070Ti 不受支持
|-
|9.0 – 9.2
|3.0 – 7.2
|[[开普勒微架构|Kepler]], {{link-en|Maxwell (微架构)|Maxwell (microarchitecture)|Maxwell}}, [[帕斯卡微架构|Pascal]], [[伏打微架構|Volta]]
|[[帕斯卡_(微架构)|Pascal]] GTX 1070Ti 不受 CUDA SDK 9.0 支持，但受 CUDA SDK 9.2支持
|-
|10.0 – 10.2
|3.0 – 7.5
|[[开普勒微架构|Kepler]], {{link-en|Maxwell (微架构)|Maxwell (microarchitecture)|Maxwell}}, [[帕斯卡微架构|Pascal]], [[伏打微架构|Volta]], [[图灵微架构|Turing]]
|最后支持计算能力 3.x ([[开普勒微架构|Kepler]]) 的版本；CUDA SDK 10.2 是最后能用于 [[macOS|macOS]] 的官方版本，在未来的版本中 [[macOS|macOS]] 将不被支持
|-
|11.0 –
|3.5 - 8.6
|{{link-en|Maxwell (微架构)|Maxwell (microarchitecture)|Maxwell}}, [[帕斯卡微架构|Pascal]], [[伏打微架构|Volta]], [[图灵微架构|Turing]], [[安培微架构|Ampere]]
|
|}

{| class="wikitable" style="font-size: 85%; text-align: center; width: auto;"
|+不同计算能力对应的显卡列表
! style="width: 5%;" | 计算能力（版本）
! [[微架构|微架构]]
! GPU
! [[GeForce|GeForce]] 系列
! [[Quadro_NVS|Quadro NVS]] 系列
! [[NVIDIA_Tesla|Tesla]] 系列
! [[图睿|Tegra]] 系列,<br>{{link-en|Jetson|Nvidia Jetson|Jetson}} 系列,<br>{{link-en|DRIVE|Nvidia Drive|DRIVE}} 系列
|-
| 1.0
| rowspan="4" | {{link-en|Tesla (微架构)|Tesla (microarchitecture)|Tesla}}
| G80
|GeForce 8800 Ultra, GeForce 8800 GTX, GeForce 8800 GTS(G80)
|Quadro FX 5600, Quadro FX 4600, Quadro Plex 2100 S4
|Tesla C870, Tesla D870, Tesla S870
|
|-
| 1.1
|G92, G94, G96, G98, G84, G86
|GeForce GTS 250, GeForce 9800 GX2, GeForce 9800 GTX, GeForce 9800 GT, GeForce 8800 GTS(G92), GeForce 8800 GT,  GeForce 9600 GT, GeForce 9500 GT, GeForce 9400 GT, GeForce 8600 GTS, GeForce 8600 GT, GeForce 8500 GT,<br>GeForce G110M, GeForce 9300M GS, GeForce 9200M GS, GeForce 9100M G, GeForce 8400M GT, GeForce G105M
|Quadro FX 4700 X2, Quadro FX 3700, Quadro FX 1800, Quadro FX 1700, Quadro FX 580, Quadro FX 570, Quadro FX 470, Quadro FX 380, Quadro FX 370, Quadro FX 370 Low Profile, Quadro NVS 450, Quadro NVS 420, Quadro NVS 290, Quadro NVS 295, Quadro Plex 2100 D4,<br>Quadro FX 3800M, Quadro FX 3700M, Quadro FX 3600M, Quadro FX 2800M, Quadro FX 2700M, Quadro FX 1700M, Quadro FX 1600M, Quadro FX 770M, Quadro FX 570M, Quadro FX 370M, Quadro FX 360M, Quadro NVS 320M, Quadro NVS 160M, Quadro NVS 150M, Quadro NVS 140M, Quadro NVS 135M, Quadro NVS 130M, Quadro NVS 450, Quadro NVS 420,<ref>{{cite web|url=https://www.techpowerup.com/gpu-specs/quadro-nvs-420.c1448|title=NVIDIA Quadro NVS 420 Specs|website=TechPowerUp GPU Database|accessdate=2020-07-16|archive-date=2020-07-29|archive-url=https://web.archive.org/web/20200729001808/https://www.techpowerup.com/gpu-specs/quadro-nvs-420.c1448|dead-url=no}}</ref> Quadro NVS 295
|
|
|-
|1.2
|GT218, GT216, GT215
|GeForce GT 340*, GeForce GT 330*, GeForce GT 320*, GeForce 315*, GeForce 310*, GeForce GT 240, GeForce GT 220, GeForce 210,<br>GeForce GTS 360M, GeForce GTS 350M, GeForce GT 335M, GeForce GT 330M, GeForce GT 325M, GeForce GT 240M, GeForce G210M, GeForce 310M, GeForce 305M
|Quadro FX 380 Low Profile, Quadro FX 1800M, Quadro FX 880M, Quadro FX 380M,<br>Nvidia NVS 300, NVS 5100M, NVS 3100M, NVS 2100M, ION
|
|
|-
|1.3
|GT200, GT200b
|GeForce GTX 295, GTX 285, GTX 280, GeForce GTX 275, GeForce GTX 260
|Quadro FX 5800, Quadro FX 4800, Quadro FX 4800 for Mac, Quadro FX 3800, Quadro CX, Quadro Plex 2200 D2
|Tesla C1060, Tesla S1070, Tesla M1060
|
|-
|2.0
|  rowspan="2" | {{link-en|Fermi (微架构)|Fermi (microarchitecture)|Fermi}}
|GF100, GF110
|GeForce GTX 590, GeForce GTX 580, GeForce GTX 570, GeForce GTX 480, GeForce GTX 470, GeForce GTX 465,<br>GeForce GTX 480M
|Quadro 6000, Quadro 5000, Quadro 4000, Quadro 4000 for Mac, Quadro Plex 7000,<br>Quadro 5010M, Quadro 5000M
|Tesla C2075, Tesla C2050/C2070, Tesla M2050/M2070/M2075/M2090
|
|-
|2.1
|GF104, GF106 GF108, GF114, GF116, GF117, GF119
|GeForce GTX 560 Ti, GeForce GTX 550 Ti, GeForce GTX 460, GeForce GTS 450, GeForce GTS 450*, GeForce GT 640 (GDDR3), GeForce GT 630, GeForce GT 620, GeForce GT 610, GeForce GT 520, GeForce GT 440, GeForce GT 440*, GeForce GT 430, GeForce GT 430*, GeForce GT 420*,<br>GeForce GTX 675M, GeForce GTX 670M, GeForce GT 635M, GeForce GT 630M, GeForce GT 625M, GeForce GT 720M, GeForce GT 620M, GeForce 710M, GeForce 610M, GeForce 820M, GeForce GTX 580M, GeForce GTX 570M, GeForce GTX 560M, GeForce GT 555M, GeForce GT 550M, GeForce GT 540M, GeForce GT 525M, GeForce GT 520MX, GeForce GT 520M, GeForce GTX 485M, GeForce GTX 470M, GeForce GTX 460M, GeForce GT 445M, GeForce GT 435M, GeForce GT 420M, GeForce GT 415M, GeForce 710M, GeForce 410M
|Quadro 2000, Quadro 2000D, Quadro 600,<br>Quadro 4000M, Quadro 3000M, Quadro 2000M, Quadro 1000M,<br>NVS 310, NVS 315, NVS 5400M, NVS 5200M, NVS 4200M
|
|
|-
|3.0
|  rowspan="4" | [[Kepler_(微架构)|Kepler]]
|GK104, GK106, GK107
|GeForce GTX 770, GeForce GTX 760, GeForce GT 740, GeForce GTX 690, GeForce GTX 680, GeForce GTX 670, GeForce GTX 660 Ti, GeForce GTX 660, GeForce GTX 650 Ti BOOST, GeForce GTX 650 Ti, GeForce GTX 650,<br>GeForce GTX 880M, GeForce GTX 780M, GeForce GTX 770M, GeForce GTX 765M, GeForce GTX 760M, GeForce GTX 680MX, GeForce GTX 680M, GeForce GTX 675MX, GeForce GTX 670MX, GeForce GTX 660M, GeForce GT 750M, GeForce GT 650M, GeForce GT 745M, GeForce GT 645M, GeForce GT 740M, GeForce GT 730M, GeForce GT 640M, GeForce GT 640M LE, GeForce GT 735M, GeForce GT 730M
|Quadro K5000, Quadro K4200, Quadro K4000, Quadro K2000, Quadro K2000D, Quadro K600, Quadro K420,<br>Quadro K500M, Quadro K510M, Quadro K610M, Quadro K1000M, Quadro K2000M, Quadro K1100M, Quadro K2100M, Quadro K3000M, Quadro K3100M, Quadro K4000M, Quadro K5000M, Quadro K4100M, Quadro K5100M,<br>NVS 510, Quadro 410
|Tesla K10, GRID K340, GRID K520
|
|-
|3.2
|GK20A
|
|
|
|Tegra K1,<br>Jetson TK1
|-
|3.5
|GK110, GK208
|GeForce GTX Titan Z, GeForce GTX Titan Black, GeForce GTX Titan,  GeForce GTX 780 Ti, GeForce GTX 780, GeForce GT 640 (GDDR5), GeForce GT 630 v2, GeForce GT 730, GeForce GT 720, GeForce GT 710, GeForce GT 740M (64-bit, DDR3), GeForce GT 920M
|Quadro K6000, Quadro K5200
|Tesla K40, Tesla K20x, Tesla K20
|
|-
|3.7
|GK210
|
|
| Tesla K80
|
|-
|5.0
| rowspan="3" | {{link-en|Maxwell (微架构)|Maxwell (microarchitecture)|Maxwell}}
|GM107, GM108
|GeForce GTX 750 Ti, GeForce GTX 750, GeForce GTX 960M, GeForce GTX 950M, GeForce 940M, GeForce 930M, GeForce GTX 860M, GeForce GTX 850M, GeForce 845M, GeForce 840M, GeForce 830M, GeForce GTX 870M
|Quadro K1200, Quadro K2200, Quadro K620, Quadro M2000M, Quadro M1000M, Quadro M600M, Quadro K620M, NVS 810
|Tesla M10
|
|-
|5.2
|GM200, GM204, GM206
|GeForce GTX Titan X, GeForce GTX 980 Ti, GeForce GTX 980, GeForce GTX 970, GeForce GTX 960, GeForce GTX 950, GeForce GTX 750 SE,<br>GeForce GTX 980M, GeForce GTX 970M, GeForce GTX 965M
|Quadro M6000 24GB, Quadro M6000, Quadro M5000, Quadro M4000, Quadro M2000, Quadro M5500,<br>Quadro M5000M, Quadro M4000M, Quadro M3000M
|Tesla M4, Tesla M40, Tesla M6, Tesla M60
|
|-
|5.3
|GM20B
|
|
|
|Tegra X1,<br>Jetson TX1,<br>Jetson Nano,<br>DRIVE CX,<br>DRIVE PX
|-
|6.0
| rowspan="3" |[[帕斯卡_(微架构)|Pascal]]
|GP100
|
| Quadro GP100
| Tesla P100
|
|-
|6.1
|GP102, GP104, GP106, GP107, GP108
|Nvidia TITAN Xp, Titan X,<br>GeForce GTX 1080 Ti, GTX 1080, GTX 1070 Ti, GTX 1070, GTX 1060, GTX 1050 Ti, GTX 1050,<br>GT 1030, MX350, MX330, MX250, MX230, MX150
|Quadro P6000, Quadro P5000, Quadro P4000, Quadro P2200, Quadro P2000, Quadro P1000, Quadro P400, Quadro P500, Quadro P520, Quadro P600,<br>Quadro P5000(Mobile), Quadro P4000(Mobile), Quadro P3000(Mobile)
|Tesla P40, Tesla P6, Tesla P4
|
|-
|6.2
|GP10B<ref>{{cite web|url=http://www.phoronix.com/scan.php?page=news_item&px=Tegra-X2-Nouveau-Support|title=NVIDIA Rolls Out Tegra X2 GPU Support In Nouveau|last=Larabel|first=Michael|author-link=Michael Larabel|publisher=[[Phoronix|Phoronix]]|date=2017-03-29|access-date=2017-08-08|archive-date=2017-08-09|archive-url=https://web.archive.org/web/20170809090937/http://www.phoronix.com/scan.php?page=news_item&px=Tegra-X2-Nouveau-Support|dead-url=no}}</ref>
|
|
|
|Tegra X2, Jetson TX2, DRIVE PX 2
|-
|7.0
| rowspan="2" |[[伏打微架构|Volta]]
|GV100
|NVIDIA TITAN V
|Quadro GV100
|Tesla V100, Tesla V100S
|
|-
|7.2
|GV10B<ref>[https://www.techpowerup.com/gpudb/3232/xavier Nvidia Xavier Specs] {{Wayback|url=https://www.techpowerup.com/gpudb/3232/xavier |date=20180821093922 }} on TechPowerUp (preliminary)</ref>
|
|
|
|Tegra Xavier,<br/>Jetson Xavier NX,<br/> Jetson AGX Xavier, DRIVE AGX Xavier, DRIVE AGX Pegasus
|-
|7.5
|[[图灵微架构|Turing]]
|TU102, TU104, TU106, TU116, TU117
|NVIDIA TITAN RTX,<br>GeForce RTX 2080 Ti, RTX 2080 Super, RTX 2080, RTX 2070 Super, RTX 2070, RTX 2060 Super, RTX 2060,<br>GeForce GTX 1660 Ti, GTX 1660 Super, GTX 1660, GTX 1650 Super, GTX 1650
GeForce MX450
|Quadro RTX 8000, Quadro RTX 6000, Quadro RTX 5000, Quadro RTX 4000,<br>Quadro T2000, Quadro T1000
|Tesla T4
|
|-
|8.0
|{{link-en|Ampere (微架构)|Ampere_(microarchitecture)|Ampere}}
|GA100, GA102, GA104, GA106
|NVIDIA Geforce RTX 3090, <br> Geforce RTX 3080, RTX 3070 , RTX 3060Ti, RTX 3060
|
|A100
|
|}
'*' – 仅限 [[代工生产|OEM]] 产品

详情请参见[http://developer.nvidia.com/cuda-gpus Nvidia]{{Wayback|url=http://developer.nvidia.com/cuda-gpus |date=20160122050105 }}:

== 應用 ==
利用CUDA技術，配合適當的軟體（例如MediaCoder<ref>{{Cite web |url=http://www.pcpop.com/doc/0/413/413171_1.shtml |title=CUDA转码软件 |accessdate=2009-09-14 |archive-date=2009-09-18 |archive-url=https://web.archive.org/web/20090918170949/http://www.pcpop.com/doc/0/413/413171_1.shtml |dead-url=no }}</ref>、Freemake Video Converter），就可以利用顯示核心進行高清视频編碼加速。视频解碼方面，同樣可以利用CUDA技術實現。此前，[[NVIDIA|NVIDIA]]的顯示核心本身已集成[[PureVideo|PureVideo]]單元。可是，實現相關加速功能的一個[[微軟|微軟]][[API|API]]－DXVA，偶爾會有加速失效問題。所以利用[[CoreAVC|CoreAVC]]配合CUDA，變相在顯示核心上實現軟體解碼，解決兼容性問題<ref>{{Cite web |url=http://www.inpai.com.cn/doc/hard/92710_6.htm |title=另类CUDA高清方案 |accessdate=2009-09-14 |archive-date=2009-11-29 |archive-url=https://web.archive.org/web/20091129090656/http://www.inpai.com.cn/doc/hard/92710_6.htm |dead-url=no }}</ref>。另外，配合適當的引擎，顯示核心就可以計算[[光线跟踪|光线跟踪]]。NVIDIA就放出了自家的Optix实时光线跟踪引擎，透過CUDA技術利用GPU計算[[光线跟踪|光线跟踪]]。<ref>{{Cite web |url=http://news.mydrivers.com/1/144/144004.htm |title=NVIDIA Optix实时光线追踪DEMO |accessdate=2009-09-14 |archive-date=2009-09-12 |archive-url=https://web.archive.org/web/20090912053838/http://news.mydrivers.com/1/144/144004.htm |dead-url=no }}</ref>

== 支援的產品 ==
所有基於[[GeForce_8|G80]]及之後架構的民用與專業顯示卡或運算模組皆支援CUDA技術<ref>{{Cite web |url=http://www.nvidia.com/object/cuda_gpus.html |title=NVIDIA官方支援CUDA技術的產品列表 |accessdate=2010-04-19 |archive-date=2010-02-18 |archive-url=https://web.archive.org/web/20100218114525/http://www.nvidia.com/object/cuda_gpus.html |dead-url=no }}</ref>。

== 示例 ==

=== CUDA Driver API ===
下面將示範以最底層的[https://docs.nvidia.com/cuda/cuda-driver-api/index.html CUDA Driver API]調用GPU做[[列向量|列向量]]的加法，'''以下為 CPU 端的程式碼'''<syntaxhighlight lang="c">
// 本範例修改自 Andrei de A. Formiga (2012-06-04) 寫的範例: https://gist.github.com/tautologico/2879581
// 編譯指令 nvcc -O3 -lcuda add.c -o add.exe

#include <stdio.h>
#include <stdlib.h>

#include <cuda.h>
#include <builtin_types.h> // Driver api 的型態定義

#define N 1024 //列向量長度

// 利用CUDA函數的錯誤傳回做例外處理
inline void checkCudaErrors( CUresult err)
{
    if( CUDA_SUCCESS != err) {
        printf("CUDA Driver API error = %04d from file <%s>, line %i.\n",
                err, __FILE__, __LINE__ );
        exit(-1); // 直接終止程式
    }
}

CUdevice   device; // CUDA 裝置(也就是GPU)物件
CUcontext  context; // CUDA 內容物件
CUmodule   module; // 代表GPU程式碼的物件
CUfunction function; // CUDA GPU 函數
size_t     totalGlobalMem; // CUDA 裝置記憶體總量

// Driver API 只能自外部檔案讀取 GPU 程式，可以為 PTX 中間碼也可以是 cubin 機器碼(或是混合各種架構機器碼的fatbin)
char       *module_file = (char*) "matSumKernel.cubin";

// GPU 函數名稱
char       *kernel_name = (char*) "matSum";

// 初始化 CUDA 的手續
void initCUDA()
{
    int deviceCount = 0; // 當前可使用的 CUDA 裝置(GPU)數
    CUresult err = cuInit(0); // 初始化 CUDA API

    if (err == CUDA_SUCCESS) // 取得可用裝置數
        checkCudaErrors(cuDeviceGetCount(&deviceCount));

    if (deviceCount == 0) { // 確定有可用的裝置
        fprintf(stderr, "Error: no devices supporting CUDA\n");
        exit(-1);
    }

    // get first CUDA device
    checkCudaErrors(cuDeviceGet(&device, 0)); // 取編號為 0 的裝置
    char name[100];
    cuDeviceGetName(name, 100, device); // 印出裝置名稱
    printf("> Using device 0: %s\n", name);

    checkCudaErrors( cuDeviceTotalMem(&totalGlobalMem, device) ); 
    // 印出裝置可用記憶體
    printf("  Total amount of global memory:   %llu bytes\n",
           (unsigned long long)totalGlobalMem);
    // GPU 記憶體是否是為64bits定址
    printf("  64-bit Memory Address:           %s\n",
           (totalGlobalMem > (unsigned long long)4*1024*1024*1024L)?
           "YES" : "NO");

    // 創建 CUDA 內容
    err = cuCtxCreate(&context, 0, device);
    if (err != CUDA_SUCCESS) {
        fprintf(stderr, "* Error initializing the CUDA context.\n");
        cuCtxDetach(context);
        exit(-1);
    }

    // 讀取編譯好的cubin GPU程式碼
    err = cuModuleLoad(&module, module_file);
    if (err != CUDA_SUCCESS) {
        fprintf(stderr, "* Error loading the module %s\n", module_file);
        cuCtxDetach(context); // 釋放 CUDA 內容物件
        exit(-1);
    }

    // 獲取GPU程式裡函數"matSum"的指標
    err = cuModuleGetFunction(&function, module, kernel_name);

    if (err != CUDA_SUCCESS) {
        fprintf(stderr, "* Error getting kernel function %s\n", kernel_name);
        cuCtxDetach(context);
        exit(-1);
    }
}

int main(int argc, char **argv)
{
    int a[N], b[N], c[N];
    CUdeviceptr d_a, d_b, d_c;

    // 注意 GPU 變數指標的型態是 CUdeviceptr
    // typedef unsigned int CUdeviceptr_v2
    // typedef CUdeviceptr_v2 CUdeviceptr

    // 初始化主記憶體變數
    for (int i = 0; i < N; ++i) {
        a[i] = i;
        b[i] = N - i;
    }

    initCUDA();

    // 動態分配 GPU 記憶體
    // CUresult cuMemAlloc ( CUdeviceptr* dptr, size_t bytesize )
    checkCudaErrors( cuMemAlloc(&d_a, sizeof(int) * N) ); // 
    checkCudaErrors( cuMemAlloc(&d_b, sizeof(int) * N) );
    checkCudaErrors( cuMemAlloc(&d_c, sizeof(int) * N) );

    // 將列向量傳入裝置
    // CUresult cuMemcpyHtoD ( CUdeviceptr dstDevice, const void* srcHost, size_t ByteCount ) 
    checkCudaErrors( cuMemcpyHtoD(d_a, a, sizeof(int) * N) );
    checkCudaErrors( cuMemcpyHtoD(d_b, b, sizeof(int) * N) );

    void *args[3] = { &d_a, &d_b, &d_c }; // 包裝放入GPU 函數的引數
    
    // 運行 GPU 函數
    // CUresult cuLaunchKernel ( CUfunction f, unsigned int  gridDimX, unsigned int  gridDimY, unsigned int  gridDimZ,
    //                           unsigned int  blockDimX, unsigned int  blockDimY, unsigned int  blockDimZ,
    //                           unsigned int  sharedMemBytes, CUstream hStream, void** kernelParams, void** extra )
    
    checkCudaErrors( cuLaunchKernel(function, N, 1, 1,  // Nx1x1 blocks
                                    1, 1, 1,            // 1x1x1 threads
                                    0, 0, args, 0) );

    // 將運算結果送回主記憶體
    // CUresult cuMemcpyDtoH ( void* dstHost, CUdeviceptr srcDevice, size_t ByteCount ) 
    checkCudaErrors( cuMemcpyDtoH(c, d_c, sizeof(int) * N) );
    
    // 將 CPU 和 GPU 運算結果做對照 
    for (int i = 0; i < N; ++i) {
        if (c[i] != a[i] + b[i])
            printf("* Error at array position %d: Expected %d, Got %d\n",
                   i, a[i]+b[i], c[i]);
    }

    // 釋放 GPU 記憶體
    // CUresult cuMemFree ( CUdeviceptr dptr ) 
    checkCudaErrors( cuMemFree(d_a) );
    checkCudaErrors( cuMemFree(d_b) );
    checkCudaErrors( cuMemFree(d_c) );

    cuCtxDetach(context); // 釋放 CUDA 內容物件
    return 0;
}
</syntaxhighlight>'''而以下是GPU端的程式碼'''
<syntaxhighlight lang="c">
// 本範例修改自 Andrei de A. Formiga (2012-06-04) 寫的範例: https://gist.github.com/tautologico/2879581
// 此部分要先編譯成 cubin 後才可以被 CPU 端程式使用
// 編譯指令 nvcc -O3 -cubin -arch=native matSumKernel.cu -o matSumKernel.cubin

#define N 1024 //列向量長度

extern "C" __global__ void matSum(int *a, int *b, int *c)
{
    int tid = blockIdx.x; // thread 的 x 座標
    if (tid < N)
        c[tid] = a[tid] + b[tid]; //每個 thread 做一次加法
}
</syntaxhighlight>

=== CUDA Runtime API ===
下列的範例是以相較於 Driver API 來說比較簡便的 [https://docs.nvidia.com/cuda/cuda-runtime-api/index.html CUDA Runtime API] 做[[列向量|列向量]]的加法：
<syntaxhighlight lang="c">
// 本範例修改自Nvidia官方的CUDA開發指引: https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#kernels
// 編譯指令 nvcc vector_add.cu -arch=native -o vector_add.exe
// -arch=native 代表將 device code 編譯成當前電腦 Nvidia GPU 架構的機器碼，拿掉就是照預設編譯成 PTX 中間碼。

#include <stdio.h>
#include <stdlib.h> # 引用動態分配 malloc、隨機函數 rand() 和隨機上限 RAND_MAX

#define N 1024 // 列向量長度

// Device code: 送入GPU執行的部分

__global__ void VecAdd(float* A, float* B, float* C)
{
    int i = threadIdx.x; // thread 的 x 座標
    if (tid < N){
        C[i] = A[i] + B[i]; // 每個 thread 作一次加法
    }
}
            
// Host code: 送入CPU執行的部分

int main()
{
	size_t size = N * sizeof(float); // 向量的實際大小，以位元組(bytes)為單位
	
	int i; // 迴圈計數

	// 動態分配位於"host(CPU) 記憶體" 的向量
	float* h_A = (float*)malloc(size);
	float* h_B = (float*)malloc(size);
	float* h_C = (float*)malloc(size);

	// 隨機初始化輸入向量
	for(i = 0; i < N; i++){
		h_A[i] = (float)rand() / (float)RAND_MAX;
		h_B[i] = (float)rand() / (float)RAND_MAX;
	}

	// 動態分配位於"device(GPU) 記憶體"的向量
	float* d_A;
	cudaMalloc(&d_A, size); // cudaError_t cudaMalloc ( void** devPtr, size_t size )
	float* d_B;
	cudaMalloc(&d_B, size);
	float* d_C;
	cudaMalloc(&d_C, size);

	// 將向量從 CPU 複製到 GPU
	cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);
	cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);
	
	// 將 device code 送入 GPU 並執行，執行時一個 Grid 只有一個 block ，一個 block 有 N 個 thread
	VecAdd<<<1, N>>>(d_A, d_B, d_C);

	// 將算好的向量從 GPU 複製到 CPU
	cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);
	
	// 印出運算結果
	for(i = 0; i < N; i++){
        printf("%f ", h_C[i]);
	}

	// 釋放 GPU 記憶體
	cudaFree(d_A);
	cudaFree(d_B);
	cudaFree(d_C);
 
	// 釋放 CPU 記憶體
    free(h_A);
	free(h_B);
	free(h_C);
}
</syntaxhighlight>

=== Python ===
以下以[https://documen.tician.de/pycuda/ pycuda]，間接調用 CUDA 做[[列向量|列向量]]的[[阿達瑪乘積_(矩陣)|阿達瑪乘積]](也就是元素間乘積而非[[內積|內積]])
<syntaxhighlight lang="python">
import pycuda.driver as drv #CUDA drivers
import pycuda.autoinit # 自動初始化CUDA

import numpy # 矩陣運算

# 讀取並編譯GPU執行的程式碼，以 CUDA-C 寫成

mod = drv.SourceModule("""
__global__ void multiply_them(float *c, float *a, float *b)
{
  int i = threadIdx.x;
  c[i] = a[i] * b[i];
}
""")

# 獲取GPU程式碼中的 multiply_them 函數
multiply_them = mod.get_function("multiply_them")

#生成兩個常態隨機分布的浮點數ndarray，shape 為(400, )
h_a = numpy.random.randn (400).astype(numpy.float32)
h_b = numpy.random.randn (400).astype(numpy.float32)

# 儲存結果的 h_c 列向量，其 shape 和向量 a 相同但值為零
h_c = numpy.zeros_like (a)

'''
執行GPU的函數:
注意這裡h_a, h_b 和 h_c 是在CPU記憶體的 python 變數
以下按照原來 GPU 程式碼的區域變數順序，指定哪些是從CPU傳入GPU (drv.In)；哪些是從GPU傳入CPU (drv.Out)，
簡單來說，自 GPU 傳出到 h_c； h_a 傳入 GPU；h_b 傳入 GPU。
(400,1,1) 代表一個block裡有的thread數量為 400 x 1 x 1
'''
multiply_them(
        drv.Out(h_c), drv.In(h_a), drv.In(h_b),
        block=(400,1,1))

#印出結果
print (d_c)

</syntaxhighlight>

也可以用[https://web.archive.org/web/20090420124748/http://kered.org/blog/2009-04-13/easy-python-numpy-cuda-cublas/ pycublas] 間接調用 CUDA ，來計算[[矩陣乘法|矩陣乘法]]

<syntaxhighlight lang="python">
import numpy
from pycublas import CUBLASMatrix
# 以 numpy 定義矩陣並傳入 CUBLASMatrix
A = CUBLASMatrix(numpy.mat([[1,2,3],[4,5,6|1,2,3],[4,5,6]],numpy.float32))
B = CUBLASMatrix(numpy.mat([[2,3],[4,5],[6,7|2,3],[4,5],[6,7]],numpy.float32))
# 以 CUBLASMatrix 做矩陣乘法
C = A*B
# 將運算結果轉回 numpy 並印出
print(C.np_mat())
</syntaxhighlight>

== 相關條目 ==
* [[OpenCL|OpenCL]]
* [[Vulkan_(API)|Vulkan]]

== 参考文献 ==
{{Reflist|2}}

== 外部連結 ==
* {{Official website}}
* {{Cite web|url=http://www.cc.ntu.edu.tw/chinese/epaper/0012/20100320_1205.htm|title=GPU高效能運算環境—CUDA與GPU Cluster介紹|author=周秉誼|date=|publisher=台灣大學計算機及資訊網路中心|language=zh-hant|accessdate=2010-12-05|quote=|deadurl=yes|archiveurl=https://web.archive.org/web/20100516164438/http://www.cc.ntu.edu.tw/chinese/epaper/0012/20100320_1205.htm|archivedate=2010-05-16}}

{{NVIDIA}}
{{并行计算}}

{{Authority control}}

[[Category:英伟达|Category:英伟达]]
[[Category:顯示卡|Category:顯示卡]]
[[Category:并发计算|Category:并发计算]]
[[Category:物理引擎|Category:物理引擎]]
[[Category:GPGPU|Category:GPGPU]]