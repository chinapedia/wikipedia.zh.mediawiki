{{NoteTA
|G1 = IT
|1 = zh-hans:类型; zh-hant:型別
|2 = zh-hans:数据抽象; zh-hant:資料抽象化
|3 = zh-tw:社群; zh-cn:社区;
|4 = 编程=>zh-tw:程式設計; 编程=>zh-hk:程式設計; 编程=>zh-mo:程式設計;
|5 = 編程=>zh-tw:程式設計; 編程=>zh-hk:程式設計; 編程=>zh-mo:程式設計;
}}
{{Infobox programming language
| name                    = C++
| logo                    = File:ISO_C++_Logo.svg
| logo_size               = 140px
| latest preview version  = [http://open-std.org/JTC1/SC22/WG21/docs/papers/2020/n4878.pdf N4878 标准草案]
| latest preview date     = 2020年4月
| latest release version  = [https://www.iso.org/standard/79358.html ISO/IEC 14882:2020 标准文档(需要购买)]
| latest release date     = 2020年12月
| paradigm                = [[多范型|多范型]]：[[面向对象程序设计|面向对象编程]]，[[過程化編程|過程化編程]]，[[泛型|泛型编程]]
| year                    = {{Start date and age|1983}}
| designer                = [[比雅尼·斯特劳斯特鲁普|比雅尼·斯特劳斯特鲁普]]
| typing                  = [[类型系统|静态类型]]，[[类型系统|强类型]]，[[类型系统|不安全]]
| implementations         = [[C++_Builder|Embarcadero C++Builder]], [[GCC|GCC]], [[Intel_C++编译器|Intel C++ Compiler]], [[Microsoft_Visual_C++|Microsoft Visual C++]], [[Clang|LLVM Clang]]
| dialects                = ISO/IEC 14882:1998, ISO/IEC 14882:2003, ISO/IEC 14882:2011, ISO/IEC 14882:2014, ISO/IEC 14882:2017
| influenced_by           = [[Ada|Ada 83]], [[ALGOL|ALGOL 68]], [[C语言|C]], [[CLU|CLU]], [[ML语言|ML]], [[Simula|Simula]]
| influenced              = [[Ada|Ada 95]], [[Aikido|Aikido]], [[C语言|C99]], [[C＃|C#]], [[Clojure|Clojure]], [[D语言|D]], [[道语言|Dao]], [[Falcon编程语言|Falcon]], [[Java|Java]], [[Lua|Lua]], [[Perl|Perl]], [[PHP|PHP]]
| programming_language    = C++、C 等
| license                 =
| file_ext                = .c .cc .cpp .cxx {{nowrap|.c++（源文件）}} <br/>.h .hh .hpp .hxx {{nowrap|.h++（头文件）}}
| website                 = {{URL|https://isocpp.org/}}
}}
'''C++'''是一种被广泛使用的计算机程序设计语言。它是一种通用[[程式設計語言|程式設計語言]]，支援[[多重编程范式|多重编程范式]]，例如[[过程式编程|過程化程序設計]]、[[抽象化_(計算機科學)|数据抽象]]、[[物件導向程式設計|面向对象程序設計]]、[[泛型程式設計|泛型程式設計]]和[[设计模式_(计算机)|设计模式]]等。

[[比雅尼·斯特勞斯特魯普|比雅尼·斯特勞斯特魯普]]博士在[[贝尔实验室|贝尔实验室]]工作期间在20世紀80年代發明並實現了C++。起初，這種語言被稱作“{{lang|en|C with Classes}}”（“包含‘[[类_(计算机科学)|類]]’的C語言”），作為[[C語言|C語言]]的增強版出現。随后，C++不斷增加新特性。[[虚函数|虚函数]]（{{lang|en|virtual function}}）、[[运算符重载|运算符重载]]（{{lang|en|operator overloading}}）、[[多重继承|多繼承]]（{{lang|en|multiple inheritance}}）、[[标准模板库|标准模板库]]（{{lang|en|standard template library}}, {{lang|en|STL}}）、[[异常处理|异常处理]]（{{lang|en|exception}}）、[[RTTI|运行时类型]]信息（{{lang|en|runtime type information}}）、[[命名空间|命名空間]]（{{lang|en|namespace}}）等概念逐漸納入標準。1998年，[[国际标准化组织|國際標準組織]]（{{lang|en|ISO}}）頒布了C++程序設計語言的第一個國際標準ISO/IEC 14882:1998，目前最新标准为ISO/IEC 14882:2020。根據《C++編-{}-程思想》（{{lang|en|''Thinking in C++''}}）一書，C++與C的代码执行效率往往相差在±5%之間<ref name="invention3">{{cite web|url = http://www.stroustrup.com/bs_faq.html#invention|title = Bjarne Stroustrup's FAQ: When was C++ invented?|first = Bjarne|last = Stroustrup|website = stroustrup.com|date = 2010-03-07|accessdate = 2010-09-16|archive-date = 2016-02-06|archive-url = https://web.archive.org/web/20160206214150/http://www.stroustrup.com/bs_faq.html#invention|dead-url = no}}</ref>。

== 发展历史 ==
[[File:BjarneStroustrup.jpg|缩略图]]，C++之父]]

C++語言發展大概可以分為三個階段：第一階段從80年代到1995年。這一階段C++語言基本上是傳統類型上的[[面向对象程序设计|面向对象]]語言，並且憑藉着接近C語言的效率，在工業界使用的開發語言中佔據了相當大份額；第二階段從1995年到2000年，這一階段由於[[標準模板庫|標準模板庫]]（{{lang|en|STL}}）和後來的[[Boost_C++_Libraries|Boost]]等程式庫的出現，[[泛型程式設計|泛型程序設計]]在C++中佔據了越來越多的比重。當然，同時由於[[Java|Java]]、[[C＃|C#]]等語言的出現和硬體價格的大規模下降，C++受到了一定的衝擊；第三階段從2000年至今，由於以[[Loki|Loki]]、[[Boost_C++_Libraries|MPL(Boost)]]等程式庫為代表的[[產生式編程|產生式編程]]和[[模板元編程|模板元編程]]的出現，C++出現了發展歷史上又一個新的高峰，這些新技術的出現以及和原有技術的融合，使C++已經成為當今主流程序設計語言中最複雜的一員。

[[比雅尼·史特勞斯特魯普|比雅尼·史特勞斯特魯普]]（{{lang|en|Stroustrup}}）工作起於1979年的{{lang|en|''C with Classes''}}。這個構思起源於斯特劳斯特鲁普做博士論文時的一些程式撰寫經驗。他發現[[Simula|Simula]]具備很利於大型軟體開發的特點，但{{lang|en|Simula}}的執行速度太慢，無法對現實需求發揮功效；[[BCPL|BCPL]]雖快得多，但它過於低階的特性，使其不適於大型軟體的開發。當斯特劳斯特鲁普開始在[[贝尔实验室|貝爾實驗室]]工作時，他有分析[[Unix|UNIX]][[核心|核心]]關於[[分散式計算|分散式計算]]的問題。回想起他的博士論文經驗，斯特劳斯特鲁普開始為C語言增強一些類似{{lang|en|Simula}}的特點<ref name="evolving">{{cite web|url = http://stroustrup.com/hopl-almost-final.pdf|title = Evolving a language in and for the real world: C++ 1991-2006|first = Bjarne|last = Stroustrup|accessdate = 2019-01-19|archive-date = 2007-11-20|archive-url = https://web.archive.org/web/20071120015600/http://www.research.att.com/~bs/hopl-almost-final.pdf|dead-url = no}}</ref>。之所以選擇C，是因為它適於各種用途、快速和[[可移植|可移植]]性。除了[[C|C]]和[[Simula|Simula]]之外，同時也從其它語言中取得靈感，如[[ALGOL_68|ALGOL 68]]、[[Ada|Ada]]、[[CLU|CLU]]以及[[ML|ML]]。

剛開始時，[[类_(计算机科学)|類別]]、[[继承_(计算机科学)|衍生類別]]、儲存類型檢查、[[內聯|內聯]]和[[缺省参数|缺省参数]]特性，都是透過[[Cfront|Cfront]]引入C語言之中<ref name="hopl2">{{cite web|last1=Stroustrup|first1=Bjarne|title=A History of C ++ : 1979− 1991|url=http://www.stroustrup.com/hopl2.pdf|accessdate=2019-01-19|archive-date=2019-02-02|archive-url=https://web.archive.org/web/20190202050609/http://www.stroustrup.com/hopl2.pdf|dead-url=no}}</ref>。

1983年，{{lang|en|C with Classes}}改命名為C++（<code>++</code>是C语言中的[[增值和减值操作符|增值操作符]]）。加入了新的特性，其中包括[[虛擬函式|虛擬函式]]、函式名和運算子多載、參考、常數、使用者可控制的自由空間儲存區控制、改良的型別檢查，以及新的雙斜線（<code>//</code>）單行註解風格。

1985年，發佈第一版《C++程式設計語言》，提供一個重點的語言參考，至此還不是官方標準<ref name="1st-edition3">{{cite web|url = http://www.stroustrup.com/1st.html|title = The C++ Programming Language|edition = First|first = Bjarne|last = Stroustrup|accessdate = 2010-09-16|archive-date = 2012-08-09|archive-url = https://web.archive.org/web/20120809032136/http://www.stroustrup.com/1st.html|dead-url = yes}}</ref>。1985年10月出現了第一個商業化發佈。

1989年，發佈了{{lang|en|Release 2.0}}。引入了多重繼承、抽象類別、靜態成員函式、[[常數成員函式|常數成員函式]]，以及成員保護。1990年，出版了''The Annotated C++ Reference Manual''。這本書後來成為標準化的基礎。稍後還引入了[[模板_(C++)|模板]]、[[例外處理|例外處理]]、[[命名空間|命名空間]]、新的[[強制类型转换|強制类型转换]]，以及[[布爾_(數據類型)|布林]]类型。

隨著C++語言的演變，也逐漸演化出相應的標準程式庫。最先加進C++標準函式庫的是串流{{lang|en|I/O}}程式庫，其用以取代傳統的C函式，如[[printf|printf]]和[[scanf|scanf]]。隨後所引入的程式庫中最重要的便是[[標準模板庫|標準模板庫]]，簡稱[[標準模板庫|STL]]。

多年後，一個聯合的[[美国国家标准学会|ANSI]]-[[International_Organization_for_Standardization|ISO]]委員會於1998年對C++標準化（''[[ISO/IEC_14882|ISO/IEC 14882]]：1998''）。在官方釋出1998標準的若干年後，委員會處理缺陷報告，並於2003年發佈一個C++標準的修正版本。2005年，一份名為'''[[C++_Technical_Report_1|Library Technical Report 1]]'''（簡稱{{lang|en|TR1}}）的技術報告釋出。雖然還不是官方標準的一部分，不過它所提供的幾個擴展可望成為下一版C++標準的一部分。幾乎所有目前仍在維護的C++編譯器皆已支援{{lang|en|TR1}}。

目前最新的C++标准是2020年12月发布的''[[ISO/IEC_14882|ISO/IEC 14882]]:2020''<ref name="cpp20">{{cite web |title=ISO/IEC 14882:2020 |url=https://www.iso.org/standard/79358.html?browse=tc |access-date=2021-02-25 |archive-date=2021-06-07 |archive-url=https://web.archive.org/web/20210607143955/https://www.iso.org/standard/79358.html?browse=tc }}</ref>，又称[[C++20|C++20]]。

雖然C++免專利，但標準文件本身並不是免費的，尽管标准文档不是免费的，但是很容易从网络中取得，最简单的就是C++标准文档之前的最后一次草稿版本，它与标准的差别几乎只在于排版上。

=== C++名字的由來 ===
C++這個名字是Rick Mascitti於1983年中所建議的，並於1983年12月首次使用。更早以前，尚在研究階段的發展中語言曾被稱為「{{lang|en|new C}}」，之後是「{{lang|en|C with Classes}}」。在[[電腦科學|電腦科學]]中，C++仍被稱為C語言的上層結構。它最後得名於C語言中的「++」運算子（其對[[變數|變數]]的值進行遞增）。而且在共同的命名約定中，使用「+」以表示增強的程式。斯特劳斯特鲁普說：「這個名字象徵著源自於C語言變化的自然演進」。[[ABC_(编程语言)|C+]]是一個和C/C++無關的早期程式語言。

Rick Mascitti在1992年被非正式地問起名字的由來，他表示這是在半開玩笑中說出的。他從沒想過C++會成為這門語言的正式名字。

有一個關於C++名字的笑話是，當你使用後綴++時，附加只發生在運算之後（因此，它應該是++C，而不是C++，这个笑话是说时下某些程序员还在以使用C的方式使用C++，这通常被一些权威著作认为是不正确的）。
<br/>
<code>
private void button1_Click(object sender, EventArgs e)
   {
            int i = 0;
            for (i = 100; i < numericUpDown1.Value; i++) 
            {
                int count = 1;
                int tmp = i;
                int sum = 0;
                //計算自然數i值的位數
                while (tmp / 10>0)
                {
                    count++;
                    tmp /= 10;
                }
                //計算每位數的次方和
                tmp = i;
                while (tmp>0)
                {
                    sum += (int)Math.Pow(tmp % 10, count);
                    tmp = tmp / 10;
                }
                //判斷自然數是否為水仙花數
                if (i == sum)
                    textBox1 .Text = textBox1 .Text + i.ToString () + "\r\n";
</code>

=== C++标准 ===
由{{lang|en|ISO/IEC JTC1/SC22/WG21}}进行。已经出版的标准文档如下：
{| class="wikitable"
|-
! 发布时间 !! 文档 !! 通称 !! 备注
|-
! 2020
|| ISO/IEC 14882:2020<ref name="cpp20">{{cite web |title=ISO/IEC 14882:2020 |url=https://www.iso.org/standard/79358.html?browse=tc}}</ref> || [[C++20|C++20]] || 
|-
! 2018
|| ISO/IEC TS 21544:2018<ref>{{cite web |title=ISO/IEC TS 21544:2018 |url=https://www.iso.org/standard/71051.html?browse=tc |accessdate=2020-05-10 |archive-date=2020-05-28 |archive-url=https://web.archive.org/web/20200528142431/https://www.iso.org/standard/71051.html?browse=tc |dead-url=no }}</ref> || modules TS || 模块
|-
! 2018
|| ISO/IEC TS 19570:2018<ref>{{cite web |title=ISO/IEC TS 19570:2018 |url=https://www.iso.org/standard/70588.html?browse=tc |accessdate=2020-05-10 |archive-date=2020-05-28 |archive-url=https://web.archive.org/web/20200528142425/https://www.iso.org/standard/70588.html?browse=tc |dead-url=no }}</ref> || parallelism TS || 并行扩展
|-
! 2018
|| ISO/IEC TS 19216:2018<ref>{{cite web |title=ISO/IEC TS 19216:2018 |url=https://www.iso.org/standard/64030.html?browse=tc |accessdate=2020-05-10 |archive-date=2020-05-28 |archive-url=https://web.archive.org/web/20200528142432/https://www.iso.org/standard/64030.html?browse=tc |dead-url=no }}</ref> || networking TS || 网络库
|-
! 2017
|| ISO/IEC 14882:2017<ref>{{cite web |title=ISO/IEC 14882:2017 |url=https://www.iso.org/standard/68564.html?browse=tc |accessdate=2017-12-09 |archive-date=2017-12-09 |archive-url=https://web.archive.org/web/20171209152235/https://www.iso.org/standard/68564.html?browse=tc |dead-url=no }}</ref> || [[C++17|C++17]] || 第五个C++标准
|-
! 2017
|| ISO/IEC TS 22277:2017<ref>{{cite web |title=ISO/IEC TS 22277:2017 |url=https://www.iso.org/standard/73008.html?browse=tc |accessdate=2017-12-09 |archive-date=2017-12-09 |archive-url=https://web.archive.org/web/20171209100403/https://www.iso.org/standard/73008.html?browse=tc |dead-url=no }}</ref> || coroutines TS || 协程库扩展
|-
! 2017
|| ISO/IEC TS 21425:2017<ref>{{cite web |title=ISO/IEC TS 21425:2017 |url=https://www.iso.org/standard/70910.html?browse=tc |accessdate=2017-12-09 |archive-date=2017-12-09 |archive-url=https://web.archive.org/web/20171209100346/https://www.iso.org/standard/70910.html?browse=tc |dead-url=no }}</ref> || ranges TS || 提供范围机制
|-
! 2017
|| ISO/IEC TS 19568:2017<ref>{{cite web |title=ISO/IEC TS 19568:2017 |url=https://www.iso.org/standard/70587.html?browse=tc |accessdate=2017-10-28 |archive-date=2017-10-29 |archive-url=https://web.archive.org/web/20171029012716/https://www.iso.org/standard/70587.html?browse=tc |dead-url=no }}</ref> || library fundamentals TS || 标准库扩展
|-
! 2016
|| ISO/IEC TS 19571:2016<ref>{{cite web |title=ISO/IEC TS 19571:2016 |url=https://www.iso.org/standard/65242.html?browse=tc |accessdate=2017-10-28 |archive-date=2017-10-29 |archive-url=https://web.archive.org/web/20171029012954/https://www.iso.org/standard/65242.html?browse=tc |dead-url=no }}</ref> || concurrency TS || 用于并发计算的扩展
|-
! 2015
|| ISO/IEC TS 19217:2015<ref>{{cite web |title=ISO/IEC TS 19217:2015 |url=https://www.iso.org/standard/64031.html?browse=tc |accessdate=2017-10-28 |archive-date=2017-10-29 |archive-url=https://web.archive.org/web/20171029013319/https://www.iso.org/standard/64031.html?browse=tc |dead-url=no }}</ref> || concepts TS || 概念库，用于优化编译期信息
|-
! 2015
|| ISO/IEC TS 19841:2015<ref>{{cite web |title=ISO/IEC TS 19570:2015 |url=https://www.iso.org/standard/66343.html?browse=tc |accessdate=2017-10-28 |archive-date=2017-10-29 |archive-url=https://web.archive.org/web/20171029013556/https://www.iso.org/standard/66343.html?browse=tc |dead-url=no }}</ref> || TM TS || 事务性内存操作
|-
! 2015
|| ISO/IEC TS 19570:2015<ref>{{cite web |title=ISO/IEC TS 19570:2015 |url=http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=65241 |accessdate=2015-07-09 |archive-date=2015-07-10 |archive-url=https://web.archive.org/web/20150710004336/http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=65241 |dead-url=no }}</ref> || parallelism TS || 用于并行计算的扩展
|-
! 2015
|| ISO/IEC TS 18822:2015<ref>{{cite web |title=ISO/IEC TS 18822:2015 |url=http://www.iso.org/iso/catalogue_detail.htm?csnumber=63483 |accessdate=2015-07-09 |archive-date=2015-07-10 |archive-url=https://web.archive.org/web/20150710024906/http://www.iso.org/iso/catalogue_detail.htm?csnumber=63483 |dead-url=no }}</ref> || filesystem TS || 文件系统
|-
! 2014
|| ISO/IEC 14882:2014<ref>{{cite web |title=ISO/IEC 14882:2014 |url=http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2=60&ics3=&csnumber=64029 |accessdate=2015-01-15 |archive-date=2016-02-25 |archive-url=https://web.archive.org/web/20160225041125/http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2=60&ics3=&csnumber=64029 |dead-url=no }}</ref> || [[C++14|C++14]] || 第四个C++标准
|-
! 2011
|| ISO/IEC TR 24733:2011<ref>{{cite web |title=ISO/IEC TR 24733:2011 |url=http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=38843 |accessdate=2015-07-09 |archive-date=2015-07-09 |archive-url=https://web.archive.org/web/20150709233259/http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=38843 |dead-url=no }}</ref> || - || 十进制浮点数扩展
|-
! 2011
|| ISO/IEC 14882:2011<ref>{{cite web |title=ISO/IEC 14882:2011 |url=http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2=60&ics3=&csnumber=50372 |accessdate=2012-01-03 |archive-date=2016-05-27 |archive-url=https://web.archive.org/web/20160527084921/http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2=60&ics3=&csnumber=50372 |dead-url=no }}</ref> || [[C++11|C++11]] || 第三个C++标准
|-
! 2010
|| ISO/IEC TR 29124:2010<ref>{{cite web |title=ISO/IEC TR 29124:2010 |url=http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=50511 |accessdate=2015-07-09 |archive-date=2015-07-10 |archive-url=https://web.archive.org/web/20150710012230/http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=50511 |dead-url=no }}</ref> || - || 数学函数扩展
|-
! 2007
|| ISO/IEC TR 19768:2007<ref>{{cite web |title=ISO/IEC TR 19768:2007 |url=http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2=60&ics3=&csnumber=43289 |accessdate=2012-05-13 |archive-date=2016-03-04 |archive-url=https://web.archive.org/web/20160304045148/http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2=60&ics3=&csnumber=43289 |dead-url=no }}</ref> || [[C++_Technical_Report_1|C++TR1]] || C++技术报告：库扩展
|-
! 2006
|| ISO/IEC TR 18015:2006<ref>{{cite web |title=ISO/IEC TR 18015:2006 |url=http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2=60&ics3=&csnumber=43351 |accessdate=2014-09-25 |archive-date=2016-02-25 |archive-url=https://web.archive.org/web/20160225045708/http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2=60&ics3=&csnumber=43351 |dead-url=no }}</ref> || - || C++性能技术报告
|-
! 2003
|| ISO/IEC 14882:2003<ref>{{cite web |title=ISO/IEC 14882:2003 |url=http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2=60&ics3=&csnumber=38110 |accessdate=2012-05-13 |archive-date=2017-01-13 |archive-url=https://web.archive.org/web/20170113040518/http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2=60&ics3=&csnumber=38110 |dead-url=no }}</ref> || C++03 || 第二个C++标准
|-
! 1998
|| ISO/IEC 14882:1998<ref>{{cite web |title=ISO/IEC 14882:1998 |url=http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2=60&ics3=&csnumber=25845 |accessdate=2012-05-13 |archive-date=2017-01-15 |archive-url=https://web.archive.org/web/20170115080045/http://www.iso.org/iso/iso_catalogue/catalogue_ics/catalogue_detail_ics.htm?ics1=35&ics2=60&ics3=&csnumber=25845 |dead-url=no }}</ref> || C++98 || 第一个C++标准
|-
|}

== 設計原則 ==
在《C++語言的設計和演化》（1994）中，{{lang|en|Bjarne Stroustrup}}描述了他在設計C++時，所使用的一些原則。知道這些原則有助於理解C++為何會是現在這個樣子。以下總結了一些原則，詳盡的內容可參閱《C++語言的設計和演化》：

* C++設計成直接的和廣泛的支援多種程式設計風格（[[过程式编程|過程化程式設計]]、[[抽象化_(計算機科學)|数据抽象]]、[[物件導向程式設計|物件導向程式設計]]、[[泛型程式設計|泛型程式設計]]）。
* C++設計成給程式設計者更多的選擇，即使可能導致程式設計者選擇錯誤。
* C++設計成儘可能與C相容，藉此提供一個從C到C++的平滑過渡。
* C++避免平台限定或沒有普遍用途的特性。
* C++不使用會帶來額外開銷的特性。
* C++設計成無需複雜的程式設計環境。

== 標準程序庫 ==
1998的C++[[standardization|標準]]分為兩個部分：[[核心語言|核心語言]]和[[C++標準程式庫|C++標準程式庫]]；後者包含了大部分[[標準模板庫|標準模板庫]]和C標準程式庫的稍加修改版本。存在許多不屬於標準部分的C++程式庫，且使用外部連結，程式庫甚至可以用[[C语言|C]]撰寫。

[[C++標準程式庫|C++標準程式庫]]充分吸收了C標準程式庫，並佐以少許的修改，使其與C++良好的運作。另一個大型的程式庫部分，是以[[標準模板庫|標準模板庫]]（{{lang|en|STL}}）為基礎，{{lang|en|STL}}於1994年2月正式成為ANSI/ISO C++。它提供了實用的工具，如[[容器_(抽象数据类型)|容器类]]（如：[[Array|Array]]和{{lang|en|Vector}}），[[迭代器|迭代器]]（廣義[[指標_(電腦科學)|指针]]）提供容器以類似陣列的存取方式，以及[[演算法|<u>泛型</u>算法]]進行搜尋和排序的運算。此外還提供了(multi)map和(multi)set，它們都共享相似的成员函数。因此，以下成為可能，使用模板撰寫泛型算法，它可以和任何容器或在任何以迭代器定義的序列上運作。如同C，使用<code>#include</code>[[directive_(programming)|指令]]包含[[標準表頭|標準表頭]]，即可存取[[程式庫|程式庫]]裡的功能。C++提供69個標準表頭，其中19個不再贊成使用。

使用標準模板庫（例如：使用<code>std::vector</code>或<code>std::string</code>來取代C風格的数组或字符数组）有助於導向更安全和更靈活的软件。

在[[標準模板庫|STL]]在納入C++標準以前，是來自[[Hewlett-Packard|HP]]和後來的[[Silicon_Graphics|SGI]]的第三方程式庫，標準中並未稱之為「{{lang|en|STL}}」，它只是標準庫中的一部分，但仍有許多人使用這個名稱，以別於其它的標準庫（輸入／輸出串流、國際化、診斷、C程式庫子集，等等）。
另外，如<code>std::basic_string</code>此类标准委员会添加的接口，有时也被误认为{{lang|en|STL}}；实际上它们并不存在于原始的{{lang|en|SGI STL}}中，在标准化后{{lang|en|SGI STL}}才从标准库吸收加入其中。

== <span lang="zh-hant" dir="ltr">C</span>++中的特色 ==
和C語言相比，C++引入了更多的特性，包括：复合类型（引用類型等）、{{lang|en|const}}限定符和{{lang|en|constexpr}}常量表达式、类型处理运算符（类型别名及{{lang|en|auto}}和{{lang|en|decltype}}等多种类型指示符）、C++标准库（{{lang|en|IO}}库与多种容器类）与迭代器、动态内存与智能指针、函数重載、面向对象程序设计（如数据抽象、成員函数、类作用域、构造函数与析构函数、静态成员、访问控制与繼承、虚函数、抽象类与接口等）、拷贝控制、运算符重载、造型与函数风格的強制类型转换、模板与泛型编程，以及異常處理、命名空間、多继承与虚继承、运行时类型识别及嵌套类等。

和普遍認為的相反，C++不是第一個正式引入<code>const</code>關鍵字的语言。80年代早期，{{lang|en|Bjarne Stroustrup}}和{{lang|en|Dennis Retchie}}讨论之后提供了在C语言中{{lang|en|readonly/writeonly}}的实现机制，并在带類的C中取得了一定经验。关键字<code>const</code>正式引入C語言是在{{lang|en|ANSI C89}}。这早于第一个C++国际标准近十年，但此时<code>const</code>已被C++实现普遍採用。

C++在某些案例中（見下「與C不相容之處」），進行比C還要多的類型檢查。

以「<code>//</code>」起始作為註解起源自C的前身[[BCPL|BCPL]]，而後被重新引入到C++。

C++的一些特性，C不久之後也採用了，包括在{{lang|en|for}}循环的括号中声明，C++風格的註解（使用<code>//</code>符號，和<code>inline</code>，雖然C99定義的<code>inline</code>關鍵字與C++的定義不相容。不過，[[C语言#C99|C99]]也引入了不存在於C++的特性，如：可变参数[[巨集|巨集]]，和以陣列作為參數的較佳處理；某些C++編譯器可能實作若干特性，以作為擴展，但其餘部分並不符合現存的C++特性）

一個常見的混淆其實只是一個微妙的術語問題：由於它的演化來自C，在C++中的術語'''[[对象_(计算机科学)|对象]]'''和C語言一樣是意味著'''記憶體區域'''，而不是'''-{zh:類別;zh-tw:類別;zh-cn:类}-的實體'''，在其它絕大多數的[[物件導向|物件導向]]語言也是如此。舉例來說，在C和C++中，語句<code>int i;</code>定義一個<code>int</code>型別的物件，這就是變數的值<code>i</code>將在指派時，所存入的記憶體區域。

=== C++语言中的{{lang|en|const}}关键字 ===
<code>const</code>是一个C和C++语言的关键字，意思是宣告一個常數(不能改變的變數)，即唯讀。使用<code>const</code>在一定程度上可以提高程序的安全性和可靠性，也便于实现对此进行优化（如把只读对象放入[[ROM|ROM]]中）。<code>const</code>作为-{zh:型別;zh-tw:型別;zh-cn:类型}-限定符，是型別的一部分。

以下是和C语言相容的用法：
<syntaxhighlight lang="cpp" line="1">
int m = 1, n = 2;   // int 类型的对象
const int a = 3;    // const int 类型的对象
int const b = 4;    //同上
const int *p        //指向 const int 类型对象的指针
int const *q;       //同上
int *const x;       //指向 int 类型对象的 const 指针；注意 const 的位置
const int *const r; //指向 const int 类型对象的 const 指针
int const *const t; //同上
</syntaxhighlight>

但是，<code>const</code>在C++中有更强大的特性。它允许在编译时确定作为真正的常量表达式。例如，
<syntaxhighlight lang="cpp" line="1">
const int max_len = 42;
int a[max_len];
</syntaxhighlight>
此前C语言并不支持这样的用法，直到[[C99|C99]]允许用变量作为数组长度（需要注意的是[[C99|C99]]中的{{lang|en|VLA}}支持运行期确定数组长度，但C++从未支持）。此外，C++中，命名空间作用域的{{lang|en|const}}对象的名称隐含内部链接。这意味着直接在头文件里定义{{lang|en|const}}对象被多个源文件包含时，也不会重定义。

在C++11及之后的C++标准中，推荐使用拥有更严格语义的<code>constexpr</code>限定符来表示一个可以出现在常量表达式中的变量。const可区分为顶层const(top-level const)和底层const(low-level const)。

实际上，在语义表达方面，const更多表示为“只读”，constexpr才表示编译期常量。

== 与C不兼容之处 ==
C++有时被认为是C的[[超集|超集]]（{{lang|en|superset}}），但这並不严谨。

各个版本的{{lang|en|ISO/IEC 14882}}的附录C中都指出了C++和{{lang|en|ISO C}}的一些不兼容之处。

大部分的C代码可以很轻易的在C++中正确编译，但仍有少数差异，导致某些有效的C代码在C++中失效，或者在C++中有不同的行为。

最常见的差异之一是，C允许从<code>void*</code>隐式转换到其它的指标类型，但C++不允许。下列是有效的C代码：

<syntaxhighlight lang="cpp" line="1">
// 从void *隐式转换为int *
int *i = malloc(sizeof(int) * 5);
</syntaxhighlight>

但要使其在C和C++''两者''皆能运作，就需要使用显式转换：
<syntaxhighlight lang="cpp" line="1">
int *i = (int *)malloc(sizeof(int) * 5);
</syntaxhighlight>

另一个常见的[[可移植|可移植]]問題是，C++定义了很多的新关键字，如<code>new</code>和<code>class</code>，它们在C程式中，是可以作为识別字（例：变量名）的。

[[C语言#C99|C99]]去除了一些不兼容之处，也新增了一些C++的特性，如<code>//</code>注释，以及在代码中混合使用。不过C99也纳入几个和C++冲突的新特性（如：可变长数组、原生复数类型和复合逐字常数），而C++11已经加入了兼容C99预处理器的特性。

由于C++函数和C函数通常具有不同的[[名字修饰|名字修饰]]和[[调用约定|调用约定]]，所有在C++中呼叫的C函数，须放在<code>extern "C" { /* C函数声明 */ }</code>之內。

== C++的{{lang|en|Hello World}}程序 ==

下面这个程序显示“Hello, world!”然后结束运行：
<syntaxhighlight lang="cpp" line="1">
#include <iostream>
int main() {
    std::cout << "Hello, world!" << std::endl;
    return 0;
}
</syntaxhighlight>

这里也可以使用{{lang|en|using}}指令以避免再次声明std::——
<syntaxhighlight lang="cpp" line="1">
#include <iostream>
using namespace std;
int main() {
    cout << "Hello, world!" << endl;
    return 0;
}
</syntaxhighlight>

如果使用“\n”代替以上代碼裡的“{{lang|en|endl}}”，输出结果相等。
<syntaxhighlight lang="cpp" line="1">
std::cout << "Hello, world!\n";
</syntaxhighlight>
std::endl 不仅仅会在某个输出流中插入换行字符，还将执行输出流的 flush() 函数（即刷新缓冲区），而'\n'则不会。


根据ISO C++的规定，全局{{lang|en|main}}函数必须返回{{lang|en|int}}。
以下两种形式是合法的：
<syntaxhighlight lang="cpp" line="1">
int main() {
    // ...
}
</syntaxhighlight>
<syntaxhighlight lang="cpp" line="1">
int main(int argc, char *argv[]) {
    // ...
}
</syntaxhighlight>
不过，在一些编译器（例如[[Microsoft_Visual_C++|Visual C++]]）上，
<syntaxhighlight lang="cpp" line="1">
void main() {
    // ...
}
</syntaxhighlight>
也是合法的。但是这样的写法兼容性较差。

== 語言特性 ==
=== 运算符 ===
{{Main|C和C++运算符}}
分為
{| class="wikitable"
|-
! 優先權 !! 運算子 !! 說明 !! 結合性
|-
| 1 || () || 括號 || 由左至右
|-
| 2 || !、-、++、-- || 邏輯運算子NOT、算術運算子負號、遞增、遞減 || 由右至左
|-
| 3 || *、/、% || 算術運算子的乘法、除法、餘數 || 由左至右
|-
| 4 || +、- || 算術運算子加法、減法 || 由左至右
|-
| 5 || <<、>>、>>> || 位元運算子左移、右移、無符號右移 || 由左至右
|-
| 6 || >、>=、<、<= || 關係運算子大於、大於等於、小於、小於等於 || 由左至右
|-
| 7 || ==、!= || 關係運算子等於、不等於 || 由左至右
|-
| 8 || & || 位元運算子AND || 由左至右
|-
| 9 || ^ || 位元運算子XOR || 由左至右
|-
| 10 || | || 位元運算子OR || 由左至右
|-
| 11 || && || 邏輯運算子AND || 由左至右
|-
| 12 || || || 邏輯運算子OR || 由左至右
|-
| 13 || ?: || 條件控制運算子 || 由右至左
|-
| 14 || =、op= || 指定運算子 || 由右至左
|}

=== 預處理器 ===
C++主要有三個編譯階段：預處理、轉譯成目的碼和連結（最後的兩個階段一般才視為真正的「編譯」）。在第一階段，預處理，會將''預處理器指令''替換成原始碼，然後送到下一個編譯階段。

==== 預處理器指令和巨集 ====
預處理指令的運作方式是根據使用者定義的規則，簡單的把記號字元序列置換成其它的記號字元序列。它們進行[[巨集置換|巨集置換]]、含入其它的檔案（由底層至高階的特性，例如包含模組／包／單元／元件）、條件式編譯和條件式含入。例如：
<syntaxhighlight lang="cpp">#define PI 3.1415926535897932384626433832795028841971693993751</syntaxhighlight>
原始代码中出現的<code>PI</code>，都將會替換為<code>3.1415926535897932384626433832795028841971693993751</code>。另一個普遍的例子是
<syntaxhighlight lang="cpp">#include <iostream></syntaxhighlight>
它将標準庫头文件<code>iostream</code>中所有的声明语句都纳入调用者所在的程序块。除了以上提到的常用指令以外，還有幾個額外的預處理器指令，可以用來控制編譯流程、條件式含入或排除代碼區塊等等。

:''參閱[[預處理器|預處理器]]和[[C預處理器|C預處理器]]''

=== 模板 ===
<!--{{update}}-->{{main|模板 (C++)}}
模板（{{lang|en|Template}}）指C++程式語言中的函式模板（{{lang|en|function template}}）與類別模板（{{lang|en|class template}}），這種觀念是取材自[[Simula|Simula]]的泛型程式設計。它采用[[typename|typename]]和[[class|class]]两个关键字，来标识模板類別的型別参数。[[C++11|C++11]]和[[C++14|C++14]]分别引入了类型别名模板和变量模板。

=== 類別与对象 ===
{{main|C++類 |l1=類別 (C++)}}
在物件導向物件程式設計術語中，物件（{{lang|en|object}}）是資料（{{lang|en|data}}）和處理資料的指令（{{lang|en|instructions}}）的聯合（{{lang|en|association}}）。模擬（{{lang|en|simulate}}）實際世界（{{lang|en|real-world}}），物件有三種特質（{{lang|en|characteristics}}）：狀態（{{lang|en|State}}）、行為（{{lang|en|Behavior}}）、{{link-en|同一性身分|Identity (object-oriented programming)}}，並且使用訊息（{{lang|en|message}}）來引發彼此的互動。類別（{{lang|en|class}}）為物件的[[藍圖|藍圖]]或工廠，定義了物件的抽象特質，包括物件的屬性特質和物件的行為特質，屬性的值即是物件的狀態，行為即是物件能夠做的事。

C++為類別構成式物件導向程式設計語言（{{lang|en|class-based object-oriented programming language}}），類別概念具現化（{{lang|en|reification}}）地作為二等公民（{{lang|en|second-class citizen}}）出現在C++語言當中，在語法中明確地使用類別來做到資料抽象化、封裝、模組化、繼承、子型別多型、物件狀態的自動初始化。C++中，一個類別即為一個型別，加上封裝，一個類別即為一個[[抽象資料型別|抽象資料型別]]（{{lang|en|Abstract Data Type}}，{{lang|en|ADT}}），繼承、多型、模板都加強了類別的可抽象性。在C++可以使用{{lang|en|class}}或{{lang|en|struct}}這兩個關鍵字宣告類別（{{lang|en|class}}），而使用{{lang|en|new}}運算子實體化類別產生的實體（{{lang|en|instance}}）即為物件，是[[頭等物件|一等公民]]。C/C++以資料成員（{{lang|en|data member}}）表達屬性，以成員函式（{{lang|en|member function}}）表達行為。

声明一个{{lang|en|Car class}}：
<syntaxhighlight lang="cpp" line="1">
class Car {
private:
    int isRunning;
public:
    Run();
};
</syntaxhighlight>
但是仍然需要注意，严格来说，C++中对象的概念和C的对应概念接近，表示的是具有特定类型的存储，而非面向对象意义上的“对象”：一个对象不一定是类类型的。此外，C++意义上的“实例”仅指模板实例化的结果，而并不指对象。作为对比，[[Java|Java]]的“对象”和“实例”的概念和这里的使用一致。

==== 封裝 ====
封裝（{{lang|en|Encapsulation}}）是將資料和處理資料的[[计算机程序|程序]]（{{lang|en|procedure}}）組合起來，僅對外公開接口（{{lang|en|interface}}），达到信息隐藏（{{lang|en|information hiding}}）的功能。封裝的優點是能減少耦合（{{lang|en|Coupling}}）。C++、{{lang|en|Java}}、C# 等語言定義对象都是在語法中明確地使用類別（{{lang|en|Class}}）來做到封裝。

C++的類別对其成员（包括数据成员、函数成员）分为三种封装状态：
* 公有（{{lang|en|public}}）：類別的用户可以访问、使用该類別的此种成员。
* 保护（{{lang|en|protected}}）：该類別的衍生類別可以访问、使用该類別的此成员。外部程序代码不可以访问、使用这种成员。
* 私有（{{lang|en|private}}）：只有類別自身的成员函数可以访问、使用该類別的此成员。

一般可以将C++類的对外接口设定为公有成员；類内部使用的数据、函数设定为私有成员；供派生自该類別的子類別使用的数据、函数设定为保护成员。

==== 繼承 ====
[[繼承_(計算機科學)|繼承]]（{{lang|en|Inheritance}}）是指派生类（{{lang|en|subclass}}）繼承基类（{{lang|en|superclass}}），會自動取得超類別除私有特質外的全部特質，同一類別的所有實體都會自動有該類別的全部特質，做到程式碼再用（{{lang|en|reuse}}）。C++只支援類別構成式繼承，雖然同一類別的所有實體都有該類別的全部特質，但是實體能夠共享的實體成員只限成員函式，類別的任何實體資料成員乃每個實體獨立一份，因此物件間並不能共享狀態，除非特質為參考型別的屬性，或使用指標來間接共享。C++支持的继承关系为：
* 公有繼承（{{lang|en|public inheritance}}）：最常用繼承关系，含义是「{{lang|en|is-a}}」關係，代表了在完全使用公有繼承的物件類別之間的层次关系（{{lang|en|hierarchy}}）。
* 受保護繼承（{{lang|en|protected inheritance}}）：基礎類別的公有或保护内容可以被衍生類別，以及由此衍生的其他類別使用。但是基礎類別对外界用户是不可见的。衍生類別的用户不能访问基礎類別的成员、不能把派生類別转换（造型）为基礎類別的指针或引用。
* 私有繼承（{{lang|en|private inheritance}}）：基礎類別的公有或保护内容仅可以被衍生類別访问。但基礎類別对衍生類別的子類別或衍生類別的用户都是不可见的。衍生類別的子類別或衍生類別的用户都不能访问基礎類別的内容、不能把衍生類別转换为基礎類別的指针或引用。

C++支持多繼承（{{lang|en|multiple inheritance}}，{{lang|en|MI}}）。多繼承（{{lang|en|multiple inheritance}}，{{lang|en|MI}}）的優缺點一直廣為使用者所爭議，許多語言（如[[Java|Java]]）並不支援多重繼承，而改以單一繼承和介面繼承（{{lang|en|interface inheritance}}），而另一些語言则采用用單一繼承和混入（{{lang|en|mixin}}）。C++通过[[虛繼承|虛繼承]]（{{lang|en|Virtual Inheritance}}）来解決多繼承带来的一系列问题。

=== 多态 ===
{| class="toccolours" style="float: right; margin-left: 0em; margin-right: 1em; font-size: 85%; background:#c6dbf7; color:black; width:25em; max-width: 40%;" cellspacing="1"
| style="text-align: left;" |<div style="text-align: center;">Polymorphism<br /><br />Ad Hoc                   Universal<br />Overloading   Coercion       Inclusion  Parametric</div>
|}
除了封裝與繼承外，C++還提供了[[多型_(物件導向程式設計)|多型]]功能，物件導向的精神在於多态（{{lang|en|Polymorphism}}），一般的多态，是指動態多态，係使用繼承和動態绑定（{{lang|en|Dynamic Binding}}）實現，使用多型可建立起繼承體系（{{lang|en|Inheritance hierarchy}}）。類（{{lang|en|class}}）與繼承只是達成多态中的一種手段，所以稱物件導向而非類別導向。

多态又分成靜態多态（{{lang|en|Static Polymorphism}}）與動態多态（{{lang|en|Dynamic Polymorphism}}）。C++语言支持的動態多态必須結合繼承和动态绑定（{{lang|en|Dynamic Binding}}）方式實現。靜態多态是指编译时决定的多态，包括重载和以模板（{{lang|en|template}}）實現多型的方法即參數化型態（{{lang|en|Parameterized Types}}），是使用巨集（{{lang|en|macro}}）的“程序代码膨脹法”達到多型效果。

类型轉換（{{lang|en|type cast}}）也是一種非参数化（{{lang|en|ad hoc}}）多态的概念，C++提供dynamic_cast, static_cast等运算符來實作强制类型轉換（{{lang|en|Coercion}}）。

運算元重載（{{lang|en|operator overloading}}）或函式重載（{{lang|en|function overloading}}）也算是多型的概念。

== 分析和處理C++原始代碼 ==
{{Fact|C/Java/C#都可以用某種 [[LR剖析器|LR剖析器]]（或其變形）分析文法|time=2016-09-03T11:22:15+00:00}}，但C++是個著名的例外：请看下面的代码。
<syntaxhighlight lang="c++" line="1">
#include <vector>
#include <string>
std::vector< std::vector<std::string> >table1;
std::vector<std::vector<std::string>>table2;
</syntaxhighlight>
上面的{{lang|en|table1}}显然是一个[[字符串|字符串]]的二维[[数组|数组]]，而{{lang|en|table2}}则未必能通过编译：如果严格遵循{{lang|en|LR}}分析过程，串 >> 会被解释为[[位操作#移位|右移]]运算符而非两个代表[[模板_(C++)|模板]]参数表结束的右尖括号，因此出现编译错误，必须以{{lang|en|table1}}的方式用空格区分。(在C++11发布之后，特别规定了当处理模板时，>>被优先视为两个>，所以table1和table2均可通过编译.)

private void button1_Click(object sender, EventArgs e)
        {
            int i = 0;
            for (i = 100; i < numericUpDown1.Value; i++) 
            {
                int count = 1;
                int tmp = i;
                int sum = 0;
                //計算自然數i值的位數
                while (tmp / 10>0)
                {
                    count++;
                    tmp /= 10;
                }
                //計算每位數的次方和
                tmp = i;
                while (tmp>0)
                {
                    sum += (int)Math.Pow(tmp % 10, count);
                    tmp = tmp / 10;
                }
                //判斷自然數是否為水仙花數
                if (i == sum)
                    textBox1 .Text = textBox1 .Text + i.ToString () + "\r\n";

== 争议 ==
「在這12年裡，C++使用者人數大約每七個月半增加一倍」是許多C++相關文件必引的一段話；然而，時至今日新語言層出不窮，使用者人數已不太可能以如此速度增長。分析機構{{lang|en|EvansData}}定期對開發人員展開調查，其資料顯示，以C++為工具的開發人員在整個開發界所佔的比例由1998年春天的76%下降至2004年秋的46%。

一部分{{lang|en|Unix/C}}程序员对C++语言深恶痛绝，他们批评的理由如下：
# STL以非常丑陋的方式封装了各种数据结构和算法，写出来的代码难以理解、不美观。
# C++编译器复杂和不可靠，不适合构建人命关天类-{}-型的程序。
# Ian Joyner认为[[面向对象程序设计|面向对象]]技术徒增学习成本，不如面向过程的C语言简单容易使用，尤其是在系统软件的构建上<ref>Ian Joyner著的《C++?? A Critique of C++ and Programming and Language Trends of the 1990s》第3章51节</ref>。

概括說來[[UNIX|UNIX]]程式設計師批評C++主要是由於{{lang|en|UNIX}}社群與C++社群的文化差異<ref>Eric Raymond著的《[[Unix編程藝術|Unix編-{}-程藝術]]》一書第十四章第四節“語言評估”</ref>。

[[Linux|Linux]]之父[[林纳斯·托瓦兹|林纳斯·托瓦兹]]曾经多次炮轰C++。[[图灵奖|图灵奖]]得主[[尼克劳斯·维尔特|尼克劳斯·维尔特]]也曾经批评C++语言太复杂、语法语义模糊，是“拙劣工程学”的成果。

事实上，对于C++语言的批评并不只来源于{{lang|en|Unix/Unix-Like}}系统下的程序员。就像C++语言本身是一个跨平台的语言一样，对C++的批评并不局限于{{lang|en|Unix/Unix-Like}}系统用户。

一个确定的观点是：C++是一门复杂的语言、这门语言拥有过多的特性从而难以彻底掌握；C++的某些库难以学习、掌握并应用于实际当中；很多程序员都认为C++是一个[[过度设计|过度设计]]的程序语言。{{来源请求}}

== 參閱 ==
{{Portal|電腦程式設計}}

* 《[[C++程式語言_(書)|C++程式語言]]》（{{lang|en|''The C++ Programming Language''}}）
* [[比较Java和C++|比较Java和C++]]
* [[C++託管擴展|C++託管擴展]]
* [[C++/CLI|C++/CLI]]
* [[Boost_C++_Libraries|Boost C++ Libraries]]
* [[Objective-C|Objective-C]] ，另一個以C語言添加物件導向設計的程式語言

== 参考文献 ==
{{Reflist|30em}}

== 延伸阅读 ==
* {{Cite book |first=Nicolai M. |last=Josuttis |title=The C++ Standard Library, A Tutorial and Reference |edition=Second|year=2012 |publisher=Addison-Wesley |isbn=0-321-62321-5}}
* {{Cite book |first=Stanley B. |last=Lippman |authorlink= |first2=Josée |last2=Lajoie |first3=Barbara E. |last3=Moo |year=2011|edition=Fifth |title=C++ Primer |publisher=Addison-Wesley |isbn= 0-321-71411-3}}
** {{cite book|author1=[美] Stanley B. Lippman|author2=[美] Josée Lajoie|author3=[美] Barbara E. Moo  |title=C++ Primer(中文版)(第5版)|translator1= 王刚 |translator2=杨巨峰 | language =zh-cn|date=2013-09-01|publisher=电子工业出版社|isbn= 9787121155352}}
* {{Cite book |first=Scott |last=Meyers |authorlink= |year=2005 |title=Effective C++ |url=https://archive.org/details/effectivec55spec00meye |edition=Third |publisher=Addison-Wesley |isbn=0-321-33487-6 }}
* {{Cite book |first=Scott |last=Meyers |authorlink= |year=2001 |title=Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library |edition=|publisher=Addison-Wesley |isbn= }}
* {{Cite book |first=Bjarne |last=Stroustrup|authorlink=Bjarne Stroustrup |year=2013 |title=[[C++程式語言_(書)|The C++ Programming Language]] |edition=Fourth ed.|publisher=Addison-Wesley |isbn=978-0-321-56384-2 }}
* {{Cite book |first=Bjarne |last=Stroustrup|authorlink=Bjarne Stroustrup |year=1994 |title=The Design and Evolution of C++ |publisher=Addison-Wesley |isbn=0-201-54330-3 }}
* {{Cite book |first=Bjarne |last=Stroustrup|authorlink=Bjarne Stroustrup|year=2014 |title=Programming Principles and Practice Using C++ |url=https://archive.org/details/programmingprinc0000stro_b7o6 |edition=Second ed.|publisher=Addison-Wesley |isbn=978-0-321-99278-9 }}
* {{Cite book |first=David |last=Vandevoorde |first2=Nicolai M. |last2=Josuttis |year=2003 |title=C++ Templates: The complete Guide |url=https://archive.org/details/ctemplatescomple0000vand |publisher=Addison-Wesley |isbn=0-201-73484-2 }}

== 外部連結 ==
{{Sister project links|q=no|s=no|n=no|v=no}}
* [http://www.open-std.org/jtc1/sc22/wg21/ JTC1/SC22/WG21]{{Wayback|url=http://www.open-std.org/jtc1/sc22/wg21/ |date=20180110175536 }} - The C++ Standards Committee {{en}}
* [https://www.toptal.com/c/the-ultimate-list-of-resources-to-learn-c-and-c-plus-plus C和C++资源的最终列表]{{Wayback|url=https://www.toptal.com/c/the-ultimate-list-of-resources-to-learn-c-and-c-plus-plus |date=20190924180549 }}
* [http://www.tw511.com/2/14/285.html C++教學] {{Wayback|url=http://www.tw511.com/2/14/285.html |date=20220423010316 }}

{{-}}
{{C++}}
{{程序设计语言|C++}}
{{Authority control}}

[[Category:C++|]]
[[Category:C語言家族|Category:C語言家族]]
[[Category:跨平台軟體|Category:跨平台軟體]]
[[Category:基于类的编程语言|Category:基于类的编程语言]]
[[Category:1983年建立的程式語言|Category:1983年建立的程式語言]]