{{NoteTA|G1=IT}}
{{ Infobox programming language
| name                   = Cuneiform
| logo                   = G18225.png
| logo size              = 120px
| paradigm               = [[纯函数式编程|纯函数式]], [[数据流程编程|数据流程]]
| designer               = Jörgen Brandt
| founder                =
| status                 = Active
| latest release version = 3.0.5
| latest release date    = {{Start date and age|2022|05|27}}
| latest preview version =
| latest preview date    =
| typing                 = 简单类型
| implementations        =
| dialects               =
| influenced_by          = {{en-link|Swift (并行脚本语言)|Swift (parallel scripting language)}}
| influenced             =
| operating system       = [[Linux|Linux]], [[Mac_OS|Mac OS]]
| programming language   = [[Erlang|Erlang]]
| license                = [[Apache许可证|Apache许可证]] 2.0
| website                = {{URL|https://cuneiform-lang.org/}}
| file_ext               = .cfl
| year                   = {{start date and age|2013}}
}}

'''Cuneiform'''是用于大规模科学数据分析的[[开源软件|开源]]{{en-link|科学工作流程系统|Scientific workflow system|工作流程语言}}<ref>{{Cite web |url=https://github.com/joergen7/cuneiform |title=存档副本 |access-date=2021-03-03 |archive-date=2021-03-18 |archive-url=https://web.archive.org/web/20210318132149/https://github.com/joergen7/cuneiform }}</ref><ref>{{Cite journal
 |last1        = Brandt
 |first1       = Jörgen
 |last2        = Bux
 |first2       = Marc N.
 |last3        = Leser
 |first3       = Ulf
 |title        = Cuneiform: A functional language for large scale scientific data analysis
 |journal      = Proceedings of the Workshops of the EDBT/ICDT
 |volume       = 1330
 |pages        = 17–26
 |year         = 2015
 |url          = http://ceur-ws.org/Vol-1330/paper-03.pdf
 |access-date  = 2021-03-03
 |archive-date = 2020-02-17
 |archive-url  = https://web.archive.org/web/20200217161337/http://ceur-ws.org/Vol-1330/paper-03.pdf
}}</ref>。
它是促进[[并行计算|并行计算]]的[[静态类型|静态类型]]的[[纯函数式编程|纯函数式]][[编程语言|编程语言]]。它的特征是有个全功能的{{en-link|外界函数接口|foreign function interface}}，允许用户集成来自很多外部编程语言的软件。Cuneiform在组织层面上提供了一些设施，如[[条件运算式|条件分支]]和[[递归_(计算机科学)|通用递归]]，使其具有[[图灵完备性|图灵完备性]]。

==概述==
Cuneiform尝试拉近在科学工作流程系统如{{en-link|Apache Taverna}}、{{en-link|KNIME}}或[[Galaxy_(计算生物学)|Galaxy]]，与大规模数据分析程序模型如[[MapReduce|MapReduce]]或[[Pig|Pig Latin]]之间的间隙，同时提供函数式编程语言的通用性。

Cuneiform是用分布式[[Erlang|Erlang]]实现的。如果运行在分布式模态下，它导出一个遵循[[POSIX|POSIX]]的[[分布式文件系统|分布式文件系统]]，如[[Gluster|Gluster]]或{{en-link|Ceph|Ceph (software)#CephFS|Ceph}}（用[[FUSE|FUSE]]集成某个其他文件系统例如[[Apache_Hadoop#HDFS|HDFS]]）。作为替代选择，Cuneiform脚本可以执行在{{en-link|HTCondor}}或[[Apache_Hadoop|Apache Hadoop]]顶上<ref>{{cite web|title=Scalable Multi-Language Data Analysis on Beam: The Cuneiform Experience by Jörgen Brandt|url=http://beta.erlangcentral.org/videos/scalable-multi-language-data-analysis-on-beam-the-cuneiform-experience-by-jorgen-brandt/#.WBLlE2hNzIU|website=Erlang Central|access-date=28 October 2016|archive-url=https://web.archive.org/web/20161002222350/http://beta.erlangcentral.org/videos/scalable-multi-language-data-analysis-on-beam-the-cuneiform-experience-by-jorgen-brandt/#.WBLlE2hNzIU|archive-date=2 October 2016}}</ref><ref>{{Cite journal
 |last1        = Bux
 |first1       = Marc
 |last2        = Brandt
 |first2       = Jörgen
 |last3        = Lipka
 |first3       = Carsten
 |last4        = Hakimzadeh
 |first4       = Kamal
 |last5        = Dowling
 |first5       = Jim
 |last6        = Leser
 |first6       = Ulf
 |title        = SAASFEE: scalable scientific workflow execution engine
 |journal      = Proceedings of the VLDB Endowment
 |volume       = 8
 |number       = 12
 |pages        = 1892–1895
 |year         = 2015
 |url          = http://www.vldb.org/pvldb/vol8/p1892-bux.pdf
 |doi          = 10.14778/2824032.2824094
 |access-date  = 2021-03-03
 |archive-date = 2020-11-25
 |archive-url  = https://web.archive.org/web/20201125125926/http://www.vldb.org/pvldb/vol8/p1892-bux.pdf
}}</ref><ref>{{Cite journal
 |last1        = Bessani
 |first1       = Alysson
 |last2        = Brandt
 |first2       = Jörgen
 |last3        = Bux
 |first3       = Marc
 |last4        = Cogo
 |first4       = Vinicius
 |last5        = Dimitrova
 |first5       = Lora
 |last6        = Dowling
 |first6       = Jim
 |last7        = Gholami
 |first7       = Ali
 |last8        = Hakimzadeh
 |first8       = Kamal
 |last9        = Hummel
 |first9       = Michael
 |last10       = Ismail
 |first10      = Mahmoud
 |last11       = Laure
 |first11      = Erwin
 |last12       = Leser
 |first12      = Ulf
 |last13       = Litton
 |first13      = Jan-Eric
 |last14       = Martinez
 |first14      = Roxanna
 |last15       = Niazi
 |first15      = Salman
 |last16       = Reichel
 |first16      = Jane
 |last17       = Zimmermann
 |first17      = Karin
 |title        = Biobankcloud: a platform for the secure storage, sharing, and processing of large biomedical data sets
 |journal      = The First International Workshop on Data Management and Analytics for Medicine and Healthcare (DMAH 2015)
 |volume       = 
 |number       = 
 |pages        = 
 |year         = 2015
 |url          = http://www.di.fc.ul.pt/~bessani/publications/dmah15-bbc.pdf
 |access-date  = 2021-03-03
 |archive-date = 2018-10-01
 |archive-url  = https://web.archive.org/web/20181001092347/http://www.di.fc.ul.pt/~bessani/publications/dmah15-bbc.pdf
}}</ref><ref>{{cite web|title=Scalable Multi-Language Data Analysis on Beam: The Cuneiform Experience|url=http://www.erlang-factory.com/euc2016/jorgen-brandt|website=Erlang-factory.com|access-date=28 October 2016|archive-date=2020-07-12|archive-url=https://web.archive.org/web/20200712055404/http://www.erlang-factory.com/euc2016/jorgen-brandt}}</ref>。

Cuneiform受到了Peter Kelly的工作的影响，他提议函数式编程作为科学工作流程执行的模型<ref>{{cite journal
| last1 = Kelly      | first1 = Peter M.
| last2 = Coddington | first2 = Paul D.
| last3 = Wendelborn | first3 = Andrew L.
| year = 2009
| title = Lambda calculus as a workflow model
| journal = Concurrency and Computation: Practice and Experience
| volume = 21
| issue = 16
| pages = 1999–2017
| doi = 10.1002/cpe.1448 }}
{{cite journal
 |title        = Workflows and extensions to the Kepler scientific workflow system to support environmental sensor data access and analysis
 |last1        = Barseghian
 |first1       = Derik
 |last2        = Altintas
 |first2       = Ilkay
 |last3        = Jones
 |first3       = Matthew B.
 |last4        = Crawl
 |first4       = Daniel
 |last5        = Potter
 |first5       = Nathan
 |last6        = Gallagher
 |first6       = James
 |last7        = Cornillon
 |first7       = Peter
 |last8        = Schildhauer
 |first8       = Mark
 |last9        = Borer
 |first9       = Elizabeth T.
 |last10       = Seabloom
 |first10      = Eric W.
 |journal      = Ecological Informatics
 |volume       = 5
 |number       = 1
 |pages        = 42–50
 |year         = 2010
 |doi          = 10.1016/j.ecoinf.2009.08.008
 |url          = https://escholarship.org/content/qt2q46n1tp/qt2q46n1tp.pdf?t=nivnuu
 |access-date  = 2021-03-03
 |archive-date = 2022-02-25
 |archive-url  = https://web.archive.org/web/20220225225350/https://escholarship.org/content/qt2q46n1tp/qt2q46n1tp.pdf?t=nivnuu
}}</ref>。
故而，Cuneiform不同于其他的基于[[数据流程编程|数据流程编程]]的工作流程语言，如[[并行计算|并行]][[脚本语言|脚本语言]]{{en-link|Swift (并行脚本语言)|Swift (parallel scripting language)|Swift}}<ref>
{{cite journal
| title = Nextflow enables reproducible computational workflows
| last1 = Di Tommaso | first1 = Paolo
| last2 = Chatzou    | first2 = Maria
| last3 = Floden     | first3 = Evan W
| last4 = Barja      | first4 = Pablo Prieto
| last5 = Palumbo    | first5 = Emilio
| last6 = Notredame  | first6 = Cedric
| journal = Nature Biotechnology
| volume = 35
| number = 4
| pages = 316–319
| year = 2017
| doi = 10.1038/nbt.3820 | pmid = 28398311  }}
</ref>。

==扩展软件集成==

外部工具和库（比如[[R语言|R]]或[[Python|Python]]库）是通过{{en-link|外界函数接口|foreign function interface}}来集成的。通过它可以组合，比如允许通过snippet节点使用外部软件的{{en-link|KNIME}}，或为集成[[Java|Java]]软件提供{{en-link|BeanShell}}服务的{{en-link|Apache Taverna}}。通过定义采用外界语言的任务，就可能使用一个外部工具或库的API。这种方式下，工具可以直接集成而不需要写包装器或重新实现工具<ref>{{cite web|title=A Functional Workflow Language Implementation in Erlang|url=http://www.erlang-factory.com/static/upload/media/1448992381831050cuneiformberlinefl2015.pdf|access-date=28 October 2016|archive-date=2022-02-25|archive-url=https://web.archive.org/web/20220225225411/http://www.erlang-factory.com/static/upload/media/1448992381831050cuneiformberlinefl2015.pdf}}</ref>。

目前支持的外界编程语言有：
{{div col|colwidth=10em}}
* [[Bash|Bash]]
* [[Elixir|Elixir]]
* [[Erlang|Erlang]]
* [[Java|Java]]
* [[JavaScript|JavaScript]]
* [[MATLAB|MATLAB]]
* [[GNU_Octave|GNU Octave]]
* [[Perl|Perl]]
* [[Python|Python]]
* [[R语言|R]]
* [[Racket|Racket]]
{{div col end}}
计划增加外界语言[[AWK|AWK]]和[[gnuplot|gnuplot]]。

==类型系统==

Cuneiform提供简单的、静态检查的类型系统<ref>
{{ cite journal
| title = Computation semantics of the functional scientific workflow language Cuneiform
| last1 = Brandt | first1 = Jörgen
| last2 = Reisig | first2 = Wolfgang
| last3 = Leser  | first3 = Ulf
| journal = [[Journal_of_Functional_Programming|Journal of Functional Programming]]
| volume = 27
| year = 2017
| doi = 10.1017/S0956796817000119 | s2cid = 6128299 }}
</ref>。虽然Cuneiform提供列表作为[[复合数据类型|复合数据类型]]，它省略了传统的列表访问子（<code>head</code>和<code>tail</code>），以避免在访问空列表时，可能引起的运行时间错误的可能性。转而列表只能通过在其上<code>map</code>或<code>fold</code>，以全有或全无方式访问。此外，Cuneiform（在组织层面）省略了算术，这排除了除以零的可能性。省略任何的部份定义运算，允许保证运行时间错误只能在外界代码中引发。

===基础数据类型===

Cuneiform提供的基础数据类型有[[布尔值|布尔值]]、[[字符串|字符串]]和[[文件|文件]]。这里的文件被用来以任意格式在外界函数之间交换数据。

===记录和模式匹配===

Cuneiform提供[[记录|记录]]（结构）作为复合数据类型。下面的例子展示定义一个变量<code>r</code>，作为有两个字段<code>a1</code>和<code>a2</code>的记录，第一个是字符串，而第二个是布尔值：

<syntaxhighlight lang="swift">
let r : <a1 : Str, a2 : Bool> =
  <a1 = "my string", a2 = true>;
</syntaxhighlight>

记录可以要么通过投影（projection）要么通过[[模式匹配|模式匹配]]来访问。下面的例子从记录<code>r</code>，提取两个字段<code>a1</code>和<code>a2</code>：

<syntaxhighlight lang="swift">
let a1 : Str = ( r|a1 );

let <a2 = a2 : Bool> = r;
</syntaxhighlight>

===列表和列表处理===

进一步的，Cuneiform提供[[列表_(抽象数据类型)|列表]]作为复合数据类型。下面的例子展示定义一个变量<code>xs</code>，作为一个有三个元素的一个文件：

<syntaxhighlight lang="erlang">
let xs : [File] =
  ['a.txt', 'b.txt', 'c.txt' : File];
</syntaxhighlight>

列表可以通过<code>for</code>和<code>fold</code>算子来处理。这里的<code>for</code>算子可以接受多个列表，来逐个元素的处置列表（类似于[[Racket|Racket]]中的<code>for/list</code>、[[Common_Lisp|Common Lisp]]中的<code>mapcar</code>或[[Erlang|Erlang]]中的<code>zipwith</code>）。

下面的例子展示如何在一个单一的列表上<code>map</code>，结果是一个文件列表：

<syntaxhighlight lang="ruby">
for x <- xs do
  process-one( arg1 = x )
  : File
end;
</syntaxhighlight>

下面的例子展示如何<code>zip</code>两个列表，结果也是一个文件列表：

<syntaxhighlight lang="ruby">
for x <- xs, y <- ys do
  process-two( arg1 = x, arg2 = y )
  : File
end;
</syntaxhighlight>

最后，列表可以使用<code>fold</code>算子来做聚集。下面的例子合计一个列表的元素：

<syntaxhighlight lang="text">
  fold acc = 0, x <- xs do
    add( a = acc, b = x )
  end;
</syntaxhighlight>

==并行执行==

Cuneiform是纯函数式语言，就是说它不支持[[参照|可变引用]]。作为结论，它可以使用独立子项，将一个程序分解成可并行的各部份。Cuneiform调度器分布这些部份到做工节点。此外，Cuneiform采用[[求值策略#传名调用|传名调用求值策略]]，值只在它对计算结果有贡献时计算。最后，外界函数应用是[[记忆化|记忆化]]的，用来加速包含以前推导结果的计算。

例如，下列Cuneiform程序允许<code>f</code>和<code>g</code>的应用平行的运行，而<code>h</code>是有依赖的，它只在<code>f</code>和<code>g</code>二者完成的时候可以开始：

{{pre|1=
let output-of-f : File = f();
let output-of-g : File = g();

h( f = output-of-f, g = output-of-g );
}}

下列Cuneiform程序通过将函数<code>f</code>映射到一个三元素列表，创建了三个并行应用：

{{pre|1=
let xs : [File] =
  ['a.txt', 'b.txt', 'c.txt' : File];

for x <- xs do
  f( x = x )
  : File
end;
}}

类似的，在记录<code>r</code>的构造中，<code>f</code>和<code>g</code>的应用是独立的，因此可以并行运行：

{{sxhl|lang=erlang|1=
let r : <a : File, b : File> =
  <a = f(), b = g()>;
}}

==例子==

下面是一个hello-world脚本：
<syntaxhighlight lang="ruby">
def greet( person : Str ) -> <out : Str>
in Bash *{
  out="Hello $person"
}*

( greet( person = "world" )|out );
</syntaxhighlight>
这个脚本定义了采用[[Bash|Bash]]的一个任务<code>greet</code>，它对其字符串实际参数<code>person</code>预加上<code>"Hello "</code>。这个函数产生具有一个单一字符串字段的记录<code>out</code>。应用<code>greet</code>，绑定实际参数<code>person</code>到字符串<code>"world"</code>，产生记录<code><out = "Hello world"></code>。将这个记录投影为它的字段<code>out</code>，求值出字符串<code>"Hello world"</code>。

可以通过定义采用[[Bash|Bash]]的一个任务来集成命令行工具：
<syntaxhighlight lang="ruby">
def samtoolsSort( bam : File ) -> <sorted : File>
in Bash *{
  sorted=sorted.bam
  samtools sort -m 2G $bam -o $sorted
}*
</syntaxhighlight>
在这个例子中定义了任务<code>samtoolsSort</code>。它调用了工具{{en-link|SAMtools}}，处置一个BAM格式的输入文件，并产生一个排序了也是BAM格式的输出文件。

==发行历史==

{| class="wikitable"
|-
! 版本 !! 出现日期 !! 实现语言 !! 发布平台 !! 外界语言
|-
! 1.0.0
| 2014年5月
| [[Java|Java]]
| [[Apache_Hadoop|Apache Hadoop]]
| Bash, Common Lisp, GNU Octave, Perl, Python, R, Scala
|-
! 2.0.x
| 2015年3月
| [[Java|Java]]
| {{en-link|HTCondor}}, [[Apache_Hadoop|Apache Hadoop]]
| Bash, {{en-link|BeanShell}}, [[Common_Lisp|Common Lisp]], MATLAB, GNU Octave, Perl, Python, R, [[Scala|Scala]]
|-
! 2.2.x
| 2016年4月
| [[Erlang|Erlang]]
| {{en-link|HTCondor}}, [[Apache_Hadoop|Apache Hadoop]]
| Bash, Perl, Python, R
|-
! 3.0.x
| 2018年2月
| [[Erlang|Erlang]]
| 分布式Erlang
| [[Bash|Bash]], [[Erlang|Erlang]], [[Java|Java]], [[MATLAB|MATLAB]], [[GNU_Octave|GNU Octave]], [[Perl|Perl]], [[Python|Python]], [[R语言|R]], [[Racket|Racket]]
|}

在2016年4月，Cuneiform的实现语言从[[Java|Java]]切换成了[[Erlang|Erlang]]，并且在2018年2月，它的主要发布执行平台从[[Apache_Hadoop|Apache Hadoop]]变更为分布式Erlang。此外，从2015年到2018年，{{en-link|HTCondor}}曾被作为可替代执行平台来维护。

Cuneiform的外表语法修订过两次，这反映在主版本号上。

===版本1===

在2014年5月发布的最初草案中，Cuneiform密切关联于[[Make|Make]]，它构造解释器在执行期间要遍历的静态数据依赖图。与后来版本的主要区别，是缺乏条件、递归或静态类型检查。区分文件和字符串，是通过同波浪号<code>~</code>形成一个单一引用的字符串。脚本的查询表达式，通过<code>target</code>关键字来介入。Bash是缺省外界语言。函数应用必须使用<code>apply</code>形式来完成，它接受<code>task</code>作为第一个关键字实际参数。一年之后，这种外表语法被一种精简却类似的版本所替代。

下面的例子脚本从一个FTP服务器下载一个参考genome：
<pre>
declare download-ref-genome;

deftask download-fa( fa : ~path ~id ) *{
    wget $path/$id.fa.gz
    gunzip $id.fa.gz
    mv $id.fa $fa
}*

ref-genome-path = ~'ftp://hgdownload.cse.ucsc.edu/goldenPath/hg19/chromosomes';
ref-genome-id = ~'chr22';

ref-genome = apply(
    task : download-fa
    path : ref-genome-path
    id : ref-genome-id
);

target ref-genome;
</pre>

===版本2===

[[File:Cf_screenshot.jpg|thumb]]
Cuneiform外表语法的第二个草案，首次发表于2015年3月，在Cuneiform的实现语言从[[Java|Java]]到[[Erlang|Erlang]]的迁移期间，持续使用了三年。求值不同于早期方式，解释器归约一个表达式，而非遍历一个静态图。在外表语法保持使用这段时期，解释器被形式化和简化，这导致了第一个Cuneiform的语义规定。语法特征是有了条件。但是，布尔值被编码为列表，再度利用空列表为布尔值<code>false</code>，非空列表为布尔值<code>true</code>。递归后来作为形式化的副产品而增加。但是，静态类型检查，只在后来的版本3中介入。

下列脚本解压一个压缩文件，并把它分解为大小均匀的划分：
<pre>
deftask unzip( <out( File )> : zip( File ) ) in bash *{
  unzip -d dir $zip
  out=`ls dir | awk '{print "dir/" $0}'`
}*

deftask split( <out( File )> : file( File ) ) in bash *{
  split -l 1024 $file txt
  out=txt*
}*

sotu = "sotu/stateoftheunion1790-2014.txt.zip";
fileLst = split( file: unzip( zip: sotu ) );

fileLst;
</pre>

===版本3===

Cuneiform外表语法的当前版本，比较于早期的草案，是尝试拉近与主流函数式编程语言的间隙。它的特征是简单的静态检查的类型系统，并在列表之外介入记录作为第二个复合数据结构类型。布尔值独立为基础数据类型。

下列脚本解包一个文件，结果为一个文件列表：

<pre>
def untar( tar : File ) -> <fileLst : [File]>
in Bash *{
  tar xf $tar
  fileLst=`tar tf $tar`
}*

let hg38Tar : File =
  'hg38/hg38.tar';

let <fileLst = faLst : [File]> =
  untar( tar = hg38Tar );

faLst;
</pre>

==引用==
{{Reflist|2}}

{{程序设计语言}}
[[Category:函数式编程语言|Category:函数式编程语言]]
[[Category:脚本语言|Category:脚本语言]]
[[Category:程序设计工具|Category:程序设计工具]]
[[Category:Hadoop|Category:Hadoop]]
[[Category:静态类型编程语言|Category:静态类型编程语言]]
[[Category:自由跨平台软件|Category:自由跨平台软件]]