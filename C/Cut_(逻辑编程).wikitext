[[Prolog|Prolog]]编程中的'''cut'''操作，用'''!'''表示，该操作总能够成功，但是不能够回溯位于该操作左边的子句。'''Cut'''操作被广泛的用于减掉不希望回溯的分支，例如，避免找到程序不需要的额外的答案和避免额外的计算。

应当保守的应用'''cut'''操作，当程序不正确会有一种诱惑来插入'''cut'''来检验cut能否让程序正确。如果一个测试是不必须的因为有'''cut'''来保证这是真的，那么最好在合适的地方加上注释说明这一点。

Cut被某些人认为是有争议的逻辑程序控制方式<ref>''Foundations of Logic Programming'', Springer (1984).</ref>，因为该操作是因为效率问题被加入的而且不是一个Horn clause.

==Cut的类型==
===Green cut===
如果一个'''cut'''操作只是为了提高性能，那么它就被称为green cut，例如：

  gamble(X) :- gotmoney(X),!.
  gamble(X) :- gotcredit(X), \+ gotmoney(X).

上述操作被称为green cut操作符。!只是简单的告诉Prolog解释器停止寻找其他的答案。但是你会注意到如果'''gotmoney(X)'''子句失败的话，那么解释器将会检查第二条规则。第二个规则中的'''gotmoney(X)'''似乎显得多余，因为只有当第一个规则失败的时候，第二个规则才会被查看，但是，显式地写上 '''\+ gotmoney(X)'''，你就能确保第二个规则总是能正确地工作，即使在第一条规则被恰巧移除或改变的情况下也是正确的。

'''Green cut'''的目的是让程序变的效率更高，而不会改变程序的输出。

===Red Cut===
如果一个'''cut'''操作不是'''green'''的，那么它就是'''red cut'''，例如：

  gamble(X) :- gotmoney(X), !.
  gamble(X) :- gotcredit(X).

那么程序的运行结果将依赖于'''cut'''操作符的位置和关联子句的顺序，这些将决定这个程序的含义。如果任何情况下地一个关联子句被移除了（例如，剪切粘贴的时候的错误），第二个子句将不会表达和上述'''green cut'''例子中一样的意思，因为该子句将不能保证 '''\+ gotmoney(X)'''。


== 参考资料 ==
{{reflist}}

[[Category:逻辑编程|Category:逻辑编程]]