{{noteTA
| G1=IT
}}
{{C_Standard_library}} <!-- to edit this template go to [[template:C_Standard_library|template:C Standard library]] -->
{{lowercase|title=time.h}}
'''time.h'''是[[C标准函数库|C标准函数库]]中获取时间与日期、对时间与日期数据操作及格式化的[[头文件|头文件]]。

== 表示时间的三种数据类型 ==

* 日历时间（Calendar Time），是从一个标准'''时间点'''（epoch）到现在的时间经过的秒数，不包括插入[[闰秒|闰秒]]对时间的调整。开始计时的标准时间点，各种编译器一般使用[[协调世界时|UTC]] 1970-01-01 00:00:00。日历时间用数据类型<code>time_t</code>表示。{{R|APUE|page=20}}<code>time_t</code>类型实际上一般是32位整数类型，因此表示的时间不能晚于[[协调世界时|UTC]] 2038-01-18 19:14:07。为此，某些编译器引入了64位甚至更长的整型来保存日历时间，如Visual C++支持<code>__time64_t</code>数据类型，通过<code>_time64()</code>函数获取日历时间，可支持到[[协调世界时|UTC]] 3001-01-01 00:00:00的时间。
* 处理器时间（Processor Time），也被称为[[CPU|CPU]]时间（CPU Time），用以度量[[进程|进程]]使用的CPU资源。处理器时间以时钟滴答数（Clock Tick）计算，通常从进程启动开始计时，因此这是相对时间。时钟滴答数用[[系统基本数据类型|系统基本数据类型]]<code>clock_t</code>来表示，每[[秒钟|秒钟]]包含<code>CLOCKS_PER_SEC</code>（time.h中定义的常量，一般为1000）个时钟滴答，也可使用<code>sysconf</code>函数得到每秒的时钟滴答数。<code>clock_t</code>类型一般是32位整数类型。{{R|APUE|page=20}}
* 分解时间(broken-down time)，用结构数据类型<code>tm</code>表示，<code>tm</code>包含下列结构成员：

{| class="wikitable" width="60%"
|-
! width=25%|成员 || 描述
|-
| <code>[[整数_(计算机科学)|int]] tm_hour</code> || 小时 (0 – 23)
|-
| <code>int tm_isdst</code> || [[夏令时|夏令时]]启用 (> 0)、禁用 (= 0)、未知 (< 0)
|-
| <code>int tm_mday</code> || 一月中的哪一天 (1 – 31)
|-
| <code>int tm_min</code> || 分 (0 – 59)
|-
| <code>int tm_mon</code> || 月 (0 – 11, 0 = 一月)
|-
| <code>int tm_sec</code> || 秒 (0 – 60, 60 = 闰秒)
|-
| <code>int tm_wday</code> || 一周中的哪一天 (0 – 6, 0 = 周日)
|-
| <code>int tm_yday</code> || 一年中的哪一天 (0 – 365)
|-
| <code>int tm_year</code> || 1900 以来的年数
|}

== 从计算机系统时钟获得时间的方法 ==

* <code>time_t '''time'''(time_t* ''timer'')</code>
: 得到从标准计时点（一般是UTC 1970年1月1日午夜）到当前时间的秒数。
* <code>clock_t '''clock'''(void)</code>
: 得到从进程启动到此次函数调用的累计的时钟滴答数。

Windows API提供了更为精确的GetLocalTime()获取毫秒级的日历时间；QueryPerformanceCounter和QueryPerformanceFrequency两个函数获取高于1毫秒的精度。

== 三种时间日期数据类型的转换函数 ==

* <code>struct tm* '''gmtime'''(const time_t* ''timer'')</code>
: 从日历时间<code>time_t</code>到分解时间<code>tm</code>（[[世界协调时|世界协调时]]UTC）的转换。函数返回的是一个静态分配的<code>tm</code>结构存储空间，该存储空间被<code>gmtime</code>, <code>localtime</code>与<code>ctime</code>函数所共用. 这些函数的每一次调用会覆盖这块<code>tm</code>结构存储空间的内容。
* <code>struct tm* '''gmtime_r'''(const time_t* ''timer'', struct tm* ''result'')</code>
: 该函数是<code>gmtime</code>函数的线程安全版本.
* <code>struct tm* '''localtime'''(const time_t* ''timer'')</code>
: 从日历时间<code>time_t</code>到分解时间<code>tm</code>的转换，即结果数据已经调整到本地时区与夏令时。
* <code>time_t '''mktime'''(struct tm* ''ptm'')</code>
: 从基于本地时区(与夏令时)的分解时间<code>tm</code>到日历时间<code>time_t</code>的转换。忽略tm_wday与tm_yday的输入值。如果tm_isdst不确定则输入设为-1。其它各输入域的值可以任意设定，输出时被规范化到正确范围。例如，想要计算2012年的第200天的日期，设为1月200日，函数会输出正确的结果
* <code>time_t '''timegm'''(struct tm* ''brokentime'')</code>
: 从分解时间<code>tm</code>（被视作UTC时间，不考虑本地时区设置）到日历时间<code>time_t</code>的转换。该函数较少被使用。

== 时间日期数据的格式化函数 ==

* <code>char *asctime(const struct tm* tmptr)</code>
: 把分解时间<code>tm</code>输出到字符串，结果的格式为"Www Mmm dd hh:mm:ss yyyy"，即“周几 月份数 日数 小时数:分钟数:秒钟数 年份数”。函数返回的字符串为静态分配，长度不大于26，与<code>ctime</code>函数共用。函数的每次调用将覆盖该字符串内容。
* <code>char* ctime(const time_t* timer)</code>
: 把日历时间<code>time_t timer</code>输出到字符串，输出格式与<code>asctime</code>函数一样.
* <code>size_t strftime(char* s, size_t n, const char* format, const struct tm* tptr)</code>
: 把分解时间<code>tm</code>转换为自定义格式的字符串，类似于常见的字符串格式输出函数<code>sprintf</code>。例如：strftime(buf, 64, "%Y-%m-%d %H:%M:%S", localtime);
* <code>char * strptime(const char* buf, const char* format, struct tm* tptr)</code>
: <code>strftime</code>的逆操作，把字符串按照自定义的格式转换为分解时间<code>tm</code>。

== 对时间数据的操作 ==

* <code>double difftime(time_t timer2, time_t timer1)</code>
: 比较两个日历时间之差。

== 源代码示例 ==

打印当前时间到标准输出流：
<syntaxhighlight lang="c">
# include <stdio.h>
# include <time.h>

int main(void)
{
    time_t  timer = time(NULL);
    printf("ctime is %s\n", ctime(&timer));
    return 0;
}
</syntaxhighlight>

== 参考文献 ==
{{Reflist|refs=
<ref name = "APUE">{{citation|last1=Stevens|first1=W. Richard|last2=Rago|first2=Stephen A.|title=''Advanced Programming in the UNIX Environment''|edition=3rd.|url=http://www.apuebook.com|location=United States of America|publisher=[[Pearson_Education|Pearson Education]], Inc.|year=2013|isbn=978-0-321-63773-4|language=en|accessdate=2021-02-09|archive-date=2014-03-15|archive-url=https://web.archive.org/web/20140315222243/http://www.apuebook.com/|dead-url=no}}</ref>
}}

== 參考來源 ==
* {{cite book |date=2001-07-06 |title=The GNU C Library Reference Manual |chapter=Calendar Time |url=http://www.gnu.org/software/libc/manual/html_node/Calendar-Time.html |accessdate=2007-04-03 |archive-date=2007-03-28 |archive-url=https://web.archive.org/web/20070328204505/http://www.gnu.org/software/libc/manual/html_node/Calendar-Time.html |dead-url=no }}
* {{cite book |date=2008-12-09 |title=The Open Group Base Specifications |chapter=gmtime |url=http://www.opengroup.org/onlinepubs/009695399/functions/gmtime.html |access-date=2011-07-01 |archive-date=2010-12-08 |archive-url=https://web.archive.org/web/20101208080611/http://www.opengroup.org/onlinepubs/009695399/functions/gmtime.html |dead-url=no }}

== 外部連結 ==
* [http://en.cppreference.com/w/cpp/chrono/c C++ reference for date/time functions inherited from C]{{Wayback|url=http://en.cppreference.com/w/cpp/chrono/c |date=20110625152710 }}

{{CProLang}}
[[Category:时间|时间]]
[[Category:C标准函数库|C标准函数库]]
[[Category:C语言|Category:C语言]]