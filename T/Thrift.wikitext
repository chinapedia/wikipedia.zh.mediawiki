{{Infobox software
| name = Apache Thrift
| logo =
| screenshot =
| caption =
| collapsible =
| developer = [[Apache软件基金会|Apache软件基金会]]
| latest_release_version = 0.9.3
| latest_release_date = {{start date and age|2015|10|06|df=yes}}
| latest_preview_version =
| latest_preview_date =
| operating_system =
| programming_language =
| genre = [[远程过程调用|远程过程调用]]框架
| license = [[Apache许可证|Apache许可证]] 2.0
| website = {{URL|http://thrift.apache.org/}}
}}

'''Thrift'''是一种[[接口描述语言|接口描述语言]]和二进制通讯协议，<ref>{{Cite web | accessdate=2011-03-30 | location=http://www.sodeso.nl/ | publisher=Sodeso–软件开发解决方案 | title=安装和使用Java下的Apache Cassandra第4部分（Thrift客户端） | quote=Thrift是一个独立的Apache项目，简单地说，就是一种二进制通讯协议。 | url=http://www.sodeso.nl/?p=251 | archive-date=2010-08-15 | archive-url=https://web.archive.org/web/20100815022825/http://www.sodeso.nl/?p=251 | dead-url=yes }}{{en}}</ref>它被用来定义和创建跨语言的服务。<ref>{{Cite web | accessdate=2011-04-11 | author=Andrew Prunicki | location=http://www.ociweb.com/ | publisher=对象计算有限公司–一家开放解决方案公司 | title=Apache Thrift：介绍 | quote=通过一种简单且直截了当的接口定义语言（IDL），Thrift允许你定义和创建一种服务，这种服务既可以用多种语言来实现，又可以由多种语言来使用。利用代码生成功能，Thrift可以创建一套文件，然后通过这套文件来创建服务端和客户端程序。除了互操作性之外，Thrift还非常高效，这得益于一套独特的、在时间和空间上都高效的序列化机制。 | url=http://jnb.ociweb.com/jnb/jnbJun2009.html | archive-date=2011-07-23 | archive-url=https://web.archive.org/web/20110723051326/http://jnb.ociweb.com/jnb/jnbJun2009.html | dead-url=no }}{{en}}</ref>它被当作一个[[远程过程调用|远程过程调用]]（RPC）框架来使用，是由[[Facebook|Facebook]]为“大规模跨语言服务开发”而开发的。它通过一个代码生成引擎联合了一个软件栈，来创建不同程度的、无缝的[[跨平台|跨平台]]高效服务，可以使用[[C♯|C#]]、[[C++|C++]]（基于[[POSIX|POSIX]]兼容系统<ref>[http://wiki.apache.org/thrift/ThriftRequirements Thrift的要求] {{Wayback|url=http://wiki.apache.org/thrift/ThriftRequirements |date=20160124051900 }}，要支持Windows参见[https://issues.apache.org/jira/browse/THRIFT-1123 这里] {{Wayback|url=https://issues.apache.org/jira/browse/THRIFT-1123 |date=20160127170140 }}{{en}}</ref>）、Cappuccino、<ref>Fred Potter，[http://blog.parallel48.com/using-thrift-with-cappuccino 使用Thrift + Cappuccino] {{Wayback|url=http://blog.parallel48.com/using-thrift-with-cappuccino |date=20110812154611 }}，parallel48的甜美的邮件博客，2010年6月10日。{{en}}</ref>[[Cocoa|Cocoa]]、[[Delphi|Delphi]]、[[Erlang|Erlang]]、[[Go|Go]]、[[Haskell|Haskell]]、[[Java|Java]]、[[Node.js|Node.js]]、[[OCaml|OCaml]]、[[Perl|Perl]]、[[PHP|PHP]]、[[Python|Python]]、[[Ruby|Ruby]]和[[Smalltalk|Smalltalk]]。<ref>{{Cite web | accessdate=2011-04-12 | author=Andrew Prunicki | location=http://www.ociweb.com/ | publisher=对象计算有限公司–一家开放解决方案公司 | title=Apache Thrift：代码生成 | quote=Thrift在不同程度上支持许多语言，完整的名单如下：（请小心，不能仅仅因为你的语言在某种程度上被支持，就假设它支持所有的Thrift特性。比如Python，仅支持TBinaryProtocol。）Cocoa、C++、C#、Erlang、Haskell、Java、OCaml、Perl、PHP、Python、Ruby和Smalltalk。 | url=http://jnb.ociweb.com/jnb/jnbJun2009.html | archive-date=2011-07-23 | archive-url=https://web.archive.org/web/20110723051326/http://jnb.ociweb.com/jnb/jnbJun2009.html | dead-url=no }}{{en}}</ref>虽然它以前是由Facebook开发的，但它现在是[[Apache软件基金会|Apache软件基金会]]的[[开源|开源]]项目了。该实现被描述在2007年4月的一篇由Facebook发表的技术论文中，该论文现由Apache掌管。<ref>Mark Slee、Aditya Agarwal、Marc Kwiatkowski，[http://thrift.apache.org/static/files/thrift-20070401.pdf Thrift：大规模跨语言服务的实现] {{Wayback|url=http://thrift.apache.org/static/files/thrift-20070401.pdf |date=20160119075047 }}{{en}}</ref>

== 架构 ==

[[Image:Apache_Thrift_architecture.png|400px]]

Thrift包含一套完整的栈来创建客户端和服务端程序。<ref name="Architecture">{{Cite web | accessdate=2011-04-11 | author=Andrew Prunicki | location=http://www.ociweb.com/ | publisher=对象计算有限公司–一家开放解决方案公司 | title=Apache Thrift：介绍 | quote=该栈的顶层部分是从你的Thrift定义文件生成的代码。Thrift服务在生成的客户端和处理器代码中提供结果。在图中，这些是用棕色框表示的。被发送的数据结构（不同于内建类型）也由生成的代码产生。这些结果由红色框表示。通讯和传输协议是Thrift运行时库的一部分。因此，用Thrift，你可以定义一个服务，并可以自由地改变通讯和传输协议，而无需重新生成你的代码。Thrift还包括一个服务器基础设施，以集成各个通讯和传输协议。它支持阻塞、非阻塞、单线程以及多线程服务器。栈中“作为I/O基础”的部分则是因语言而异的。对于Java和Python网络I/O，Thrift库对其内建库起到了杠杆作用，而C++的实现使用了它自己的习惯。 | url=http://jnb.ociweb.com/jnb/jnbJun2009.html | archive-date=2011-07-23 | archive-url=https://web.archive.org/web/20110723051326/http://jnb.ociweb.com/jnb/jnbJun2009.html | dead-url=no }}{{en}}</ref>顶层部分是由Thrift定义生成的代码。而服务则由这个文件客户端和处理器代码生成。在生成的代码里会创建不同于内建类型的数据结构，并将其作为结果发送。协议和[[传输层|传输层]]是[[运行时库|运行时库]]的一部分。有了Thrift，就可以定义一个服务或改变通讯和传输协议，而无需重新编译代码。除了客户端部分之外，Thrift还包括服务器基础设施来集成协议和传输，如阻塞、非阻塞及多线程服务器。栈中作为I/O基础的部分对于不同的语言则有不同的实现。

Thrift支持众多通讯协议：<ref name="Architecture" />
* TBinaryProtocol – 一种简单的二进制格式，简单，但没有为空间效率而优化。比文本协议处理起来更快，但更难于[[调试|调试]]。
* TCompactProtocol – 更紧凑的二进制格式，处理起来通常同样高效。
* TDebugProtocol – 一种人类可读的文本格式，用来协助调试。
* TDenseProtocol – 与TCompactProtocol类似，将传输数据的元信息剥离。
* TJSONProtocol – 使用[[JSON|JSON]]对数据编码。
* TSimpleJSONProtocol – 一种只写协议，它不能被Thrift解析，因为它使用JSON时丢弃了元数据。适合用脚本语言来解析。<ref>{{Cite web | last1=Skelton | first1=Steven | title=对开发者友好的Thrift请求日志 | url=http://stevenskelton.ca/developer-friendly-thrift-request-logging/ | accessdate=2014年7月3日 | archive-date=2014年7月14日 | archive-url=https://web.archive.org/web/20140714185551/http://stevenskelton.ca/developer-friendly-thrift-request-logging/ | dead-url=no }}{{en}}</ref>

支持的''传输协议''有：
* TFileTransport – 该传输协议会写文件。
* TFramedTransport – 当使用一个非阻塞服务器时，要求使用这个传输协议。它按帧来发送数据，其中每一帧的开头是长度信息。
* TMemoryTransport – 使用[[存储器映射输入输出|存储器映射输入输出]]。（Java的实现使用了一个简单的{{Javadoc:SE|java/io|ByteArrayOutputStream}}。）
* TSocket – 使用阻塞的套接字I/O来传输。
* TZlibTransport – 用[[zlib|zlib]]执行压缩。用于连接另一个传输协议。

Thrift还提供众多的服务器，包括：
* TNonblockingServer – 一个多线程服务器，它使用非阻塞I/O（Java的实现使用了[[Java_NIO|NIO]]通道）。TFramedTransport必须跟这个服务器配套使用。
* TSimpleServer – 一个单线程服务器，它使用标准的阻塞I/O。测试时很有用。
* TThreadPoolServer – 一个多线程服务器，它使用标准的阻塞I/O。

== 优点 ==

Thrift一些已经明确的优点包括：{{citation needed | date=2011年4月 }}
* 跟一些替代选择，比如[[SOAP|SOAP]]相比，跨语言序列化的代价更低，因为它使用二进制格式。
* 它有一个又瘦又干净的库，没有编码框架，没有[[XML|XML]]配置文件。
* [[绑定|绑定]]感觉很自然。例如，[[Java|Java]]使用<code>java.util.ArrayList<String></code>；[[C++|C++]]使用<code>std::vector<std::string></code>。
* 应用层通讯格式与序列化层通讯格式是完全分离的。它们都可以独立修改。
* 预定义的序列化格式包括：二进制格式、对HTTP友好的格式，以及紧凑的二进制格式。
* 兼作跨语言文件[[序列化|序列化]]。
* 协议使用软版本号机制{{clarify | 软件版本管理 | date=2013年8月 }}。Thrift不要求一个中心化的和显式的版本号机制，例如[[软件版本号|主版本号/次版本号]]。松耦合的团队可以轻松地控制RPC调用的演进。
* 没有构建依赖也不含非标准化的软件。不存在不兼容的软件许可证混用的情况。

== 创建一个Thrift服务 ==

Thrift由C++编写，但可以为众多语言创建代码。要创建一个Thrift服务，必须写一些Thrift文件来描述它，为目标语言生成代码，并且写一些代码来启动服务器及从客户端调用它。下面就是一个这样的描述文件的代码示例：

<syntaxhighlight lang="Cpp">
enum PhoneType {
 HOME,
 WORK,
 MOBILE,
 OTHER
}

struct Phone {
 1: i32 id,
 2: string number,
 3: PhoneType type
}
</syntaxhighlight>

Thrift将由这个描述信息生成独立的代码。例如，在Java里，<code>PhoneType</code>将是<code>Phone</code>类中一个简单的<code>enum</code>。

== 参见 ==

{{ Portal | Free software }}

* {{ link-en | 数据序列化格式比较 | Comparison of data serialization formats }}
* [[Apache_Avro|Apache Avro]]
* [[ASN.1|ASN.1]]（抽象语法标记一）
* Caucho的{{ link-en | Hessian | Hessian (Web service protocol) }}
* [[Google|Google]]的[[Protocol_Buffers|Protocol Buffers]]
* [[外部数据表示法|外部数据表示法]]
* {{ link-en | ZeroC | ZeroC }}的[[ICE_(中间件)|ICE]]
* {{ link-en | SDXF | SDXF }}（结构化数据交换格式）

== 参考文献 ==

{{ Reflist }}

== 外部链接 ==

* {{Official | http://thrift.apache.org/}}{{en}}
* [http://diwakergupta.github.com/thrift-missing-guide/ Thrift：缺失的指南]{{Wayback|url=http://diwakergupta.github.com/thrift-missing-guide/ |date=20130223021810 }}{{en}}
* [http://code.google.com/p/thriftc-task/ Thrift蚂蚁任务]{{Wayback|url=http://code.google.com/p/thriftc-task/ |date=20141227162945 }}{{en}}
* [http://www.thrift.pl/ Thrift指导]{{Wayback|url=http://www.thrift.pl/ |date=20160208040606 }}{{en}}

{{Apache}}
{{Facebook navbox}}

[[Category:应用层协议|Category:应用层协议]]
[[Category:数据序列化格式|Category:数据序列化格式]]
[[Category:进程间通信|Category:进程间通信]]
[[Category:远端程序呼叫|Category:远端程序呼叫]]
[[Category:Facebook软件|Category:Facebook软件]]