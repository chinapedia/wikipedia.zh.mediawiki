{{NoteTA|G1=IT}}
{{lowercase}}
{{dead end|time=2014-10-25T08:50:37+00:00}}
{{unreferenced|time=2014-10-25T08:50:37+00:00}}
在计算机中，'''ioctl'''(input/output control)是一个专用于设备输入输出操作的系统调用,该调用传入一个跟设备有关的请求码，系统调用的功能完全取决于请求码。举个例子，[[CD-ROM|CD-ROM]]驱动程序可以弹出光驱，它就提供了一个对应的'''Ioctl'''请求码。设备无关的请求码则提供了内核调用权限。ioctl这名字第一次出现在[[UNIX|Unix]]第七版中，他在很多类unix系统（比如[[Linux|Linux]]、[[Mac_OSX|Mac OSX]]等）都有提供，不过不同系统的请求码对应的设备有所不同。[[Microsoft_Windows|Microsoft Windows]]在Win32 API里提供了相似的函数，叫做[[DeviceIoControl|DeviceIoControl]]。
==背景==
传统的操作系统可以分成两层，用户层和内核层。应用程序代码比如编辑器，处于用户层，然而系统底层程序，比如网络栈，处于内核层。内核代码处理敏感资源同时在不同应用程序中间提供了安全且可信的隔离，出于此，操作系统要阻止用户态的程序直接访问内核资源。用户空间的程序通常发出一个给内核的请求，该请求称为系统调用，它的实现代码在内核层。系统调用采取“系统调用增量”的方式，用递增的序号指示系统调用。举个例子，exit()可能是1，write()可能是4。系统调用增量能通过这样的不同数值找到对应的被请求的内核函数，传统的操作系统通常用这种方式给用户空间提供了上百个系统调用。操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址,但是当访问非标准硬件设备这些系统调用显得不合适,有时候用户模式可能需要直接访问设备，比如，一个系统管理员可能要修改网卡的配置。现代操作系统提供了各种各样设备的支持，有一些设备可能没有被内核设计者考虑到，如此一来提供一个这样的系统调用来使用设备就变得不可能了。 为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个'''Ioctl'''接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的'''Ioctl'''调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。

[[Category:Unix|Category:Unix]]