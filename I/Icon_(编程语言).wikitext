{{NoteTA|G1=IT}}
{{Infobox programming language
|name = Icon
|logo = Icon logo.png
|paradigm = [[编程范型|多范型]]：面向文本, [[结构化编程|结构化]], [[非确定性编程|非确定性]]
|designer = {{en-link|Ralph Griswold}}
|developer =
|typing = [[类型系统|动态]]
|implementations = Icon, Jcon
|dialects = [[Unicon_(编程语言)|Unicon]]
|license = [[公有领域|公有领域]]
|influenced = Unicon, [[Python|Python]]<ref name="pep-0255">{{cite web |url=https://www.python.org/dev/peps/pep-0255/ |title=PEP 255 -- Simple Generators |last=Schemenauer |first=Neil |last2=Peters |first2=Tim |last3=Hetland |first3=Magnus |date=2001-12-21 |10= |accessdate=2008-09-05 |archive-date=2020-06-05 |archive-url=https://web.archive.org/web/20200605012926/https://www.python.org/dev/peps/pep-0255/ |dead-url=no }}</ref>, [https://github.com/proebsting/goaldi Goaldi]
|website = {{URL|www.cs.arizona.edu/icon}}
|year = {{Start date and age|1977}}
| latest_release_version = 9.5.21b
| latest_release_date = {{Start date and age|2021|09|25}}<ref>{{cite web |url=https://github.com/gtownsend/icon/releases/tag/v9.5.21b |title=v9.5.21b |access-date=2022-02-03 |archive-date=2022-02-03 |archive-url=https://web.archive.org/web/20220203063746/https://github.com/gtownsend/icon/releases/tag/v9.5.21b }}</ref>
|influenced_by = [[SNOBOL|SNOBOL]]<ref>{{cite book |last1=Griswold |first1=Ralph E. |last2=Poage |first2=J.F. |last3=Polonsky |first3=Ivan P. |title=The SNOBOL 4 Programming Language |publisher=Prentice-Hall |location=Englewood Cliffs NJ |year=1971 |isbn=0-13-815373-6 |edition=2nd |url=https://archive.org/details/snobol4programmi00gris }}</ref>, SL5<ref>Ralph E. Griswold, David R. Hanson, "An Overview of SL5", ''SIGPLAN Notices'' '''12''':4:40-50 (April 1977)</ref>, [[ALGOL|ALGOL]]
}}
'''Icon'''是一门[[领域特定语言|领域特定]]的[[高级编程语言|高级编程语言]]，有着“目的（goal）导向执行”特征，和操纵[[字符串|字符串]]和文本模式的很多设施。它衍生自[[SNOBOL|SNOBOL]]和SL5字符串处理语言<ref>{{cite book |last1=Griswold |first1=Ralph E. |last2=Griswold |first2=Madge T. |chapter=History of the Icon programming language |editor1-last=Bergin |editor1-first=Thomas J. |editor2-last=Gibson |editor2-first=Richard G. |title=History of Programming Languages II |publisher=ACM Press |location=New York NY |year=1996 }}</ref>。Icon不是[[面向对象|面向对象]]的，但在1996年开发了叫做Idol的面向对象扩展，它最终变成了[[Unicon_(编程语言)|Unicon]]。

==历史==
在1971年8月，[[SNOBOL|SNOBOL]]的设计者之一{{en-link|Ralph Griswold}}离开了[[贝尔实验室|贝尔实验室]]，成为了[[亚利桑那大学|亚利桑那大学]]的教授{{sfn|Griswold|1981|pp=609}}。他那时将SNOBOL4介入为研究工具{{sfn|Griswold|1981|pp=629}}。

作为最初在1960年代早期开发的语言，SNOBOL的语法带有其他早期编程语言的印记，比如[[FORTRAN|FORTRAN]]和[[COBOL|COBOL]]。特别是，语言是依赖列的，像很多要录入到[[打孔卡|打孔卡]]的语言一样，有着列布局是很自然的。此外，控制结构几乎完全基于了分支，而非使用[[块_(编程)|块]]，而块在[[ALGOL_60|ALGOL 60]]中介入之后，已经成为了必备的特征。在他迁移到亚利桑那的时候，SNOBOL4的语法已然过时了{{sfn|Griswold|Griswold|1993|p=53}}。

Griswold开始致力于用传统的流程控制结构如<code>if…then</code>，来实现SNOBOL底层的成功和失败概念。这成为了SL5，即“SNOBOL Language 5”的简写，但是结果不令人满意{{sfn|Griswold|Griswold|1993|p=53}}。在1977年，他考虑设计语言的新版本。他放弃了在SL5中介入的非常强力的函数系统，介入更简单的暂停和恢复概念，并为SNOBOL4自然后继者开发了新概念，具有如下的原则{{sfn|Griswold|Griswold|1993|p=53}}：
* SNOBOL4的哲学和语义基础；
* SL5的语法基础；
* SL5的特征，排除广义的过程机制。

新语言最初叫做SNOBOL5，但因为除了底层概念外，全都与SNOBOL有着显著的差异，最终想要一个新名字。在这个时候[[Xerox_PARC|Xerox PARC]]出版了他们关于[[图形用户界面|图形用户界面]]的工作，术语“icon”从而进入了计算机词汇中。起初确定为“icon”而最终选择了“Icon”{{sfn|Griswold|Griswold|1993|p=53}}。

==基本语法==
Icon语言衍生自[[ALGOL|ALGOL]]类的[[结构化编程|结构化编程]]语言，因而有着类似[[C语言|C]]或[[Pascal_(程式語言)|Pascal]]的语法。Icon最类似于Pascal的，是使用了<code>:=</code>语法的赋值，<code>procedure</code>关键字和类似的语法。在另一方面，Icon使用C风格的花括号来结构化执行分组，并且程序开始于运行叫做<code>main</code>的过程。

Icon还在很多方面分享了多数[[脚本语言|脚本语言]]（还有[[SNOBOL|SNOBOL]]及SL5）的特征：变量不需要声明，类型是自动转换的，就说数字和字符串可以自动来回转换。另一个常见于很多而非全部的脚本语言的特征是，缺少行终止字符；在Icon中，不结束于分号的行，若其确有意义则由暗含的分号来终结。

过程是Icon程序的基本建造块。尽管它们使用Pascal名称，但工效上更像C函数并可以返回值；在Icon中没有<code>function</code>关键字。

<syntaxhighlight lang="icon">
procedure doSomething(aString)
  write(aString)
end
</syntaxhighlight>

==目的导向执行==
Icon的关键概念之一就是其控制结构基于表达式的“成功”或“失败”，而非大多数其他编程语言中的[[布尔逻辑|布尔逻辑]]。这个特征直接派生自[[SNOBOL|SNOBOL]]，在其中表达式求值、[[模式匹配|模式匹配]]和模式匹配连带替换，都可以跟随着成功或失败子句，用来指定在这个条件下要分支到一个语句标签。例如，下列代码打印“Hello, World!”五次<ref name=lane>{{cite web |url=https://try-mts.com/snobol-introduction/ |title=SNOBOL - Introduction |website=Try MTS |date=26 July 2015 |first=Rupert |last=Lane |access-date=2022-02-03 |archive-date=2022-05-09 |archive-url=https://web.archive.org/web/20220509071457/https://try-mts.com/snobol-introduction/ }}</ref>：
<syntaxhighlight lang=snobol>
* 打印Hello, World!五次的SNOBOL程序 
      I = 1
LOOP  OUTPUT = "Hello, World!"
      I = I + 1
      LE(I, 5) : S(LOOP)
END
</syntaxhighlight>
要进行循环，在索引变量<code>I</code>之上调用内建的函数<code>LE</code>（小于等于），并且如果<code>S</code>（成功），意味着<code>I</code>小于等于<code>5</code>，它分支到命名标签<code>LOOP</code>并继续下去<ref name=lane/>。

Icon保留了基于成功或失败的控制流程的基本概念，但进一步发展了语言。一个变更是将加标签的<code>GOTO</code>式的分支，替代为面向块的结构，符合在1960年代后期席卷计算机工业的[[结构化编程|结构化编程]]风格{{sfn|Griswold|Griswold|1993|p=53}}。另一个变更是允许失败沿着调用链向上传递，使得整个块作为一个整体的成功或失败。这是Icon语言的关键概念。而在传统语言中，必须包括基于[[布尔逻辑|布尔逻辑]]的测试成功或失败的代码，并接着基于产出结果进行分支，这种测试和分支是固有于Icon代码的，而不需要明确的写出{{sfn|Tratt|2010|p=73}}。考虑如下复制[[标准输入|标准输入]]到[[标准输出|标准输出]]的简单代码：
<syntaxhighlight lang="icon">
while a := read() then write(a)
</syntaxhighlight>
它的含义是：“只要读取不返回失败，调用写出，否则停止”{{sfn|Tratt|2010|p=74}}。在Icon中，<code>read()</code>函数返回一行文本或<code>&fail</code>。<code>&fail</code>不是简单的[[Java|Java]]中的特殊返回值<code>EOF</code>（文件结束）的类似者，因为它被语言依据上下文明确理解为意味着“停止处理”或“按失败状况处理”。这里即使<code>read()</code>导致一个错误它都会工作，比如说如果文件不存在。在这种情况下，语句<code>a := read()</code>会失败，而写操作简单的不调用。

成功和失败将沿着调用链向上传递，意味着可以将函数嵌入其他函数内，在{{en-link|嵌套函数|nested function}}失败时，它们整体停止。例如，上面的代码可以精简为{{sfn|Griswold|1996|p=2.1}}：

<syntaxhighlight lang="icon">
while write(read())
</syntaxhighlight>

在<code>read()</code>命令失败的时候，比如在文件结束之处，失败将沿着调用链上传，而<code>write()</code>也会失败。<code>while</code>作为一个控制结构，在失败时停止。Icon称谓这个概念为“目的导向执行”，指称这种只要某个目的达到执行就继续的方式。在上面的例子中目的是读整个文件；读命令在有信息读到的时候成功，而在没有的时候失败。目的因此直接编码于语言中，不用再去检查[[退出状态|返回码]]或类似的构造。

Icon使用目的导向机制用于进行传统的布尔测试，尽管有着微妙的差异。一个简单的比较如{{code|if a < b then write("a is smaller than b")|icon}}，这里的<code>if</code>子句，不像在多数语言中那样意味着：“如果右侧运算求值为真”；转而它的意味更像是：“如果右侧运算成功”。在这种情况下，如果这个比较为真，<code><</code>算子成功。如果<code>if</code>子句的这个表达式成功，则调用<code>then</code>子句，如果它失败了，则调用<code>else</code>子句或下一行。结果同于在其他语言中见到的传统<code>if…then</code>，如果<code>a</code>小于<code>b</code>，<code>if</code>进行<code>then</code>子句。微妙之处是相同的比较表达式可以放置在任何地方，例如：
<syntaxhighlight lang="icon">
write(a < b)
</syntaxhighlight>

另一个不同是<code><</code>算子如果成功，返回它的第二个实际参数，在这个例子中，如果<code>b</code>大于<code>a</code>，则导致它的值被写出，否则什么都不写。因为并非测试本身，而是一个算符返回一个值，它们可以串联在一起，允许像<code>if a < b < c</code>这样的事情{{sfn|Griswold|1996|p=2.1}} ，在多数语言中平常类型的比较下，必须写为两个不等式的结合，比如<code>if (a < b) && (b <  c)</code>。

将成功和失败的概念与[[异常处理|异常]]的概念相对比是很重要的；异常是不寻常的状况，不是预期的结果。在Icon中失败是预期的结果；到达文件的结束处是预期的状况而不是异常。Icon没有传统意义上的异常处理，尽管失败经常被用于类似异常的状况下。例如，如果要读取的文件的不存在，<code>read</code>失败而不指示出特殊状况{{sfn|Tratt|2010|p=74}}。在传统语言中，没有指示这些“其他状况”的自然方式，典型的异常处理是“抛出”一个值，下面是用[[Java|Java]]处理缺失文件的例子：

<syntaxhighlight lang="java">
try {
    while ((a = read()) != EOF) {
        write(a);
    }
} catch (Exception e) {
    // 某个事情出错了，使用这个catch来退出循环
}
</syntaxhighlight>

这种情况需要两个比较：一个用于文件结束（EOF）而另一个用于所有其他错误。因为Java不允许异常作为逻辑元素来比较，就像Icon中那样，转而必须使用冗长的<code>try/catch</code>语法。<code>try</code>块即使没有异常抛出，也强加了性能上的惩罚，Icon避免了这种{{en-link|分摊成本|Distributed cost}}。

目的导向执行的一个关键方面，是程序可能必须在一个过程失败时倒转到以前的状态，这个任务叫做[[回溯法|回溯]]。例如，考虑设置一个变量为一个开始位置，并接着进行可以改变这个值的操作，这是在字符串扫描中常见情况，这里前进游标通过它所扫描的字符串。如果这个过程失败了，任何对这个变量的后续读取都返回最初的状态，而非被内部操纵后的状态是很重要的。对于这种任务，Icon有一个“可逆赋值”算子<code><-</code>，和“可逆交换”算子<code><-></code>。例如，考虑如下尝试在一个更大字符串内找到一个模式字符串的代码：
<syntaxhighlight lang="icon">
{
  (i := 10) &
  (j := (i < find(pattern, inString)))
}
</syntaxhighlight>
这个代码开始于移动<code>i</code>到<code>10</code>，这是查找的开始位置。但是，如果<code>find</code>失败，这个块将作为整体失败，作为一个不想要的[[副作用_(计算机科学)|副作用]]，它导致<code>i</code>的值留下为<code>10</code>。故而应将<code>i := 10</code>替代为<code>i <- 10</code>，指示<code>i</code>在这个块失败时应当被重置为它以前的值。这提供了执行中的{{en-link|原子性提交|Atomic commit|原子性}}的类似者。

==生成器==
在Icon中表达式经常返回一个单一的值，例如<code>5 > x</code>，将求值并且如果<code>x</code>的值小于<code>5</code>则成功并返回<code>x</code>，否则失败。但是，Icon还包括了过程不立即返回成功或失败，转而每次调用它们之时返回一个新值的概念。这些过程叫做[[生成器_(计算机编程)|生成器]]，并且是Icon语言的关键部份。在Icon的用语中，一个表达式或函数的求值产生一个“结果序列”。结果序列包含这个表达式或函数生成的所有可能的值。在结果序列被耗尽的时候，这个表达式或函数失败。

Icon允许任何过程返回一个单一值或多个值，使用<code>fail</code>、<code>return</code>和<code>suspend</code>关键字来控制。缺乏任何这种关键字的过程返回<code>&fail</code>，它在执行进行到一个过程的<code>end</code>处的时候发生。例如：

<syntaxhighlight lang="icon">
procedure f(x)
  if x > 0 then {
    return 1
  }
end
</syntaxhighlight>

调用<code>f(5)</code>将返回<code>1</code>，而调用<code>f(-1)</code>将返回<code>&fail</code>。这将导致不明显的行为，比如<code>write(f(-1))</code>将什么都输出，因为<code>f</code>失败而暂停了<code>write</code>的操作{{sfn|Tratt|2010|p=75}}。

将一个过程转换成一个生成器，要使用<code>suspend</code>关键字，它意味着“返回这个值，并且在再次调用时，从这一点开始执行”。例如{{sfn|Tratt|2010|p=74}}：

<syntaxhighlight lang="icon">
procedure ItoJ(i, j)
  while i <= j do {
    suspend i
    i +:= 1
  }
  fail
end
</syntaxhighlight>

建立一个生成器，它返回一系列的数，开始于<code>i</code>并结束于<code>j</code>，接着在它们之后返回<code>&fail</code>。{{efn|<code>fail</code>在这种情况下是不要求的，因为它紧前于<code>end</code>，增加它是为了清晰性。}}<code>suspend i</code>停止执行，并返回<code>i</code>的值，而不重置任何状态。当对相同函数做出另一次调用的时候，执行在这一点上拾起以前的值。在这种情况下，导致它进行<code>i +:= 1</code>，循环回到<code>while</code>的开始处，并接着返回下一个值并再次暂停。这将持续直到<code>i <= j</code>失败，在这一点上它退出这个块并调用<code>fail</code>。这允许轻易的构造[[迭代器|迭代器]]{{sfn|Tratt|2010|p=74}}。

另一种类型的生成器建造器是“{{en-link|交替 (形式语言理论)|Alternation (formal language theory)|交替}}子”（alternator），它的感观和运算就像布尔算子<code>or</code>，例如：

<syntaxhighlight lang="icon">
if y < (x | 5) then write("y=", y)
</syntaxhighlight>
这看起来是在说“如果<code>y</code>小于<code>x</code>或者<code>5</code>那么...”，实际上它是生成器的一种简写形式，它返回值直到脱离于这个列表的结束处。这个列表的值被注入到运算之中，在这里是<code><</code>。所以这个例子，系统首先测试<code>y < x</code>，如果<code>x</code>实际上大于<code>y</code>，它返回<code>x</code>的值，这个测试通过，而<code>y</code>的值在<code>then</code>子句中写出。然而，如果<code>x</code>不大于<code>y</code>，它失败了，交替子继续，进行<code>y < 5</code>。如果这个测试通过，写出<code>y</code>。如果<code>y</code>不小于<code>x</code>或者<code>5</code>，交替子用完了，测试失败，<code>if</code>子句失败，而不进行<code>write</code>。因此，<code>y</code>的值如果小于<code>x</code>或<code>5</code>，则它将出现在控制台上，从而履行了布尔<code>or</code>的作用。函数不会被调用，除非求值它们的参数成功，所以这个例子可以简写为：

<syntaxhighlight lang="icon">
write("y=", (x | 5) > y)
</syntaxhighlight>

在内部，交替子不是简单的一个<code>or</code>，它还可以用来构造值的任意列表。这可以用来在任意的一组值上迭代，比如：

<syntaxhighlight lang="icon">
every i := (1|3|4|5|10|11|23) do write(i)
</syntaxhighlight>

<code>every</code>类似于<code>while</code>，循环经过一个生成器的返回的所有项目，在失败时退出{{sfn|Tratt|2010|p=75}}。

因为整数列表在很多编程场景都是很常见的，Icon还包括了<code>to</code>关键字来构造“事实上的”整数生成器：

<syntaxhighlight lang="icon">
every k := i to j do write(k)
</syntaxhighlight>

在这种情况下，从<code>i</code>到<code>j</code>的值，将注入到<code>write</code>并写出多行输出{{sfn|Tratt|2010|p=75}}。它可以简写为：

<syntaxhighlight lang="icon">
every write(i to j)
</syntaxhighlight>

Icon不是强类型的，所以交替子列表可以包含不同类型的项目：

<syntaxhighlight lang="icon">
every i := (1 | "hello" | x < 5)  do write(i)
</syntaxhighlight>

这将依赖于<code>x</code>的值，写出<code>1</code>、<code>"hello"</code>或可能的<code>5</code>。

同样的“合取算符”<code>&</code>，以类似于布尔算符<code>and</code>的方式来使用{{sfn|Tratt|2010|p=76}}：

<syntaxhighlight lang="icon">
every x := ItoJ(0,10) & x % 2 == 0 do write(x)
</syntaxhighlight>

这个代码调用<code>ItoJ</code>并返回一个初始值<code>0</code>，它被赋值给<code>x</code>。接着进行合取的右手端，并且因为<code>x % 2</code>不等于<code>0</code>，它写出这个值。接着再次调用<code>ItoJ</code>生成器，它赋值<code>1</code>到<code>x</code>，这使得右手端失败而不打印任何东西。最终结果是从<code>0</code>到<code>10</code>的所有偶数的一个列表{{sfn|Tratt|2010|p=76}}。

生成器的概念对于字符串操作是很强大的。在Icon中，<code>find</code>函数是个生成器。下面的例子代码，在一个字符串中找出<code>"the"</code>的所有出现位置：

<syntaxhighlight lang="icon">
s := "All the world's a stage. And all the men and women merely players"
every write(find("the", s))
</syntaxhighlight>

<code>find</code>在每次被<code>every</code>恢复的时候，将返回<code>"the"</code>的下一个实例的索引，最终达到字符串结束处并失败。

当然人们有时会想要找到在输入中某点之后的一个字符串，例如，扫描包含多列数据的一个文本文件。目的导向执行也能起效：

<syntaxhighlight lang="icon">
write(5 < find("the", s))
</syntaxhighlight>

只返回<code>"the"</code>出现在位置<code>5</code>之后的那些位置；否则比较会失败。成功的比较返回右手侧的结果，所以把<code>find</code>放置到这个比较的右手侧是重要的。

==搜集==
Icon包括了一些[[集合_(计算机科学)|搜集类型]]，包括[[列表_(抽象数据类型)|列表]]，它还可以用作[[堆栈|堆栈]]和[[队列|队列]]，[[关联数组|表格]]（在其他语言中也叫做映射或字典），和{{en-link|集合 (抽象数据类型)|Set (abstract data type)|集合}}等。Icon称它们为“结构”。搜集是固有的生成器，并可以使用“叹号语法”来轻易调用。例如：

<syntaxhighlight lang="icon">
lines := []                    # 建立一个空列表
while line := read() do {      # 循环从标准输入读取行
  push(lines, line)            # 使用类堆栈语法来将行压入列表
}
while line := pop(lines) do {  # 循环于行可以从列表弹出之时
  write(line)                  # 将行写出
}
</syntaxhighlight>

使用如前面例子中见到的失败传播，可以组合测试和循环：

<syntaxhighlight lang="icon">
lines := []                    # 建立空列表
while push(lines, read())      # 压入直到为空
while write(pop(lines))        # 写直到为空
</syntaxhighlight>

由于列表搜集是个生成器，可以使使用叹号语法进一步简化：

<syntaxhighlight lang="icon">
lines := []
every push(lines, !&input)
every write(!lines)
</syntaxhighlight>

在这种情况下，在<code>write</code>内的叹号，导致Icon从数组一个接一个的返回一行文本，并且在结束处失败。<code>&input</code>是基于生成器的<code>read</code>的类似者，它从[[标准输入|标准输入]]读取一行，所以<code>!&input</code>继续读取行直到文件结束。

因为Icon是无类型的，列表可以包含任何不同类型的值：

<syntaxhighlight lang="icon">
aCat := ["muffins", "tabby", 2002, 8]
</syntaxhighlight>

在列表内的项目可以包括其他结构。为了建造更大的列表，Icon包括了<code>list</code>生成器；<code>i := list(10, "word")</code>生成包含<code>"wold"</code>的<code>10</code>个复本的一个列表。

就像其他语言中的数组，Icon允许项目按位置来查找，比如<code>weight := aCat[4]</code>。就像{{en-link|数组分片|Array slicing}}那样，索引是在元素之间的，可以通过指定范围来获得列表的分片，比如<code>aCat[2:4]</code>产生列表<code>["tabby",2002]</code>。

表格本质上是具有任意索引键而非仅为整数的列表：
<syntaxhighlight lang="icon">
symbols := table(0)
symbols["there"] := 1
symbols["here"] := 2
</syntaxhighlight>
这个代码建立使用的<code>0</code>作为任何未知键的缺省值的一个<code>table</code>。接着向它增加了两个项目，具有键<code>"there"</code>和<code>"here"</code>，和分别的值<code>1</code>和<code>2</code>。

集合也类似于列表，但是只包含任何给定值的一个单一成员。Icon包括了<code>++</code>来产生两个集合的并集，<code>**</code>用于交集，和<code>--</code>用于差集。Icon包括一些预定义的<code>Cset</code>，即包含各种字符的集合。在Icon中有四个标准<code>Cset</code>：<code>&ucase</code>、<code>&lcase</code>、<code>&letters</code>和<code>&digits</code>。可以通过用单引号包围字符串来建造<code>Cset</code>，例如<code>vowel :{{=}} 'aeiou'</code>.

==字符串==
在Icon中，字符串是字符的列表。作为一个列表，它们是生成器，并可以使用“叹号语法”来迭代：
<syntaxhighlight lang="icon">
write(!"Hello, world!")
</syntaxhighlight>
这将在独立行上打印出字符串的每个字符。

子字符串可以使用在方括号内的一个范围规定从字符串中提取出来。范围规定可以返回到一个单一字符的一个点，或字符串的一个分片（slice）。字符串可以从左或从右索引。在一个字符串内的位置被定义为在字符之间：<code><sub>1</sub>A<sub>2</sub>B<sub>3</sub>C<sub>4</sub></code>，也可以从右规定：<code><sub>−3</sub>A<sub>−2</sub>B<sub>−1</sub>C<sub>0</sub></code>。例如：
<syntaxhighlight lang="icon">
"Wikipedia"[1]     == "W"
"Wikipedia"[3]     == "k"
"Wikipedia"[0]     == "a"
"Wikipedia"[1:3]   == "Wi"
"Wikipedia"[-2:0]  == "ia"
"Wikipedia"[2+:3]  == "iki"
</syntaxhighlight>
这里最后例子采用了{{code|x1[i1+:i2] : x2|"icon"}}表达式，产生<code>x1</code>在<code>i1</code>和<code>i1 + i2</code>之间的子字符串。

子字符串规定可以用作字符串内的[[值_(计算机科学)|左值]]。这可以被用来把字符串插入到另一个字符串，或删除字符串的某部份。例如：

<syntaxhighlight lang="icon">
s := "abc"
s[2] := "123"
# s现在的值是"a123c"
s := "abcdefg"
s[3:5] := "ABCD"
# s现在的值是"abABCDefg"
s := "abcdefg"
s[3:5] := ""
# s现在的值是"abefg"
</syntaxhighlight>
Icon的下标索引是在元素之间的。给定字符串<code>s := "ABCDEFG"</code>，索引是<code><sub>1</sub>A<sub>2</sub>B<sub>3</sub>C<sub>4</sub>D<sub>5</sub>E<sub>6</sub>F<sub>7</sub>G<sub>8</sub></code>。分片<code>s[3:5]</code>是在索引<code>3</code>和<code>5</code>之间的字符串，它是字符串<code>"CD"</code>。

==字符串扫描==
对处理字符串的进一步简化是“扫描”系统，通过<code>?</code>来发起，它在一个字符串上调用函数：

<syntaxhighlight lang="icon">
s ? write(find("the"))
</syntaxhighlight>

Icon称呼<code>?</code>的左手端为“主语”，并将它传递到字符串函数中。所调用的<code>find</code>接受两个参数，查找的文本作为参数一，而要在其中查找的字符串是参数二。使用<code>?</code>，第二个参数是隐含的，而不由编程者来指定。在多个函数被依次调用在一个单一字符串上的常见情况下，这种风格可以显著的所见结果代码的长度并增加清晰性。

<code>?</code>不是简单的一种语法糖，它还为任何随后的字符串操作，建立一个“字符串扫描环境”。这基于了两个内部变量，<code>&subject</code>和<code>&pos</code>，这里的<code>&subject</code>是要扫描的字符串，而<code>&pos</code>是在这个主语字符串内的“游标”或当前位置。例如：

<syntaxhighlight lang="icon">
s := "this is a string"
s ? write("subject=[",&subject,"] pos=[",&pos,"]")
</syntaxhighlight>
将产生：
<syntaxhighlight lang="icon">
subject=[this is a string] pos=[1]
</syntaxhighlight>

内建和用户定义的函数，可以被用于在要扫描的字符串上移动。所有内建函数缺省采用<code>&subject</code>和<code>&pos</code>，来允许用上扫描语法。比如函数{{code|tab (i) : s|"icon"}}，它设置扫描位置：产生{{code|&subject[&pos:i]|"icon"}}，并将<code>i</code>赋值到<code>&pos</code>。下列例子代码，写出在一个字符串内，所有空白界定出的<code>word</code>：
<syntaxhighlight lang="icon">
s := "this is a string"
s ? {                           # 建立字符串扫描环境
  while not pos(0) do {         # 测试字串结束
    tab(many(' '))              # 跃过任何空白
    word := tab(upto(' ') | 0)  # 下一个word是直到下一个空白或行结束
    write(word)                 # 写这个word
  }
}
</syntaxhighlight>

这个例子介入了一些新函数。<code>pos</code>返回<code>&pos</code>的当前值。为何需要这个函数，而不简单的直接使用<code>&pos</code>的值，不是显而易见的；原因是<code>&pos</code>是一个变量，而不能呈现值<code>&fail</code>，而过程<code>pos</code>能。因此<code>pos</code>提供对<code>&pos</code>的轻量级包装，它允许轻易使用Icon的目的导向控制流，而不用针对<code>&pos</code>提供手写的布尔测试。在这种情况下，测试是“<code>&pos</code>是零”，在Icon的字符串位置的特异编码中，零是行结束。如果它不是零，<code>pos</code>返回<code>&fail</code>，它通过<code>not</code>反转而使得循环继续。

<code>many</code>从当前<code>&pos</code>开始，找到提供的<code>Cset</code>参数的一个或多个例子。在这种情况下，它查找空格字符，所以这个函数的结果是在<code>&pos</code>之后的第一个非空格字符的位置。<code>tab</code>移动<code>&pos</code>到那个位置，这种情况下再次具有潜在的<code>&fail</code>，例如<code>many</code>在字符结束处脱离。<code>upto</code>本质上是<code>many</code>的反函数；它返回紧前于提供的<code>Cset</code>的例子的位置，接着由另一个<code>tab</code>来设置<code>&pos</code>。这里的交替用来在行结束处也停止。

这个例子通过使用更合适的“字分隔”<code>Cset</code>，可以包括句号、逗号和其他标点，还有其他{{en-link|空白字符|Whitespace character}}如tab和[[不换行空格|不换行空格]]，能够变得更加健壮。这个<code>Cset</code>可以接着用于<code>many</code>和<code>upto</code>。

一个更复杂的例子演示了在这个语言内生成器和字符串扫描的集成：
<syntaxhighlight lang="icon">
procedure main()
  s := "Mon Dec 8"
  s ? write(Mdate() | "not a valid date")
end
# 定义一个匹配函数
# 它返回匹配day month dayofmonth的一个字符串
procedure Mdate()
# 定义一些初始值
static dates
static days
initial {
  days := ["Mon","Tue","Wed","Thr","Fri","Sat","Sun"]
  dates := ["Jan","Feb","Mar","Apr","May","Jun",
            "Jul","Aug","Sep","Oct","Nov","Dec"]
}
every suspend (retval <- tab(match(!days)) ||  # 匹配一个day
                =" " ||                        # 跟随着一个空白
                tab(match(!dates)) ||          # 跟随着一个month
                =" " ||                        # 跟随着一个空白
                matchdigits(2)) &              # 跟随着最多2位数字
              (=" " | pos(0)) &                # 要么是空白要么是字符串结束
              retval                           # 最终返回这个字符串
end
# 返回最多n位数字的一个字符串的匹配函数
procedure matchdigits(n)
  suspend (v := tab(many(&digits)) & *v <= n) & v
end
</syntaxhighlight>
表达式{{code|*x|"icon"}}计算<code>x</code>的大小。这里介入了内建函数{{code|match (s1,s2,i1,i2) : i3|"icon"}}，它匹配初始字符串：如果{{code|<nowiki>s1 == s2[i1+:*s1]</nowiki>|"icon"}}，产生{{code|i1 + *s1|"icon"}}，否则失败；它设定有缺省值：<code>s2</code>为<code>&subject</code>，如果<code>s2</code>缺省了，<code>i1</code>为<code>&pos</code>，否则为<code>1</code>，<code>i2</code>为<code>0</code>。

==参见==
*[[协程|协程]]

==注解==
{{notelist}}

==引用==
{{reflist|2}}

==参考书目==
* {{cite book
 |title=The Icon Programming Language (third edition)
 |first1=Ralph
 |last1=Griswold
 |first2=Madge
 |last2=Griswold
 |date=2002
 |publisher=Peer-to-Peer Communications
 |isbn=1-57398-001-3
 |url=https://www2.cs.arizona.edu/icon/books.htm
 |access-date=2020-09-19
 |archive-date=2020-11-09
 |archive-url=https://web.archive.org/web/20201109005230/https://www2.cs.arizona.edu/icon/books.htm
 }}
* {{cite journal
 |title=History of the Icon Programming Language
 |first1=Ralph |last1=Griswold
 |first2=Madge |last2=Griswold
 |date=March 1993
 |journal=Communications of the ACM
 |volume=23 |number=3
 |pages=53–68
}}
* {{cite encyclopedia
 |first=Ralph |last=Griswold
 |title=A History of the SNOBOL Programming Languages
 |editor-last=Wexelblat |editor-first=Richard
 |encyclopedia=History of Programming Languages
 |publisher=Academic Press
 |date=1981
}}
* {{cite web
 |first=Ralph
 |last=Griswold
 |title=An Overview of the Icon Programming Language; Version 9
 |date=2 March 1996
 |website=Department of Computer Science, The University of Arizona
 |url=https://www2.cs.arizona.edu/icon/docs/ipd266.htm
 |access-date=2022-02-03
 |archive-date=2022-04-08
 |archive-url=https://web.archive.org/web/20220408170351/https://www2.cs.arizona.edu/icon/docs/ipd266.htm
 }}
* {{cite journal
 |first=Laurence
 |last=Tratt
 |title=Experiences with an Icon-like expression evaluation system
 |doi=10.1145/1869631.1869640
 |date=18 October 2010
 |journal=Proceedings of the 6th symposium on Dynamic Languages
 |pages=73–80
 |url=https://tratt.net/laurie/research/pubs/papers/tratt__experiences_with_an_icon_like_expression_evaluation_system.pdf
 |access-date=2022-02-03
 |archive-date=2021-11-04
 |archive-url=https://web.archive.org/web/20211104200712/https://tratt.net/laurie/research/pubs/papers/tratt__experiences_with_an_icon_like_expression_evaluation_system.pdf
 }}

==外部链接==
{{Wikibooks|en:Icon Programming}}
*[http://www.cs.arizona.edu/icon Icon homepage]{{Wayback|url=http://www.cs.arizona.edu/icon |date=20201108112544 }}
*[http://purl.umn.edu/107698 Oral history interview with Stephen Wampler], Charles Babbage Institute, University of Minnesota. Wampler discusses his work on the development Icon in the late 1970s.
*[http://purl.umn.edu/107329 Oral history interview with Robert Goldberg], Charles Babbage Institute, University of Minnesota. Goldberg discusses his interaction with Griswold when working on Icon in the classroom at [[Illinois_Institute_of_Technology|Illinois Institute of Technology]].
*[http://purl.umn.edu/107697 Oral history interview with Kenneth Walker], Charles Babbage Institute, University of Minnesota. Walker describes the work environment of the Icon project, his interactions with Griswold, and his own work on an Icon compiler.
*[http://rosettacode.org/wiki/Category:Icon The Icon Programming Language page] {{Wayback|url=http://rosettacode.org/wiki/Category:Icon |date=20220430212512 }} on The Rosetta Code comparative programming tasks project site

{{程序设计语言}}
[[Category:动态类型编程语言|Category:动态类型编程语言]]
[[Category:模式匹配编程语言|Category:模式匹配编程语言]]
[[Category:公有领域软件|Category:公有领域软件]]
[[Category:面向文本编程语言|Category:面向文本编程语言]]
[[Category:1977年建立的程式語言|Category:1977年建立的程式語言]]