{{NoteTA
|G1 = IT
}}
{{Infobox programming language
|name = ISWIM
|paradigm = [[指令式编程语言|指令式]], [[函数式编程语言|函数式]]
|year = {{Start date and age|1966}}
|designer = [[Peter_J._Landin|Peter J. Landin]]
|influenced_by = [[ALGOL_60|ALGOL 60]], [[Lisp|Lisp]]
|influenced = [[ML語言|ML]], [[SASL_(编程语言)|SASL]], [[Lucid_(编程语言)|Lucid]]
}}

'''ISWIM'''（如下首字母缩写“'''I'''f you '''S'''ee '''W'''hat '''I''' '''M'''ean”），是的一种抽象的计算机[[编程语言|编程语言]]（或编程语言家族），由[[Peter_J._Landin|Peter J. Landin]]设计，并描述在他1966年于[[ACM通讯|ACM通讯]]发表的文章《The Next 700 Programming Languages》之中<ref>{{Cite journal |last=Landin |first=P. J. |date=March 1966 |title=The Next 700 Programming Languages |url=https://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf |journal=Communications of the ACM |volume=9 |issue=3 |pages=157–165 |publisher=[[Association_for_Computing_Machinery|Association for Computing Machinery]] |doi=10.1145/365230.365257 |s2cid=13409665 |access-date=2021-08-28 |archive-date=2022-03-23 |archive-url=https://web.archive.org/web/20220323111045/https://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf }}</ref>。

尽管没有实现，它被证明为在编程语言开发中非常有影响力的语言，特别是对于[[函数式编程|函数式编程]]语言，比如[[ML语言|ML]]、[[SASL_(编程语言)|SASL]]、[[Miranda_(编程语言)|Miranda]]、[[Haskell|Haskell]]和它们的后继者，还有[[数据流程编程|数据流程编程]]语言如[[Lucid_(编程语言)|Lucid]]。

==设计==
ISWIM具有由加了语法糖的[[λ演算|lambda演算]]构成的函数式核心，它是增加了可变变量和赋值的指令式语言，并具有Landin的强力控制机制{{en-link|J算子|J operator}}，它能够捕获当前的续体（[[Scheme|Scheme]]的{{en-link|call/cc|call-with-current-continuation}}算子是Landin的J算子的简化版本）。因为基于了lambda演算，ISWIM具有[[高阶函数|高阶函数]]和[[词法辖域|词法辖域]]变量。

ISWIM的操作语义，使用Landin的[[SECD抽象机|SECD抽象机]]来定义，并且使用了传值调用，因而是[[及早求值|及早求值]]的<ref>{{Cite report |last=Plotkin |first=Gordon |author-link=Gordon Plotkin |date=1975 |title=Call-by-Name, Call-by Value and the Lambda Calculus |url=http://homepages.inf.ed.ac.uk/gdp/publications/cbn_cbv_lambda.pdf |access-date=2020-04-26 |archive-date=2020-02-01 |archive-url=https://web.archive.org/web/20200201021319/http://homepages.inf.ed.ac.uk/gdp/publications/cbn_cbv_lambda.pdf }}</ref>。ISWIM的目标之一，就是要看起来更像数学表示，所以Landin放弃了[[ALGOL|ALGOL]]的语句间分号，和<code>begin...end</code>块结构，并把它们替代为[[越位规则|越位规则]]，和基于缩进的辖域。

ISWIM在表示法上的特色，是使用了<code>where</code>子句。ISWIM程序是一个单一表达式，它由<code>where</code>子句（包括变量间等式的辅助定义）、条件表达式和函数定义所量化。与[[CPL_(程式语言)|CPL]]一起，ISWIM是最早使用<code>where</code>子句的语言之一。

ISWIM的显著的语义特征，是有能力将新数据类型，定义为（可能递归的）乘积之和。这是使用稍显冗余的自然语言风格描述来完成的，但是除了表示法之外，完全等同于现代函数式语言中{{en-link|代数数据类型|algebraic data type}}。ISWIM变量没有明确的类型声明，尽管在1966年论文中没有明确的说出来，Landin好像希望这个语言是动态类型的，像LISP而不像[[ALGOL|ALGOL]]；但是也有可能他想要开发某种形式的[[类型推论|类型推论]]。

==实现和派生==
没有进行过直接实现ISWIM的尝试，但Arthur Evans的[[PAL_(编程语言)|PAL]]<ref>{{Cite conference |author=Arthur Evans|date=1968 |title=PAL: a language designed for teaching programming linguistics |book-title=Proceedings ACM National Conference |conference=ACM National Conference |publisher=[[Association_for_Computing_Machinery|Association for Computing Machinery]]}}<br />{{cite report|author=A. Evans|title=PAL -- A Reference Manual and a Primer|publisher=Department of Electrical Engineering, Massachusetts Institute of Technology|date=February 1968|url=http://www.softwarepreservation.org/projects/PAL/Pal-ref-man.pdf|access-date=2021-09-09|archive-date=2022-03-06|archive-url=https://web.archive.org/web/20220306011048/http://www.softwarepreservation.org/projects/PAL/Pal-ref-man.pdf}}<br />{{cite report|author=A. Evans|title=Appendix 2.1. The Complete Syntax for PAL|url=http://www.softwarepreservation.org/projects/PAL/PalRefAppendix2.1.pdf|date=February 1968|access-date=2021-09-10|archive-date=2022-03-06|archive-url=https://web.archive.org/web/20220306055913/http://www.softwarepreservation.org/projects/PAL/PalRefAppendix2.1.pdf}}<br />{{cite web|author=J. M. Wozencraft, A. Evans|title=Notes on Programming Linguistics|publisher=M.I.T. Department of Electrical Engineering|year=1971|url=http://www.softwarepreservation.org/projects/PAL/Notes_on_Programming_Linguistics.pdf|access-date=2021-09-11|archive-date=2022-03-06|archive-url=https://web.archive.org/web/20220306010926/http://www.softwarepreservation.org/projects/PAL/Notes_on_Programming_Linguistics.pdf}}</ref>，和{{en-link|John C. Reynolds}}的Gedanken<ref>{{Cite report |last=Reynolds |first=John C. |author-link=John C. Reynolds |date=September 1969 |title=GEDANKEN: a simple typeless language which permits functional data structures and co-routines |url=http://www.softwarepreservation.org/projects/GEDANKEN/Reynolds-GEDANKEN-ANL_7621-1969.pdf |publisher=Argonne National Laboratory |access-date=2021-09-09 |archive-date=2021-09-09 |archive-url=https://web.archive.org/web/20210909031455/http://www.softwarepreservation.org/projects/GEDANKEN/Reynolds-GEDANKEN-ANL_7621-1969.pdf }}</ref>，获取了Landin的多数概念，包括强力的控制转移操作。这两者都是动态类型的。[[Robin_Milner|Milner]]的[[ML语言|ML]]，可以被认为等价于没有J算子，而有类型推论的ISWIM。

从ISWIM衍生出的另一条路线，是去掉指令式特征（赋值和J算子）而留下纯函数式语言<ref>{{Cite journal |last1=Ivanović |first1=Mirjana |last2=Budimac |first2=Zoran |date=April 1993 |title=A definition of an ISWIM-like language via Scheme |journal=ACM SIGPLAN Notices |volume=28 |issue=4|pages=29–38 |doi=10.1145/152739.152743 |s2cid=14379260 }}</ref>。接着就有可能切换到[[惰性求值|惰性求值]]。这条路线导致了[[SASL_(编程语言)|SASL]]、[[肯特递归计算器|KRC]]、[[Hope_(编程语言)|Hope]]、[[Miranda_(编程语言)|Miranda]]、[[Haskell|Haskell]]、[[Clean_(编程语言)|Clean]]。

== 引用 ==
{{reflist|2}}
{{FOLDOC}}

[[Category:学术的编程语言|Category:学术的编程语言]]
[[Category:程序设计语言|Category:程序设计语言]]
[[Category:1966年建立的程式語言|Category:1966年建立的程式語言]]