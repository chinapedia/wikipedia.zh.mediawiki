{{unreferenced|time=2013-05-04T03:52:05+00:00}}
{{NoteTA
|G1 = IT
|G2 = Math
}}
在[[布尔逻辑|布尔逻辑]]的積項和式中(和項積式亦可)，[[规范形式_(布尔代数)|乘积项]]''P'' 是[[布尔函数|布尔函数]] ''F'' 的'''蕴涵项'''（{{lang-en|'''implicant'''}}），如果 ''P'' 蕴涵 ''F''。更加准确的说：

* ''F'' 是 ''n'' 个变量的[[布尔函数|布尔函数]]。
* ''P'' 是乘积项。
* 若对于使 ''P'' 得到值 1 的所有组合，''F'' 也等于 1，則 ''P'' 蕴涵 ''F'' (''P'' 是 ''F'' 的蘊涵項)。

这意味着在布尔空间的自然次序上 P⇒F。比如，函数

:<math>f(x,y,z,w)=xy+yz+w \,</math>

蕴涵自 <math>xy</math>，<math>xyz</math>，<math>xyzw</math>，<math>w</math> 和很多其他的项: 它们是 <math>f</math> 的蕴涵项。

[[威拉德·冯·奥曼·蒯因|威拉德·冯·奥曼·蒯因]]定义：
# ''F'' 的'''素蕴涵项'''（prime implicant）为最少化文字數量的蕴涵项——就是说，如果从 ''P'' 去除任何“文字”（literal）都导致 ''P'' 成為 ''F'' 的非蕴涵项。例如''100''和''101''是某逻辑函数的两个蕴涵项，那么''10x''就是函数的一个素蕴涵项，其中的1和0两个数字不可再去掉；
# '''本质素蕴涵项'''（essential prime implicant）为蘊涵於不满足任何其他素蕴涵项的極小項(minterm)的那些素蕴涵项——若存在只被一個素蘊涵項覆蓋的極小項，則覆蓋該極小項的素蘊涵項為本質素蘊涵項。如果以[[卡诺图|卡诺图]]的形式来描述逻辑函数，可以发现只有一种方式可以圈选这个输入组合。

使用上面的例子，你可以轻易的看到尽管 <math>xy</math>（和其他的项）是素蕴涵项，<math>xyz</math> 和 <math>xyzw</math> 不是。从后者，可以去除多个文字来使它成为素的：

*<math>x</math>、<math>y</math> 和 <math>z</math> 可以去除，生成 <math>w</math>。
*可作为选择的，<math>z</math> 和 <math>w</math> 可以去除，生成 <math>xy</math>。
*最后，<math>x</math> 和 <math>w</math> 可以被去除，生成 <math>yz</math>。

将布尔项中文字去除的过程叫做'对这个项的''扩展'''。扩展一个文字將倍增使这个项为“真”的输入组合的数目(在二元布尔代数中)。 如上例中，将xyz扩展为xy或yz不影响f的结果。

布尔函数的所有素蕴涵项的总和叫做这个函数的'''完全和'''。

==参见==
* [[Quine-McCluskey算法|Quine-McCluskey算法]]
* [[规范形式_(布尔代数)|规范形式 (布尔代数)]]

[[Category:布尔代数|U]]