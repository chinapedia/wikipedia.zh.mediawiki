{{NoteTA
|G1 = IT
}}
{{Infobox Algorithm
|class=[[排序算法|排序算法]]
|image=[[File:Insertion_sort_animation.gif|none]]
|caption= 使用插入排序为一列数字进行排序的过程
|data=[[数组|数组]]
|time=<math>O(n^2)</math>
|best-time=<math>O(n)</math> 
|average-time=<math>O(n^2)</math> 
|space=总共<math>O(n)</math> ，需要辅助空间<math>O(1)</math> 
|optimal=No
}} 
[[File:Insertion-sort-example-300px.gif|thumb]]
'''插入排序'''（{{lang-en|Insertion Sort}}）是一种简单直观的[[排序算法|排序算法]]。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。'''插入排序'''在实现上，通常采用in-place排序（即只需用到<math> O(1) </math>的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

== 記載 ==

最早擁有排序概念的機器出現在1901至1904年間由[[統計學家列表|Hollerith]]發明出使用基數排序法的分類機，此機器系統包括打孔，制表等功能，1908年分類機第一次應用於人口普查，並且在兩年內完成了所有的普查數據和歸檔。
[[統計學家列表|Hollerith]]在1896年創立的分類機公司的前身，為[[IBM|電腦製表記錄公司（CTR）]]。他在電腦製表記錄公司曾擔任顧問工程師，直到1921年退休，而電腦製表記錄公司在1924年正式改名為[[IBM|IBM]]。

== 概述 ==

Insertion Sort 和打撲克牌時，從牌桌上逐一拿起撲克牌，在手上排序的過程相同。

舉例：

Input: {5 2 4 6 1 3}。

首先拿起第一張牌, 手上有 {5}。

拿起第二張牌 2, 把 2 insert 到手上的牌 {5}, 得到 {2 5}。

拿起第三張牌 4, 把 4 insert 到手上的牌 {2 5}, 得到 {2 4 5}。

以此類推。

== 算法 ==
一般来说，'''插入排序'''都采用in-place在数组上实现。具体算法描述如下：
#从第一个元素开始，该元素可以认为已经被排序
#取出下一个元素，在已经排序的元素序列中从后向前扫描
#如果该元素（已排序）大于新元素，将该元素移到下一位置
#重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
#将新元素插入到该位置后
#重复步骤2~5

如果''比较操作''的代价比''交换操作''大的话，可以采用[[二分查找法|二分查找法]]来减少''比较操作''的数目。该算法可以认为是'''插入排序'''的一个变种，称为[[二分查找插入排序|二分查找插入排序]]。

==  範例程式碼 == 
===C语言===
<source lang="c" line="1">
void insertion_sort(int arr[], int len){
        int i,j,key;
        for (i=1;i<len;i++){
                key = arr[i];
                j=i-1;
                while((j>=0) && (arr[j]>key)) {
                        arr[j+1] = arr[j];
                        j--;
                }
                arr[j+1] = key;
        }
}
</source>
<ref>{{Introduction to Algorithms|edition=3|chapter=Section 2.1: Insertion sort|pages=16-18|mode=cs2}}.</ref>

===C++===
<source lang="cpp" line="1">
void insertion_sort(int arr[],int len){
        for(int i=1;i<len;i++){
                int key=arr[i];
                int j=i-1;
                while((j>=0) && (key<arr[j])){
                        arr[j+1]=arr[j];
                        j--;
                }
                arr[j+1]=key;
        }
}
</source>

===C#===
<source lang="Csharp">
public static void InsertSort(int[] array)
{
    for(int i = 1;i < array.length;i++)
    {
        int temp = array[i];
        for(int j = i - 1;j >= 0;j--)
        {
            if(array[j] > temp)
            {
                array[j + 1] = array[j];
                array[j] = temp;
            }
            else
                break;
        }
    }
}
</source>

=== PASCAL===
程式使用[[链表|链表]]（linked list）做插入排序，目的：将讀入的英文名字按字母排列 
<source lang="PASCAL">
TYPE
link=^node;
node=record
      data:string;
      next:link;
     end;
VAR

p,q,head,n:link;
t,m:integer;
f1,f2:text;
i:string;
BEGIN

assign(f1,'lianbiao-name-in.txt');
reset(f1);
assign(f2,'lianbiao-name-out.txt');
rewrite(f2);
head:=nil;
read(f1,t);
readln(f1);
read(f1,i);
new(p);
p^.data:=i;
p^.next:=nil;
head:=p;
readln(f1);
read(f1,i);
FOR m:=2 TO t DO
 BEGIN
  p:=head;
  new(n);
  n^.data:=i;
  while (i>p^.data) and (p^.next<>nil) do
   begin
    q:=p;
    p:=p^.next;
   end;
  if i<head^.data then begin
                        n^.next:=head;
                        head:=n;
                       end
                  else if (i>p^.data) and (p^.next=nil) then begin
                                                              p^.next:=n;
                                                              n^.next:=nil;
                                                             end
                                                        else begin
                                                              q^.next:=n;
                                                              n^.next:=p;
                                                             end;
  readln(f1);
  read(f1,i);
 end;
p:=head;
while p<>nil do
 begin
  write(f2,p^.data,' ');
  p:=p^.next;
 end;
CLOSE(f1);
CLOSE(f2);
END.
</source>

===Python===
<source lang="python">
def insert_sort(lst):
    n=len(lst)
    if n==1: return lst
    for i in range(1,n):
        for j in range(i,0,-1):
            if lst[j]<lst[j-1]: 
                lst[j],lst[j-1]=lst[j-1],lst[j]
            else:
                break
    return lst
</source>

===Python的另一个版本===
<source lang="python">
def insertion_sort(lst):
    for i in range(1, len(lst)):
        temp = lst[i]
        j = i - 1
        while j >= 0 and temp < lst[j]:
            lst[j + 1] = lst[j]
            j -= 1
        lst[j + 1] = temp
    return lst
</source>

===Java===
<source lang = "java">
public void insertionSort(int[] array) {
		for (int i = 1; i < array.length; i++) {
			int key = array[i];
			int j = i - 1;
			while (j >= 0 && array[j] > key) {
				array[j + 1] = array[j];
				j--;
			}
			array[j + 1] = key;
		}
	}
</source>

===Java的另一个版本===
<source lang="java" line="1">
    //将arr[i] 插入到arr[0]...arr[i - 1]中
	public static void insertion_sort(int[] arr) {
		for (int i = 1; i < arr.length; i++ ) {
			int temp = arr[i];
			int j = i - 1;  
    //如果将赋值放到下一行的for循环内, 会导致在第10行出现j未声明的错误
			for (; j >= 0 && arr[j] > temp; j-- ) {
				arr[j + 1] = arr[j];
			}
			arr[j + 1] = temp;
		}
	}
</source>

===JavaScript===
<source lang="javascript" line="1">
Array.prototype.insertion_sort = function() 
{
  var i,j;
  for(i = 1;i < this.length; i++){
    for(j = 0;j<i;j++){
      if(this[j]>this[i]){
        this.splice(j,0,this[i]);
        this.splice(i+1,1);
        break;
      }
    }
  }
  return this;
};
</source>
用法示例：[3,5,2,11,1,2,"abc","zfd","sad","eng"].insertion_sort();

===PHP===
<source lang="php">
function insertion_sort(&$arr) 
{
    //php的陣列視為基本型別，所以必須用傳參考才能修改原陣列
    for ($i = 1; $i < count($arr); $i++) 
    {
        if ($arr[$i-1] > $arr[$i]) {
            $temp = $arr[$i];
            for ($j = $i - 1; $j >= 0 && $arr[$j] > $temp; $j--)
                $arr[$j + 1] = $arr[$j];
            $arr[$j + 1] = $temp;
        }
    }
}
</source>

===Rust===
<source lang="rust">
fn insert_sort<T>(list: &mut Vec<T>)
    where T: PartialOrd + Copy{

    let mut i = 0;
    while i < list.len()-1 {

        let mut j = i + 1;
        while j > 0 {
            if list[j] > list[j-1] {break;}

            let temp = list[j-1];
            list[j-1] = list[j];
            list[j] = temp;

            j -= 1;
        }

        i += 1;
    }
}
</source>
用法示例：
let mut a: Vec<i32> = vec![5,8,3,9,1,0];
insert_sort(&mut a);

===Go===
<source lang="Go">
package main

import (
	"fmt"
)

func InsertSort(array []int) {
	n := len(array)
	if n < 2 {
		return
	}
	for i := 1; i < n; i++ {
		for j := i - 1; j >= 0; j-- {
			if array[j] > array[j+1] {
				array[j], array[j+1] = array[j+1],array[j]
			}else{
				break
			}
		}
	}
}

func main() {
	array := []int{
		55, 94, 87, 1, 4, 32, 11, 77, 39, 42, 64, 53, 70, 12, 9,
	}
	fmt.Println(array)
	InsertSort(array)
	fmt.Println(array)

}
</source>

=== Swift ===
<syntaxhighlight lang="swift">
//Swift 5.0
func insertionSort(_ arr:[Int]) -> [Int] {
    if arr.count<=1 {return arr}
    var sortedArr = arr
    var tempInt:Int
    for i in 0..<arr.count {
        tempInt = sortedArr[i]
        for j in stride(from: i, to: -1, by: -1){
            if tempInt < sortedArr[j]{
                sortedArr.remove(at: j + 1)
                sortedArr.insert(tempInt, at: j)
            }
        }
    }
    return sortedArr
}
let array = [55, 94, 87, 1, 4, 32, 11, 77, 39, 42, 64, 53, 70, 12, 9]
print(array)
print(insertionSort(array))
</syntaxhighlight>

== 算法复杂度== 
如果目标是把n个元素的序列升序排列，那么采用'''插入排序'''存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需<math> n-1 </math>次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有<math>\frac12n(n-1)</math>次。'''插入排序'''的赋值操作是比较操作的次数减去<math> n-1 </math>次，（因为<math> n-1 </math>次循环中，每一次循环的比较都比赋值多一个，多在最后那一次比较并不带来赋值）。平均来说'''插入排序'''算法复杂度为<math> O(n^2) </math>。因而，'''插入排序'''不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知輸入元素大致上按照順序排列，那么'''插入排序'''还是一个不错的选择。
插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。

== 参考文献 ==
{{reflist}}

== 延伸閱讀 ==
*[97严]  [[严蔚敏|严蔚敏]]，[[吴伟民|吴伟民]]，《数据结构C语言版》，[[清华大学出版社|清华大学出版社]]，1997年4月
*[99殷]  [[殷人昆|殷人昆]]，[[陶永雷|陶永雷]]，[[谢若阳|谢若阳]]，[[盛绪华|盛绪华]]，《数据结构（用面向对象方法与C++描述）》，[[清华大学出版社|清华大学出版社]]，1999年7月

{{排序算法表}}
{{算法}}

[[Category:排序算法|Category:排序算法]]

[[no:Sorteringsalgoritme#Innstikksortering|no:Sorteringsalgoritme#Innstikksortering]]