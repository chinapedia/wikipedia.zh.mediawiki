{{otheruse|subject=GNU编译器套裝|other=國際組織|海湾阿拉伯国家合作委员会}}
{{noteTA
|G1 = IT
|G2 = FL
|1 = zh-hans:调试; zh-tw:除錯;
}}
{{Infobox_Software
|name = GNU编译器套裝
|screenshot = GCC 11.1.0 compiling Chicken screenshot.png
|logo = GNU Compiler Collection logo.svg
|logo size = 100px
|developer = [[GNU計劃|GNU計劃]]
|released={{Start date|1987|5|23}}
|latest_release_version = {{LSR/wikidata}}
|latest_release_date = 
|programming language = [[C++|C++]]
|operating_system = [[跨平台|跨平台]]
|genre = [[编译器|编译器]]
|license= [[GNU通用公共许可证|GNU通用公共许可证]]第三版或更新
|website = {{URL|https://gcc.gnu.org}}
}}

'''GNU编译器套裝'''（{{lang-en|'''GNU Compiler Collection'''}}，縮寫為'''GCC'''），指一套[[编程語言|编程語言]][[编译器|编译器]]，以[[GPL|GPL]]及[[LGPL|LGPL]]許可證所發行的[[自由軟體|自由軟體]]，也是[[GNU計畫|GNU計劃]]的关键部分，也是[[GNU工具链|GNU工具链]]的主要組成部份之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。1985年由[[理查德·马修·斯托曼|理查德·马修·斯托曼]]開始發展，現在由[[自由軟體基金會|自由軟體基金會]]負責維護工作。

原名為'''GNU C語言編譯器'''（{{lang|en|'''GNU C Compiler'''}}），因為它原本只能處理[[C語言|C語言]]。GCC在发布后很快地得到擴展，變得可處理[[C++|C++]]。之後也變得可處理[[Fortran|Fortran]]、[[Pascal_(程式語言)|Pascal]]、[[Objective-C|Objective-C]]、[[Java|Java]]、[[Ada|Ada]]，[[Go|Go]]與其他語言。

許多操作系统，包括許多[[类Unix|类Unix]]系統，如[[Linux|Linux]]及BSD家族都採用GCC作為标准编译器。

GCC原本用C開發，後來因為[[LLVM|LLVM]]、[[Clang|Clang]]的崛起，它更快地將開發語言轉換為C++。許多C的愛好者在對C++一知半解的情況下主觀認定C++的性能一定會輸給C，但是Ian Lance Taylor給出了不同的意見，並表明C++不但性能不輸給C，而且能設計出更好，更容易維護的程式<ref>{{Cite web |url=https://lwn.net/Articles/542457/ |title=GCC's move to C++ |accessdate=2013-05-01 |archive-date=2013-06-14 |archive-url=https://web.archive.org/web/20130614184259/http://lwn.net/Articles/542457/ |dead-url=no }}</ref><ref>{{Cite web |url=http://airs.com/ian/cxx-slides.pdf |title=Taylor的演讲簡報 |accessdate=2018-05-19 |archive-date=2018-07-01 |archive-url=https://web.archive.org/web/20180701164437/https://airs.com/ian/cxx-slides.pdf |dead-url=no }}</ref>。

== 概觀 ==
GCC是由[[理查德·马修·斯托曼|理查德·马修·斯托曼]]在1985年開始的。他首先擴增一個舊有的編譯器，使它能編譯C，這個編譯器一開始是以[[Pastel|Pastel]]語言所寫的。Pastel是一個不可移植的[[Pascal_(程式語言)|Pascal]]語言特殊版，這個編譯器也只能編譯Pastel語言。為了讓[[自由軟體|自由軟體]]有一個編譯器，後來此編譯器由斯托曼和[[Leonard_H._Tower_Jr.|Len Tower]]在1987年<ref>Tower, Leonard (1987) "[http://groups.google.com/group/comp.lang.misc/msg/32eda22392c20f98 GNU C編譯器beta測試版釋出] {{Wayback|url=http://groups.google.com/group/comp.lang.misc/msg/32eda22392c20f98 |date=20111105110418 }}" ''comp.lang.misc'' USENET新聞群組；參閱http://gcc.gnu.org/releases.html#timeline {{Wayback|url=http://gcc.gnu.org/releases.html#timeline |date=20061228101239 }}</ref>以C語言重寫<ref>{{cite journal | last = Stallman | first = Richard M. | title = GNU狀態 | journal = GNU的公告版 | volume = 1 | issue = 1 | publisher = 自由軟體基金會 | date = February 1986 | url = http://web.cecs.pdx.edu/~trent/gnu/bull/01/bull01.txt | access-date = 2006-12-27 | archive-date = 2007-08-21 | archive-url = https://web.archive.org/web/20070821202202/http://web.cecs.pdx.edu/~trent/gnu/bull/01/bull01.txt | dead-url = no }}</ref>並成為GNU專案的編譯器。GCC的建立者由[[自由軟體基金會|自由軟體基金會]]直接管理<ref>Stallman, Richard M. (2001) "[http://gcc.gnu.org/onlinedocs/gcc-2.95.3/gcc_23.html#SEC260 GCC貢獻者名單] {{Wayback|url=http://gcc.gnu.org/onlinedocs/gcc-2.95.3/gcc_23.html#SEC260 |date=20070103120959 }}"於[http://gcc.gnu.org/onlinedocs/gcc-2.95.3/gcc.html#SEC_Top ''使用及移植GCC 2.95版''] {{Wayback|url=http://gcc.gnu.org/onlinedocs/gcc-2.95.3/gcc.html#SEC_Top |date=20061227005125 }}（Cambridge, Mass.: Free Software Foundation）</ref>。

在1997年，一群不滿GCC緩慢且封閉的創作環境者，組織了一個名為[[EGCS|EGCS]]（Experimental/Enhanced GNU Compiler System）的專案，此專案彙整了數項實驗性的分支進入某個GCC專案的分支中。EGCS比起GCC的建構環境更有活力，且EGCS最終也在1999年四月成為GCC的官方版本。

GCC目前由世界各地不同的數個程式設計師小組維護。它是移植到最多[[CPU|中央處理器]]架構以及最多[[操作系统|操作系统]]的編譯器。

由於GCC已成為GNU系統的官方編譯器（包括[[Linux|GNU/Linux]]家族），在LLVM、Clang崛起之前，它也是編譯與建立其他作業系統的主要編譯器，包括[[BSD|BSD]]家族、[[Mac_OS_X|Mac OS X]]、[[NeXTSTEP|NeXTSTEP]]與[[BeOS|BeOS]]等。

GCC通常是跨平台軟體的編譯器首選。有別於一般侷限於特定系統與執行環境的編譯器，GCC在所有平台上都使用同一個前端處理程式，產生一樣的中介碼，因此此中介碼在各個其他平台上使用GCC編譯，有很大的機會可得到正確無誤的輸出程式。

== 目前支持的语言 ==
以2011年10月26日釋出的4.6.2版為準，本編譯器版本可處理下列語言：

{{col-begin}}
{{col-break}}
* [[Ada|Ada]]（[[GNAT|GNAT]]）
* [[C语言|C]]（GCC，带 GNU 拓展）
* [[C++|C++]]（[[G++|G++]]，带 GNU 拓展）
* [[Fortran|Fortran]]（[[Fortran#FORTRAN_77|Fortran 77]]: [[G77|G77]]，[[Fortran#Fortran_90|Fortran 90]]: [[GFORTRAN|GFORTRAN]]）
{{col-break}}
* [[Java|Java]]（编译器：[[GCJ|GCJ]]；解释器：{{link-en|GIJ|GNU Interpreter for Java}}）
* [[Objective-C|Objective-C]]（[[GOBJC|GOBJC]]）
* [[Objective-C#Objective-C++|Objective-C++]]
* [[Go|Go]]
{{col-break}}
{{col-end}}

先前版本納入的{{link-en|CHILL|CHILL}}前端由於缺乏維護而被廢棄。

Fortran前端在4.0版之前是G77，此前端僅支援Fortran 77。在本版本中，G77被廢棄而採用更新的[[GFortran|GFortran]]，因為此前端支援[[Fortran#Fortran_95|Fortran 95]]。

下列前端依然存在：

{{col-begin}}
{{col-break}}
* [[Modula-2|Modula-2]]
* [[Modula-3|Modula-3]]
* [[Pascal_(程式語言)|Pascal]]
* [[PL/I|PL/I]]
{{col-break}}
* [[D語言|D語言]]
* [[Mercury|Mercury]]
* [[VHDL|VHDL]]
{{col-break}}
{{col-end}}

=== 内嵌OpenMP支持 ===
[[OpenMP|OpenMP]]是一种跨语言的[[对称多处理机|对称多处理机]]多[[线程|线程]][[平行計算|并行]]程序的编程工具，也非常适合当今越来越流行的单CPU多核硬件环境，因此从gcc4.2开始，OpenMP成为其内嵌支持的并行编程规范，可以直接编译内嵌OpenMP语句的C/C++/Fortran95的源代码。gcc4.2之前如果想在C/C++/Fortran中嵌入OpenMP语句的话，需要额外安装库和预处理器才能识别和正确处理这些语句。现在 GCC GOMP 计划实现了这些支持<ref>{{Cite web |url=http://gcc.gnu.org/projects/gomp/ |title=GOMP计划 |accessdate=2009-04-24 |archive-date=2009-04-10 |archive-url=https://web.archive.org/web/20090410022756/http://gcc.gnu.org/projects/gomp/ |dead-url=no }}</ref>：

* gcc 4.2.0开始支持OpenMP v2.5
* gcc 4.4.0开始支持OpenMP v3.0
* gcc 4.9.1开始支持OpenMP v4.0

== 支援的處理器架構 ==
GCC目前支援下列處理器架構（以4.1版為準）：

{{col-begin}}
{{col-break}}
* [[DEC_Alpha|Alpha]]
* [[ARM_architecture|ARM]]
* [[Atmel_AVR|Atmel AVR]]
* [[Blackfin|Blackfin]]
* [[Hitachi_H8|H8/300]]
* [[IA-32|IA-32]]（[[x86|x86]]）與[[x86-64|x86-64]]
* [[IA-64|IA-64]]例如：[[Itanium|Itanium]]
{{col-break}}
* [[MorphoSys|MorphoSys]]家族
* [[Motorola_68000|Motorola 68000]]
* [[Motorola_88000|Motorola 88000]]
* [[MIPS架構|MIPS]]與[[龍芯|龍芯]]
* [[PA-RISC|PA-RISC]]
* [[PDP-11|PDP-11]]
* [[PowerPC|PowerPC]]
{{col-break}}
* [[System/370|System/370]]，[[zSeries|System/390]]
* [[SuperH|SuperH]]
* [[HC12|HC12]]
* [[SPARC|SPARC]]
* [[VAX|VAX]]
* [[Renesas|Renesas]] [[R8C|R8C]]／[[M16C|M16C]]／[[M32C|M32C]]家族
{{col-break}}
{{col-end}}

較不知名的處理器架構也在官方釋出版本中支援：
{{col-begin}}
{{col-break}}
* [[AMD_Am29000|A29K]]
* [[Advanced_Risc_Computing|ARC]]
* [[C4x|C4x]]
* [[CRIS|CRIS]]
* [[D30V|D30V]]
* [[DSP16xx|DSP16xx]]
* [[FR-30|FR-30]]
* [[FR-V|FR-V]]
{{col-break}}
* [[Intel_i960|Intel i960]]
* [[IP2000|IP2000]]
* [[M32R|M32R]]
* [[Freescale_68HC11|68HC11]]
* [[MCORE|MCORE]]
* [[MMIX|MMIX]]
{{col-break}}
* [[MN10200|MN10200]]
* [[MN10300|MN10300]]
* [[NS320xx|NS32K]]
* [[ROMP|ROMP]]
* [[Stormy16|Stormy16]]
* [[V850|V850]]
* [[Xtensa|Xtensa]]
{{col-break}}
{{col-end}}

由FSF個別維護的GCC處理器架構：
{{col-begin}}
{{col-break}}
* [[D10V|D10V]]
* [[MicroBlaze|MicroBlaze]]
{{col-break}}
* [[PDP-10|PDP-10]]
* [[TI_MSP430|MSP430]]
{{col-break}}
* [[Zilog_Z8000|Z8000]]
* [[NEC|NEC]] SX-9 [[並行向量處理機|並行向量處理機]]<ref>{{Cite web |url=http://code.google.com/p/sx-gcc/ |title=sx-gcc - port gcc to nec sx vector cpu - Google Project Hosting |accessdate=2011-03-21 |archive-date=2011-05-25 |archive-url=https://web.archive.org/web/20110525154258/http://code.google.com/p/sx-gcc/ |dead-url=no }}</ref>
{{col-end}}

當GCC需要移植到一個新平台上，通常使用此平台固有的語言來撰寫其'''初始階段'''。

== 結構 ==
GCC的外部介面長得像一個標準的[[Unix|Unix]][[編譯器|編譯器]]。使用者在命令列下鍵入<code>gcc</code>命令，以及一些命令參數，以便決定每個輸入檔案使用的個別語言[[編譯器|編譯器]]，並為輸出程式碼使用適合此硬體平台的[[組合語言|組合語言編譯器]]，並且選擇性地執行[[連結器|連結器]]以製造可執行的程式。

每個語言[[編譯器|編譯器]]都是獨立程式，此程式可處理輸入的原始碼，並輸出組合語言碼。全部的語言[[編譯器|編譯器]]都擁有共通的中介架構：一個前端[[構文解析|解析]]符合此語言的原始碼，並產生一[[抽象語法樹|抽象語法樹]]，以及一翻譯此語法樹成為GCC的[[暫存器轉換語言|暫存器轉換語言]]的後端。[[編譯器最佳化|編譯器最佳化]]與[[靜態程式碼解析|靜態程式碼解析]]技術（例如FORTIFY_SOURCE[http://fedoraproject.org/wiki/Security/Features]{{Wayback|url=http://fedoraproject.org/wiki/Security/Features |date=20070107153447 }}，一個試圖發現[[緩衝區溢位|緩衝區溢位]]的[[編譯器|編譯器]]）在此階段應用於程式碼上。最後，適用於此硬體架構的組合語言程式碼以{{tsl|en|Jack Davidson|傑克·戴維森}}與{{tsl|en|Chris Fraser|克里斯·弗雷澤}}發明的演算法產出。

幾乎全部的GCC都由C/C++寫成，除了[[Ada|Ada]]前端大部分以[[Ada|Ada]]寫成。

=== 前端介面 ===
前端的功能在於產生一個可讓後端處理之語法樹。此語法解析器是手寫之遞迴語法解析器。

直到最近，程式的語法樹結構尚無法與欲產出的處理器架構脫鉤。而語法樹的規則有時在不同的語言前端也不一樣，有些前端會提供它們特別的語法樹規則。

在2005年，兩種與語言脫鉤的新型態語法樹納入GCC中。它們稱為[[GENERIC|GENERIC]]與[[GIMPLE|GIMPLE]]。語法解析變成產生與語言相關的暫時語法樹，再將它們轉成GENERIC。之後再使用「gimplifier」技術降低GENERIC的複雜結構，成為一較簡單的[[静态单赋值形式|静态单赋值形式]]（Static Single Assignment form，SSA）基礎的GIMPLE形式。此形式是一個與語言和處理器架構脫鉤的全域最佳化通用語言，適用於大多數的現代程式語言。

=== 中介介面 ===
一般[[編譯器|編譯器]]作者會將語法樹的最佳化放在前端，但其實此步驟並不看語言的種類而有不同，且不需要用到語法解析器。因此GCC作者們將此步驟歸入通稱為'''中介階段'''的部分裡。此類的最佳化包括[[消解死碼|消解死碼]]、[[消解重複運算|消解重複運算]]與[[全域數值重編碼|全域數值重編碼]]等。許多最佳化技巧也正在實作中。

=== 後端介面 ===
GCC後端的行為因不同的[[前處理器巨集|前處理器巨集]]和特定架構的功能而不同，例如不同的[[字元尺寸|字元尺寸]]、[[呼叫方式|呼叫方式]]與大小[[尾序|尾序]]等。後端介面的前半部利用這些訊息決定其RTL的生成形式，因此雖然GCC的RTL理論上不受處理器影響，但在此階段其抽象指令已被轉換成目標架構的格式。

GCC的最佳化技巧依其釋出版本而有很大不同，但都包含了標準的最佳化演算法，例如[[迴圈最佳化|迴圈最佳化]]、[[執行緒跳躍|執行緒跳躍]]、[[共通程式子句消減|共通程式子句消減]]、[[指令排程|指令排程]]等等。而RTL的最佳化由於可用的情形較少，且缺乏較高階的資訊，因此比較起近來增加的GIMPLE語法樹形式[https://web.archive.org/web/20070106234009/http://people.redhat.com/dnovillo/pub/tree-ssa/doc/html/]，便顯得比較不重要。

後端經由一'''重讀取'''步驟後，利用描述目標處理器的[[指令集|指令集]]時所取得的資訊，將抽象暫存器替換成處理器的真實暫存器。此階段非常複雜，因為它必須關照所有GCC可移植平台的處理器指令集的規格與技術細節。

後端的最後步驟相當公式化，僅僅將前一階段得到的組合語言碼藉由簡單的副函式轉換其暫存器與記憶體位置成相對應的機械碼。

== 替GCC程式除錯 ==
[[GNU除錯器|GNU除錯器]]是一個為GCC除錯的程式。其他特殊用途的除錯工具是[[Valgrind|Valgrind]]，用以發現[[内存泄漏|内存泄漏]]（memory leak）。而[[GNU測量器|GNU測量器]]（gprof）可以得知程式中某些函式花費多少時間，以及其呼叫頻率；此功能需要使用者在編譯時選定'''測量'''（profiling）選項。

== GCC内嵌汇编 ==
内嵌汇编也称行内汇编，是把汇编语言代码块插在C语言语句之间。详情参见[http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html GCC-Inline-Assembly-HOWTO.html]{{Wayback|url=http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html |date=20140125221231 }}

== 参考文献 ==
=== 引用 ===
{{Reflist|2}}

=== 来源 ===
* [[Richard_Stallman|Richard M. Stallman]]：''[http://gcc.gnu.org/onlinedocs/gcc-2.95.3/gcc.html Using and Porting the GNU Compiler Collection]{{Wayback|url=http://gcc.gnu.org/onlinedocs/gcc-2.95.3/gcc.html |date=20061227005125 }}'', [[Free_Software_Foundation|Free Software Foundation]]，ISBN 0-595-10035-X
* Richard M. Stallman: ''[http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/ Using Gcc: The Gnu Compiler Collection Reference]{{Wayback|url=http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/ |date=20061222151630 }}'', Free Software Foundation, ISBN 1-882114-39-6
* [[Brian_J._Gough|Brian J. Gough]]：''[https://archive.is/20121205072412/http://www.network-theory.co.uk/gcc/intro/ An Introduction to GCC]'', Network Theory Ltd., ISBN 0-9541617-9-3

== 更多閱讀 ==
* Arthur Griffith, ''GCC: The Complete Reference''. McGrawHill/Osborne. ISBN 0-07-222405-3.
* {{cite news
 | date = April 22, 2005
 | title = Open Source GCC 4.0: Older, Faster
 | publisher = internetnews.com
 | author = Kerner, Sean Michael
 | url = http://www.internetnews.com/dev-news/article.php/3499881
 | accessdate = 2006-12-27
 | archive-date = 2006-09-17
 | archive-url = https://web.archive.org/web/20060917233745/http://www.internetnews.com/dev-news/article.php/3499881
 | dead-url = no
 }}
* {{cite news
 | date = March 2, 2006
 | title = New GCC Heavy on Optimization
 | publisher = internetnews.com
 | author = Kerner, Sean Michael
 | url = http://www.internetnews.com/dev-news/article.php/3588926
 | accessdate = 2006-12-27
 | archive-date = 2006-10-22
 | archive-url = https://web.archive.org/web/20061022205331/http://www.internetnews.com/dev-news/article.php/3588926
 | dead-url = no
 }}

== 外部链接 ==
* [http://gcc.gnu.org GCC官方网站]{{Wayback|url=http://gcc.gnu.org/ |date=20120111104818 }}
* {{Youtube |id = o1tlfhrkrYQ |title = 淺談GCC編譯技術Break Compilation Boundaries with GCC}}
* [https://web.archive.org/web/20051024122753/http://www.nabble.com/gcc-f1154.html GCC Forum]- 由[http://www.nabble.com Nabble]{{Wayback|url=http://www.nabble.com/gcc-f1154.html |date=20051024122753 }}維持，整理所有gcc通訊討論串，並整合入一個可搜尋介面中。

== 参见 ==
{{Portal box|自由軟體}}
* GCC目前包含了[[贝姆垃圾收集器|贝姆垃圾收集器]]，一個為C/C++所設計的[[垃圾回收_(計算機科學)|垃圾回收器]]。
* [[distcc|distcc]] - 為分散式編譯所設計的軟體，以GCC為協同軟體。
* [[ccache|ccache]] - 用于缓存编译的中间结果，加快重新编译的速度。
* [[LLVM|LLVM]] - 低層虛擬機器編譯器架構，其中的 clang (Obj-)C(++) 编译器实现了大部分 GNU C 拓展。
* [[MinGW|MinGW]] - 將GNU開發工具移植到Win32平臺下的計畫
* [[Cygwin|Cygwin]] - 在 Windows 上執行 Unix 程式的模擬軟體。
* [[GCC_Summit|GCC Summit]]
* [[Watcom|OpenWatcom]] - 另一個開放原碼的C++/Fortran編譯器。
* [[Code_Sourcery|Code Sourcery]] - 一個GCC顧問公司。
* [[ggcc|ggcc]] - 全球化GCC專案。

{{-}}
{{GNU}}

[[Category:编译器软件|Category:编译器软件]]
[[Category:GNU計劃軟體|Category:GNU計劃軟體]]
[[Category:C編譯器|Category:C編譯器]]