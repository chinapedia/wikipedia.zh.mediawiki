{{Lead too short}}
{{Copyedit}}
'''计算机编码'''指[[电脑|电脑]]内部代表文字、符號、字母或数字的方式。電子計算機的文數字編碼，是指在計算機硬件軟件中對於文字或數值的內部表示。通常數值會儲存為位元組，而以組成它們的位元數給以名稱。選擇數值和位元模式之間的編碼，可以使計算機的操作便利；計算機處理器指令集所使用的位元編碼，通常需要將其格式再轉換以供外界的使用者來判讀，例如打印和顯示。對於紙筆書寫看似相同的文字符號或數值，在不同類型的電子計算機處理器內部中，可能有不同的約定用於整數和實數。大多數計算都是使用適合處理器暫存器的數碼格式來執行，但是某些軟件系統允許使用多種儲存方式，來表示任意大數。

== 位元、字节、字組位元和無號整數 ==

计算机的基本储存单位是“[[位元|位元]]”，通过开关变化设置表达值0或1。在有两个位元的情况下可以得到四个不同的状态：

   00   01   10   11

如果有三个位，则有八种状态：

   000   001   010   011   100   101   110   111

每当增加一个位时，将得到两倍的状态。

计算机使用不同数量的位元储存不同种类的信息。4个位元被称为一“nybble”，8个被称为一[[字节|字节]]，也有16，32，或更多位元组成的信息计量单位。

一个nybble可以为16种不同的情况编码，例如数字0到15。大体上，使用任何序列的排列来表示不同的16种状态是可以的，但在实际的应用通常是这样的：

        0000 = 十进制0           1000 = 十进制8
   0001 = 十进制1           1001 = 十进制9
   0010 = 十进制2           1010 = 十进制10
   0011 = 十进制3           1011 = 十进制11
   0100 = 十进制4           1100 = 十进制12
   0101 = 十进制5           1101 = 十进制13
   0110 = 十进制6           1110 = 十进制14
   0111 = 十进制7           1111 = 十进制15

这样的表示是很自然的，因为它符合我们所熟悉的[[十进制|十进制]]数表示方法。例如，给定一个十进制数：

: 7531

我们很自然地把它理解为：

: 7 × 1000 + 5 × 100 + 3 × 10 + 1 × 1

或者，使用10的[[幂|幂]]来表示：

: 7 × 10<sup>3</sup> + 5 × 10<sup>2</sup> + 3 × 10<sup>1</sup> + 1 × 10<sup>0</sup>

注意任何数（除了0）的0次幂都是1。

数据中的每个数字表示从0到9的值，这样我们有10个不同的数字，那就是我们把它称为“十进制”的原因。每个数字可以通过10的某次幂来决定它的位置。这听起来很复杂，但实际上并不是这样的。这正是当您读一个数字的使用认为是理所当然的事情，您甚至都不用仔细思考它。

类似地，使用[[二进制|二进制]]编码就像上面所说的那样，值13是这样编码的：

: 1101

每一个位置有两个数字可以选择，所以我们称它为“二进制”。因此，它们的位置是这样决定的：

: 1101 =
: 1 × 2<sup>3</sup> + 1 × 2<sup>2</sup> + 0 × 2<sup>1</sup> + 1 × 2<sup>0</sup> =
: 1 × 8 + 1 × 4 + 0 × 2 + 1 × 1 = 13（十进制）

注意这里使用了2的幂：1、2、4和8。痴迷于计算机的人通常可以记住2的从2到16次幂，这并不是因为他们的记忆力，而是因为他们大量的使用这些数字：

   2<sup>0</sup>  =   1        2<sup>8 </sup> =    256
   2<sup>1</sup>  =   2        2<sup>9 </sup> =    512
   2<sup>2</sup>  =   4        2<sup>10</sup> =  1,024
   2<sup>3</sup>  =   8        2<sup>11</sup> =  2,048
   2<sup>4</sup>  =  16        2<sup>12</sup> =  4,096
   2<sup>5</sup>  =  32        2<sup>13</sup> =  8,192
   2<sup>6</sup>  =  64        2<sup>14</sup> = 16,384
   2<sup>7</sup>  = 128        2<sup>15</sup> = 32,768
                2<sup>16</sup> = 65,536

注意的是，根据公制单位，值2<sup>10</sup> = 1,024通常被提及为“kilo”（千），或简写成“K”，所以很多2的高次幂通常可以简写成：



   2<sup>11</sup> =  2 K =  2,048
   2<sup>12</sup> =  4 K =  4,096
   2<sup>13</sup> =  8 K =  8,192
   2<sup>14</sup> = 16 K = 16,384
   2<sup>15</sup> = 32 K = 32,768
   2<sup>16</sup> = 64 K = 65,536 

同样的，值2<sup>20</sup> = 1,024 x 1,024 = 1,048,576通常被简写成“M”(即兆)：

   2<sup>21</sup> = 2 M
   2<sup>22</sup> = 4 M

而2<sup>30</sup>曾被称为“吉”，或“G”。下面我们将会大量使用这些修饰符号。

有一个很微妙的话题。如果我们使用16位，我们可以得到65,536种不同的值，但是这些值是从0到65,535的。人们通常从1开始数数，但是计算机是从0开始计数的。因为这对它们来说更简便。这个小问题有时也会使得计算机混淆。

现在，我们得到了计算位的方法：
* 您只能在您所有的位的范围内进行算术操作。也即是说，如果您正在使用的是16位，那您不能对65,535或更大的数据进行操作，否则您将得到一个“数据溢出”的错误。这个术语表明，您正在进行的是“有限精度”的操作。
* 使用这种编码不能表示小数。您只能使用非小数的“整数”。
* 使用这种编码不能表示负数。所有的数字都是“无符号数”。

虽然有这种限制，但是在计算机中对于简单的增1计数来说，“无符号整数”还是十分有用的。它们对计算机来说是很容易处理的。通常计算机使用16位或32位无符号整数，通常被称为“整数（integer）”或“长整数（long integer）”。一个整数允许对从0到65,535的数据进行操作，而一个长整型允许对从0到4,294,967,295的数进行操作。

== 八进制和十六进制数 ==

现在让我们讨论一些偏外的话题：对二进制数字的表示方法。计算机通常使用二进制来表达数据，但是在实际中如果使用像这样的二进制：

: 1001 0011 0101 0001

那将是一件痛苦的事，并且很容易出错。通常计算机使用一个基于二进制的表达方式：[[八进制|八进制]]，或更通常使用的，[[十六进制|十六进制]]。

这一件听起来挺狡猾但实际上又很简单的事。如果不是这样的话，我们就不会这样使用了。在平常的十进制体系中，我们有10数字（0到9）按以下方式构成排列：

: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ...

在八进制中，我们只有八个数字（0到7）按以下方式构成排列：

: 0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 ...

也即是说，八进制的“10”相当于十进制的“8”，八进制的“20”相当于十进制的“16”，以此类推。

在十六进制中，我们只有十六个数字（0到9，然后是从a到f）按以下方式构成排列：

: 0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 13 14 15 16 ...

也即是说，十六进制的“10”相当于十进制的“16”，十六进制的“20”相当于十进制的“32”。

这些表示数值的方法都是表位置的系统，但是它们使用的不是像十进制那样的10，而是分别使用8和16。例如：

: 八进制756
: = 7 × 8<sup>2</sup> + 5 × 8<sup>1</sup> + 6 × 8<sup>0</sup> 
: = 7 × 64 + 5 × 8 + 6 × 1 
: = 448 + 40 + 6 = 十进制494

: 十六进制3b2
: = 3 × 16<sup>2</sup> + 11 × 16<sup>1</sup> + 2 × 16<sup>0</sup>
: = 3 × 256 + 11 × 16 + 2 × 1
: = 768 + 176 + 2 = 十进制946

好了，如果您还不是那么明白，不用担心。我们想说明的是，对于八进制来说，他们刚好和3位二进制有一个完美的对应关系：

: 000 = 八进制0
: 001 = 八进制1
: 010 = 八进制2
: 011 = 八进制3
: 100 = 八进制4
: 101 = 八进制5
: 110 = 八进制6
: 111 = 八进制7

类似的，一个十六进制数刚好和一个4位的二进制数对应。

   0000 = 十六进制0       1000 = 十六进制8
   0001 = 十六进制1       1001 = 十六进制9
   0010 = 十六进制2       1010 = 十六进制a
   0011 = 十六进制3       1011 = 十六进制b
   0100 = 十六进制4       1100 = 十六进制c
   0101 = 十六进制5       1101 = 十六进制d
   0110 = 十六进制6       1110 = 十六进制e
   0111 = 十六进制7       1111 = 十六进制f

因此，把一个很长的二进制数转换成一个八进制就变得很简便，例如：把二进制1001001101010001转化成八进制：

   1 001 001 101 010 001 二进制 = 111521 八进制

转换成十六进制会更简单：

   1001 0011 0101 0001 = 9351 十六进制

但是要把它转换成十进制（37,713）就比较麻烦了。八进制和十六进制使得转换二进制机器级的数字变得简单方便。

== 有符号整数和补码 ==

在定义了无符号二进制数后，我们就要着手定义[[负数|负数]]了，或称为“有符号整数”。最简单的一个方法是保留一个位来表示数值的符号。这个“符号位”可以位于数值的最左边，当然也可以位于数值的最右边。如果这个符号位为0，表示数值是正的，如果这个符号位为1，表示数值是负的。


这样做是可以的，虽然从人类的角度来看是最明显的解决方案，但是它对于计算机来说有可能带来一些难度。例如，这种编码使得0可以有正负两种。人们可能对此感到不可思议，但是这对计算机来说是适应的。

对计算机来说，更自然的表达方式是对给定的位数的二进制数按其范围分成两半，其中前一半用来表示负数。例如，在4位数值中，你可以得到：

   0000 = 十进制0
   0001 = 十进制1
   0010 = 十进制2
   0011 = 十进制3
   0100 = 十进制4
   0101 = 十进制5
   0110 = 十进制6
   0111 = 十进制7
   1000 = 十进制-8
   1001 = 十进制-7
   1010 = 十进制-6
   1011 = 十进制-5
   1100 = 十进制-4
   1101 = 十进制-3
   1110 = 十进制-2
   1111 = 十进制-1

现在我们得到了一个“有符号整数”数字系统，使用所知道的，为了一些不是很重要的原因，“补码”编码方式。对16位有符号数字编码来说，我们可以得到范围为-32,768到32,767的有符号数字。对一个32位的有符号编码系统来说，我们可以为从-2,147,483,648到2,147,483,647的数编码。

与只改变符号位来表示负数的编码方式相比，“补码”编码方式与之有所不同。例如对于-5来说，只对符号位编码，应该是：

   1101

但是对于“补码”编码方式来说，则是：

   1011

这对于符号编码来说是-3。关于为什么计算机要使用补码这种编码方式我们会在后面解释。

所以，现在我们可以以二进制方式来表示正负两种不同的数值。请记住对于一个二进制数来说，只有两种解释方式。如果在内存中有一个这样的二进制数值：

   1101

-- 这只能解释为十进制的“13”或“-5”。

== 定点小数 ==

这种格式通常被用于商业计算（例如在电子表格或[[COBOL|COBOL]]中）；因为在这里，丢弃小数位来记录金钱是不能接受的。因此了解二进制如何存贮小数是十分有用的。

首先去我们必须决定要用多少位来存贮小数部分和多少位来存储整数部分。假设我们使用32位来表示这种格式，那么我们用16位表示整数部分，16位来表示小数部分。

小数部分怎么使用呢？这沿用了表示整数的方式：如果8位接下来是4位，是2位，1位，那么当然接下来就是半位，1/4位和1/8位等等了。

例如：
                              整数位            小数位
    0.5      =    1/2 = 00000000 00000000.10000000 00000000
    1.25     =  1 1/4 = 00000000 00000001.01000000 00000000
    7.375    =  7 3/8 = 00000000 00000111.01100000 00000000

有一点棘手的是，如果您要表达1/5（十进制的0.2），那您不能得到精确的数值表达方式。最好的方法只能是：

: 13107/65536 = 00000000 00000000.00110011 00110011 = 0.1999969... 十进制
: 13108/65536 = 00000000 00000000.00110011 00110100 = 0.2000122... 十进制

然而不，您不能这样做，即使您有更多的数位来表达。问题是，一些小数使用二进制的方式不能精确地表达出来。除非您使用一个特殊的办法。这个特殊的办法是分别使用两个数字来表达小数：一个是分子，一个是分母。然后您可以使用学校学习的加、减、乘、除来得到它们。然而，这些方法不能表达更高级的数字（例如平方根），或者如果这两个分母的最小公倍数很大的话，那就难以使用。这就是使用定点小数表达小数的缺点。

== 浮点小数 ==

当我们使用了有符号和无符号的数值表达方式时。如果遇到连32位也不足以表达的大范围的数，或也许可以表达，但我们必须为此放弃小数位时，我们可以选择的以获得更大范围的数值的表达方式的方法是使用“浮点小数”格式而抛弃“定点小数”格式。

在十进制中，我们对以下的表达方式很熟悉：

: 1.1030402 × 10<sup>5</sup> = 1.1030402 × 100000 = 110304.02

或简写成：

   1.1030402E5

这表示“1.103402乘以一个1后面跟着5个零的数”。我们可以得到一个确定的称谓“尾数”的数值（1.1030402），乘以一个10的某个幂级数(E5，表示10<sup>5</sup>或100,000），也就是“[[幂级数|幂级数]]”。如果我们使用一个负的幂级数，那就意味着乘以该正级数的倒数。例如：

: 2.3434E-6 = 2.3434 × 10<sup>-6</sup> = 2.3434 × 0.000001 = 0.0000023434

使用这种定义的好处是我们可以得到更大范围的数值，虽然尾数部分的精确度受到影响。相似的原理可以应用于二进制中为计算机使用。人们设计了很多方式，但是作常用的是由[[美国电器和电子工程师协会|美国电器和电子工程师协会]]定义的一种方法。它对64位浮点格式的定义是：
* 11位二进制表示指数，使用“超1023”格式。这种格式使得指数可以表示为0到2047的无符号数，但是在得到真实值前必须先减去1023；
* 52位尾数，使用无符号数字表示；
* 一个符号位；

下面我们使用一个例子来了解计算机如何使用内存的8字节存储这些数字：

   第0字节：         S    x10  x9   x8   x7   x6   x5   x4
   第1字节：         x3   x2   x1   x0   m51  m50  m49  m48
   第2字节：         m47  m46  m45  m44  m43  m42  m41  m40
   第3字节：         m39  m38  m37  m36  m35  m34  m33  m32
   第4字节：         m31  m30  m29  m28  m27  m26  m25  m24
   第5字节：         m23  m22  m21  m20  m19  m18  m17  m16
   第6字节：         m15  m14  m13  m12  m11  m10  m9   m8
   第7字节：         m7   m6   m5   m4   m3   m2   m1   m0

其中的“S”表示符号位，“X”表示指数位（阶码？），“m”表示尾数位。一旦这些数字被读取，它将转换成：

: <符号> × (1 + <小数形式的尾数>) × 2<sup><阶码> - 1023</sup>

这个方式提供的数字范围为：


{|
|-----
!
! 最大值
! 最小值
|-----
! 正数
| 1.797693134862231E+308 || 4.940656458412465E-324
|-----
! 负数
| -4.940656458412465E-324 || -1.797693134862231E+308
|}

这种方式也定义了一些不是数字的值，例如“NaNs”（“不是一个数字”）。这通常用来返回表示数字溢出的信息。通常您不会碰到它，所以我们也不会对它进行进一步讨论。一些程序使用32位浮点小数。最普遍的是使用32位尾数，1位符号位，8位阶码和“超127”格式。它提供7位十进制数字。

   第0字节：         S    x7   x6   x5   x4   x3   x2   x1   
   第1字节：         x0   m22  m21  m20  m19  m18  m17  m16  
   第2字节：         m15  m14  m13  m12  m11  m10  m9   m8   
   第3字节：         m7   m6   m5   m4   m3   m2   m1   m0

数字转换时使用：

: <符号> × (1 + <小数形式的尾数>) × 2<sup><阶码> - 127</sup>

它的范围为：


{|
|-----
!
! 最大值
! 最小值
|-----
! 正数
| 3.402823E+38 || 2.802597E-45
|-----
! 负数
| -2.802597E-45 || -3.402823E+38
|}

通常我们可以把32位的二进制浮点数称为“单精度”浮点数，而把64位的二进制浮点数称为“双精度”浮点数。如果我们使用real的时候，通常表示双精度的浮点数；而使用float的时候，我们通常指单精度的浮点数。

但是要记住的是，浮点数在计算机的存储是连续的：当计算机内存中有一个64位数据时，它可能是一个双精度的浮点数，也可能是两个单精度的浮点数，或4个有符号或无符号的整数，或其它8位的数据，这取决于计算机如何读取它们。如果计算机把4个无符号整数以双精度浮点小数方式读出的话，它可以得到一个双精度浮点小数，但这个数据可能是一个垃圾数据。

所以，现在虽然我们已经解决了正、负数的存贮方式，但是对于浮点数来说，仍然存在一些与整数一样的缺陷，例如：

* 像整数一样，浮点数也有范围。虽然我们得到了比整数要大得多的范围，但是仍然是有限的，如果您试图把两个很大的数乘起来，您可能会得到“数据上溢”的错误。而如果您把一个小的数字除以一个函大的数字，那就可能使得指数的数值出错，出现“数据下溢”的错误。通常把最大值称为“机器无穷”，因为它是计算机所能处理的最大的数字。
* 另一个问题是精度。虽然您有15位的数字来表示很大的数，但是当对它进行四则运算的时候，它们可能不给您任何提示就把一些数字丢弃。这意味着，如果您把一个很小的数加到一个很大的数值上去的时候，由于这个数字太小，以至于15位或16位的精度都不能显示它，计算机就会把这个数字丢弃。如果您在做计算的时候得到一个十分奇怪的数字，您可以需要检查您的数据范围是否合适。

:这意味着，如果您做浮点计算，较小的数字很可能被丢弃了。虽然这在平常来说并不明显，但是如果您是做要求很高的数学分析工作，这些错误可能会累积起来，以至于最后得到的结果十分不准确。

:这个错误对进行数学研究的人来说十分重要，他们必须对误差十分了解，以及研究一些办法来减少误差，并且应该可以估计到误差的大小。

:顺便说一句，“精度”问题与“范围”问题不同，前者指的是有关尾数的表示范围，后者指的是指数的表达范围。
* 另外一个不太明显的误差是由于浮点数的二进制和十进制并不完全相等。如果您操作的数好是2的幂级数的倒数，例如0.75，那是用二进制可以准确的标示为0.11，因为它刚好是1/2+1/4的值。可是不幸的是，您可能通常不会得到如此恰到好处的数字，这就是说，计算机会把一些数字丢掉，例如要表示0.1，只能使用无穷循环的二进制小数0.000110011……表示了。

如果您对这部分内容不理解，别担心。这里的要点是，计算机不是万能的，它只是一部机器，并要符合一定的规则和受到一定的限制。虽然很多人对计算机抱有孩子似的信任，但是在计算机虽好的解决方法下也有一些不可避免的不精确。

== 编程语言中的数 ==

对于低级语言的编程者来说，他们要担心有符号和无符号、定点和浮点数的运算。他们必须使用十分不同的代码来实现操作。

但是，对高级语言的编程者来说，诸如[[LISP编程语言|LISP]]和[[Python编程语言|Python]]提供了一些列诸如“[[有理数|有理数]]”、“[[复数_(数学)|复数]]”之类的抽象数据类型。而他们可以断言他们的系统可以使用数学操作做正确的运算。由于操作符重载，数学运算可以应用于任何数字——无论是有符号的、无符号的、有理数、定点小数、浮点小数或复数。

== 文本编码：ASCII和字符串 ==

现在我们已经得到不同的方法来存储数据了，那么文本呢？我们怎么存储姓名、地址或写给朋友的信件呢？

当然，如果您还记得位是位的话，我们没有理由不能使用位来表达字母“A”或“？”或“Z”之类的。因为很多计算机每次处理一个字节，所以使用单字节的数据来表达单个字母会很方便。我们可以使用这个：

   0100 0110 (hex 46)

来表示字母“F”。计算机使用这样的“字符编码”来向显示程序传送要求的文本。

下面是一个用来存储西方字母的标准二进制编码，就是通常所说的“[[美国信息交换标准码|美国信息交换标准码]]”（英文简称“[[ASCII|ASCII]]”），下面的编码为ASCII编码，使用“d”表示十进制编码，“h”表示十六进制代码，“o”表示八进制代码：

<pre>
 ASCII码表
   ______________________________________________________________________

   ch ctl   d  h  o     ch   d  h  o     ch   d  h   o     ch    d  h   o 
   ______________________________________________________________________

   NUL ^@   0  0  0     sp  32 20 40      @  64 40 100      '   96 60 140 
   SOH ^A   1  1  1      !  33 21 41      A  65 41 101      a   97 61 141 
   STX ^B   2  2  2      "  34 22 42      B  66 42 102      b   98 62 142 
   ETX ^C   3  3  3      #  35 23 43      C  67 43 103      c   99 63 143 
   EOT ^D   4  4  4      $  36 24 44      D  68 44 104      d  100 64 144 
   ENQ ^E   5  5  5      %  37 25 45      E  69 45 105      e  101 65 145 
   ACK ^F   6  6  6      &  38 26 46      F  70 46 106      f  102 66 146 
   BEL ^G   7  7  7      `  39 27 47      G  71 47 107      g  103 67 147 

   BS  ^H   8  8 10      (  40 28 50      H  72 48 110      h  104 68 150 
   HT  ^I   9  9 11      )  41 29 51      I  73 49 111      i  105 69 151 
   LF  ^J  10  a 12      *  42 2a 52      J  74 4a 112      j  106 6a 152 
   VT  ^K  11  b 13      _  43 2b 53      K  75 4b 113      k  107 6b 153 
   FF  ^L  12  c 14      ,  44 2c 54      L  76 4c 114      l  108 6c 154 
   CR  ^M  13  d 15      _  45 2d 55      M  77 4d 115      m  109 6d 155 
   SO  ^N  14  e 16      .  46 2e 56      N  78 4e 116      n  110 6e 156 
   SI  ^O  15  f 17      /  47 2f 57      O  79 4f 117      o  111 6f 157 

   DLE ^P  16 10 20      0  48 30 60      P  80 50 120      p  112 70 160 
   DC1 ^Q  17 11 21      1  49 31 61      Q  81 51 121      q  113 71 161 
   DC2 ^R  18 12 22      2  50 32 62      R  82 52 122      r  114 72 162 
   DC3 ^S  19 13 23      3  51 33 63      S  83 53 123      s  115 73 163 
   DC4 ^T  20 14 24      4  52 34 64      T  84 54 124      t  116 74 164 
   NAK ^U  21 15 25      5  53 35 65      U  85 55 125      u  117 75 165 
   SYN ^V  22 16 26      6  54 36 66      V  86 56 126      v  118 76 166 
   ETB ^W  23 17 27      7  55 37 67      W  87 57 127      w  119 77 167 

   CAN ^X  24 18 30      8  56 38 70      X  88 58 130      x  120 78 170 
   EM  ^Y  25 19 31      9  57 39 71      Y  89 59 131      y  121 79 171 
   SUB ^Z  26 1a 32      :  58 3a 72      Z  90 5a 132      z  122 7a 172 
   ESC ^[  27 1b 33      ;  59 3b 73      [  91 5b 133      {  123 7b 173 
   FS  ^\  28 1c 34      <  60 3c 74      \  92 5c 134         124 7c 174 
   GS  ^]  29 1d 35      =  61 3d 75      ]  93 5d 135      }  125 7d 175 
   RS  ^^  30 1e 36      >  62 3e 76      ^  94 5e 136      ~  126 7e 176 
   US  ^_  31 1f 37      ?  63 3f 77      _  95 5f 137     DEL 127 7f 177 
   ______________________________________________________________________
</pre>

上面这个列表的最左边有一个些奇怪的字符，例如“FF”和“BS”，这些都不是文本字符。相反，它们是控制字符，也就是说当这些字符发送到特定的设备时，它将产生一些动作。例如“FF”表示换页，或弹出；“BS”表示退格，而“BEL”表示一个响声。在一个文本编辑器中，它们会显示成一个白色或黑色的方块，或笑脸、音符或其它一些奇怪的符号。要打出这些字符，可以使用CTRL键和一个合适的代码。例如同时按住“CTRL”和“G”，或简写成“CTRL-G”或“^G”可以打出一个BEL字符。

上面这个ASCII码表示定义了128个字符，这意味着ASCII码只需要7位。但是，很多计算机都以字节为单位存储信息。这个额外的一位可以定义第二个128个字集，一个“扩展”字集。

在实际中，有很多不同的“扩展”字集，提供很多例如数学符号等的符号或非英语字符。这个扩展字集并没有进行标准化，并经常会引起混淆。

这个表格强调了这篇文章的主题：位就是位。这样的话，您可以使用位来表示字符。您可以把特殊的代码描述成特殊的十进制、八进制和十六进制，但是它们仍然是相同的代码。这些数值的表达，无论是十进制、八进制或十六进制，都只是相同的位的表达。

当然，您可能在一段话中表达很多的字符，例如：

: Tiger, tiger burning bright!

这只是简单的替换成ASCII码，表示成：

: 54 69 67 65 72 2c 20 74 69 67 65 72 20 62 75 ... 

计算机把这种ASCII“字符串”以连续空间的“数组”来存储。一些应用程序可以包括一个二进制数值表示字符串的长度，但是更通常的做法是使用一个表示结尾的字符NULL（ASCII表中的0字符〕表示字符串的结束。

== 参见 ==
* [[二进制|二进制]]
* [[二进制数学|二进制数学]]
* [[二进制编码数据|二进制编码数据]]
* [[八进制|八进制]]
* [[十六进制|十六进制]]

[[Category:计算机科学|Category:计算机科学]]
[[Category:計算機算術|Category:計算機算術]]