{{GA}}
{{noteTA
|G1=IT
|1=zh-hans:算法; zh-hant:演算法;
}}
{{Infobox algorithm
|class=[[搜索算法|搜索算法]]<ref name=IntroToAlgo /><ref name=Discrete /><br>[[贪心算法|贪心算法]]<ref name=IntroToAlgo /><br>[[动态规划|动态规划]]<ref>有争议，见：{{cite journal |author1=Moshe Sniedovich |title=Dijkstra's algorithm revisited: the dynamic programming connexion |journal=Control and Cybernetics |date=2006 |volume=35 |pages=599-620 |url=https://www.infona.pl/resource/bwmeta1.element.baztech-article-BAT5-0013-0005/tab/summary |author= |access-date=2020-03-04 |archive-url=https://web.archive.org/web/20200304030456/https://www.infona.pl/resource/bwmeta1.element.baztech-article-BAT5-0013-0005/tab/summary |archive-date=2020-03-04 |dead-url=no }}等</ref>
|image=Dijkstra Animation.gif
|caption = 戴克斯特拉算法运行演示（找到A，B之间的最短路），本算法每次取出未访问结点中距离最小的，用该结点更新其他结点的距离。在演示过程中访问过的结点会被标为红色。
|data=[[图_(数据结构)|图]]<br>[[堆|堆]]/[[优先队列|优先队列]]（算法优化）<ref name=IntroToAlgo>{{cite book | author1-link = Thomas H. Cormen | first1 = Thomas H. | last1 = Cormen | author2-link = Charles E. Leiserson | first2 = Charles E. | last2 = Leiserson | author3-link = Ronald L. Rivest | first3 = Ronald L. | last3 = Rivest | author4-link = Clifford Stein | first4 = Clifford | last4 = Stein | title = [[算法导论|Introduction to Algorithms]] | edition = Second | publisher = [[麻省理工学院出版社|MIT Press]] and [[标普全球|McGraw–Hill]] | year = 2001 | isbn = 0-262-03293-7 | chapter = Section 24.3: Dijkstra's algorithm | pages = [https://archive.org/details/introductiontoal00corm_691/page/n617 595]–601 | ref = harv}}</ref><ref name=tarjan />
|time= <math>O(|E| + |V| \log|V|)</math>（使用[[斐波那契堆|斐波那契堆]]优化的戴克斯特拉算法）<ref>{{cite journal |author1=Andrew V. Goldberg |coauthors=[[羅伯特·塔揚|Robert E. Tarjan]] |title=Expected performance of Dijkstra’s shortest path algorithm |journal=NEC Research Institute Report |date=1996年 |url=http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.54.4349&rep=rep1&type=pdf |access-date=2019-12-12 |archive-date=2021-11-22 |archive-url=https://web.archive.org/web/20211122065707/http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.54.4349&rep=rep1&type=pdf }}</ref><ref name=tarjan>{{cite conference|first1=Michael Lawrence|last1=Fredman|authorlink1=Michael Fredman|first2=Robert E.|last2=Tarjan|authorlink2=羅伯特·塔揚|title=Fibonacci heaps and their uses in improved network optimization algorithms|conference=25th Annual Symposium on Foundations of Computer Science|year=1984|publisher=[[电气电子工程师学会|IEEE]]|pages=338–346|ref=harv|doi=10.1109/SFCS.1984.715934}}</ref>
|best-time=
|average-time=
|SpaceComp=<math>O(|E|+|V|)</math>（使用邻接表存储边的情况）<ref name=IntroToAlgo />
|space=
|optimal=
|complete=
|Def1=<math>|E|</math>代表图中边数，<math>|V|</math>代表图中结点个数，<math>Q</math>为目前所有实际最短路径值不确定结点的集合，<math>S</math>为目前所有实际最短路径值确定结点的集合，<math>d[]</math>为到某点的最短路径估计，<math>\delta</math>为到某点的最短路径实际值，<math>|L|</math>为边集中边的最大权值。
|Var1=|E|、|V|、Q、S、G、d[]、\delta
}}
{{图搜索算法}}
'''戴克斯特拉算法'''（{{lang-en|Dijkstra's algorithm}}），又译'''迪杰斯特拉算法'''，亦可不音譯而稱爲'''Dijkstra算法'''<ref>{{cite journal |author1=乐阳、龚健雅 |title=Dijkstra最短路径算法的一种高效率实现 |journal=《科学技术创新》 |date=2020 |issue=17 |pages=75-77 |url=http://ch.whu.edu.cn/article/id/4401 |accessdate=2020-06-30 |archive-date=2021-02-13 |archive-url=https://web.archive.org/web/20210213073439/http://ch.whu.edu.cn/article/id/4401 |dead-url=no }}</ref>，是由荷兰计算机科学家[[艾茲赫尔·戴克斯特拉|艾茲赫尔·戴克斯特拉]]在1956年发现的算法，并于3年后在[[学术期刊|期刊]]上发表<ref>{{cite web |url=http://amturing.acm.org/award_winners/dijkstra_1053701.cfm |title=Edsger Wybe Dijkstra |last=Richards |first=Hamilton |website=A.M. Turing Award |publisher=Association for Computing Machinery |access-date=2017-10-16 |quote=At the Mathematical Centre a major project was building the ARMAC computer. For its official inauguration in 1956, Dijkstra devised a program to solve a problem interesting to a nontechnical audience: Given a network of roads connecting cities, what is the shortest route between two designated cities? |archive-url=https://web.archive.org/web/20171021182150/http://amturing.acm.org/award_winners/dijkstra_1053701.cfm |archive-date=2017-10-21 |dead-url=no }}</ref><ref name="Dijkstra Interview">{{cite journal|first=Phil |last=Frana |title=An Interview with Edsger W. Dijkstra|journal=Communications of the ACM|date=August 2010|volume=53|issue=8|pages=41–47 |doi=10.1145/1787234.1787249}}</ref><ref name="Dijkstra1959">{{cite journal | authorlink = 艾兹赫尔·戴克斯特拉 | first1 = E. W. | last1 = Dijkstra | url = http://www-m3.ma.tum.de/twiki/pub/MN0506/WebHome/dijkstra.pdf | title = A note on two problems in connexion with graphs | journal = Numerische Mathematik | volume = 1 | year = 1959 | pages = 269–271 | ref = harv | doi = 10.1007/BF01386390 | author =  | access-date = 2020-01-27 | archive-url = https://web.archive.org/web/20200123110037/http://www-m3.ma.tum.de/foswiki/pub/MN0506/WebHome/dijkstra.pdf | archive-date = 2020-01-23 | dead-url = no }}</ref>。戴克斯特拉算法使用类似[[廣度优先搜索|廣度优先搜索]]的方法解决赋权图{{r|Dijkstra1959}}的单源[[最短路径问题|最短路径问题]]<ref name="felner">{{cite conference |first=Ariel |last=Felner |title=Position Paper: Dijkstra's Algorithm versus Uniform Cost Search or a Case Against Dijkstra's Algorithm |conference=Proc. 4th Int'l Symp. on Combinatorial Search |year=2011 |url=http://www.aaai.org/ocs/index.php/SOCS/SOCS11/paper/view/4017/4357 |access-date=2020-02-18 |archive-url=https://web.archive.org/web/20200218150924/https://www.aaai.org/ocs/index.php/SOCS/SOCS11/paper/view/4017/4357 |archive-date=2020-02-18 |dead-url=yes }}</ref><ref name=IntroToAlgo /><ref name=Discrete>{{cite book|title=Discrete Mathematics and Its Applications|publisher=McGraw-Hill College|year=2002|isbn=0-07-293033-0|author=Rosen, Kenneth H.}}</ref>。

该算法存在很多变体：戴克斯特拉的原始版本仅适用于找到两个顶点之间的最短路径{{r|Dijkstra1959}}，后来更常见的变体固定了一个顶点作为源结点然后找到该顶点到图中所有其它结点的最短路径，产生一个[[最短路径树|最短路径树]]<ref name=IntroToAlgo />。

该算法解决了圖 <math>G=\langle V,E\rangle</math>上带权的单源最短路径问题<ref name=IntroToAlgo /><ref name="mehlhorn">{{cite book |last1=Mehlhorn |first1=Kurt |author1-link=Kurt Mehlhorn |first2=Peter |last2=Sanders |author2-link=Peter Sanders (computer scientist) |title=Algorithms and Data Structures: The Basic Toolbox |publisher=Springer |year=2008 |chapter=Chapter 10. Shortest Paths |chapterurl=http://people.mpi-inf.mpg.de/~mehlhorn/ftp/Toolbox/ShortestPaths.pdf |isbn=978-3-540-77977-3 |doi=10.1007/978-3-540-77978-0 |access-date=2020-02-14 |archive-date=2021-02-24 |archive-url=https://web.archive.org/web/20210224062728/http://people.mpi-inf.mpg.de/~mehlhorn/ftp/Toolbox/ShortestPaths.pdf |dead-url=no }}</ref>{{rp|196–206}}。具体来说，戴克斯特拉算法设置了一顶点集合<math>S</math>，在集合<math>S</math>中所有的顶点与[[顶点_(图论)|源点]]<math>s</math>之间的最终最短路径权值均已确定<ref name=IntroToAlgo />。算法反复选择最短路径估计最小的点<math>u \in{V-S}</math>并将<math>u</math>加入<math>S</math>中<ref name=IntroToAlgo />。该算法常用于[[路由|路由]]算法或者作为其他图算法的一个子模块<ref name=OSPF />。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该演算法可以用来找到两个城市之间的最短路径<ref name="Dijkstra Interview" /><ref name=Discrete />。

应当注意，绝大多数的戴克斯特拉算法不能有效处理带有负权边的图<ref name=IntroToAlgo /><ref>{{cite journal |
|first1 = Dinitz
|last1 = Yefim
|first2 = Itzhak
|last2 = Rotem
|title = Hybrid Bellman–Ford–Dijkstra algorithm,
|journal = Journal of Discrete Algorithms
|volume = 42
|date = 2017
|pages = 35-44
|doi = 10.1016/j.jda.2017.01.001 }}</ref>。

戴克斯特拉算法在计算机科学的[[人工智能|人工智能]]等领域也被称为均一开销搜索，并被认为是{{tsl|en|best-first search|最良优先搜索}}的一个特例<ref name="felner" />。

== 算法描述 ==
[[Image:Dijkstras_progress_animation.gif|thumb]]
戴克斯特拉算法通過保留目前為止所找到的每個頂點<math>v \in V</math>從<math>s</math>到<math>v</math>的最短路徑來工作<ref name=IntroToAlgo /><ref name=Discrete />。初始時，原點<math>s</math>的路径权重被賦為 0 （即原点的实际最短路径=0）<ref name=IntroToAlgo /><ref name=Discrete />。同時把所有其他頂點的路徑長度設為無窮大，即表示我們不知道任何通向這些頂點的路徑<ref name=IntroToAlgo />。當算法結束時，<math>d[v]</math> 中儲存的便是從<math>s</math>到<math>v</math>的最短路徑，或者如果路徑不存在的話是無窮大<ref name=IntroToAlgo />。

松弛操作是戴克斯特拉算法的基礎操作：如果存在一條從<math>u</math>到<math>v</math>的邊，那麼從<math>s</math>到<math>v</math>的一条新路径是將邊<math>w(u,v) \in E</math>添加到從<math>s</math>到<math>u</math>的路徑尾部來拓展一條從<math>s</math>到<math>v</math>的路径<ref name=IntroToAlgo /><ref name="Dijkstra1959" />。這條路徑的長度是<math>d[u] + w(u, v)</math><ref name=IntroToAlgo />。如果這個值比目前已知的<math>d[v]</math>的值要小，那么可以用这个值來替代當前<math>d[v]</math>中的值<ref name=IntroToAlgo />。松弛邊的操作一直執行到所有的<math>d[v]</math>都代表從<math>s</math>到<math>v</math>的最短路徑的长度值<ref name=IntroToAlgo />。

算法維護兩個頂點集合<math>S</math>和<math>Q</math><ref name=IntroToAlgo /><ref name="Dijkstra1959" />。集合<math>S</math>保留所有已知实际最短路径值的頂點，而集合<math>Q</math>則保留其他所有頂點<ref name=IntroToAlgo /><ref name="Dijkstra1959" />。集合<math>S</math>初始狀態為空，而後每一步都有一個頂點從<math>Q</math>移動到<math>S</math><ref name=IntroToAlgo /><ref name="Dijkstra1959" />。這個被選擇的頂點是<math>Q</math>中擁有最小的<math>d[u]</math>值的頂點<ref name=IntroToAlgo /><ref name=Discrete />。當一個頂點<math>u</math>從<math>Q</math>中轉移到了<math>S</math>中，算法對<math>u</math>的每条外接邊<math>w(u, v)</math>進行松弛<ref name=IntroToAlgo />。

《[[算法导论|算法导论]]》中给出了以下伪代码<ref name=IntroToAlgo />：该伪代码计算并保留图<math>G</math>中原点<math>s</math>到每一顶点<math>v</math>的最短距离<math>d[v]</math>。其中，函数<math>Extract-Min(Q)</math>将頂點集合<math>Q</math>中有最小<math>d[u]</math>值的頂點<math>u</math>从<math>Q</math>中删除并返回<math>u</math><ref name=IntroToAlgo />。

 -{}-
  1  '''function''' Dijkstra(G, w, s)
  2   INITIALIZE-SINGLE-SOURCE(G, s)                //实际上的操作是将每个除原点外的顶点的<math>d[v]</math>置为无穷大，<math>d[s]=0</math>
  3   <math>S \leftarrow \emptyset</math>
  4   <math>Q \leftarrow s</math>                                //<math>Q</math>是顶点<math>V</math>的一个优先队列，以顶点的最短路径估计排序
  5   while(<math> Q \not= \emptyset</math>)
  6       do <math> u \leftarrow EXTRACT-MIN(Q)</math>          //选取<math>u</math>为<math>Q</math>中最短路径估计最小的顶点
  7       <math>S \leftarrow S \cup u</math>
  8       for each vertex v <math>\in Adj[u]</math>
  9            do RELAX(u, v, w)            //松弛成功的结点会被加入到队列中

如果我們只對在<math>s</math>和<math>t</math>之間尋找一條最短路徑的話，我們可以在第5或第6行添加條件如果滿足<math>u=t</math>的話終止程序<ref name=IntroToAlgo /><ref name=Discrete />。

在肯尼·罗森所著的《离散数学及其应用》中给出了如下的另一份伪代码<ref name=Discrete />：
 -{}-
  1 '''procedure''' Dijkstra(G：边全为正权的图）
  2   {G带有顶点<math>a=v_0,v_1,v_2...</math>和若干边<math>w(v_i,v_j)</math>}
  3    for <math>i:=1</math> to n
  4       <math>D(v_i):=\infty</math>
  5    <math>D(a):=0</math>
  6    <math>S:=\emptyset</math>
  7    while <math>z \notin S</math>
  8    begin
  9          <math>u:=</math>不属于<math>S</math>的<math>D(u)</math>最小的一个顶点
  10        <math>S:=S \cup \{u\}</math>
  11        for 所有不属于<math>S</math>的顶点<math>v</math>
  12            if <math>D(u)+w(u,v)<D(v)</math> then <math>D(v):=D(u)+w(u,v)</math>
  13    end{<math>D(z)=</math>从a到z的最短路长度}

== 時間複雜度 ==

我們可以用[[大O符號|大O符號]]將该算法的運行時間表示為邊數<math>|E|</math>和頂點數<math>|V|</math>的函數<ref name=IntroToAlgo />。

对于任何基于顶点集<math>Q</math>的实现，算法的运行时间是<math>O(|E| \cdot dk_Q + |V| \cdot em_Q)</math>，其中<math>dk_Q</math>和<math>em_Q</math>分别表示完成键的降序排列时间和从<math>Q</math>中提取最小键值的时间<ref name=IntroToAlgo />。

对于没有任何优化的戴克斯特拉算法，实际上等价于每次遍历了整个图的所有结点来找到Q中满足条件的元素（即寻找最小的頂點是<math>O(|V|)</math>的），此外实际上还需要遍历所有的边一遍，因此算法的复杂度是<math>O(|V|^2+|E|)</math><ref name=Discrete />。

對於邊數少於<math>|V|^2</math>的稀疏圖來說，可以用[[鄰接表|鄰接表]]來更有效的實現该算法<ref name=IntroToAlgo />。

可以使用一個[[二叉堆|二叉堆]]或者[[斐波納契堆|斐波納契堆]]用作[[優先隊列|優先隊列]]來尋找最小的頂點（<math>Extract-Min</math>）以优化算法<ref name=Johnson /><ref name=Fibonacci1 />。當用到[[二叉堆|二叉堆]]的時候，算法所需的時間為<math>O((|E| + |V|)\log |V|)</math><ref name=Johnson />，[[斐波納契堆|斐波納契堆]]能提高一些性能，讓算法運行時間達到<math>O(|E| + |V| \log |V|)</math><ref name=tarjan /><ref name=Fibonacci1 />。然而，使用[[斐波納契堆|斐波納契堆]]进行编程，有时会由于算法常数过大而导致速度没有显著提高<ref>{{cite book |last=Skiena |first1=Steven |url=http://sist.sysu.edu.cn/~isslxm/DSA/textbook/Skiena.-.TheAlgorithmDesignManual.pdf |title=The Algorithm Design Manual |edition=2 |publisher=Springer |date=2008-07-26 |page=212 |isbn=978-0073523408 |doi=10.1007/978-1-84800-070-4 |language=en |accessdate=2015-04-11 |deadurl=yes |archiveurl=https://web.archive.org/web/20150609195555/http://sist.sysu.edu.cn/~isslxm/DSA/textbook/Skiena.-.TheAlgorithmDesignManual.pdf |archivedate=2015-06-09 }}</ref>。

下面是一些戴克斯特拉算法经典实现的复杂度比较：

{| class=wikitable
! 算法 !! 最坏时间复杂度 !! 发现者（按照论文发表时间从前向后排序）
|-
| 使用鄰接表的戴克斯特拉算法|| <math>O(|V|^2)</math> || 莱索雷克及格雷等人<ref>{{cite book|first1=M.|last1=Leyzorek|first2=R. S.|last2=Gray|first3=A. A.|last3=Johnson|first4=W. C.|last4=Ladew|first5=S. R.|last5=Meaker, Jr.|first6=R. M.|last6=Petry|first7=R. N.|last7=Seitz|title=Investigation of Model Techniques — First Annual Report — 6 June 1956 — 1 July 1957 — A Study of Model Techniques for Communication Systems|publisher=Case Institute of Technology|location=Cleveland, Ohio|year=1957|ref=harv}}</ref>，[[艾兹赫尔·戴克斯特拉|艾兹赫尔·戴克斯特拉]]{{r|Dijkstra1959}}，明蒂<ref>见{{cite journal | last1=Pollack |first1= Maurice |last2=Wiebenson |first2=Walter |date=March–April 1960 |title=Solution of the Shortest-Route Problem—A Review |journal=Oper. Res. |volume=8 |issue=2 |pages=224–230 |ref=harv|doi=10.1287/opre.8.2.224}}  Attributes Dijkstra's algorithm to Minty ("private communication") on p.225.</ref>，怀廷及希利尔<ref>{{cite journal |last2=Hillier |first2=J. A. |date=March–June 1960 |title=A Method for Finding the Shortest Route through a Road Network |journal=Operational Research Quarterly |volume=11 |issue=1/2 |pages=37–40 |ref=harv|last1=Whiting |first1=P. D. |doi=10.1057/jors.1960.32}}</ref>
|-
| 使用[[二叉堆|二叉堆]]优化的戴克斯特拉算法|| <math>O((|E|+|V|) \log |V|)</math> || [[唐纳德·布鲁斯·约翰逊|唐纳德·约翰逊]]<ref name=Johnson>{{cite journal
 | last = Johnson 
 | first = Donald B.
 | authorlink = 唐纳德·布鲁斯·约翰逊
 | title = Efficient algorithms for shortest paths in sparse networks
 | journal = [[ACM期刊|Journal of the ACM]]
 | volume = 24
 | issue = 1
 | pages = 1–13
 | year = 1977
 | doi=10.1145/321992.321993}}</ref>
|-
|使用[[斐波那契堆|斐波那契堆]]优化的戴克斯特拉算法||<math>O(|E|+|V|\log |V|)</math> || 迈克尔·弗雷德曼及[[羅伯特·塔揚|羅伯特·塔揚]]<ref name=tarjan /><ref name=Fibonacci1>{{cite journal|first1=Michael Lawrence|last1=Fredman|authorlink1=Michael Fredman|first2=Robert E.|last2=Tarjan|authorlink2=Robert Tarjan|title=Fibonacci heaps and their uses in improved network optimization algorithms|journal=Journal of the Association for Computing Machinery|volume=34|year=1987|pages=596–615|url=http://portal.acm.org/citation.cfm?id=28874|ref=harv|doi=10.1145/28869.28874|issue=3|author=|access-date=2018-04-03|archive-url=https://web.archive.org/web/20060428015053/http://portal.acm.org/citation.cfm?id=28874|archive-date=2006-04-28|dead-url=no}}</ref>
|-
| || <math>O(|E| \log \log |L|)</math> || 唐纳德·约翰逊<ref>{{cite journal
 | last = Johnson | first = Donald B. | date = December 1981
 | title = A priority queue in which initialization and queue operations take {{math|''O''(log log ''D'')}} time
 | journal = Mathematical Systems Theory
 | volume = 15
 | issue = 1
 | pages = 295–309
 | doi = 10.1007/BF01786986
 | mr = 683047
 | ref = harv| authorlink = Donald B. Johnson
 }}</ref>，洛夫·卡尔松及帕特里西奥·波夫莱特<ref>{{cite journal
 | last2 = Poblete | first2 = Patricio V.
 | year = 1983
 | title = An {{math|''O''(''m'' log log ''D'')}} algorithm for shortest paths
 | journal = [[Discrete_Applied_Mathematics|Discrete Applied Mathematics]]
 | volume = 6
 | issue = 1
 | pages = 91–93
 | doi = 10.1016/0166-218X(83)90104-X
 | mr = 700028
 | ref = harv| last1 = Karlsson | first1 = Rolf G.
 }}</ref>
|}

==算法正确性证明==
[[File:Edsger_Wybe_Dijkstra.jpg|right]]，戴克斯特拉算法的发现者]]
[[戴克斯特拉|戴克斯特拉]]本人在他的论文中给出了一份简单的证明<ref name="Dijkstra1959" />。

《[[算法导论|算法导论]]》使用循环不变式（[[数学归纳法|数学归纳法]]）给出了如下的一份证明<ref name=IntroToAlgo />：
:已知一带权图<math>G=<V,E></math>，其加权函数<math>w</math>的值非负，源点为<math>s</math>。对该图运行戴克斯特拉算法，对所有<math>u \in V</math>有<math>d[u]=\delta(s,u)</math>。其中<math>d[u]</math>表示u点的最短路径估计，<math>\delta(s,u)</math>表示<math>s</math>到<math>u</math>点的最短路径。
:证明：证明如下的循环不变式成立即可：在每次执行EXTRACT-MIN时，对每个顶点<math>u \in S</math>，有<math>d[u]=\delta(s,u)</math>成立即可。由于上界性质，在<math>u</math>加入了<math>S</math>之后，一旦有<math>d[u]=\delta(s,u)</math>，则在后面的每次循环中都不会改变这个性质。
:初始化：第一次循环前，<math>S=\empty</math>，因此循环不变式显然成立。
:保持：实际上要证明每一轮循环中加入到<math>S</math>中的结点满足<math>d[u]=\delta(s,u)</math>。利用反证法，假设<math>u</math>是第一个不满足此条件的结点，考虑循环开始前的状况，首先<math>u</math>一定不等于<math>s</math>，这是显然的。其次<math>s</math>一定有到<math>u</math>的路径，否则路径为无穷大。那么假设在<math>u</math>进入时，有最短路径<math>p=s->u</math>，假设该路径上存在两个点<math>x</math>，<math>y</math>。<math>y \in V-S</math>、<math>x \in S</math>，且x是y的前驱，路径<math>p</math>可以分解为<math>s-p_1->x->y-p_2->u</math>（此处<math>-p_1-></math>表示经过<math>p_1</math>这条路径，后同），其中路径<math>p_1</math>和路径<math>p_2</math>可以为空。由于<math>u</math>是第一个不满足<math>d[u]=\delta(s,u)</math>的，又因为<math>x</math>是满足该条件的，而且<math>(x,y)</math>一定已经被松弛过了，所以<math>y</math>是满足该条件的。
:现在只需要推出矛盾，即可证明u不存在：<math>y</math>在<math>u</math>之前出现，而且图中所有权值非负，因此有<math>\delta(s,y) \leq \delta(s,u)</math>，所以：<br/><math>d[y] \leq \delta(s,y) \leq \delta(s,u) \leq d[u]</math>，但是由于<math>u</math>和<math>y</math>同时在<math>V-S</math>中，因此<math>d[u] \leq d[y]</math>，因此必有<math>d[y]= \delta(s,y)=\delta(s,u)=d[u]</math>，也就证明了<math>u</math>点不可能不满足该条件，上述假设为假，原命题得证。
:终止：终止时，<math>Q=\empty</math>，由于<math>Q=V-S</math>，因此<math>V=S</math>，因此对所有<math>u \in V</math>有<math>d[u]=\delta(s,u)</math>。

==算法起源与历史==
{{quote|从[[鹿特丹|鹿特丹]]到[[格罗宁根|格罗宁根]]的最短路径是什么？实际上，这就是对于任意两座城市之间的[[最短路问题|最短路问题]]。解决这个问题实际上大概只花了我20分钟：一天早上，我和我的未婚妻在阿姆斯特丹购物，累了，我们便坐在咖啡馆的露台上喝咖啡，然后我就试了一下能否用一个算法解决最短路问题。正如我所说，这是一个20分钟的发现。不过实际上，我在3年后的1959年才把这个算法发表在论文上。即使现在来看这篇论文的可读性也非常高，这个算法之所以如此优雅，其中一个原因就是我没用笔纸就设计了它。后来我才知道，没用笔纸设计的优点之一是你不得不避免所有可避免的复杂问题。令我惊讶的是，这个算法最终成为我成名的基石之一。|艾兹赫尔·戴克斯特拉在2001年的采访中提到戴克斯特拉算法的发现历程<ref name="Dijkstra Interview"/>}}
戴克斯特拉1956年在[[荷兰数学和计算机科学研究学会|荷兰数学和计算机科学研究学会]]担任程序员时为了展示新型计算机ARMAC的功能曾思考过最短路径问题的解法<ref>{{cite web|title=ARMAC|url=http://www-set.win.tue.nl/UnsungHeroes/machines/armac.html|website=Unsung Heroes in Dutch Computing History|date=2007|archiveurl=https://web.archive.org/web/20131113021126/http://www-set.win.tue.nl/UnsungHeroes/machines/armac.html|archivedate=2013-11-13}}</ref>。他的目标是让不去实际计算的人也能理解这个问题和解决的方法，于是他在发现了这个算法之后在ARMAC上做了简单实验<ref name="Dijkstra Interview"/>。1959年，他正式将此算法发表在期刊上，该算法也成为了戴克斯特拉成名的基石之一<ref name="Dijkstra Interview" /><ref name="Dijkstra1959" />。

== 算法相关应用==
[[File:OSPF_area.jpg|thumb]]]]

{{tsl|en|Link-state routing protocol|链路状态路由协议}}中需要计算最短路时常常要用到该算法，该算法在[[開放最短路徑優先|開放最短路徑優先]]和[[中间系统到中间系统|中间系统到中间系统]]协议中的相关应用是其在網絡[[路由|路由]]中的典型實現<ref name=OSPF>{{cite journal |author1=H. Ishikawa, S. Shimizu, Y. Arakawa, N. Yamanaka, K. Shiba |title=New Parallel Shortest Path Searching Algorithm based on Dynamically Reconfigurable Processor DAPDNA-2 |journal=IEEE |date=13 August 2007 |doi=10.1109/ICC.2007.332 |url=https://ieeexplore.ieee.org/document/4289003 |access-date=2020-03-21 |archive-date=2020-12-18 |archive-url=https://web.archive.org/web/20201218173835/https://ieeexplore.ieee.org/document/4289003 |dead-url=no }}</ref>。

戴克斯特拉算法及其改进算法应用广泛，尤其是在[[寻路|寻路]]、[[交通|交通]]、[[规划|规划]]中<ref>{{cite journal |author1=Sven Peyer |coauthors=Dieter Rautenbach,Jens Vygen |title=A generalization of Dijkstra's shortest path algorithm with applications to VLSI routing |journal=Journal of Discrete Algorithms |date=2007 |volume=7 |issue=4 |pages=377-390 |doi=10.1016/j.jda.2007.08.003}}</ref><ref>{{cite journal |author1=Ismail Rakip Karas，Sait Demir |title=Dijkstra algorithm interactive training software development for network analysis applications in GIS |journal=Energy Education Science and Technology Part A: Energy Science and Research |date=2011 |volume=28 |pages=445-452 |url=http://web.karabuk.edu.tr/ismail.karas/files/EEST_Part_A_2011_28(1)_445-452.pdf |author= |access-date=2020-03-04 |archive-url=https://web.archive.org/web/20200304070529/http://web.karabuk.edu.tr/ismail.karas/files/EEST_Part_A_2011_28(1)_445-452.pdf |archive-date=2020-03-04 |dead-url=no }}</ref><ref>{{cite journal |author1=Dean Djokic,David R. Maidment |title=Application of GIS Network Routines for Water Flow and Transport |journal=Journal of Water Resources Planning and Management |date=1993 |volume=119 |issue=2 |doi=10.1061/(ASCE)0733-9496(1993)119:2(229)}}</ref><ref>{{cite journal |author1=江琦浩 |title=迪杰斯特拉算法在企业成本控制研究中的应用 |journal=中国商贸 |url=http://www.cqvip.com/qk/82030x/201209/690718377201209035.html |date=2012 |issue=03X |access-date=2020-12-24 |archive-date=2021-02-13 |archive-url=https://web.archive.org/web/20210213073526/http://www.cqvip.com/qk/82030x/201209/690718377201209035.html |dead-url=no }}</ref>。

如果有已知信息可用來估計某一點到目標點的距離，則可改用[[A*搜尋算法|A*搜尋算法]]，以減小最短路徑的搜索範圍，戴克斯特拉算法本身也可以看作是A*搜索算法的一个特例<ref name="geospatial">{{citation|title=Geospatial Analysis: A Comprehensive Guide to Principles, Techniques and Software Tools|first1=Michael John|last1=De Smith|first2=Michael F.|last2=Goodchild|first3=Paul|last3=Longley|publisher=Troubadour Publishing Ltd|year=2007|isbn=9781905886609|page=344|url=https://books.google.com/books?id=SULMdT8qPwEC&pg=PA344|access-date=2020-03-04|archive-url=https://web.archive.org/web/20170227203644/https://books.google.com/books?id=SULMdT8qPwEC&pg=PA344|archive-date=2017-02-27|dead-url=no}}.</ref><ref name="pythalgs">{{citation|title=Python Algorithms: Mastering Basic Algorithms in the Python Language|first=Magnus Lie|last=Hetland|publisher=Apress|year=2010|isbn=9781430232377|page=214|url=https://books.google.com/books?id=9_AXCmGDiz8C&pg=PA214|access-date=2020-03-04|archive-url=https://web.archive.org/web/20170228104339/https://books.google.com/books?id=9_AXCmGDiz8C&pg=PA214|archive-date=2017-02-28|dead-url=no}}.</ref>。

戴克斯特拉算法本身采用了与[[Prim算法|Prim算法]]类似的[[贪心|贪心]]策略<ref name=Dijkstra1959 /><ref>{{citation|first=Robert Endre|last=Tarjan|authorlink=羅伯特·塔揚|title=Data Structures and Network Algorithms|series=CBMS_NSF Regional Conference Series in Applied Mathematics|volume=44|year=1983|publisher=Society for Industrial and Applied Mathematics|page=75|quote=The third classical minimum spanning tree algorithm was discovered by Jarník and rediscovered by Prim and Dikstra; it is commonly known as Prim's algorithm.}}</ref><ref>{{cite journal|last1=Prim|first1=R.C.|title=Shortest connection networks and some generalizations|journal=Bell System Technical Journal|date=1957|volume=36|issue=6|pages=1389–1401|doi=10.1002/j.1538-7305.1957.tb01515.x|url=http://bioinfo.ict.ac.cn/~dbu/AlgorithmCourses/Lectures/Prim1957.pdf|archiveurl=https://web.archive.org/web/20170718230207/http://bioinfo.ict.ac.cn/~dbu/AlgorithmCourses/Lectures/Prim1957.pdf|archivedate=18 July 2017|access-date=18 July 2017|bibcode=1957BSTJ...36.1389P}}</ref><ref>V. Jarník: ''O jistém problému minimálním'' [About a certain minimal problem], Práce Moravské Přírodovědecké Společnosti, 6, 1930, pp. 57–63. (in Czech)</ref>。[[快速行进算法|快速行进算法]]与戴克斯特拉算法同样有相似之处<ref>{{cite journal |author1=Danielsson, Per-Erik |coauthors=Lin, Qingfen |title=A Modified Fast Marching Method |journal=Image Analysis |date=24 June 2003 |pages=1154-1161 |url=https://link.springer.com/chapter/10.1007/3-540-45103-X_151 |access-date=2020-03-25 |archive-date=2021-02-13 |archive-url=https://web.archive.org/web/20210213073541/https://link.springer.com/chapter/10.1007/3-540-45103-X_151 |dead-url=no }}</ref>。

== 参考源程序 ==                                                                                                                                   
以下是该算法使用堆优化的一个C++实现参考<ref>{{cite web |author1=geeksforgeeks |title=Dijkstra’s Shortest Path Algorithm using priority_queue of STL |url=https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/ |website=geeksforgeeks |access-date=2020-05-11 |archive-date=2021-02-13 |archive-url=https://web.archive.org/web/20210213073618/https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/ |dead-url=no }}</ref>：
<!--geeksforgeeks 属于CC-BY-SA，但并未声明具体是3.0还是4.0，原文有改动（除翻译外)，代码有修改-->
<syntaxhighlight lang="c++" line="1">
#include<bits/stdc++.h> 
using namespace std; 
# define INF 0x3f3f3f3f 
  
// iPair ==> Integer Pair（整数对）
typedef pair<int, int> iPair; 
  
// 加边
void addEdge(vector <pair<int, int> > adj[], int u, 
                                     int v, int wt) 
{ 
    adj[u].push_back(make_pair(v, wt)); 
    adj[v].push_back(make_pair(u, wt)); 
} 
   
  
// 计算最短路
void shortestPath(vector<pair<int,int> > adj[], int V, int src) 
{ 
    // 关于stl中的优先队列如何实现，参考下方网址：
    // http://geeksquiz.com/implement-min-heap-using-stl/ 
    priority_queue< iPair, vector <iPair> , greater<iPair> > pq; 
  
    // 距离置为正无穷大
    vector<int> dist(V, INF); 
    vector<bool> visited(V, false);

    // 插入源点，距离为0
    pq.push(make_pair(0, src)); 
    dist[src] = 0; 
  
    /* 循环直到优先队列为空 */
    while (!pq.empty()) 
    { 
        // 每次从优先队列中取出顶点事实上是这一轮最短路径权值确定的点
        int u = pq.top().second; 
        pq.pop(); 
        if (visited[u]) {
            continue;
        }
        visited[u] = true;
        // 遍历所有边
        for (auto x : adj[u]) 
        { 
            // 得到顶点边号以及边权
            int v = x.first; 
            int weight = x.second; 
  
            //可以松弛
            if (dist[v] > dist[u] + weight) 
            { 
                // 松弛 
                dist[v] = dist[u] + weight; 
                pq.push(make_pair(dist[v], v)); 
            } 
        } 
    } 
  
    // 打印最短路
    printf("Vertex Distance from Source\n"); 
    for (int i = 0; i < V; ++i) 
        printf("%d \t\t %d\n", i, dist[i]); 
} 
int main() 
{ 
    int V = 9; 
    vector<iPair > adj[V]; 
    addEdge(adj, 0, 1, 4); 
    addEdge(adj, 0, 7, 8); 
    addEdge(adj, 1, 2, 8); 
    addEdge(adj, 1, 7, 11); 
    addEdge(adj, 2, 3, 7); 
    addEdge(adj, 2, 8, 2); 
    addEdge(adj, 2, 5, 4); 
    addEdge(adj, 3, 4, 9); 
    addEdge(adj, 3, 5, 14); 
    addEdge(adj, 4, 5, 10); 
    addEdge(adj, 5, 6, 2); 
    addEdge(adj, 6, 7, 1); 
    addEdge(adj, 6, 8, 6); 
    addEdge(adj, 7, 8, 7); 
  
    shortestPath(adj, V, 0); 
  
    return 0; 
} 
</syntaxhighlight>

以下是该算法Python的一个实现:
<syntaxhighlight lang="python" line="1">
import sys
max = sys.maxsize

vertices_number = 6
adjacency_matrix = [
    [0, 1, 10, -1, -1, 2],
    [10, 0, 1, -1, -1, -1],
    [1, 10, 0, -1, -1, -1],
    [-1, -1, 2, 0, 1, 10],
    [-1, -1, -1, 10, 0, 1],
    [-1, -1, -1, 1, 10, 0]]
start = []
dest = ["2", "5"]
key = []


def init_keys(s: int):
    global key
    key = [ max ] * vertices_number
    key[s] = 0


def dijkstra(from_vertex, dest_vertex):
    fid = int(from_vertex) - 1
    tid = int(dest_vertex) - 1
    init_keys(fid)
    rel = [fid]
    min_vertex = fid
    hop_path = {}

    while len(rel) <= vertices_number and min_vertex != tid:
        for i in range(vertices_number):
            if i != min_vertex and i not in rel and \
                adjacency_matrix[min_vertex][i] > 0 \
                and key[i] > key[min_vertex] + adjacency_matrix[min_vertex][i]:
                key[i] = key[min_vertex] + adjacency_matrix[min_vertex][i]
                hop_path.update({i + 1: {"from": min_vertex + 1, "cost": adjacency_matrix[min_vertex][i]}})

        if min_vertex not in rel:
            rel.append(min_vertex)

        min_vertex = tid
        for i in range(vertices_number):
            if i not in rel and key[i] < key[min_vertex]:
                min_vertex = i

    if len(hop_path) == 0 or int(dest_vertex) not in hop_path:
        return -1, -1
    else:
        next_hop = int(dest_vertex)
        path_str = dest_vertex
        while hop_path[next_hop]["from"] != int(from_vertex):
            cost = hop_path[next_hop]["cost"]
            next_hop = hop_path[next_hop]["from"]
            path_str =  "{} -({})-> {}".format(str(next_hop), cost ,path_str)
        path_str =  "{} -({})-> {}".format(str(hop_path[next_hop]["from"]), hop_path[next_hop]["cost"], path_str)

        return key[tid], path_str



def find_shortest_router():
    for s in start:
        print("Forwarding Table for {}".format(s))
        print("{:>10} {:>10}       {}".format("To", "Cost", "Path"))
        for d in dest:
            c, n = dijkstra(s, d)
            print("{:>10} {:>10}       {}".format(d, c, n))


def main():
    for i in range(1, vertices_number + 1):
        if str(i) not in dest:
            start.append(str(i))
    find_shortest_router()

if __name__ == '__main__':
    main()
</syntaxhighlight>

== 参见 ==
{{Portal|信息技术|计算机程序设计}}
* [[图论|图论]]
* [[A*搜尋演算法|A*搜尋演算法]]
* [[贝尔曼-福特算法|贝尔曼-福特算法]]
* [[宽度优先搜索|宽度优先搜索]]
* [[Flood_fill|Flood fill]]
* [[Floyd-Warshall算法|Floyd-Warshall算法]]
* [[最长路径问题|最长路径问题]]

== 參考 ==
===参考文献===
{{Reflist|30em}}

===扩展阅读===
{{refbegin}}
* {{cite book  | first1 = Thomas H. | last1 = Cormen | first2 = Charles E. | last2 = Leiserson | author3-link = Ronald L. Rivest | first3 = Ronald L. | last3 = Rivest  | first4 = Clifford | last4 = Stein | title = ''[[算法导论|Introduction to Algorithms]]'' | edition = second | publisher = [[麻省理工学院出版社|MIT Press]]、[[标普全球|S&P Global]] | year = 2001 | isbn = 0-262-03293-7 | chapter = Section 24.3: Dijkstra's algorithm | pages = 595–601 | ref = harv}}
* {{cite journal
 | last = Dial | first = Robert B.
 | doi = 10.1145/363269.363610
 | issue = 11
 | journal = [[ACM通讯|CACM]]
 | pages = 632–633
 | title = Algorithm 360: Shortest-path forest with topological ordering [H]
 | volume = 12
 | year = 1969
 | ref = harv}}
* {{cite journal | first1 = F. Benjamin | last1 = Zhan | first2 = Charles E. | last2 = Noon |date=February 1998 | title = Shortest Path Algorithms: An Evaluation Using Real Road Networks | url = https://archive.org/details/sim_transportation-science_1998-02_32_1/page/65 | journal = Transportation Science | volume = 32 | issue = 1 | pages = 65–73 | doi = 10.1287/trsc.32.1.65}}
* {{cite journal|first1=D.E.|last1=Knuth|title=A Generalization of Dijkstra's Algorithm|journal=Information Processing Letters|volume=6|number=1|pages=1–5|year=1977|authorlink1=Donald Knuth|doi=10.1016/0020-0190(77)90002-3}}
* {{cite journal|first1=Ravindra K.|last1=Ahuja|first2=Kurt|last2=Mehlhorn|first3=James B.|last3=Orlin|first4=Robert E.|last4=Tarjan|title=Faster Algorithms for the Shortest Path Problem|journal=Journal of Association for Computing Machinery (ACM)|volume=37|number=2|pages=213–223| date=April 1990 |doi=10.1145/77600.77615|ref=harv}}
*{{cite journal|first1=Rajeev|last1=Raman|title=Recent results on the single-source shortest paths problem|journal=SIGACT News|volume=28|issue=2|pages=81–87|year=1997|ref=harv|doi=10.1145/261342.261352}}
*{{cite journal|first1=Mikkel|last1=Thorup|title=On RAM priority Queues|journal=SIAM Journal on Computing|volume=30|issue=1|pages=86–109|year=2000|doi=10.1137/S0097539795288246|ref=harv}}
*{{cite journal|first1=Mikkel|last1=Thorup|title=Undirected single-source shortest paths with positive integer weights in linear time|journal=journal of the ACM|volume=46|issue=3|pages=362–394|year=1999|doi=10.1145/316542.316548|ref=harv|url=http://www.diku.dk/users/mthorup/PAPERS/sssp.ps.gz|author=|access-date=2017-11-01|archive-url=https://web.archive.org/web/20170921234030/http://www.diku.dk/users/mthorup/PAPERS/sssp.ps.gz|archive-date=2017-09-21|dead-url=yes}}
*{{cite journal |author1=ZHANG Lin-guang,FANG Jin-yun,SHEN Pai-wei |title=An Improved Dijkstra Algorithm Based on Pairing Heap |journal=Journal of Image and Graphics |date=2007-05}}
{{refend}}

== 外部連結 ==
{{Commons category|Dijkstra's algorithm}}

* [http://v.youku.com/v_show/id_XMjQyOTY1NDQw.html 迪科斯彻算法分解演示视频（优酷）] {{Wayback|url=http://v.youku.com/v_show/id_XMjQyOTY1NDQw.html |date=20210213073618 }}
* [http://www.cs.sunysb.edu/~skiena/combinatorica/animations/dijkstra.html Animation of Dijkstra's algorithm] {{Wayback|url=http://www.cs.sunysb.edu/~skiena/combinatorica/animations/dijkstra.html |date=20140219102217 }}
* [http://www.boost.org/libs/graph/doc/index.html The Boost Graph Library (BGL)] {{Wayback|url=http://www.boost.org/libs/graph/doc/index.html |date=20081202234015 }}
* [http://students.ceid.upatras.gr/~papagel/english/java_docs/minDijk.htm Interactive Implementation of Dijkstra's Algorithm] {{Wayback|url=http://students.ceid.upatras.gr/~papagel/english/java_docs/minDijk.htm |date=20200217212029 }}
* [https://web.archive.org/web/20070927234553/http://www-b2.is.tokushima-u.ac.jp/~ikeda/suuri/dijkstra/Dijkstra.shtml Shortest Path Problem: Dijkstra's Algorithm]
* [http://blog.cleancoder.com/uncle-bob/2016/10/26/DijkstrasAlg.html Dijkstra算法使用TDD的一个实现] {{Wayback|url=http://blog.cleancoder.com/uncle-bob/2016/10/26/DijkstrasAlg.html |date=20201229133730 }}
* [http://www.gilles-bertrand.com/2014/03/disjkstra-algorithm-description-shortest-path-pseudo-code-data-structure-example-image.html Graphical explanation of Dijkstra's algorithm step-by-step on an example] {{Wayback|url=http://www.gilles-bertrand.com/2014/03/disjkstra-algorithm-description-shortest-path-pseudo-code-data-structure-example-image.html |date=20210317123138 }}

{{算法}}

[[Category:艾兹赫尔·戴克斯特拉|Category:艾兹赫尔·戴克斯特拉]]
[[Category:图算法|Category:图算法]]
[[Category:搜尋演算法|Category:搜尋演算法]]
[[Category:组合优化|Category:组合优化]]
[[Category:带有伪代码示例的条目|Category:带有伪代码示例的条目]]
[[Category:路由算法|D]]
[[Category:圖算法|D]]