[[File:DotNet_Remoting_Architecture.png|thumb]]
{{noteTA|G1=IT}}

'''.NET远程处理'''<ref>{{Cite web |url= http://msdn.microsoft.com/zh-cn/library/72x4h507.aspx |title= .NET 远程处理 |accessdate= 2013-01-03 |archive-date= 2013-05-11 |archive-url= https://web.archive.org/web/20130511081831/http://msdn.microsoft.com/zh-cn/library/72x4h507.aspx |dead-url= no }}</ref>（'''.NET Remoting''' ）是微軟 [[.NET_Framework|.NET Framework]] 中的一種網路通訊技術，與 XML Web Service 不同的是，它可以使用 SOAP 以外的協定來通訊，而在伺服端和用戶端之間所操作的方法近乎相同，用戶端可以不必考慮使用的協定，即可存取伺服端所開放的物件。這個技術與是由[[Distributed_COM|Distributed COM]]所發展而來的，與DCOM最大的不同是，DCOM有限制使用 TCP Port，但.NET Remoting 可以選擇使用 TCP 或 HTTP 的方式通訊，而資料可以利用 SOAP 或二進位傳輸方式在網路上流動，二進位的傳輸效能是 SOAP 所不能比的，但 SOAP 卻可以得到和 Web Service 相互溝通的能力，因此 .NET Remoting 的設計彈性較大。

.NET Remoting 技術目前已整合到 [[Windows_Communication_Foundation|Windows Communication Foundation]] 中。

== 原理 ==

.NET Remoting 使用了 '''信道''' 和 '''序列化''' 機制來串接兩台機器間的物件，信道是負責處理網路通訊的部份，而序列化則是處理物件與串流資料的處理工作。

* 信道支援了 IPC（行程間通訊）、TCP 與 HTTP 通訊協定<ref>{{Cite web |url=http://msdn.microsoft.com/en-us/library/bb552616.aspx |title=Channels |accessdate=2008-09-30 |archive-date=2016-04-02 |archive-url=https://web.archive.org/web/20160402211916/https://msdn.microsoft.com/en-us/library/bb552616.aspx |dead-url=no }}</ref>。
* 序列化支援二進位（binary）或 XML（SOAP）通訊協定的資料串流<ref>{{Cite web |url=http://msdn.microsoft.com/en-us/library/bb552674.aspx |title=Serialization Formatters |accessdate=2008-09-30 |archive-date=2016-05-09 |archive-url=https://web.archive.org/web/20160509014604/https://msdn.microsoft.com/en-us/library/bb552674.aspx |dead-url=no }}</ref>。

當伺服端設定好使用的通道以及協定後，用戶端必須要跟隨伺服端的設定，並且依伺服端決定的活化模型來啟動，而程式設計的方法和一般呼叫元件般簡單。

<syntaxhighlight lang="csharp">
public static void Main()
{
   RemotingConfiguration.Configure("Client.exe.config"); // 读取设置
   RemotableType remoteObject = new RemotableType(); // 创建可远程处理对象
   Console.WriteLine(remoteObject.SayHello()); // 调用远程方法
}
</syntaxhighlight>

== 組態設定 ==

.NET Remoting 的設計理念，就是為了要簡化網路上的物件通訊，而且要讓開發人員不必太過於在通訊的底層傷腦筋，因此在網路通訊協定上做了許多的包裝，並且允許在 Configuration File（app.config）中直接設定，或是由 .NET Remoting 的 Configuration API 來設定即可，故組態設定的選項複雜度較高，設計較複雜的 .NET Remoting 應用程式在組態的設定上往往會相當複雜。

以下為設定 .NET Remoting 用戶端的範例設定：

<syntaxhighlight lang="xml">
<configuration>
   <system.runtime.remoting>
      <application>
         <client>
            <wellknown 
               type="RemotableType, RemotableType"
               url="http://localhost:8989/RemotableType.rem"
            />
         </client>
      </application>
   </system.runtime.remoting>
</configuration>
</syntaxhighlight>

== 活化模型 ==

活化（Activation）是指用戶端啟動伺服端元件的方式，.NET Remoting 中支援了兩種方式<ref>{{Cite web |url=http://msdn.microsoft.com/en-us/library/bb552668.aspx |title=Activation of Remote Objects |accessdate=2008-09-30 |archive-date=2008-10-18 |archive-url=https://web.archive.org/web/20081018095708/http://msdn.microsoft.com/en-us/library/bb552668.aspx |dead-url=no }}</ref>：

* '''Single-Call'''：在每一次用戶端呼叫時都生成一個執行個體。 
* '''Single-ton'''：在第一次呼叫時就生成執行個體，之後每一次呼叫都使用相同的執行個體。

== 物件傳遞 ==

在 .NET Remoting 中，不論是傳值或傳址，每一個物件都必須要繼承 '''System.MarshalByRefObject''' 類別，才可以利用 .NET Remoting 來傳輸<ref>{{Cite web |url=http://msdn.microsoft.com/en-us/library/h8f0y3fc.aspx |title=Making Object Remotable |accessdate=2008-09-30 |archive-date=2010-01-23 |archive-url=https://web.archive.org/web/20100123042850/http://msdn.microsoft.com/en-us/library/h8f0y3fc.aspx |dead-url=no }}</ref>。

以下程式碼為伺服端的 Remoting 元件：

<syntaxhighlight lang="csharp">
// RemotableType.cs
using System;
public class RemotableType : MarshalByRefObject // Remoting 物件必須繼承自 System.MarshalByRefObject 類別。
{
    public string SayHello()
    {
        Console.WriteLine("RemotableType.SayHello() was called!");
        return "Hello, world";
    }
}
</syntaxhighlight>

== 參考資料 ==
<div class="references-small">
<references />
</div>

{{Microsoft APIs}}
{{DotNET}}

[[Category:.NET|Category:.NET]]
[[Category:进程间通信|Category:进程间通信]]