{{NoteTA
|G1 = IT
|G2 = Math
}}
{{算法信息框
|image=[[File:MST_kruskal_en.gif|255px]]
|class=[[最小生成树|最小生成树]]
|data=[[并查集|并查集]]
|best-time=
|average-time=<math>O (|E| \log |V|)</math>
|space=<math>\Omega (|E| + |V|)</math>
|time=
}}
{{图搜索算法}}
{{Unreferenced|time=2013-04-04T02:01:48+00:00 }}
'''Kruskal演算法'''是一種用來尋找[[最小生成樹|最小生成樹]]的演算法，由Joseph Kruskal在1956年發表。用來解決同樣問題的還有[[Prim演算法|Prim演算法]]和{{tsl|en|Kruskal's algorithm|Boruvka演算法}}等。三種演算法都是[[贪心法|贪心算法]]的應用。和Boruvka演算法不同的地方是，Kruskal演算法在圖中存在相同權值的邊時也有效。

== 步驟 ==
# 新建圖G，G中擁有原圖中相同的節點，但沒有邊
# 將原圖中所有的邊按權值從小到大排序
# 從權值最小的邊開始，如果這條邊連接的兩個節點於圖G中不在同一個連通分量中，則添加這條邊到圖G中
# 重複3，直至圖G中所有的節點都在同一個連通分量中

== 證明 ==
#這樣的步驟保證了選取的每條邊都是橋，因此圖G構成一個樹。
#為什麼這一定是最小生成樹呢？關鍵還是步驟3中對邊的選取。演算法中總共選取了n-1條邊，每條邊在選取的當時，都是連接兩個不同的連通分量的權值最小的邊
#要證明這條邊一定屬於最小生成樹，可以用反證法：如果這條邊不在最小生成樹中，它連接的兩個連通分量最終還是要連起來的，通過其他的連法，那麼另一種連法與這條邊一定構成了環，而環中一定有一條權值大於這條邊的邊，用這條邊將其替換掉，圖仍舊保持連通，但總權值減小了。也就是說，如果不選取這條邊，最後構成的生成樹的總權值一定不會是最小的。

== 時間複雜度 ==
平均时间复杂度为<math>\Omicron(|E| \log |V|)</math>，其中<math>E</math>和<math>V</math>分别是图的边集和点集。

== 示例 ==

{| border=1 cellspacing=2 cellpadding=5 class="wikitable"
! 图例 !! 说明
|-
|[[Image:Kruskal_Algorithm_1.svg|200px]]
|'''AD'''和'''CE'''是最短的两条边，长度为5，其中'''AD'''被任意选出，以高亮表示。
|-
|[[Image:Kruskal_Algorithm_2.svg|200px]]
|现在'''CE'''是不属于环的最短边，长度为5，因此第二个以高亮表示。
|-
|[[Image:Kruskal_Algorithm_3.svg|200px]]
|下一条边是长度为6的'''DF'''，同样地以高亮表示。
|-
|[[Image:Kruskal_Algorithm_4.svg|200px]]
|接下来的最短边是'''AB'''和'''BE'''，长度均为7。'''AB'''被任意选中，并以高亮表示。边'''BD'''用红色高亮表示，因为'''B'''和'''D'''之间已经存在一条（标为绿色的）路径，如果选择它将会构成一个环（'''ABD'''）。
|-
|[[Image:Kruskal_Algorithm_5.svg|200px]]
|以高亮表示下一条最短边'''BE'''，长度为7。这时更多的边用红色高亮标出：会构成环'''BCE'''的'''BC'''、会构成环'''DBEA'''的'''DE'''以及会构成环'''FEBAD'''的'''FE'''。
|-
|[[Image:Kruskal_Algorithm_6.svg|200px]]
|最终，标记长度为9的边'''EG'''，得到最小生成树，结束算法过程。
|}

== 演算法 ==
 -{}-
 KRUSKAL-FUNCTION(G, w)
 1    F := 空集合
 2    '''for each''' 图 G 中的顶点 v
 3        '''do''' 將 v 加入森林 F
 4    所有的边(u, v) ∈ E依权重 w 递增排序
 5    '''for each''' 边(u, v) ∈ E
 6        '''do if''' u 和 v 不在同一棵子树
 7            '''then''' F := F ∪ {(u, v)}
 8                將 u 和 v 所在的子树合并

{{算法}}
[[Category:图算法|Category:图算法]]