{{NoteTA
|G1 = IT
}}
{{Algorithms
|Name = 深度优先搜索
|Image = [[File:Depth-first-tree.svg|none]]
|Caption = 節點進行深度优先搜索的順序
|Class = [[搜索演算法|搜索演算法]]
|DataStructure = [[圖|圖]]
|TimeComp = <math>O(b^m)</math>
|SpaceComp = <math>O(bm)</math>
|Optimal = 否
|Complete = 是
|Var1 = <math>b</math>
|Def1=[[分支因子|分支係數]]
|Var2=<math>m</math>
|Def2=圖的最大深度
}}
{{图算法}}
'''深度优先搜索算法'''（{{lang-en|Depth-First-Search}}，{{lang|en|DFS}}）是一种用于遍历或搜索[[树_(数据结构)|树]]或[[图_(数学)|图]]的[[算法|算法]]。这个算法会尽可能深地搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。<ref name="ItoA">{{Cite book|title=Introduction to Algorithms|isbn=978-7-111-40701-0|trans-title=算法导论}}</ref>{{Rp|page=603}}{{FACT|这种算法不会根据图的结构等信息调整执行策略|time=2020-03-18}}。

深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的[[拓扑排序|拓扑排序]]表<ref name="ItoA" />{{Rp|page=612}}，利用拓扑排序表可以方便的解决很多相关的[[图论|图论]]问题，如无权最长路径问题等等。

因发明“深度优先搜索算法”，[[約翰·霍普克洛夫特|約翰·霍普克洛夫特]]与[[罗伯特·塔扬|罗伯特·塔扬]]在[[1986年|1986年]]共同获得计算机领域的最高奖：[[图灵奖|图灵奖]]。<ref>{{cite web |url=https://amturing.acm.org/award_winners/tarjan_1092048.cfm |title=Robert E Tarjan - A.M. Turing Award Winner |language=en |accessdate=2017-10-29 |archive-date=2017-10-30 |archive-url=https://web.archive.org/web/20171030003443/https://amturing.acm.org/award_winners/tarjan_1092048.cfm |dead-url=no }}</ref>

== 演算方法 ==
# 首先将根节点放入<var>stack</var>中。
# 从<var>stack</var>中取出第一个节点，并检验它是否为目标。
#: 如果找到目标，则结束搜寻并回传结果。
#: 否则将它某一个尚未检验过的直接子节点加入<var>stack</var>中。
# 重复步骤2。
# 如果不存在未检测过的直接子节点。
#: 将上一级节点加入<var>stack</var>中。
#: 重复步骤2。
# 重复步骤4。
# 若<var>stack</var>为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。

== C++的實作 ==
定义一个结构体来表达一個二叉树的[[节点|节点]]的结构：
<syntaxhighlight lang="cpp" line="1">
struct Node {
    int self;     // 数据
    Node *left;   // 左孩子
    Node *right;  // 右孩子
};
</syntaxhighlight>
那么我们在搜索一个树的时候，从一个[[节点|节点]]开始，能首先获取的是它的两个子节点。例如：
{{cquote|
                  A
            B           C
       D   E          F   G
                                       }}

A是第一个访问的，然后顺序是B和D、然后是E。然后再是C、F、G。那么我们怎么来保证这个顺序呢？

这里就应该用[[堆栈|堆栈]]的结构，因为堆栈是一个后进先出(LIFO)的顺序。通过使用[[C++|C++]]的[[標準模板庫|STL]]，下面的程序能帮助理解：
<syntaxhighlight lang="cpp" line="1">
const int TREE_SIZE = 9;
std::stack<Node *> unvisited;
Node nodes[TREE_SIZE];
Node *current;

//初始化树
for (int i = 0; i < TREE_SIZE; i++) {
    nodes[i].self = i;
    int child = i * 2 + 1;
    if (child < TREE_SIZE) // Left child
        nodes[i].left = &nodes[child];
    else
        nodes[i].left = NULL;
    child++;
    if (child < TREE_SIZE) // Right child
        nodes[i].right = &nodes[child];
    else
        nodes[i].right = NULL;
}

unvisited.push(&nodes[0]); //先把0放入UNVISITED stack

// 树的深度优先搜索在二叉树的特例下，就是二叉树的先序遍历操作（这里是使用循环实现）
// 只有UNVISITED不空
while (!unvisited.empty()) {
    current = (unvisited.top()); //当前访问的
    unvisited.pop();
    if (current->right != NULL)
        unvisited.push(current->right );
    if (current->left != NULL)
        unvisited.push(current->left);
    cout << current->self << endl;
}
</syntaxhighlight>

== 参考文献 ==
{{Reflist}}

== 參見 ==
* [[广度优先搜索|广度优先搜索]]

{{算法}}

[[Category:圖演算法|Category:圖演算法]]
[[Category:搜尋演算法|Category:搜尋演算法]]
[[Category:带有代码示例的条目|Category:带有代码示例的条目]]