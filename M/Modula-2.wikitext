{{NoteTA
|G1=IT
}}
{{Infobox programming language
| name                   = Modula-2
| logo                   = 
| paradigm               = [[指令式編程|指令式]]、[[结构化编程|结构化]]、[[模块化编程|模块化]]、{{tsl|en|information hiding|数据和方法隐藏}}、[[并发计算|并发]]
| family = [[尼克劳斯·维尔特|Wirth]] [[Modula|Modula]]
| year                   = {{start date and age|1978}}
| designer               = [[尼克劳斯·维尔特|尼克劳斯·维尔特]]
| typing                 = 强，静态
| platform = {{en-link|Lilith (计算机)|Lilith (computer)|Lilith}}（[[Advanced_Micro_Devices|AMD]] {{en-link|AMD Am2900|AMD Am2900|2901}}）
| dialects               = PIM2、PIM3、PIM4、ISO
| implementations        = [[Niklaus_Wirth|Niklaus Wirth]]編写的[https://web.archive.org/web/20080803231305/http://www.sysecol.ethz.ch/RAMSES/MacMETH.html ETH编译器], [http://www.nongnu.org/gm2/ GNU Modula-2], [http://www.modula2.org/ ADW Modula-2]
| influenced_by          = [[Modula|Modula]], [[Mesa语言|Mesa]], [[Pascal_(程式語言)|Pascal]], [[ALGOL_W|ALGOL W]], {{tsl|en|Euclid (programming language)||Euclid}}
| influenced             = [[Modula-3|Modula-3]], [[Oberon|Oberon]], [[Ada|Ada]], [[Fortran|Fortran]], [[Lua|Lua]], {{tsl|en|Seed7}}, {{tsl|en|Zonnon}}, Modula-GM
| operating_system       = [[跨平台|跨平台]]
| license                = 
| file_ext               = .mod .m2 .def .MOD .DEF .mi .md
| website                = {{URL|www.modula2.org}}
}}

'''Modula-2'''，是一种通用的结构化[[过程式编程|过程式]][[编程语言|编程语言]]，由[[尼克劳斯·维尔特|尼克劳斯·维尔特]]在1978年至1985年间于[[苏黎世联邦理工学院|苏黎世联邦理工学院]]开发。它具有充分的灵活性用于[[系统编程|系统编程]]，和更加广阔应用领域。特别是，它被设计为以一种直接的方式支持分离编译和数据抽象。它的很多语法基于了维尔特早先的周知语言[[Pascal语言|Pascal]]。

==历史==
在1976年至1977年年間，维尔特在[[Xerox|Xerox]] [[Palo_Alto|Palo Alto]][[帕羅奧多研究中心|研究中心]]，與一群設計[[Xerox_Alto|Alto]]電腦的工作夥伴一同工作。1978年，维尔特在瑞士聯邦理工學院資訊研究所，根據其早期對[[Pascal程式語言|Pascal程式語言]]、[[Modula|Modula]]模組程式語言、及Alto電腦的經驗，定義了Modula-2語言，他還開始了一個{{en-link|Lilith (计算机)|Lilith (computer)|Lilith}}個人電腦計畫。

Modula-2語言本身與Lilith結構之設計，都以優雅及簡單為原則，是以Modula-2為Lilith的系統程式語言，而不需用到[[組譯器|組譯器]]，並且以Lilith為Modula-2的組織架構。為此，Modula-2語言不僅要適用於編寫高階的應用程式，也要應適用於編寫低階的與機器相關的編碼程式，用於裝置的操控與儲存體的配置。

Modula-2提供了一些標準程式庫模組，如異常處置、字串處理、輸入/輸出及並行程式設計等，通過重複使用它們來降低語言本身的複雜度。在Lilith計畫從1978年到1988年的整個生命期中，作業系統、繪圖套裝軟體、資料庫系統、網路協議、檔案伺服器，及許多其他系統和應用模組，都是藉著Modula-2發展出來的。

== 描述 ==
Modula-2被设计为显著的类似于[[Pascal语言|Pascal]]，移除了一些元素和语法歧义，增补了“[[模块化编程|模块]]”这个重要概念，并且对[[多道程序|多道程序]]有直接的语言支持。维尔特将Modula-2看作他早期的编程语言[[Pascal语言|Pascal]]和[[Modula|Modula]]的后继者<ref>{{cite book |last=Wirth |first=Niklaus |author-link=Niklaus Wirth |chapter=Pascal and its Successors |date=2002 |editor1-last=Broy |editor1-first=Manfred |editor2-last=Denert |editor2-first=Ernst |title=Software Pioneers: Contributions to Software Engineering |url=https://archive.org/details/softwarepioneers00broy |location=Berlin, Heidelberg |publisher=[[Springer-Verlag|Springer-Verlag]] |pages=[https://archive.org/details/softwarepioneers00broy/page/n105 108]–120 |doi=10.1007/978-3-642-59412-0 |isbn=978-3-642-59412-0}}</ref><ref>{{cite magazine |last=Wirth |first=Niklaus |author-link=Niklaus Wirth |date=18 February 2005 |title=History and Goals of Modula-2 |url=https://www.drdobbs.com/open-source/history-and-goals-of-modula-2/223000094 |magazine=[[Dr._Dobb's_Journal|Dr. Dobb's Journal]] |publisher=Informa PLC |access-date=2021-06-15 |archive-date=2021-04-10 |archive-url=https://web.archive.org/web/20210410115207/https://www.drdobbs.com/open-source/history-and-goals-of-modula-2/223000094 }}</ref>。主要的概念是：
# [[模块化编程|模块]]是分离编译的编译单元。
# [[协程|协程]]是[[并发计算|并发处理]]的基本建造块。
# 类型和过程允许访问特定于机器的数据。

Modula-2提供了（有限的）单处理器并发（[[监视器_(程序同步化)|监视器]]、[[协程|协程]]和显式控制转移）和硬件访问（绝对地址、位操纵和[[中断|中断]]）。它使用了{{en-link|名称类型系统|nominal type system}}。Modula-2语言允许使用{{en-link|一趟编译器|One-pass compiler}}。{{en-link|Jürg Gutknecht|Jürg Gutknecht|Gutknecht}}和维尔特的这种[[编译器|编译器]]大致上比早前的{{en-link|多趟编译器|Multi-pass compiler}}要快上四倍<ref>{{cite web |last=Wirth |first=Niklaus |author-link=Niklaus Wirth |date=1 May 1984 |title=A Single-pass Modula-2 Compiler for Lilith |url=http://www.cfbsoftware.com/modula2/M2SinglePass.pdf |website=CFB Software |access-date=28 January 2019 |archive-date=2021-01-24 |archive-url=https://web.archive.org/web/20210124155936/https://www.cfbsoftware.com/modula2/M2SinglePass.pdf }}</ref>。

Modula-2有两种主要方言：PIM和[[国际标准化组织|ISO]]，PIM得名于Niklaus Wirth的著作《Programming in Modula-2》<ref name="PIM">{{cite book |last=Wirth |first=Niklaus |author-link=Niklaus Wirth |title=Programming in Modula-2 |year=1988 |location=Berlin, Heidelberg |publisher=Springer |edition=4th |isbn=978-3-642-83565-0 |doi=10.1007/978-3-642-83565-0}} Page 4.</ref>，这本书一共有四个版本，成为方言的是PIM2、PIM3和PIM4。

==例子代码==
下面是"[[Hello_world|Hello world]]"程序的Modula-2源代码例子：

<syntaxhighlight lang="modula2">
MODULE Hello;
FROM STextIO IMPORT WriteString;
BEGIN
  WriteString("Hello World!");
END Hello.
</syntaxhighlight>

==模块==
Modula-2的模块（module），可以用来封装一组有关的子程序和数据结构，并限制它们对程序其他部份的可见性。模块设计以清晰的方式，实现了Modula-2的数据抽象特征。语言有严格的[[作用域|作用域]]控制。模块的作用域，可以被当作是不可逾越的墙：除了标准标识符之外，来自外部的[[对象_(计算机科学)|对象]]在模块内是不可见的，除非显式的导入它；内部的模块对象在外部是不可见的，除非显式的导出它。

Modula-2程序是由模块组成，其中“程序模块”包含一个Modula-2程序的主程序。所有Modula-2程序，必须有定义了执行开始之处的一个主程序。在一个单一的程序中，不能有链接在一起的两个程序模块。“局部模块”是在其他模块内声明的模块。程序模块和局部模块的起始关键字，就是单独的{{code|MODULE|"modula2"}}。

===定义模块与实现模块===
除了程序模块之外的“全局模块”，都构成自两个部份：作为接口部份的“定义模块”，它只包含“导出”（对其他模块可见）的那部份子系统，和同名的“实现模块”，它包含模块内部的工作代码：
<syntaxhighlight lang="modula2">
DEFINITION MODULE GM;
  ...
  
IMPLEMENTATION MODULE GM;
  ...
</syntaxhighlight>

定义模块中可以包含{{en-link|不透明数据类型|Opaque data type|不透明类型}}声明，它有如下形式：
<syntaxhighlight lang="modula2">
TYPE name;
</syntaxhighlight>
它对应的实际类型，对于这个模块的用户是不可见的。这个类型名字，可以用在定义模块内的其他声明之中。对于在定义模块中声明的任何不透明类型，在对应的实现模块中，必须包含它的完全类型声明。完全类型声明，必须定义一个指针类型。

===导出===
假定局部模块<code>M1</code>导出对象<code>a</code>、<code>b</code>、<code>c</code>和<code>P</code>，可将它们的标识符列举于显式<code>EXPORT</code>导出列表之中：
<syntaxhighlight lang="modula2">
MODULE M1;
  EXPORT a, b, c, P;
  ...
</syntaxhighlight>

如果加上了可选的关键字<code>QUALIFIED</code>，它们以一种有限制的方式给导出至外部，必须将导出的这个模块名字用作限定符，并跟随着对象的名字。这里的来自模块<code>M1</code>的对象<code>a</code>、<code>b</code>、<code>c</code>和<code>P</code>，在模块<code>M1</code>外部就叫做<code>M1.a</code>、<code>M1.b</code>、<code>M1.c</code>和<code>M1.P</code>。

1983年的PIM2，在定义模块中要求显式的<code>EXPORT</code>子句；而1985年的PIM3，从定义模块中删除了<code>EXPORT</code>子句，因为发现了它是多余的。

===导入===
假定模块<code>M2</code>包含下列<code>IMPORT</code>声明：

<syntaxhighlight lang="modula2">
MODULE M2;
  IMPORT M1;
  ...
</syntaxhighlight>

然后这意味着模块<code>M1</code>导出至它所包围的程序的外部的对象，现在可以用在模块<code>M2</code>内部。它们以一种限定方式来引用，也就是<code>M1.a</code>、<code>M1.b</code>、<code>M1.c</code>和<code>M1.P</code>。例如：

<syntaxhighlight lang="modula2">
  ...
  M1.a := 0;
  M1.c := M1.P(M1.a + M1.b);
  ...
</syntaxhighlight>

限定导出避免了名字冲突：例如，如果另一个模块<code>M3</code>也导出了一个对象叫做<code>P</code>，那么我们仍可以区分这两个对象，因为<code>M1.P</code>不同于<code>M3.P</code>。凭借限定导出，两个对象在它们的导出模块<code>M1</code>和<code>M3</code>中都叫做<code>P</code>是不碍事的。

存在一种可作为替代的方式，它在Modula-2编程者中广泛采用。假定模块<code>M3</code>是公式化为如下：

<syntaxhighlight lang="modula2">
MODULE M3;
  FROM M1 IMPORT a, b, c, P;
</syntaxhighlight>

然后这意味着模块<code>M1</code>导出至外部的对象，可以用在模块<code>M3</code>内部，但可以用无限定方式来引用导出的标识符，也就是<code>a</code>、<code>b</code>、<code>c</code>和<code>P</code>。例如：

<syntaxhighlight lang="modula2">
  ...
  a := 0;
  c := P(a + b);
  ...
</syntaxhighlight>

这种无限定导入的方法，允许在其导出模块之外，以同在它们的导出模块之内一样简单的方式，来使用这些变量和其他对象。对于所有这些已经被显式允许的对象，包围所有模块的墙变得与它们无关了。当然无限定导入只在没有名字冲突时是可用的。

这些导出和导入规则，看起来可能是没有必要的限制和冗余的。但是它们不只是守卫对象免于不希望的访问，而且还有一个让人愉悦的副作用，提供了在程序中定义的所有标识符的自动交叉引用：如果标识符被一个模块名字所限定，那么它的定义位于那个模块。否则如果它是无限定的出现的，简单的回溯查找，将会要么遇到这个标识符的声明，要么遇到它出现在一个<code>IMPORT</code>语句中，指出了它所来自的模块的名字。这个性质在尝试理解包含很多模块的大型程序时是非常有用的。

==评价==
Modula-2程式語言有幾項特色，使其在電腦科學的發展過程中，有著功不可沒的功勞。首先，它所提出的電腦架構、語言和作業環境的整合概念，是一項創舉；其次，它強調程式設計師，在使用者介面的設計上，至少需花費同於實作程式設計時所耗費的成本和努力。最後，它提出對抽象化資料的簡化。

Modula-2程式是由上而下的方式發展，其步驟乃是先建立定義資料抽象化介面規格的若干定義模組，在其中宣告其他程式設計師可能會引用到的程式標頭，此後再隨著需要建立對應的實作模組。它们個別分開來編譯，一旦編譯好就不必再改變。

== 參見 ==
*{{lang|en|[[Pascal语言|Pascal]]}}
*{{lang|en|[[Modula|Modula]]}}
*{{lang|en|[[Modula-3|Modula-3]]}}
*{{lang|en|[[Oberon|Oberon]] }}

==引用==
{{reflist|2}}

== 图书 ==
*{{cite book |last=Wirth |first=Niklaus |author-link=Niklaus Wirth |date=1988 |title=Programming in Modula-2 |edition=4th |url=https://link.springer.com/book/10.1007/978-3-642-83565-0 |location=[[Berlin|Berlin]] [[Heidelberg|Heidelberg]] |publisher=[[Springer-Verlag|Springer-Verlag]] |doi=10.1007/978-3-642-83565-0 |isbn=978-0-387-96051-7 |access-date=2021-06-14 |archive-date=2021-06-05 |archive-url=https://web.archive.org/web/20210605060051/https://link.springer.com/book/10.1007/978-3-642-83565-0 }}
*{{cite book |last=King |first=K. N. |date=1 January 1988 |title=Modula-2: A Complete Guide |url=http://knking.com/books/modula2/ |location=[[Burlington,_Massachusetts|Burlington, Massachusetts]] |publisher=Jones and Bartlett Publishers |isbn=978-0669110913 |access-date=2021-06-14 |archive-date=2020-02-19 |archive-url=https://web.archive.org/web/20200219222950/http://knking.com/books/modula2/ }}
*{{cite book |last=Sutcliffe |first=Richard J. |date=2004–2005 |title=Modula-2: Abstractions for Data and Programming Structures |url=http://www.arjay.bc.ca/Modula-2/Text/ |publisher=Arjay Books |isbn=978-0-669-11091-3 |access-date=2021-06-14 |archive-date=2021-01-26 |archive-url=https://web.archive.org/web/20210126182732/http://www.arjay.bc.ca/Modula-2/Text/ }} Uses ISO-standard Modula-2.
*{{cite book |last=Gleaves |first=Richard |date=1984 |title=Modula-2 for Pascal Programmers |series=Springer Books on Professional Computing |edition=1st |url=https://link.springer.com/book/10.1007%2F978-1-4613-8531-8 |location=Switzerland |publisher=Springer Nature |doi=10.1007/978-1-4613-8531-8 |isbn=978-0-387-96051-7 |access-date=2021-06-14 |archive-date=2021-06-14 |archive-url=https://web.archive.org/web/20210614115801/https://link.springer.com/book/10.1007%2F978-1-4613-8531-8 }}
*{{cite book |last=Cooper |first=Doug |date=1 September 1990 |title=Oh My! Modula-2: An Introduction to Programming |location=[[New_York_City|New York City]], [[New_York_(state)|New York]] |publisher=[[W._W._Norton_&_Company|W. W. Norton & Company]] |isbn=978-0393960099}}

== 外部連結 ==
* {{Official website|www.modula2.org}}

{{FOLDOC}}
{{程序设计语言}}

[[Category:Modula程式語言家族|Category:Modula程式語言家族]]
[[Category:ISO标准化编程语言|Category:ISO标准化编程语言]]
[[Category:静态类型编程语言|Category:静态类型编程语言]]
[[Category:系統程式語言|Category:系統程式語言]]
[[Category:1978年建立的程式語言|Category:1978年建立的程式語言]]