--[[
This module is intended to replace the functionality of {{Coord}} and related
templates.  It provides several methods, including

{{#invoke:Coordinates | coord }} : General function formatting and displaying
coordinate values.

{{#invoke:Coordinates | dec2dms }} : Simple function for converting decimal
degree values to DMS format.

{{#invoke:Coordinates | dms2dec }} : Simple function for converting DMS format
to decimal degree format.

{{#invoke:Coordinates | link }} : Export the link used to reach the tools

]]

require('Module:No globals')

local math_mod = require("Module:Math")
local coordinates = {};

local current_page = mw.title.getCurrentTitle()
local page_name = mw.uri.encode( current_page.prefixedText, 'WIKI' );
-- 请注意：此处要指明中文版
local coord_link = '//geohack.toolforge.org/geohack.php?language=zh&pagename=' .. page_name .. '&params='
local templatestyles = 'Module:Coordinates/styles.css'

--[[Helper_function,_replacement_for_{{coord/display/title}}|Helper function, replacement for {{coord/display/title}}]]
local function displaytitle(s, notes)
	local l = "[[地理坐标|-{zh-hans:坐标;zh-hant:座標}-]]：" .. s
	local co = '<span id="coordinates">' .. l .. notes .. '</span>';
	return '<span style="font-size: small;">' .. co .. '</span>';
end

--[[Helper_function,_Replacement_for_{{coord/display/inline}}|Helper function, Replacement for {{coord/display/inline}}]]
local function displayinline(s, notes)
	return s .. notes
end

--[[Helper_function,_used_in_detecting_DMS_formatting|Helper function, used in detecting DMS formatting]]
local function dmsTest(first, second)
	if type(first) ~= 'string' or type(second) ~= 'string' then
		return nil
	end
	local s = (first .. second):upper()
	return s:find('^[NS][EW]$') or s:find('^[EW][NS]$')
end


--[[Wrapper_function_to_grab_args,_see_Module:Arguments_for_this_function's_documentation.|Wrapper function to grab args, see Module:Arguments for this function's documentation.]]
local function makeInvokeFunc(funcName)
	return function (frame)
		local args = require('Module:Arguments').getArgs(frame, {
			wrappers = 'Template:Coord'
		})
		return coordinates[funcName](args, frame)
	end
end

--[[Helper_function,_handle_optional_args.|Helper function, handle optional args.]]
local function optionalArg(arg, supplement)
	return arg and arg .. supplement or ''
end

--[[
Formats any error messages generated for display
]]
local function errorPrinter(errors)
	local result = ""
	for i,v in ipairs(errors) do
		local errorHTML = '<strong class="error">坐标：' .. v[2] .. '</strong>'
		result = result .. errorHTML .. "<br />"
	end
	return result
end

--[[
Determine the required CSS class to display coordinates

Usually geo-nondefault is hidden by CSS, unless a user has overridden this for himself
default is the mode as specificied by the user when calling the {{coord}} template
mode is the display mode (dec or dms) that we will need to determine the css class for
]]
local function displayDefault(default, mode)
	if default == "" then
		default = "dec"
	end

	if default == mode then
		return "geo-default"
	else
		return "geo-nondefault"
	end
end

--[[
specPrinter

Output formatter.  Takes the structure generated by either parseDec
or parseDMS and formats it for inclusion on Wikipedia.
]]
local function specPrinter(args, coordinateSpec)
	local uriComponents = coordinateSpec["param"]
	if uriComponents == "" then
		-- RETURN error, should never be empty or nil
		return "ERROR param was empty"
	end
	if args["name"] then
		uriComponents = uriComponents .. "&title=" .. mw.uri.encode(coordinateSpec["name"])
	end

	local geodmshtml = '<span class="geo-dms" title="此地的地图、航拍照片和其他数据">'
			.. '<span class="latitude">' .. coordinateSpec["dms-lat"] .. '</span> '
			.. '<span class="longitude">' ..coordinateSpec["dms-long"] .. '</span>'
			.. '</span>'

	local lat = tonumber( coordinateSpec["dec-lat"] ) or 0
	local geodeclat
	if lat < 0 then
		-- FIXME this breaks the pre-existing precision
		geodeclat = tostring(coordinateSpec["dec-lat"]):sub(2) .. "°S"
	else
		geodeclat = (coordinateSpec["dec-lat"] or 0) .. "°N"
	end

	local long = tonumber( coordinateSpec["dec-long"] ) or 0
	local geodeclong
	if long < 0 then
		-- FIXME does not handle unicode minus
		geodeclong = tostring(coordinateSpec["dec-long"]):sub(2) .. "°W"
	else
		geodeclong = (coordinateSpec["dec-long"] or 0) .. "°E"
	end

	local geodechtml = '<span class="geo-dec" title="此地的地图、航拍照片和其他数据">'
			.. geodeclat .. ' '
			.. geodeclong
			.. '</span>'

	local geonumhtml = '<span class="geo">'
			.. coordinateSpec["dec-lat"] .. '; '
			.. coordinateSpec["dec-long"]
			.. '</span>'

	local inner = '<span class="' .. displayDefault(coordinateSpec["default"], "dms" ) .. '">' .. geodmshtml .. '</span>'
				.. '<span class="geo-multi-punct">﻿ / ﻿</span>'
				.. '<span class="' .. displayDefault(coordinateSpec["default"], "dec" ) .. '">';

	if not args["name"] then
		inner = inner .. geodechtml
				.. '<span style="display:none">﻿ / ' .. geonumhtml .. '</span></span>'
	else
		inner = inner .. '<span class="vcard">' .. geodechtml
				.. '<span style="display:none">﻿ / ' .. geonumhtml .. '</span>'
				.. '<span style="display:none">﻿ (<span class="fn org">'
				.. args["name"] .. '</span>)</span></span></span>'
	end

	return mw.getCurrentFrame():extensionTag{ name = 'templatestyles', args = { src = templatestyles} }
	       .. '<span class="plainlinks nourlexpansion">'
	       .. '[' .. coord_link .. uriComponents .. ' ' .. inner .. ']'
	       .. '</span>'
end

--[[Helper_function,_convert_decimal_to_degrees|Helper function, convert decimal to degrees]]
local function convert_dec2dms_d(coordinate)
	local d = math_mod._round( coordinate, 0 ) .. "°"
	return d .. ""
end

--[[Helper_function,_convert_decimal_to_degrees_and_minutes|Helper function, convert decimal to degrees and minutes]]
local function convert_dec2dms_dm(coordinate)
	coordinate = math_mod._round( coordinate * 60, 0 );
	local m = coordinate % 60;
	coordinate = math.floor( (coordinate - m) / 60 );
	local d = coordinate % 360 .."°"

	return d .. string.format( "%02d′", m )
end

--[[Helper_function,_convert_decimal_to_degrees,_minutes,_and_seconds|Helper function, convert decimal to degrees, minutes, and seconds]]
local function convert_dec2dms_dms(coordinate)
	coordinate = math_mod._round( coordinate * 60 * 60, 0 );
	local s = coordinate % 60
	coordinate = math.floor( (coordinate - s) / 60 );
	local m = coordinate % 60
	coordinate = math.floor( (coordinate - m) / 60 );
	local d = coordinate % 360 .."°"

	return d .. string.format( "%02d′", m ) .. string.format( "%02d″", s )
end

--[[
Helper function, convert decimal latitude or longitude to
degrees, minutes, and seconds format based on the specified precision.
]]
local function convert_dec2dms(coordinate, firstPostfix, secondPostfix, precision)
	local coord = tonumber(coordinate)
	local postfix
	if coord >= 0 then
		postfix = firstPostfix
	else
		postfix = secondPostfix
	end

	precision = precision:lower();
	if precision == "dms" then
		return convert_dec2dms_dms( math.abs( coord ) ) .. postfix;
	elseif precision == "dm" then
		return convert_dec2dms_dm( math.abs( coord ) ) .. postfix;
	elseif precision == "d" then
		return convert_dec2dms_d( math.abs( coord ) ) .. postfix;
	end
end

--[[
Convert DMS format into a N or E decimal coordinate
]]
local function convert_dms2dec(direction, degrees_str, minutes_str, seconds_str)
	local degrees = tonumber(degrees_str)
	local minutes = tonumber(minutes_str) or 0
	local seconds = tonumber(seconds_str) or 0

	local factor = 1
	if direction == "S" or direction == "W" then
		factor = -1
	end

	local precision = 0
	if seconds_str then
		precision = 5 + math.max( math_mod._precision(seconds_str), 0 );
	elseif minutes_str and minutes_str ~= '' then
		precision = 3 + math.max( math_mod._precision(minutes_str), 0 );
	else
		precision = math.max( math_mod._precision(degrees_str), 0 );
	end

	local decimal = factor * (degrees+(minutes+seconds/60)/60)
	return string.format( "%." .. precision .. "f", decimal ) -- not tonumber since this whole thing is string based.
end

--[[
Checks input values to for out of range errors.
]]
local function validate( lat_d, lat_m, lat_s, long_d, long_m, long_s, source, strong )
	local errors = {};
	lat_d = tonumber( lat_d ) or 0;
	lat_m = tonumber( lat_m ) or 0;
	lat_s = tonumber( lat_s ) or 0;
	long_d = tonumber( long_d ) or 0;
	long_m = tonumber( long_m ) or 0;
	long_s = tonumber( long_s ) or 0;

	if strong then
		if lat_d < 0 then
			table.insert(errors, {source, "指定了半球名称，但纬度 < 0"})
		end
		if long_d < 0 then
			table.insert(errors, {source, "指定了半球名称，但经度 < 0"})
		end
		--[[
		#coordinates is inconsistent about whether this is an error.  If globe: is
		specified, it won't error on this condition, but otherwise it will.

		For not simply disable this check.

		if long_d > 180 then
			table.insert(errors, {source, "longitude degrees > 180 with hemisphere flag"})
		end
		]]
	end

	if lat_d > 90 then
		table.insert(errors, {source, "纬度 > 90"})
	end
	if lat_d < -90 then
		table.insert(errors, {source, "纬度 < -90"})
	end
	if lat_m >= 60 then
		table.insert(errors, {source, "纬度分 >= 60"})
	end
	if lat_m < 0 then
		table.insert(errors, {source, "纬度分 < 0"})
	end
	if lat_s >= 60 then
		table.insert(errors, {source, "纬度秒 >= 60"})
	end
	if lat_s < 0 then
		table.insert(errors, {source, "纬度秒 < 0"})
	end
	if long_d >= 360 then
		table.insert(errors, {source, "经度 >= 360"})
	end
	if long_d <= -360 then
		table.insert(errors, {source, "经度 <= -360"})
	end
	if long_m >= 60 then
		table.insert(errors, {source, "经度分 >= 60"})
	end
	if long_m < 0 then
		table.insert(errors, {source, "经度分 < 0"})
	end
	if long_s >= 60 then
		table.insert(errors, {source, "经度秒 >= 60"})
	end
	if long_s < 0 then
		table.insert(errors, {source, "经度秒 < 0"})
	end

	return errors;
end

--[[
parseDec

Transforms decimal format latitude and longitude into the
structure to be used in displaying coordinates
]]
local function parseDec( lat, long, format )
	local coordinateSpec = {}
	local errors = {}

	if not long then
		return nil, {{"parseDec", "缺少经度"}}
	elseif not tonumber(long) then
		return nil, {{"parseDec", "经度无法解析为数字：" .. long}}
	end

	errors = validate( lat, nil, nil, long, nil, nil, 'parseDec', false );
	coordinateSpec["dec-lat"]  = lat;
	coordinateSpec["dec-long"] = long;

	local mode = coordinates.determineMode( lat, long );
	coordinateSpec["dms-lat"]  = convert_dec2dms( lat, "N", "S", mode)  -- {{coord/dec2dms|{{{1}}}|N|S|{{coord/prec dec|{{{1}}}|{{{2}}}}}}}
	coordinateSpec["dms-long"] = convert_dec2dms( long, "E", "W", mode)  -- {{coord/dec2dms|{{{2}}}|E|W|{{coord/prec dec|{{{1}}}|{{{2}}}}}}}

	if format then
		coordinateSpec.default = format
	else
		coordinateSpec.default = "dec"
	end

	return coordinateSpec, errors
end

--[[
parseDMS

Transforms degrees, minutes, seconds format latitude and longitude
into the a structure to be used in displaying coordinates
]]
local function parseDMS( lat_d, lat_m, lat_s, lat_f, long_d, long_m, long_s, long_f, format )
	local coordinateSpec, errors, backward = {}, {}

	lat_f = lat_f:upper();
	long_f = long_f:upper();

	-- Check if specified backward
	if lat_f == 'E' or lat_f == 'W' then
		lat_d, long_d, lat_m, long_m, lat_s, long_s, lat_f, long_f, backward = long_d, lat_d, long_m, lat_m, long_s, lat_s, long_f, lat_f, true;
	end

	errors = validate( lat_d, lat_m, lat_s, long_d, long_m, long_s, 'parseDMS', true );
	if not long_d then
		return nil, {{"parseDMS", "缺少经度" }}
	elseif not tonumber(long_d) then
		return nil, {{"parseDMS", "经度无法解析为数字：" .. long_d }}
	end

	if not lat_m and not lat_s and not long_m and not long_s and #errors == 0 then
		if math_mod._precision( lat_d ) > 0 or math_mod._precision( long_d ) > 0 then
			if lat_f:upper() == 'S' then
				lat_d = '-' .. lat_d;
			end
			if long_f:upper() == 'W' then
				long_d = '-' .. long_d;
			end

			return parseDec( lat_d, long_d, format );
		end
	end

	coordinateSpec["dms-lat"]  = lat_d.."°"..optionalArg(lat_m,"′") .. optionalArg(lat_s,"″") .. lat_f
	coordinateSpec["dms-long"] = long_d.."°"..optionalArg(long_m,"′") .. optionalArg(long_s,"″") .. long_f
	coordinateSpec["dec-lat"]  = convert_dms2dec(lat_f, lat_d, lat_m, lat_s) -- {{coord/dms2dec|{{{4}}}|{{{1}}}|0{{{2}}}|0{{{3}}}}}
	coordinateSpec["dec-long"] = convert_dms2dec(long_f, long_d, long_m, long_s) -- {{coord/dms2dec|{{{8}}}|{{{5}}}|0{{{6}}}|0{{{7}}}}}

	if format then
		coordinateSpec.default = format
	else
		coordinateSpec.default = "dms"
	end

	return coordinateSpec, errors, backward
end

--[[
Check the input arguments for coord to determine the kind of data being provided
and then make the necessary processing.
]]
local function formatTest(args)
	local result, errors
	local backward, primary = false, false

	local function getParam(args, lim)
		local ret = {}
		for i = 1, lim do
			ret[i] = args[i] or ''
		end
		return table.concat(ret, '_')
	end

	if not args[1] then
		-- no lat logic
		return errorPrinter( {{"formatTest", "缺少纬度"}} )
	elseif not tonumber(args[1]) then
		-- bad lat logic
		return errorPrinter( {{"formatTest", "无法将纬度解析为数字：" .. args[1]}} )
	elseif not args[4] and not args[5] and not args[6] then
		-- dec logic
		result, errors = parseDec(args[1], args[2], args.format)
		if not result then
			return errorPrinter(errors);
		end
		-- formatting for geohack: geohack expects D_N_D_E notation or D;D notation
		-- wikiminiatlas doesn't support D;D notation
		-- #coordinates parserfunction doesn't support negative decimals with NSWE
		result.param = table.concat({
			math.abs(tonumber(args[1])),
			((tonumber(args[1]) or 0) < 0) and 'S' or 'N',
			math.abs(tonumber(args[2])),
			((tonumber(args[2]) or 0) < 0) and 'W' or 'E',
			args[3] or ''}, '_')
	elseif dmsTest(args[4], args[8]) then
		-- dms logic
		result, errors, backward = parseDMS(args[1], args[2], args[3], args[4],
			args[5], args[6], args[7], args[8], args.format)
		if args[10] then
			table.insert(errors, {'formatTest', '额外的未知参数'})
		end
		if not result then
			return errorPrinter(errors)
		end
		result.param = getParam(args, 9)
	elseif dmsTest(args[3], args[6]) then
		-- dm logic
		result, errors, backward = parseDMS(args[1], args[2], nil, args[3],
			args[4], args[5], nil, args[6], args['format'])
		if args[8] then
			table.insert(errors, {'formatTest', '额外的未知参数'})
		end
		if not result then
			return errorPrinter(errors)
		end
		result.param = getParam(args, 7)
	elseif dmsTest(args[2], args[4]) then
		-- d logic
		result, errors, backward = parseDMS(args[1], nil, nil, args[2],
			args[3], nil, nil, args[4], args.format)
		if args[6] then
			table.insert(errors, {'formatTest', '额外的未知参数'})
		end
		if not result then
			return errorPrinter(errors)
		end
		result.param = getParam(args, 5)
	else
		-- Error
		return errorPrinter({{"formatTest", "参数格式不明"}})
	end
	result.name = args.name

	local extra_param = {'dim', 'globe', 'scale', 'region', 'source', 'type'}
	for _, v in ipairs(extra_param) do
		if args[v] then
			table.insert(errors, {'formatTest', '参数："' .. v .. '=" 应为 "' .. v .. ':"' })
		end
	end

	local ret = specPrinter(args, result)
	if #errors > 0 then
		ret = ret .. ' ' .. errorPrinter(errors) .. '[[Category:需要修復的經緯模板引用|Category:需要修復的經緯模板引用]]'
	end
	return ret, backward
end

--[[
Generate Wikidata tracking categories.
]]
local function makeWikidataCategories(qid)
	local ret
	if mw.wikibase and current_page.namespace == 0 then
		local entity = qid and mw.wikibase.getEntityObject(qid) or mw.wikibase.getEntityObject()
		if entity and entity.claims and entity.claims.P625 and entity.claims.P625[1] then
			local snaktype = entity.claims.P625[1].mainsnak.snaktype
			if snaktype == 'value' then
				-- coordinates exist both here and on Wikidata, and can be compared.
				ret = '维基数据存在坐标数据的页面'
			elseif snaktype == 'somevalue' then
				ret = '维基数据坐标数据为未知值的页面'
			elseif snaktype == 'novalue' then
				ret = '维基数据坐标数据为无值的页面'
			end
		else
			-- We have to either import the coordinates to Wikidata or remove them here.
			ret = '维基数据不存在坐标数据的页面'
		end
	end
	if ret then
		return string.format('[[Category:%s|Category:%s]]', ret)
	else
		return ''
	end
end

--[[
link

Simple function to export the coordinates link for other uses.

Usage:
	{{#invoke:Coordinates | link }}

]]
function coordinates.link(frame)
	return coord_link;
end

--[[
dec2dms

Wrapper to allow templates to call dec2dms directly.

Usage:
	{{#invoke:Coordinates | dec2dms | decimal_coordinate | positive_suffix |
		negative_suffix | precision }}

decimal_coordinate is converted to DMS format.  If positive, the positive_suffix
is appended (typical N or E), if negative, the negative suffix is appended.  The
specified precision is one of 'D', 'DM', or 'DMS' to specify the level of detail
to use.
]]
coordinates.dec2dms = makeInvokeFunc('_dec2dms')
function coordinates._dec2dms(args)
	local coordinate = args[1]
	local firstPostfix = args[2] or ''
	local secondPostfix = args[3] or ''
	local precision = args[4] or ''

	return convert_dec2dms(coordinate, firstPostfix, secondPostfix, precision)
end

--[[
Helper function to determine whether to use D, DM, or DMS
format depending on the precision of the decimal input.
]]
function coordinates.determineMode( value1, value2 )
	local precision = math.max( math_mod._precision( value1 ), math_mod._precision( value2 ) );
	if precision <= 0 then
		return 'd'
	elseif precision <= 2 then
		return 'dm';
	else
		return 'dms';
	end
end

--[[
dms2dec

Wrapper to allow templates to call dms2dec directly.

Usage:
	{{#invoke:Coordinates | dms2dec | direction_flag | degrees |
		minutes | seconds }}

Converts DMS values specified as degrees, minutes, seconds too decimal format.
direction_flag is one of N, S, E, W, and determines whether the output is
positive (i.e. N and E) or negative (i.e. S and W).
]]
coordinates.dms2dec = makeInvokeFunc('_dms2dec')
function coordinates._dms2dec(args)
	local direction = args[1]
	local degrees = args[2]
	local minutes = args[3]
	local seconds = args[4]

	return convert_dms2dec(direction, degrees, minutes, seconds)
end

--[[
coord

Main entry point for Lua function to replace {{coord}}

Usage:
	{{#invoke:Coordinates | coord }}
	{{#invoke:Coordinates | coord | lat | long }}
	{{#invoke:Coordinates | coord | lat | lat_flag | long | long_flag }}
	...

	Refer to {{coord}} documentation page for many additional parameters and
	configuration options.

Note: This function provides the visual display elements of {{coord}}.  In
order to load coordinates into the database, the {{#coordinates:}} parser
function must also be called, this is done automatically in the Lua
version of {{coord}}.
]]
coordinates.coord = makeInvokeFunc('_coord')
function coordinates._coord(args)
	if not tonumber(args[1]) and not args[2] then
		args[3] = args[1]; args[1] = nil
		local entity = mw.wikibase.getEntityObject(args.qid)
		if entity
			and entity.claims
			and entity.claims.P625
			and entity.claims.P625[1].mainsnak.snaktype == 'value'
		then
			local precision = entity.claims.P625[1].mainsnak.datavalue.value.precision
			args[1] = entity.claims.P625[1].mainsnak.datavalue.value.latitude
			args[2] = entity.claims.P625[1].mainsnak.datavalue.value.longitude
			if precision then
				precision = -math_mod._round(math.log(precision)/math.log(10),0)
				args[1] = math_mod._round(args[1],precision)
				args[2] = math_mod._round(args[2],precision)
			end
		end
	end

	local contents, backward = formatTest(args)
	local Notes = args.notes or ''
	local Display = args.display and args.display:lower() or 'inline'

	local function isInline(s)
		-- Finds whether coordinates are displayed inline.
		return s:find('inline') ~= nil or s == 'i' or s == 'it' or s == 'ti'
	end
	local function isInTitle(s)
		-- Finds whether coordinates are displayed in the title.
		return s:find('title') ~= nil or s == 't' or s == 'it' or s == 'ti'
	end

	local function coord_wrapper(in_args)
		-- Calls the parser function {{#coordinates:}}.
		return mw.getCurrentFrame():callParserFunction('#coordinates', in_args) or ''
	end

	local text = ''
	if isInline(Display) then
		text = text .. displayinline(contents, Notes)
	end
	if isInTitle(Display) then
		text = text
			.. displaytitle(contents, Notes)
			.. makeWikidataCategories(args.qid)
	end
	if not args.nosave then
		local page_title, count = mw.title.getCurrentTitle(), 1
		if backward then
			local tmp = {}
			while not string.find((args[count-1] or ''), '[EW]') do tmp[count] = (args[count] or ''); count = count+1 end
			tmp.count = count; count = 2*(count-1)
			while count >= tmp.count do table.insert(tmp, 1, (args[count] or '')); count = count-1 end
			for i, v in ipairs(tmp) do args[i] = v end
		else
			while count <= 9 do args[count] = (args[count] or ''); count = count+1 end
		end
		if isInTitle(Display) and not page_title.isTalkPage and page_title.subpageText ~= 'doc' and page_title.subpageText ~= 'testcases' then args[10] = 'primary' end
		args.notes, args.format, args.display = nil
		text = text .. coord_wrapper(args)
	end
	return text
end

--[[
coord2text

Extracts a single value from a transclusion of {{Coord}}.
IF THE GEOHACK LINK SYNTAX CHANGES THIS FUNCTION MUST BE MODIFIED.

Usage:

    {{#invoke:Coordinates | coord2text | {{Coord}} | parameter }}

Valid values for the second parameter are: lat (signed integer), long (signed integer), type, scale, dim, region, globe, source

]]
function coordinates.coord2text(frame)
	if frame.args[1] == '' or frame.args[2] == '' or not frame.args[2] then return nil end
	frame.args[2] = mw.text.trim(frame.args[2])
	if frame.args[2] == 'lat' or frame.args[2] == 'long' then
		local result, negative = mw.text.split((mw.ustring.match(frame.args[1],'[%.%d]+°[NS] [%.%d]+°[EW]') or ''), ' ')
		if frame.args[2] == 'lat' then
			result, negative = result[1], 'S'
		else
			result, negative = result[2], 'W'
		end
		result = mw.text.split(result, '°')
		if result[2] == negative then result[1] = '-'..result[1] end
		return result[1]
	else
		return mw.ustring.match(frame.args[1], 'params=.-_'..frame.args[2]..':(.-)[ _]')
	end
end

--[[
coordinsert

Injects some text into the Geohack link of a transclusion of {{Coord}} (if that text isn't already in the transclusion). Outputs the modified transclusion of {{Coord}}.
IF THE GEOHACK LINK SYNTAX CHANGES THIS FUNCTION MUST BE MODIFIED.

Usage:

    {{#invoke:Coordinates | coordinsert | {{Coord}} | parameter:value | parameter:value | … }}

Do not make Geohack unhappy by inserting something which isn't mentioned in the {{Coord}} documentation.

]]
function coordinates.coordinsert(frame)
	for i, v in ipairs(frame.args) do
		if i ~= 1 then
			if not mw.ustring.find(frame.args[1], (mw.ustring.match(frame.args[i], '^(.-:)') or '')) then
				frame.args[1] = mw.ustring.gsub(frame.args[1], '(params=.-)_? ', '%1_'..frame.args[i]..' ')
			end
		end
	end
	if frame.args.name then
		if not mw.ustring.find(frame.args[1], '<span class="vcard">') then
			local namestr = frame.args.name
			frame.args[1] = mw.ustring.gsub(frame.args[1],
				'(<span class="geo%-default">)(<span[^<>]*>[^<>]*</span><span[^<>]*>[^<>]*<span[^<>]*>[^<>]*</span></span>)(</span>)',
				'%1<span class="vcard">%2<span style="display:none">﻿ (<span class="fn org">' .. namestr .. '</span>)</span></span>%3')
			frame.args[1] = mw.ustring.gsub(frame.args[1], '(&params=[^&"<>%[%] ]*) ', '%1&title=' .. mw.uri.encode(namestr) .. ' ')
		end
	end
	return frame.args[1]
end

return coordinates