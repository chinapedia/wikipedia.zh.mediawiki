{{Infobox programming language
|name = ML
|logo =
|paradigm = [[编程范型|多范型]]：[[函数式编程语言|函数式]]，[[指令式编程语言|指令式]]
|year = {{start date and age|1973}}
|designer = [[罗宾·米尔纳|罗宾·米尔纳]]及[[爱丁堡大学|爱丁堡大学]]其他人
|developer =
|latest release version = [https://smlfamily.github.io/sml97-defn.pdf Standard ML '97]
|latest release date = {{start date and age|1997}}
|typing = [[类型推论|类型推论]]，[[静态类型|静态类型]]，[[强类型|强类型]]
|implementations =
|dialects = [[Standard_ML|Standard ML]], [[OCaml|OCaml]]
|influenced_by = [[ISWIM|ISWIM]]<ref name="LCF ML" />，[[PAL_(编程语言)|PAL]]<ref name="ML tradition" />，[[POP-2|POP-2]]<ref name="LCF ML" />，GEDANKEN<ref name="LCF ML" />
|influenced = [[Clojure|Clojure]]、[[Coq|Coq]]、{{en-link|Cyclone (编程语言)|Cyclone (programming language)|Cyclone}}、[[C++|C++]]、[[Elm_(编程语言)|Elm]]<ref name="elm" />、[[Futhark_(编程语言)|Futhark]]<ref name="futhark" />、[[F♯|F#]]、[[F*|F*]]、[[Haskell|Haskell]]、[[Idris|Idris]]、Lazy ML<ref>{{cite web|title=The Chalmers Lazy-ML Compiler|url=https://academic.oup.com/comjnl/article/32/2/127/543548|author={{en-link|Lennart Augustsson}}, Thomas Johnsson|year=1989|access-date=2021-09-17|archive-date=2021-09-17|archive-url=https://web.archive.org/web/20210917125153/https://academic.oup.com/comjnl/article/32/2/127/543548}}</ref>、[[Miranda_(编程语言)|Miranda]]、[[Nemerle|Nemerle]]<ref name="nemerle" />、[[OCaml|OCaml]]、{{en-link|Opa (编程语言)|Opa (programming language)|Opa}}、[[Rust|Rust]]、[[Scala|Scala]]、[[Standard_ML|Standard ML]]、[[Ur_(编程语言)|Ur]]<ref name="ur" />
|wikibooks = Standard ML Programming
}}
'''ML'''（'''M'''eta '''L'''anguage：元语言），是一个[[函数式编程语言|函数式]]、[[指令式编程语言|指令式]]的[[通用编程语言|通用]]的[[编程语言|编程语言]]，它著称于使用了[[多态_(计算机科学)|多态]]的[[类型推论#Hindley–Milner_类型推论算法|Hindley–Milner类型推论]]<ref name="Milner78">{{cite web|title=A theory of type polymorphism in programming.|author=Robin Milner|year=1978|url=https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/milner-type-polymorphism.pdf|access-date=2021-09-01|archive-date=2020-11-01|archive-url=https://web.archive.org/web/20201101135440/https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/milner-type-polymorphism.pdf}} Journal of Computer and System Sciences, 17(3):348–375.</ref>。ML能自动的指定多数{{en-link|表达式 (计算机科学)|Expression (computer science)|表达式}}的[[数据类型|类型]]，不要求显式的类型标注，而且能够确保类型安全，已经正式证明了有良好类型的ML程序不会导致运行时间类型错误<ref name="Milner78" />。

ML提供了对函数实际参数的[[模式匹配|模式匹配]]、[[垃圾回收_(计算机科学)|垃圾回收]]、[[指令式编程|指令式编程]]、[[求值策略#传值调用|传值调用]]和[[柯里化|柯里化]]。它被大量的用于编程语言研究之中，并且是全面规定了的和使用[[形式语义学|形式语义]]验证了的少数语言之一。它的类型和模式匹配使得它非常适合并且经常用于在其他形式语言上进行操作，比如在[[编译器|编译器构造]]、[[自动化定理证明|自动化定理证明]]和[[形式验证|形式验证]]中。

==历史==
在[[1970年代|1970年代]]早期，ML由[[爱丁堡大学|爱丁堡大学]]的[[罗宾·米尔纳|罗宾·米尔纳]]及他人研制出来<ref name="LCF ML">{{cite book|author=Michael J. Gordon, Arthur J. Milner, Christopher P. Wadsworth|year=1979|title=Edinburgh LCF: A Mechanised Logic of Computation|url=https://epdf.pub/edinburgh-lcf.html|publisher=Lecture Notes in Computer Science, Vol. 78. Springer-Verlag, New York, NY, USA|quote=ML is a general purpose programming language. It is derived in different aspects from [[ISWIM|ISWIM]], [[POP-2|POP2]] and GEDANKEN, and contains perhaps two new features. First, it has an escape and escape trapping mechanism, well-adapted to programming strategies which may be (in fact usually are) inapplicable to certain goals. Second, it has a polymorphic type discipline which combines the flexibility of programming in a typeless language with the security of compile-time type checking (as in other languages, you may also define your own types, which may be abstract and/or recursive); this is what ensures that a well-typed program cannot perform faulty proofs.|access-date=2021-12-28|archive-date=2021-12-28|archive-url=https://web.archive.org/web/20211228111519/https://epdf.pub/edinburgh-lcf.html}}<br />{{cite web | author={{en-link|Michael J. C. Gordon}} | year=1996 | title=From LCF to HOL: a short history | url=http://www.cl.cam.ac.uk/~mjcg/papers/HolHistory.html | quote=Around 1973 Milner moved to Edinburgh University and established a project to build a successor to Stanford LCF, which was subsequently dubbed Edinburgh LCF. He initially hired Lockwood Morris and Malcolm Newey (both recent PhD graduates from Stanford) as research assistants. …… Milner, ably assisted by Morris and Newey, designed the programming language ML (an abbreviation for “Meta Language”). …… In 1975, Morris and Newey took up faculty positions at Syracuse University and the Australian National University, respectively, and were replaced by Chris Wadsworth and myself. The design and implementation of ML and Edinburgh LCF was finalised and the book “Edinburgh LCF” was written and published. In 1978, the first LCF project finished, Chris Wadsworth went off trekking in the Andes (returning to a permanent position at the Rutherford Appleton Laboratory) and I remained at Edinburgh supported by a postdoctoral fellowship and with a new research interest: hardware verification. | access-date=2021-02-27 | archive-date=2016-09-05 | archive-url=https://web.archive.org/web/20160905201847/http://www.cl.cam.ac.uk/~mjcg/papers/HolHistory.html }}</ref>，用于在{{en-link|可计算函数逻辑|Logic for Computable Functions|LCF}}定理证明器中开发证明策略<ref>{{cite web|author=Robin Milner|title=How ML Evolved|url=https://www.pure.ed.ac.uk/ws/portalfiles/portal/17084823/Milner_R_1982_How_ML_Evolved.pdf|year=1982|publisher=Polymorphism—The ML/LCF/Hope Newsletter,Vol. 1, No. 1.|access-date=2021-09-09|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128120245/https://www.pure.ed.ac.uk/ws/portalfiles/portal/17084823/Milner_R_1982_How_ML_Evolved.pdf}}</ref>。LCF的语言是“PPλ”，它是[[一阶逻辑|一阶逻辑]]演算与有类型的[[多态_(计算机科学)|多态]][[λ演算|λ演算]]的结合，以ML作为[[元语言|元语言]]。ML的语法从[[ISWIM|ISWIM]]及其扩展实现[[PAL_(编程语言)|PAL]]得到了启发<ref name="ML tradition">{{cite web|url=http://www-public.it-sudparis.eu/~gibson/Teaching/CSC4504/ReadingMaterial/GordonMMNW78.pdf|title=A Metalanguage for Interactive Proof in LCF|author=M. Gordon, R. Milner, L. Morris, M. Newey, C. Wadsworth|year=1978|quote=ML is a higher-order functional programming language in the tradition of [[ISWIM|ISWIM]], [[PAL_(编程语言)|PAL]], [[POP-2|POP2]] and GEDANKEN, but differs principally in its handling of failure and, more so, of types.|access-date=2021-08-31|archive-date=2021-05-06|archive-url=https://web.archive.org/web/20210506210705/http://www-public.it-sudparis.eu/~gibson/Teaching/CSC4504/ReadingMaterial/GordonMMNW78.pdf}}</ref>，LCF ML运行在[[PDP-10|DEC-10]]/[[TOPS-10|TOPS-10]][[大型计算机|主机]]的[[Stanford|Stanford]] [[LISP|LISP]]下<ref>{{cite web|url=https://www.cl.cam.ac.uk/~lp15/archive/LCF77.tar.gz|title=The original Edinburgh LCF|year=1977|access-date=2021-10-10|archive-date=2021-10-10|archive-url=https://web.archive.org/web/20211010105859/https://www.cl.cam.ac.uk/~lp15/archive/LCF77.tar.gz}}</ref>。

在1980年，{{en-link|Luca Cardelli}}于爱丁堡大学的[[VAX|VAX]]/[[VMS|VMS]]系统上开发了ML编译器，它被称为“VAX ML”<ref>{{cite web|title=ML under VMS|author={{en-link|Luca Cardelli}}|year=1982|url=https://smlfamily.github.io/history/Cardelli-ML-VMS-manual-1982.pdf|access-date=2021-09-04|archive-date=2021-11-06|archive-url=https://web.archive.org/web/20211106083812/https://smlfamily.github.io/history/Cardelli-ML-VMS-manual-1982.pdf}}</ref>，以区别于LCF版本的“DEC-10 ML”<ref>{{cite web|title=Differences between VAX and DEC-10 ML|author=Luca Cardelli|year=1982|url=https://smlfamily.github.io/history/Cardelli-mlchanges_doc-1982_03.pdf|access-date=2021-09-04|archive-date=2021-11-06|archive-url=https://web.archive.org/web/20211106083812/https://smlfamily.github.io/history/Cardelli-mlchanges_doc-1982_03.pdf}}</ref>。VAX ML的编译器和运行时间系统二者，都是用[[Pascal语言|Pascal]]书写而建立在“函数[[抽象机器|抽象机器]]”（FAM）之上<ref>{{cite web|author={{en-link|Luca Cardelli}}|title=The Functional Abstract Machine|url=http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.310.1089&rep=rep1&type=pdf|year=1983|access-date=2021-09-04|archive-date=2021-09-04|archive-url=https://web.archive.org/web/20210904050834/http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.310.1089&rep=rep1&type=pdf}} Bell Labs Technical Report TR-107.<br />{{cite web|author=Luca Cardelli|title=Compiling a functional language|url=http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.35.6169&rep=rep1&type=pdf|year=1984|access-date=2021-09-03|archive-date=2021-09-03|archive-url=https://web.archive.org/web/20210903025234/http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.35.6169&rep=rep1&type=pdf}} In Proceedings of the 1984 ACM Symposium on LISP and Functional Programming, pages 208–217, New York, NY, USA. ACM.</ref>。在1982年，爱丁堡大学的Kevin Mitchell，用VAX ML重写了VAX ML编译器，随即John Scott和{{en-link|Alan Mycroft}}加入了开发，在又进行一系列重写改进之后，新的编译器被称为“Edinburgh ML”<ref>{{cite web|author=Kevin Mitchell, Alan Mycroft|year=1985|title=The Edinburgh Standard ML Compiler|url=https://smlfamily.github.io/history/KMitchell-Mycroft-Edinburgh%20Standard%20ML%20Compiler-1985_01.pdf|access-date=2021-09-10|archive-date=2022-01-29|archive-url=https://web.archive.org/web/20220129053559/https://smlfamily.github.io/history/KMitchell-Mycroft-Edinburgh%20Standard%20ML%20Compiler-1985_01.pdf}}</ref>。

在1981年，[[法国国家信息与自动化研究所|INRIA]]的{{en-link|Gérard Huet}}，将最初的LCF ML适配到[[Multics|Multics]]系统的[[Maclisp|Maclisp]]下，并且增加了编译器<ref name="caml-doc" />。这个实现被描述于[[法国国家信息与自动化研究所|INRIA]]内部文档“ML手册”之中<ref>{{cite book|title=The ML Handbook, Version 6.2|series=Internal document|author= G. Cousineau, M. Gordon, G. Huet, R. Milner, L. C. Paulson, C. Wadsworth |publisher=Project Formel, INRIA|date=July 1985}}<br />{{cite web|title=Introduction to Classic ML|author=Christoph Kreitz, Vincent Rahli|year=2011|url=http://www.nuprl.org/crash/eventml/KreitzandRahli-ClassicML.pdf|quote=This handbook is a revised edition of Section 2 of ‘Edinburgh LCF’, by M. Gordon, R. Milner, and C. Wadsworth, published in 1979 as Springer Verlag Lecture Notes in Computer Science no 78. ……The language is somewhere in between the original ML from LCF and standard ML, since Guy Cousineau added the constructors and call by patterns. This is a LISP based implementation, compatible for Maclisp on Multics, Franzlisp on VAX under Unix, Zetalisp on Symbolics 3600, and Le Lisp on 68000, VAX, Multics, Perkin-Elmer, etc... Video interfaces have been implemented by Philippe Le Chenadec on Multics, and by Maurice Migeon on Symbolics 3600. The ML system is maintained and distributed jointly by INRIA and the University of Cambridge.|access-date=2021-09-09|archive-date=2022-01-29|archive-url=https://web.archive.org/web/20220129103018/http://www.nuprl.org/crash/eventml/KreitzandRahli-ClassicML.pdf}}</ref>，它被开发者自称为“Le_ML”<ref name="caml-hist" />。[[剑桥大学|剑桥大学]]的{{en-link|Lawrence Paulson}}用它开发了基于[[Franz_Lisp|Franz Lisp]]的Cambridge LCF<ref>{{cite web|title=The theorem prover Cambridge LCF. coded in Franz Lisp|url=https://www.cl.cam.ac.uk/~lp15/archive/lcf.tar.gz|author=Lawrence C. Paulson|year=1989|access-date=2021-10-10|archive-date=2021-10-10|archive-url=https://web.archive.org/web/20211010105856/https://www.cl.cam.ac.uk/~lp15/archive/lcf.tar.gz}}<br />{{cite web | author={{en-link|Michael J. C. Gordon}} | year=1996 | title=From LCF to HOL: a short history | url=http://www.cl.cam.ac.uk/~mjcg/papers/HolHistory.html | quote=In 1981, I moved to a permanent position as Lecturer at the University of Cambridge Computer Laboratory. ……Larry Paulson, recently graduated with a PhD from Stanford, was hired at Cambridge ……. About this time, and in parallel, G ́erard Huet ported the Edinburgh LCF code to Lelisp and MacLisp. Paulson and Huet then established a collaboration and did a lot of joint development of LCF by sending each other magnetic tapes in the post. …… Edinburgh LCF ran interpretively, but during Paulson and Huet’s collaboration an ML compiler was implemented that provided a speedup by a factor of about twenty. …… The resulting new LCF system was named “Cambridge LCF” and completed around 1985. Paulson did little work on it after that. Mikael Hedlund (of the Rutherford Appleton Laboratory) then ported Cambridge LCF to Standard ML (using a new implementation of ML that he created). The resulting Standard ML based version of Cambridge LCF is documented …… in Paulson’s 1987 book Logic and Computation. | access-date=2021-02-27 | archive-date=2016-09-05 | archive-url=https://web.archive.org/web/20160905201847/http://www.cl.cam.ac.uk/~mjcg/papers/HolHistory.html }}</ref>，进而[[剑桥大学|剑桥大学]]的{{en-link|Michael J. C. Gordon}}又用它开发了基于[[Common_Lisp|Common Lisp]]的第一版的{{en-link|HOL|HOL (proof assistant)|HOL}}<ref>{{cite web|title=HOL88, source code|url=https://launchpad.net/ubuntu/+archive/primary/+sourcefiles/hol88/2.02.19940316-31/hol88_2.02.19940316.orig.tar.gz}}<br />{{cite web | author={{en-link|Michael J. C. Gordon}} | year=1996 | title=From LCF to HOL: a short history | url=http://www.cl.cam.ac.uk/~mjcg/papers/HolHistory.html | quote=Whilst Paulson was designing and implementing Cambridge LCF, I was mainly concerned with hardware verification. …… The first version of the HOL system was created by modifying the Cambridge LCF parser and pretty-printer to support higher order logic concrete syntax. …… The core HOL system became stable in about 1988. A new release that consolidated various changes and enhancements called HOL88 was issued then. We were fortunate to receive support from DSTO Australia to document HOL and from Hewlett Packard to port it from Franz Lisp to Common Lisp (a job very ably done by John Carroll). …… In the late 1980’s Graham Birtwistle of the University of Calgary started a project to reimplement HOL in Standard ML. The work was done by Konrad Slind, under Birtwistle’s direction and with the collaboration of the HOL group at Cambridge. The resulting system, called HOL90, was first released around 1990. …… Recently John Harrison and Konrad Slind have entirely reworked the design of HOL ……. …… This new version of HOL is called “HOL Light”. It is implemented in Caml Light and runs on modest platforms (e.g. standard PCs). It is faster than the Lisp-based HOL88, but a bit slower than HOL90 running in modern implementations of Standard ML. | access-date=2021-02-27 | archive-date=2016-09-05 | archive-url=https://web.archive.org/web/20160905201847/http://www.cl.cam.ac.uk/~mjcg/papers/HolHistory.html }}</ref>。

在1983年，Robin Milner由两个动机驱使开始重新设计ML<ref>{{cite web|title=A Proposal for Standard ML|author=Robin Milner|year=1983|url=https://smlfamily.github.io/history/SML-proposal-11-83.pdf|access-date=2021-09-02|archive-date=2021-11-06|archive-url=https://web.archive.org/web/20211106091506/https://smlfamily.github.io/history/SML-proposal-11-83.pdf}}</ref>。其一是[[爱丁堡大学|爱丁堡大学]]的{{en-link|Rod Burstall}}及其小组在规定上的工作，具体化为规定语言CLEAR<ref>{{cite web|title=The semantics of CLEAR, a specification language|url=https://www.researchgate.net/publication/225529039_The_semantics_of_CLEAR_a_specification_language|author=R. M. Burstall, J. A. Goguen|year=1977|access-date=2021-09-03|archive-date=2021-09-03|archive-url=https://web.archive.org/web/20210903103936/https://www.researchgate.net/publication/225529039_The_semantics_of_CLEAR_a_specification_language}}<br />{{cite web|title=Semantics, Implementation and Pragmatics of Clear, a Program Specification Language|year=1982|author=Donald Sannella|url=https://www.researchgate.net/publication/292787979_Semantics_Implementation_and_Pragmatics_of_Clear_a_Program_Specification_Language|access-date=2021-09-06|archive-date=2021-09-06|archive-url=https://web.archive.org/web/20210906185521/https://www.researchgate.net/publication/292787979_Semantics_Implementation_and_Pragmatics_of_Clear_a_Program_Specification_Language}}</ref>，和表达可执行规定的函数式语言[[Hope_(编程语言)|HOPE]]<ref>{{cite web|url=https://homepages.inf.ed.ac.uk/dts/pub/hope.pdf|author={{en-link|Rod Burstall}}, D.B. MacQueen, {{en-link|Don Sannella|Don Sannella|D.T. Sannella}}|year=1980|title=Hope: An Experimental Applicative Language|access-date=2021-09-03|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128115243/https://homepages.inf.ed.ac.uk/dts/pub/hope.pdf}} Conference Record of the 1980 LISP Conference, Stanford University, pp. 136-143.</ref>。这项工作与ML有关的是两方面成果：首先，HOPE拥有优雅的编程特征，特别是模式匹配<ref>{{cite web|author=R.M. Burstall|title=Proving properties of programs by structural induction|year=1968|url=https://www.cse.chalmers.se/edu/year/2017/course/DAT140_Types/Burstall.pdf|access-date=2021-09-13|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128115225/https://www.cse.chalmers.se/edu/year/2017/course/DAT140_Types/Burstall.pdf}}</ref>，和子句式函数定义<ref>{{cite web|author=R.M. Burstall, J. Darlington|title=A transformation system for developing recursive programs|url=https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.645&rep=rep1&type=pdf|publisher=Journal of the Association for Computing Machinery|page=24(1):44–67|year=1977|access-date=2021-09-13|archive-date=2020-01-28|archive-url=https://web.archive.org/web/20200128085329/http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.645&rep=rep1&type=pdf}}</ref>；其次，是使用在接口中的签名，进行规定的模块化构造的想法。其二是{{en-link|Luca Cardelli}}在VAX ML上的工作，通过增加命名记录和可变类型，扩展了ML中数据类型的品目<ref>{{cite web|author=Luca Cardelli|title=ML under Unix|year=1983|url=http://lucacardelli.name/Papers/MLUnix.pdf|access-date=2021-09-10|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128174419/http://lucacardelli.name/Papers/MLUnix.pdf}}<br />{{cite web|author=Luca Cardelli|title=ML under Unix, Pose 4|year=1984|url=http://www.lucacardelli.name/Papers/MLUnix%20Pose%204.pdf|access-date=2021-09-04|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128115301/http://www.lucacardelli.name/Papers/MLUnix%20Pose%204.pdf}}</ref>。

在1984年，[[贝尔实验室|贝尔实验室]]的David MacQueen提出了对[[Standard_ML|Standard ML]]的[[模块化编程|模块系统]]的设计<ref>{{cite journal|title=Modules for Standard ML|journal=LFP '84 Proceedings of the 1984 ACM Symposium on LISP and functional programming|url=https://www.researchgate.net/publication/221252232_Modules_for_Standard_ML|pages=198–207|author=David MacQueen|date=August 1984|access-date=2021-06-23|archive-date=2021-05-02|archive-url=https://web.archive.org/web/20210502221834/https://www.researchgate.net/publication/221252232_Modules_for_Standard_ML}}</ref>。在Standard ML的持续设计期间<ref>*{{cite web|title=The Standard ML Core Language|author=Robin Milner|date=July 1984|url=https://smlfamily.github.io/history/SML-proposal-7-84.pdf|access-date=2021-09-05|archive-date=2021-11-06|archive-url=https://web.archive.org/web/20211106083807/https://smlfamily.github.io/history/SML-proposal-7-84.pdf}}
*{{cite web|title=The Standard ML Core Language|author=Robin Milner|date=October 1984|url=https://smlfamily.github.io/history/SML-proposal-10-84.pdf|access-date=2021-09-05|archive-date=2021-11-06|archive-url=https://web.archive.org/web/20211106083824/https://smlfamily.github.io/history/SML-proposal-10-84.pdf}}
*{{cite web|title=The Standard ML Core Language (Revised)|author=Robin Milner|year=1985|url=https://smlfamily.github.io/history/SML-proposal-9-85.pdf|access-date=2021-09-05|archive-date=2021-11-06|archive-url=https://web.archive.org/web/20211106083813/https://smlfamily.github.io/history/SML-proposal-9-85.pdf}}
*{{cite web|title=Standard ML. Technical Report ECS-LFCS-86-2|author=Robert Harper, David B. MacQueen, Robin Milner|year=1986|url=http://www.lfcs.inf.ed.ac.uk/reports/86/ECS-LFCS-86-2/ECS-LFCS-86-2.pdf|access-date=2021-09-04|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128115220/http://www.lfcs.inf.ed.ac.uk/reports/86/ECS-LFCS-86-2/ECS-LFCS-86-2.pdf}} LFCS, Department of Computer Science, University of Edinburgh.
*{{cite web|author=Robin Milner|year=1987|title=Changes to the Standard ML Core language. Technical Report ECS-LFCS-87-33|url=http://www.lfcs.inf.ed.ac.uk/reports/87/ECS-LFCS-87-33/ECS-LFCS-87-33.pdf|access-date=2021-09-04|archive-date=2021-09-04|archive-url=https://web.archive.org/web/20210904041319/http://www.lfcs.inf.ed.ac.uk/reports/87/ECS-LFCS-87-33/ECS-LFCS-87-33.pdf}} LFCS, Department of Computer Science, University of Edinburgh.
*{{cite web|author=Robert Harper, Robin Milner, Mads Tofte|year=1987|title=The Semantics of Standard ML, Version 1. Technical Report ECS-LFCS-87-36|url=http://www.lfcs.inf.ed.ac.uk/reports/87/ECS-LFCS-87-36/ECS-LFCS-87-36.pdf|access-date=2021-09-04|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128115409/http://www.lfcs.inf.ed.ac.uk/reports/87/ECS-LFCS-87-36/ECS-LFCS-87-36.pdf}} LFCS, Department of Computer Science, University of Edinburgh. 
*{{cite web|author=Robert Harper, Robin Milner, Mads Tofte|year=1988|title=The Definition of Standard ML, Version 2. Technical Report ECS-LFCS-88-62|url=http://www.lfcs.inf.ed.ac.uk/reports/88/ECS-LFCS-88-62/ECS-LFCS-88-62.pdf|access-date=2021-09-04|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128115234/http://www.lfcs.inf.ed.ac.uk/reports/88/ECS-LFCS-88-62/ECS-LFCS-88-62.pdf}} LFCS, Department of Computer Science, University of Edinburgh.
*{{cite web|author=Robert Harper, Robin Milner, Mads Tofte|year=1989|title=The Definition of Standard ML, Version 3. Technical Report ECS-LFCS-89-81|url=http://www.lfcs.inf.ed.ac.uk/reports/89/ECS-LFCS-89-81/ECS-LFCS-89-81.pdf|access-date=2021-09-04|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128115242/http://www.lfcs.inf.ed.ac.uk/reports/89/ECS-LFCS-89-81/ECS-LFCS-89-81.pdf}} LFCS, Department of Computer Science, University of Edinburgh.</ref>，Edinburgh ML被渐进的修改，充当了[[Standard_ML|Standard ML]]的近似原型实现<ref>{{cite web|title=Edinburgh ML (Core Language) (SML '90), Version 4.1.02|year=1991|url=http://www.dcs.ed.ac.uk/home/edml/|access-date=2021-09-13|archive-date=2021-09-13|archive-url=https://web.archive.org/web/20210913043842/http://www.dcs.ed.ac.uk/home/edml/}}<br />{{cite web|title=The Edinburgh Standard ML Library (SML '90)|year=1993|url=http://www.dcs.ed.ac.uk/home/ml/library/|access-date=2021-09-13|archive-date=2020-08-12|archive-url=https://web.archive.org/web/20200812005009/http://www.dcs.ed.ac.uk/home/ml/library/}}</ref>。在1986年，[[普林斯顿大学|普林斯顿大学]]的{{en-link|Andrew Appel}}和[[贝尔实验室|贝尔实验室]]的David MacQueen，以Edinburgh Standard ML作为起步开发环境<ref>{{cite web|title=A Standard ML compiler|url=http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.35.571&rep=rep1&type=pdf|author={{en-link|Andrew Appel|Andrew Appel|Andrew W. Appel}}, David MacQueen|year=1987|access-date=2021-09-03|archive-date=2021-09-03|archive-url=https://web.archive.org/web/20210903014152/http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.35.571&rep=rep1&type=pdf}}<br />{{cite web|title=An Implementation of Standard ML Modules|author=David Macueen|year=1988|url=http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9D69EB6BB01C953661AD5591A22D93B9?doi=10.1.1.48.6127&rep=rep1&type=pdf|access-date=2021-09-03|archive-date=2021-09-03|archive-url=https://web.archive.org/web/20210903012529/http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9D69EB6BB01C953661AD5591A22D93B9?doi=10.1.1.48.6127&rep=rep1&type=pdf}}</ref>，开始了专注于生成高质量机器代码的[[新泽西Standard_ML|Standard ML of New Jersey]]的活跃开发<ref>{{cite web|url=https://www.researchgate.net/publication/221266857_Standard_ML_of_New_Jersey|title=Standard ML of New Jersey|year=1991|author={{en-link|Andrew Appel|Andrew Appel|Andrew W. Appel}}, David MacQueen|access-date=2021-08-31|archive-date=2021-08-31|archive-url=https://web.archive.org/web/20210831115858/https://www.researchgate.net/publication/221266857_Standard_ML_of_New_Jersey}}<br />{{cite web|url=http://www.smlnj.org/NEWS/93-README.html|year=1993|title=Standard ML of New Jersey, Version 0.93|access-date=2021-09-14|archive-date=2022-03-28|archive-url=https://web.archive.org/web/20220328070141/http://www.smlnj.org/NEWS/93-README.html}}</ref>。

在1990年，[[Robin_Milner|Robin Milner]]、{{en-link|Mads Tofte}}和{{en-link|Robert Harper|Robert Harper (computer scientist)|Robert Harper}}制定的[[Standard_ML|Standard ML]]的正式规定《The Definition of Standard ML》最终完成<ref>{{cite web|author=Robin Milner, Mads Tofte, Robert Harper|year=1990|title=The Definition of Standard ML|url=https://smlfamily.github.io/sml90-defn.pdf|publisher=The MIT Press, Cambridge, MA, USA|access-date=2021-03-01|archive-date=2021-01-14|archive-url=https://web.archive.org/web/20210114130545/https://smlfamily.github.io/sml90-defn.pdf}}</ref>；在1997年，这个标准规定增补了David MacQueen为作者并进行了修订<ref>{{cite web|author=Robin Milner, Mads Tofte, Robert Harper, David MacQueen|year=1997|title=The Definition of Standard ML (Revised)|url=https://smlfamily.github.io/sml97-defn.pdf|publisher=The MIT Press, Cambridge, MA, USA|access-date=2021-03-01|archive-date=2022-03-09|archive-url=https://web.archive.org/web/20220309034143/https://smlfamily.github.io/sml97-defn.pdf}}</ref>。在1989年，{{en-link|Mads Tofte}}、Nick Rothwell和David N. Turner于[[爱丁堡大学|爱丁堡大学]]开始开发ML Kit编译器，为了强调清晰性而非高效，将标准定义直接转译成一组Standard ML模块；在1992年和1993年期间，主要通过[[爱丁堡大学|爱丁堡大学]]的Nick Rothwell和[[哥本哈根大学|哥本哈根大学]]{{en-link|UCPH计算机科学系|UCPH Department of Computer Science|计算机科学系}}（DIKU）的Lars Birkedal的工作<ref>{{cite web|title=The ML Kit, Version 1|author=Lars Birkedal, Nick Rothwell, Mads Tofte, David N. Turner|year=1993|url=http://www.cs.cmu.edu/afs/cs/user/birkedal/pub/kit.ps.gz|access-date=2021-09-13|archive-date=2021-09-13|archive-url=https://web.archive.org/web/20210913210520/http://www.cs.cmu.edu/afs/cs/user/birkedal/pub/kit.ps.gz}}</ref>，ML Kit第一版完成并开源发行<ref>{{cite web|title=The release of the ML Kit Version 1|year=1993|url=http://www.dcs.ed.ac.uk/home/mlkit/|access-date=2021-09-13|archive-date=2021-09-13|archive-url=https://web.archive.org/web/20210913050811/http://www.dcs.ed.ac.uk/home/mlkit/}}</ref>。

在1987年，[[法国国家信息与自动化研究所|INRIA]]的Ascánder Suárez，基于[[巴黎第七大学|巴黎第七大学]]的{{fr-link|Guy Cousineau}}的“{{en-link|范畴抽象机器|Categorical abstract machine}}”（CAM）<ref>{{cite web|author=G. Cousineau, P.-L. Curien, M. Mauny|title=The categorical abstract machine|year=1985|url=https://www.sciencedirect.com/science/article/pii/0167642387900207|access-date=2021-09-04|archive-date=2021-09-03|archive-url=https://web.archive.org/web/20210903015705/https://www.sciencedirect.com/science/article/pii/0167642387900207}} LNCS, 201, Functional programming languages computer architecture, pp.~50-64.<br />{{cite web|title=Implementing functional languages in the Categorical Abstract Machine|author=Michel Mauny, Ascánder Suárez|year=1986|url=http://michel.mauny.net/data/papers/mauny-suarez-1986.pdf|access-date=2021-09-04|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128115221/http://michel.mauny.net/data/papers/mauny-suarez-1986.pdf}} LFP '86: Proceedings of the 1986 ACM conference on LISP and functional programming, Pages 266–278.</ref>，利用[[Le_Lisp|Le Lisp]]的运行时间系统重新实现了Le_ML，并正式命名为[[Caml|Caml]]<ref name="caml-doc">{{cite web|title=The CAML primer Version 2.6.1|author=Guy Cousineau, {{en-link|Gérard Huet}}|url=https://hal.inria.fr/inria-00070045/document|year=1990|access-date=2021-09-02|archive-date=2022-05-04|archive-url=https://web.archive.org/web/20220504232145/https://hal.inria.fr/inria-00070045/document}} RT-0122, INRIA. pp.78.<br />{{cite web|title=The CAML reference manual Version 2.6.1|url=https://hal.inria.fr/inria-00070046/document|author=Pierre Weis, Maria Virginia Aponte, Alain Laville, Michel Mauny, Ascander Suarez|year=1990|access-date=2021-09-02|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406231614/https://hal.inria.fr/inria-00070046/document}} [Research Report] RT-0121, INRIA. pp.491.</ref>。在1990年和1991年，[[法国国家信息与自动化研究所|INRIA]]的{{en-link|Xavier Leroy}}基于用[[C语言|C]]实现的字节码解释器<ref>{{cite web|author=Xavier Leroy|title=The ZINC experiment : an economical implementation of the ML language|year=1990|url=https://hal.inria.fr/inria-00070049/document|access-date=2021-09-06|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406232126/https://hal.inria.fr/inria-00070049/document}} RT-0117, INRIA.</ref>，利用{{en-link|Damien Doligez}}提供的内存管理系统重新实现了Caml，并称其为[[Caml|Caml Light]]<ref>{{cite web|url=https://caml.inria.fr/pub/docs/manual-caml-light/|title=The Caml Light system Release 0.74, documentation and user's guide|author={{en-link|Xavier Leroy}}|year=1997|access-date=2021-09-02|archive-date=2022-03-08|archive-url=https://web.archive.org/web/20220308045958/https://caml.inria.fr/pub/docs/manual-caml-light/}}</ref>。在1995年，Xavier Leroy又增加了机器代码编译器和高层模块系统<ref name=“module”>{{cite web|author=Xavier Leroy|title=Manifest types, modules, and separate compilation|publisher=Principles of Programming Languages|year=1994|url=https://caml.inria.fr/pub/papers/xleroy-manifest_types-popl94.pdf|access-date=2021-09-07|archive-date=2021-10-22|archive-url=https://web.archive.org/web/20211022073638/https://caml.inria.fr/pub/papers/xleroy-manifest_types-popl94.pdf}}</ref>，这个版本也称为“Caml Special Light”。在1996年，[[法国国家信息与自动化研究所|INRIA]]的Didier Rémy和Jérôme Vouillon，向Caml Special Light增加了[[面向对象编程|面向对象]]特征<ref>{{cite web|author=Didier Rémy|title=Type inference for records in a natural extension of ML|publisher=Research Report RR-1431, INRIA|year=1991|url=https://hal.inria.fr/inria-00075129/document|access-date=2021-09-10|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406233611/https://hal.inria.fr/inria-00075129/document}}<br />{{cite web|author=Didier Rémy, Jérôme Vouillon|title=Objective ML: a simple object-oriented extension of ML|url=http://gallium.inria.fr/~remy/ftp/objective-ml!popl97.pdf|year=1997|access-date=2021-09-06|archive-date=2022-01-21|archive-url=https://web.archive.org/web/20220121031810/http://gallium.inria.fr/~remy/ftp/objective-ml!popl97.pdf}}<br />{{cite web|author=Didier Rémy, Jérôme Vouillon|title=Objective ML: An effective object-oriented extension to ML|url=https://caml.inria.fr/pub/papers/remy_vouillon-objective_ml-tapos98.pdf|year=1998|access-date=2021-09-06|archive-date=2022-01-20|archive-url=https://web.archive.org/web/20220120081109/https://caml.inria.fr/pub/papers/remy_vouillon-objective_ml-tapos98.pdf}}</ref>，从而形成了[[OCaml|OCaml]]<ref>{{cite web|title=The Objective Caml system release 1.07, Documentation and user's manual|url=https://caml.inria.fr/pub/distrib/ocaml-1.07/ocaml-1.07-refman.txt|author=Xavier Leroy|year=1997|access-date=2021-09-02|archive-date=2022-01-23|archive-url=https://web.archive.org/web/20220123211218/https://caml.inria.fr/pub/distrib/ocaml-1.07/ocaml-1.07-refman.txt}}</ref>。

今天ML家族的两个主要的方言是[[Standard_ML|Standard ML]]和[[OCaml|OCaml]]。ML的实力大多被用于语言设计和操作，比如建构编译器、分析器、定理证明器，但是它作为通用语言也被用于生物信息和财务系统等领域。ML确立了[[静态类型|静态类型]][[函数式编程|函数式]][[编程范型|编程范型]]，从而在[[编程语言历史|编程语言历史]]上占有显要地位，它的思想在影响了众多的语言，例如[[Haskell|Haskell]]、[[Nemerle|Nemerle]]<ref name="nemerle">{{Citation |title=Programming language for "special forces" of developers. |publisher=Nemerle Project Team |publication-place=Russian Software Development Network |url=http://nemerle.org/About |access-date=January 24, 2021 |archive-date=2021-05-04 |archive-url=https://web.archive.org/web/20210504173355/http://nemerle.org/About }}</ref>、{{en-link|ATS (编程语言)|ATS (programming language)|ATS}}和[[Elm_(编程语言)|Elm]]<ref name="elm">{{cite book|author=Bruce A. Tate, Fred Daoud, Ian Dees, Jack Moffitt|title=Seven More Languages in Seven Weeks|date=2014|url=http://www.r-5.org/files/books/computers/overviews/cs-tools/Bruce_Tate-Seven_More_Languages_in_Seven_Weeks-EN.pdf|publisher=The Pragmatic Programmers, LLC|isbn=978-1-941222-15-7|pages=97, 101|edition=Book version: P1.0-November 2014|chapter=3. Elm|quote=On page 101, Elm creator Evan Czaplicki says: 'I tend to say "Elm is an ML-family language" to get at the shared heritage of all these languages.' ["these languages" is referring to Haskell, OCaml, SML, and F#.]|access-date=2021-09-04|archive-date=2021-03-15|archive-url=https://web.archive.org/web/20210315062732/http://www.r-5.org/files/books/computers/overviews/cs-tools/Bruce_Tate-Seven_More_Languages_in_Seven_Weeks-EN.pdf}}</ref>。

==解释与编译==
ML代码片段很容易通过将其录入到“顶层”来研习，它也叫作[[读取﹣求值﹣输出循环|读取﹣求值﹣输出循环]]或REPL。这是打印结果或定义的表达式的推论类型的交互式会话。很多SML实现提供交互式REPL，比如[[新泽西Standard_ML|SML/NJ]]：
<syntaxhighlight lang="console">
$ sml
Standard ML of New Jersey v110.79 [built: Sat Oct 26 12:27:04 2019]
- 
</syntaxhighlight>

可以在提示符<code>-</code>后键入代码。例如计算<code>1 + 2 * 3</code>:

<syntaxhighlight lang="sml">
- 1 + 2 * 3;
val it = 7 : int
</syntaxhighlight>

顶层推论这个表达式的类型为<code>int</code>并给出结果<code>7</code>。如果输入不完全则打印第二提示符<code>=</code>，这时经常可以用<code>;</code>终结输入。<code>it</code>是给未指定变量的表达式的标准变量。输入control-C可返回解释器顶层，输入control-D可退出解释器。

下面是[[Hello,_world|hello, world!]]的程序代码在SML/NJ解释器下执行的结果：
<syntaxhighlight lang="sml">
- val _ = print "Hello, world!\n";
Hello, world!
</syntaxhighlight>
和使用[[MLton|MLton]]编译器进行编译执行的例子：
<syntaxhighlight lang="console">
$ echo 'print "Hello, world!\n";' > hello-world.sml
$ mlton hello-world.sml
$ ./hello-world
Hello, world!
</syntaxhighlight>

==核心语言==
不同于[[纯函数式编程|纯函数式编程]]语言，ML是兼具一些指令式特征的[[函数式编程|函数式编程]]语言。ML的特征包括：传值调用的[[求值策略|求值策略]]，[[头等函数|头等函数]]，带有[[垃圾回收_(計算機科學)|垃圾收集]]的自动[[内存管理|内存管理]]，[[参数多态|参数多态]]，[[静态类型|静态类型]]，[[类型推论|类型推论]]，{{en-link|代数数据类型|Algebraic data type}}，[[模式匹配|模式匹配]]和[[异常处理|异常处理]]。不同于[[Haskell|Haskell]]，ML与大多数编程语言一样使用[[及早求值|及早求值]]。

用ML书写的程序构成自要被求值的{{en-link|表达式 (计算机科学)|Expression (computer science)|表达式}}，而非语句或命令，尽管一些表达式返回一个平凡的<code>unit</code>值并且只为其[[副作用_(计算机科学)|副作用]]而求值。以下章节介绍采用[[Standard_ML|Standard ML]]的语法和语义。

===函数===
就像所有的函数式语言一样，ML的关键特征是[[子程序|函数]]，它被用于进行抽象。例如[[阶乘|阶乘]]函数用纯ML可表达为：

<syntaxhighlight lang="sml">
fun fac 0 = 1
  | fac n = n * fac (n - 1)
</syntaxhighlight>

这里将阶乘描述为递归函数，具有一个单一的终止基础情况。它类似于在数学教科书见到的阶乘描述。多数ML代码在设施和语法上类似于数学。

凭借类型推论编译器能推导出，<code>fac</code>接受整数<code>0</code>作为实际参数，则形式参数<code>n</code>也是整数类型<code>int</code>，而<code>fac 0</code>的结果是整数<code>1</code>，则函数<code>fac</code>的结果也是整数类型。函数<code>fac</code>接受一个整数的形式参数并返回一个整数结果，它作为一个整体从而有着“从整数到整数的函数”类型<code>int -> int</code>。函数及其形式参数的"类型"还可以用类型标注（annotation）来描述，使用<code>E : t</code>表示法，它可以被读作表达式<code>E</code>有类型<code>t</code>，它是可选也可忽略的。使用类型标注，这个例子可重写为如下：

<syntaxhighlight lang="sml">
fun fac 0 = 1
  | fac (n : int) : int = n * fac (n - 1)
</syntaxhighlight>

这个函数还依赖于[[模式匹配|模式匹配]]，这是ML语言的重要部份。注意函数形式参数不必须在圆括号内但要用空格分隔。当一个函数的实际参数是<code>0</code>，它将返回整数<code>1</code>。对于所有其他情况，尝试第二行。这是一个[[递归_(计算机科学)|递归]]，并且再次执行这个函数直到达到基础情况。它可以使用<code>case</code>表达式重写为：

<syntaxhighlight lang="sml">
fun fac n = case n 
     of 0 => 1
      | n => n * fac (n - 1)
</syntaxhighlight>

这里<code>case</code>介入了模式和对应表达式的序列。它还可以重写为将标识符绑定到[[匿名函数|lambda函数]]：

<syntaxhighlight lang="sml">
val rec fac =
     fn 0 => 1
      | n => n * fac (n - 1)
</syntaxhighlight>

这里的关键字<code>val</code>介入了标识符到值的绑定，<code>fn</code>介入了[[匿名函数|匿名函数]]的定义，它可以用在<code>fun</code>的位置上，但使用<code>=></code>算符而非<code>=</code>。绑定到递归的匿名函数需要使用<code>rec</code>关键字来指示。

通过将主要工作写入[[尾调用|尾递归]]风格的内部迭代函数，借助于语言编译或解释系统进行的[[尾调用|尾调用优化]]，这个函数可以得以增进性能，它的[[调用栈|调用栈]]不需要随函数调用数目而成比例的增长。对这个函数可以采用向内部函数增加额外的“[[累加器|累加器]]”形式参数<code>acc</code>来实现：

<syntaxhighlight lang="sml">
fun fact n = let
    fun fac (0, acc) = acc
      | fac (n, acc) = fac (n - 1, n * acc)
    in
        fac (n, 1)
    end
</syntaxhighlight>

<code>let</code>表达式的值是在<code>in</code>和<code>end</code>之间表达式的值。这个递归函数的实现不保证能够终止，因为负数实际参数会导致递归调用的[[无穷降链|无穷降链条件]]。更健壮的实现会在递归前检查实际参数为非负数，并在有问题的情况，即<code>n</code>是负数的时候，启用[[异常处理|异常处理]]：

<syntaxhighlight lang="sml">
fun fact n = let
    fun fac (0, acc) = acc
      | fac (n, acc) = fac (n - 1, n * acc)
    in
        if (n < 0) 
        then raise Fail "negative argument"
        else fac (n, 1)
    end
</syntaxhighlight>

===类型===
有一些基本类型可以当作是“内建”的，因为它们是在Standard ML标准基本库中预先定义的，并且语言为它们提供{{en-link|文字 (计算机编程)|Literal (computer programming)|文字}}表示法，比如<code>34</code>是整数，而<code>"34"</code>是字符串。一些最常用的基本类型是：
* <code>int</code> [[整数|整数]]，比如<code>3</code>或<code>~12</code>。注意波浪号<tt>~</tt>表示负号。
* <code>real</code>[[浮点数|浮点数]]，比如<code>4.2</code>或<code>~6.4</code>。Standard ML不隐含的提升整数为浮点数，因此表达式<code>2 + 5.67</code> 是无效的。
* <code>string</code>[[字符串|字符串]]，比如<code>"this is a string"</code>或<code>""</code>（空串）。
* <code>char</code>[[字符_(计算机科学)|字符]]，比如<code>#"y"</code>或<code>#"\n"</code>（换行符）。
* <code>bool</code>[[布尔值|布尔值]]，它是要么<code>true</code>要么<code>false</code>。产生<code>bool</code>值的有比较算符<code>=</code>、<code><></code>、<code>></code>、<code>>=</code>、<code><</code>、<code><=</code>，逻辑函数<code>not</code>和[[短路求值|短路求值]]的中缀算符<code>andalso</code>、<code>orelse</code>。

包括上述基本类型的各种类型可以用多种方式组合。一种方式是[[元组|元组]]，它是值的有序集合，比如表达式<code>(1, 2)</code>的类型是<code>int * int</code>，而<code>("foo", false)</code>的类型是<code>string * bool</code>。可以使用<code>#1 ("foo", false)</code>这样的语法来提取元组的指定次序的成员。

有0元组<code>()</code>，它的类型指示为<code>unit</code>。但是没有1元组，或者说在例子<code>(1)</code>和<code>1</code>之间没有区别，都有类型<code>int</code>。元组可以嵌套，<code>(1, 2, 3)</code>不同于<code>((1, 2), 3)</code>和<code>(1, (2, 3))</code>二者。前者的类型是<code>int * int * int</code>，其他两个的类型分别是<code>(int * int) * int</code>和<code>int * (int * int)</code>。

组合值的另一种方式是[[记录|记录]]。记录很像元组，除了它的成员是有名字的而非有次序的，例如<code>{a = 5.0, b = "five"}</code>有类型<code>{a : real, b : string}</code>，这同于类型<code>{b : string, a : real}</code>。可以使用<code>#a {a = 5.0, b = "five"}</code>这样的语法来选取记录的指定名字的字段。

Standard ML中的函数只接受一个值作为参数，而不是参数的一个列表，可以使用上述元组模式匹配来实际上传递多个参数。函数还可以返回一个元组。例如：
<syntaxhighlight lang="sml">
fun sum (a, b) = a + b
fun average pair = sum pair div 2

infix averaged_with
fun a averaged_with b = average (a, b)
val c = 3 averaged_with 7

fun int_pair (n : int) = (n, n)
</syntaxhighlight>
这里第一段创建了两个类型是<code>int * int -> int</code>的函数<code>sum</code>和<code>average</code>。第二段创建[[中缀表示法|中缀]]算子<code>averaged_with</code>，接着定义它为类型<code>int * int -> int</code>的函数。最后的<code>int_pair</code>函数的类型是<code>int -> int * int</code>。

下列函数是[[参数多态|多态类型]]的一个例子：
<syntaxhighlight lang="sml">
fun pair x = (x, x)
</syntaxhighlight>
编译器无法推论出的<code>pair</code>的特殊化了的类型，它可以是<code>int -> int * int</code>、<code>real -> real * real</code>甚至是<code>(int * real -> string) -> (int * real -> string) * (int * real -> string)</code>。在Standard ML中，它可以简单指定为多态类型<code>'a -> 'a * 'a</code>，这里的<code>'a</code>（读作“[[Α|alpha]]”）是一个类型变量，指示任何可能的类型。在上述定义下，<code>pair 3</code>和<code>pair "x"</code>都是有良好定义的，分别产生<code>(3, 3)</code>和<code>("x", "x")</code>。

SML标准基本库包括了[[运算符重载|重载标识符]]：<code>+</code>、<code>-</code>、<code>*</code>、<code>div</code>、<code>mod</code>、<code>/</code>、<code>~</code>、<code>abs</code>、<code><</code>、<code>></code>、<code><=</code>、<code>>=</code>。标准基本库提供了多态函数：<code>!</code>、<code>:=</code>、<code>o</code>、<code>before</code>、<code>ignore</code>。中缀运算符可以有从缺省最低<code>0</code>到最高<code>9</code>的任何[[运算符优先级|运算符优先级]]。标准基本库提供了如下内建中缀规定：
<syntaxhighlight lang="sml">
infix  7  * / div mod
infix  6  + - ^
infixr 5  :: @
infix  4  = <> > >= < <=
infix  3  := o
infix  0  before
</syntaxhighlight>

===等式类型===
算符<code>=</code>和<code><></code>分别被定义为多态的等式和不等式。<code>=</code>它确定两个值是否相等，有着类型<code><nowiki>''a * ''a -> bool</nowiki></code>。这意味着它的两个运算数必须有相同的类型，这个类型必须是等式类型（<code>eqtype</code>）。上述基本类型中除了<code>real</code>之外，<code>int</code>、<code>real</code>、<code>string</code>、<code>char</code>和<code>bool</code>都是等式类型。

例如：<code>3 = 3</code>、<code>"3" = "3"</code>、<code>#"3" = #"3"</code>和<code>true = true</code>，都是有效的表达式并求值为<code>true</code>；而<code>3 = 4</code>是有效表达式并求值为<code>false</code>，<code>3.0 = 3.0</code>是无效表达式而被编译器拒绝。这是因为IEEE浮点数等式打破了ML中对等式的一些要求。特别是<code>nan</code>不等于自身，所以关系不是自反的。

元组和记录类型是等式类型，当时且仅当它的每个成员类型是等式类型；例如<code>int * string</code>、<code>{b : bool, c : char}</code>和<code>unit</code>是等式类型，而<code>int * real</code>和<code>{x : real}</code>不是。函数类型永远不是等式类型，因为一般情况下不可能确定两个函数是否等价。

===类型声明===
类型声明或同义词（synonym）使用<code>type</code>关键字来定义。下面是给在平面中的点的类型声明，计算两点间距离，和通过[[海伦公式|海伦公式]]计算给定角点的三角形的面积的函数。
<syntaxhighlight lang="sml">
type loc = real * real

fun heron (a: loc, b: loc, c: loc) = let
    fun dist ((x0, y0), (x1, y1)) = let
        val dx = x1 - x0
        val dy = y1 - y0
        in
            Math.sqrt (dx * dx + dy * dy)
        end
    val ab = dist (a, b)
    val bc = dist (b, c)
    val ac = dist (a, c)
    val s = (ab + bc + ac) / 2.0
    in
        Math.sqrt (s * (s - ab) * (s - bc) * (s - ac))
    end
</syntaxhighlight>

===数据类型===
Standard ML提供了对{{en-link|代数数据类型|Algebraic data type}}（ADT）的强力支持。一个ML数据类型可以被当作是[[元组|元组]]的[[不交并|不交并]]（{{en-link|积类型|Product type|积}}之[[和类型|和]]）。数据类型使用<code>datatype</code>关键字来定义，比如：
<syntaxhighlight lang="sml">
datatype int_or_string
  = INT of int
  | STRING of string
  | NEITHER
</syntaxhighlight>
这个数据类型声明建立一个全新的数据类型<code>int_or_string</code>，还有一起的新[[构造器|构造子]]（一种特殊函数或值）<code>INT</code>、<code>STRING</code>和<code>NEITHER</code>；每个这种类型的值都是要么<code>INT</code>具有一个整数，要么<code>STRING</code>具有一个字符串，要么<code>NEITHER</code>。写为如下这样：
<syntaxhighlight lang="sml">
val i = INT 3
val s = STRING "qq"
val n = NEITHER
val INT j = i
</syntaxhighlight>
这里最后的一个声明通过模式匹配，将变量<code>j</code>绑定到变量<code>i</code>所绑定的整数<code>3</code>。<code>val 模式 = 表达式</code>是绑定的一般形式，它是良好定义的，当且仅当模式和表达式有相同的类型。

数据类型可以是[[多态_(计算机科学)|多态]]的：
<syntaxhighlight lang="sml">
datatype 'a pair
  = PAIR of 'a * 'a
</syntaxhighlight>
这个数据类型声明建立一个新的类型<code>'a pair</code>家族，比如<code>int pair</code>，<code>string pair</code>等等。

数据类型可以是[[递归数据类型|递归]]的：
<syntaxhighlight lang="sml">
datatype int_list
  = EMPTY
  | INT_LIST of int * int_list
</syntaxhighlight>
这个数据类型声明建立一个新类型<code>int_list</code>，这个类型的每个值是要么<code>EMPTY</code>（空列表），要么是一个整数和另一个<code>int_list</code>的接合。

通过<code>datatype</code>创建的类型是等式类型，如果它的所有变体，要么是没有参数的空构造子，要么是有等式类型参数的构造子，并且在多态类型情况下所有类型参数也都是等式类型。递归类型在有可能情况下是等式类型，否则就不是。

===列表===
基础库提供的复杂数据类型之一是列表<code>list</code>。它是一个递归的、多态的数据类型，可以等价的定义为：
<syntaxhighlight lang="sml">
datatype 'a list
  = nil 
  | :: of 'a * 'a list
</syntaxhighlight>
这里的<code>::</code>是中缀算符，例如<code>3 :: 4 :: 5 :: nil</code>是三个整数的列表。列表是ML程序中最常用的数据类型之一，语言还为生成列表提供了特殊表示法<code>[3, 4, 5]</code>。

<code>real list</code>当然不是等式类型。但是没有<code>int list</code>不能是等式类型的理由，所以它就是等式类型。注意类型变量不同就是不同的列表类型，比如<code>(nil : int list) = (nil : char list)</code>是无效的，因为两个表达式有不同的类型，即使它们有相同的值。但是<code>nil = nil</code>和<code>(nil : int list) = nil</code>都是有效的。

基本库<code>rev</code>函数“反转”一个列表中的元素。它的类型是<code>'a list -> 'a list</code>，就是说它可以接受其元素有任何类型的列表，并返回相同类型的列表。更准确的说，它返回其元素相较于给定列表是反转次序的一个新列表，比如将<code>[ "a", "b", "c" ]</code>映射成<code>[ "c", "b", "a" ]</code>。中缀算符<code>@</code>表示两个列表的串接。

<code>rev</code>和<code>@</code>一般被实现为基本库函数<code>revAppend</code>的简单应用：
<syntaxhighlight lang="sml">
fun revAppend ([], l) = l
  | revAppend (x :: r, l) = revAppend(r, x :: l)

fun rev l = revAppend(l, [])

fun l1 @ l2 = revAppend(rev l1, l2)
</syntaxhighlight>

===模式匹配===
Standard ML的数据类型可以轻易的定义和用于编程，在很大程度上是由它的[[模式匹配|模式匹配]]，还有多数Standard ML实现的模式穷尽性检查和模式冗余检查。

模式匹配可以在语法上嵌入到变量绑定之中，比如：
<syntaxhighlight lang="sml">
val ((m: int, n: int), (r: real, s: real)) = ((2, 3), (2.0, 3.0))

type hyperlink = {protocol: string, address: string, title: string}

val url : hyperlink =
    {title="The Standard ML Basis Library", protocol="https",
     address="//smlfamily.github.io/Basis/overview.html"}
val {protocol=port, address=addr, title=name} = url

val x as (fst, snd) = (2, true)
</syntaxhighlight>
第一个<code>val</code>绑定了四个变量<code>m</code>、<code>n</code>、<code>r</code>和<code>s</code>；第二个<code>val</code>绑定了一个变量<code>url</code>；第三个<code>val</code>绑定了三个变量<code>port</code>、<code>addr</code>和<code>name</code>，第四个叫分层模式，绑定了三个变量<code>x</code>、<code>fst</code>和<code>snd</code>。

模式匹配可以在语法上嵌入到函数定义中，比如：
<syntaxhighlight lang="sml">
datatype shape
  = Circle of loc * real    (* 中心和弧度 *)
  | Square of loc * real    (* 左上角和边长，坐标轴对齐 *)
  | Triangle of loc * loc * loc     (* 角点 *)

fun area (Circle (_, r)) = 3.14 * r * r
  | area (Square (_, s)) = s * s
  | area (Triangle (a, b, c)) = heron (a, b, c) 
</syntaxhighlight>

次序在模式匹配中是紧要的：模式按文本次序来依次进行匹配。在特定计算中，使用下划线<code>_</code>，来省略不需要它的值的子成员，这也叫做通配符（wildcard）模式。所谓的“子句形式”风格的函数定义，这里的模式紧随在函数名字之后出现，只是如下形式的一种[[语法糖|语法糖]]：
<syntaxhighlight lang="sml">
fun area shape = case shape
      of Circle (_, r) => 3.14 * r * r
       | Square (_, s) => s * s
       | Triangle (a, b, c) => heron (a, b, c)
</syntaxhighlight>

模式穷尽性检查将确保数据类型的每个情况都已经顾及到。{{efn|
子句集合是穷尽和不冗余的函数示例：
<syntaxhighlight lang="sml">
fun hasCorners (Circle _) = false
  | hasCorners _ = true
</syntaxhighlight>
如果控制通过了第一个模式<code>Circle</code>，则这个值必定是要么<code>Square</code>要么<code>Triangle</code>。在任何这些情况下，这个形状都有角点，所以返回<code>true</code>而不用区分具体是那种情况。}}
如果有遗漏，则产生警告。{{efn|
不详尽的模式示例：
<syntaxhighlight lang="sml">
fun center (Circle (c, _)) = c
  | center (Square ((x, y), s)) = (x + s / 2.0, y + s / 2.0)
</syntaxhighlight>
这里在<code>center</code>函数中没有给<code>Triangle</code>的模式。
编译器发起模式不详尽的一个警告，并且如果在运行时间，<code>Triangle</code>被传递给这个函数，则发起异常<code>Match</code>。}}
如果模式存在冗余，也会导致一个编译时间警告。{{efn|
存在模式冗余的（无意义）函数示例：
<syntaxhighlight lang="sml">
fun f (Circle ((x, y), r)) = x+y
  | f (Circle _) = 1.0
  | f _ = 0.0
</syntaxhighlight>
匹配第二个子句的模式的任何值都也匹配第一个子句的模式，所以第二个子句是不可到达的。因此这个定义整体上是冗余的。}}

===高阶函数===
函数可以接受函数作为实际参数，比如：
<syntaxhighlight lang="sml">
fun applyToBoth f x y = (f x, f y)
</syntaxhighlight>

函数可以产生函数作为返回值，比如：
<syntaxhighlight lang="sml">
fun constantFn k = (fn anything => k)
</syntaxhighlight>

函数可以同时接受和产生函数，比如{{en-link|函数复合 (计算机科学)|Function composition (computer science)|复合函数}}：
<syntaxhighlight lang="sml">
fun compose (f, g) = (fn x => f (g x))
</syntaxhighlight>

基本库的函数<code>List.map</code>，是在Standard ML中最常用的[[Curry化|Curry化]][[高阶函数|高阶函数]]，它在概念上可定义为：
<syntaxhighlight lang="sml">
fun map' _ [] = []
  | map' f (x :: xs) = f x :: map f xs
</syntaxhighlight>
在基本库中将函数复合定义为多态中缀算符<code>(f o g)</code>，<code>[[Map_(高阶函数)|map]]</code>和<code>[[Fold_(高阶函数)|fold]]</code>高阶函数有较高效率的实现。{{efn|
映射函数的实际实现：
<syntaxhighlight lang="sml">
fun map f = let
    fun m [] = []
	  | m [a] = [f a]
	  | m [a, b] = [f a, f b]
	  | m [a, b, c] = [f a, f b, f c]
	  | m (a :: b :: c :: d :: r) = f a :: f b :: f c :: f d :: m r
    in
	    m
    end
</syntaxhighlight>
折叠函数的实际实现：
<syntaxhighlight lang="sml">
fun foldl f b l = let
    fun f2 ([], b) = b
	  | f2 (a :: r, b) = f2 (r, f (a, b))
    in
	    f2 (l, b)
    end

fun foldr f b l = foldl f b (rev l)
</syntaxhighlight>
过滤器函数的实际实现：
<syntaxhighlight lang="sml">
fun filter pred [] = []
  | filter pred (a :: rest) =
      if pred a
	  then a :: (filter pred rest)
	  else (filter pred rest)
</syntaxhighlight>}}

===异常===
异常可以使用<code>raise</code>关键字发起，并通过模式匹配<code>handle</code>构造来处理：
<syntaxhighlight lang="sml">
exception Undefined;

fun max [x] = x
  | max (x :: xs) = let
    val m = max xs
    in
        if x > m then x else m 
    end
  | max [] =
      raise Undefined

fun main xs = let
    val msg = (Int.toString (max xs))
              handle Undefined => "empty list...there is no max!"
    in
        print (msg ^ "\n")
    end
</syntaxhighlight>

这里的<code>^</code>是字符串串接算符。可以利用异常系统来实现非局部退出，例如这个函数所采用技术：
<syntaxhighlight lang="sml">
exception Zero;

fun listProd ns = let
    fun p [] = 1
      | p (0 :: _) = raise Zero
      | p (h :: t) = h * p t
    in
        (p ns)
        handle Zero => 0
    end
</syntaxhighlight>

异常<code>Zero</code>在<code>0</code>情况下发起，控制从函数<code>p</code>中一起出离。

===引用===
初始化基础库还以引用的形式提供了[[不可变对象|可变]]的存储。引用<code>ref</code>可以在某种意义上被认为是如下这样定义的：

<syntaxhighlight lang="sml">
datatype 'a ref = ref of 'a
</syntaxhighlight>

还定义了内建的<code>:=</code>函数来修改引用的内容，和<code>!</code>函数来检索引用的内容。阶乘函数可以使用引用定义为[[指令式编程|指令式]]风格：
<syntaxhighlight lang="sml">
fun factImperative n = let
    val i = ref n and acc = ref 1
    in
        while !i > 0 do
            (acc := !acc * !i;
             i := !i - 1);
        !acc
    end
</syntaxhighlight>
这里使用圆括号对以<code>;</code>分隔的表达式进行了顺序复合。

可变类型<code>'a ref</code>是等式类型，即使它的成员类型不是。两个引用被称为是相等的，如果它们标识相同的“<code>ref</code>单元”，就是说相同的对<code>ref</code>构造子调用生成的同一个指针。因此<code>(ref 1) = (ref 1)</code>和<code>(ref 1.0) = (ref 1.0)</code>都是有效的，并且都求值为<code>false</code>，因为即使两个引用碰巧指向了相同的值，引用自身是分立的，每个都可以独立于其他而改变。

==模块语言==
[[模块化编程|模块]]是ML用于构造大型项目和库的系统。

===模块===
一个模块构成自一个签名（signature）文件和一个或多个结构文件。签名文件指定要实现的[[API|API]]（就像C语言头文件或[[接口_(Java)|Java接口]]文件）。结构实现这个签名（就像C语言源文件或Java[[类_(计算机科学)|类]]文件）。解释器通过<code>use</code>命令导入它们。ML的标准库被实现为这种方式的模块。

例如，下列定义一个[[算术|算术]]签名：
<syntaxhighlight lang="sml">
signature ARITH =
sig
    eqtype t
    val zero : t
    val one : t
    val fromInt: int -> t  
    val fromIntPair : int * int -> t
    val fromReal : real -> t
    val succ : t -> t
    val pred : t -> t
    val ~ : t -> t
    val + : t * t -> t
    val - : t * t -> t
    val * : t * t -> t
    val / : t * t -> t
    val == : t * t -> bool
    val <> : t * t -> bool
    val > : t * t -> bool
    val >= : t * t -> bool
    val < : t * t -> bool
    val <= : t * t -> bool
end
</syntaxhighlight>
和这个签名使用[[有理数|有理数]]的实现：
<syntaxhighlight lang="sml">
structure Rational : ARITH =
struct
    datatype t = Rat of int * int
    val zero = Rat (0, 1)
    val one = Rat (1, 1)
    fun fromInt n = Rat (n, 1)
    fun ineg (a, b) = (~a, b)
    fun fromIntPair (num, den) = let
        fun reduced_fraction (numerator, denominator) = let
            fun gcd (n, 0) = n
              | gcd (n, d) = gcd (d, n mod d)
            val d = gcd (numerator, denominator)
            in 
                if d > 1 then (numerator div d, denominator div d) 
                else (numerator, denominator)
            end
        in  
            if num < 0 andalso den < 0
            then Rat (reduced_fraction (~num, ~den))
            else if num < 0 
            then Rat (ineg (reduced_fraction (~num, den)))
            else if den < 0
            then Rat (ineg (reduced_fraction (num, ~den)))
            else Rat (reduced_fraction (num, den))
        end
    val SOME maxInt = Int.maxInt
    val minPos = 1.0 / (real maxInt)
    fun fromReal r = let
        fun convergent (i, f, h_1, k_1, h_2, k_2) = 
              if i <> 0 andalso ((h_1 > (maxInt - h_2) div i)
                  orelse (k_1 > (maxInt - k_2) div i))
              then (h_1, k_1)
              else if f < minPos 
              then (i * h_1 + h_2, i * k_1 + k_2)
              else convergent (trunc (1.0 / f), Real.realMod (1.0 / f),
                               i * h_1 + h_2, i * k_1 + k_2, h_1, k_1)
        in 
            if r < 0.0
            then Rat (ineg (convergent (trunc (~ r), 
                      Real.realMod (~ r), 1, 0, 0, 1))) 
            else Rat (convergent (trunc r, Real.realMod r, 1, 0, 0, 1))
        end
    fun succ (Rat (a, b)) = fromIntPair (a + b, b)
    fun pred (Rat (a, b)) = fromIntPair (a - b, b)
    fun add (Rat (a, b), Rat (c, d)) = 
          if b = d then fromIntPair(a + c, b) 
          else fromIntPair (a * d + c * b, b * d)
    fun sub (Rat (a, b), Rat (c, d)) = 
          if b = d then fromIntPair(a - c, b) 
          else fromIntPair (a * d - c * b, b * d)
    fun mul (Rat (a, b), Rat (c, d)) = fromIntPair (a * c, b * d)
    fun div_ (Rat (a, b), Rat (c, d)) = fromIntPair (a * d, b * c)
    fun gt (Rat (a, b), Rat (c, d)) =
          if b = d then (a > c) else (a * d) > (b * c)
    fun lt (Rat (a, b), Rat (c, d)) =
          if b = d then (a < c) else (a * d) < (b * c)
    fun neg (Rat (a, b)) = Rat (~a, b)
    fun eq (Rat (a, b), Rat (c, d)) = ((b = d) andalso (a = c))
    fun ~ a = neg a
    fun a + b = add (a, b)
    fun a - b = sub (a, b)
    fun a * b = mul (a, b)
    fun a / b = div_ (a, b)
    fun op == (a, b) = eq (a, b)
    fun a <> b = not (eq (a, b))
    fun a > b = gt (a, b)
    fun a >= b = (gt (a, b) orelse eq (a, b))
    fun a < b = lt (a, b)
    fun a <= b = (lt (a, b) orelse eq (a, b))
end
</syntaxhighlight>
下面是这个结构的简单用例：
<syntaxhighlight lang="sml">
infix ==
local open Rational
in
val c = let 
    val a = fromIntPair(2, 3)
    val b = fromIntPair(4, 6)
    in
        a + b
    end
end
structure R = Rational
R.fromReal(3.245)
</syntaxhighlight>
Standard ML只允许通过签名函数同实现进行交互，例如不可以直接通过这个代码中的<code>Rat</code>来建立数据对象。结构块对外部隐藏所有实现细节。这里的<code>:</code>叫做透明归属（ascription），可以通过所绑定的变量见到此结构的数据内容，与之相对的是<code>:></code>，它叫做不透明归属，此结构的数据内容对外完全不可见。比如上面用例有结果：<code>val c = Rat (4,3) : Rational.t</code>，如果改为不透明归属则有结果：<code>val c = - : Rational.t</code>。

要用有理数进行实际上的数值计算，需要处理[[分数|分数]]形式中分母快速增大导致[[算术溢出|溢出]]整数类型大小范围等问题。{{efn|
对分数采取修约的有理数实现：
<syntaxhighlight lang="sml">
signature ARITH =
sig
    eqtype t
    val zero : t
    val one : t
    val fromInt: int -> t  
    val fromIntPair : int * int -> t
    val repr : t -> unit
    val succ : t -> t
    val pred : t -> t
    val ~ : t -> t
    val + : t * t -> t
    val - : t * t -> t
    val * : t * t -> t
    val / : t * t -> t
end
</syntaxhighlight>
<syntaxhighlight lang="sml">
structure Rational : ARITH =
struct
    type t = int * int
    val zero = (0, 1)
    val one = (1, 1)
    val maxInt = (let val SOME a = Int.maxInt in Int.toLarge a end)
    fun fromInt n = (n, 1)
    fun neg (a, b) = (~a, b)
    fun fromLargePair (a, b) = (Int.fromLarge a, Int.fromLarge b)
    fun fromIntPair (num, den) = let
        fun reduced_fraction (numerator, denominator) = let
            fun gcd (n, 0) = n
              | gcd (n, d) = gcd (d, n mod d)
            val d = gcd (numerator, denominator)
            in 
                if d > 1 then (numerator div d, denominator div d) 
                else (numerator, denominator)
            end
        in
            if num < 0 andalso den < 0
            then reduced_fraction (~num, ~den)
            else if num < 0 
            then neg (reduced_fraction (~num, den))
            else if den < 0
            then neg (reduced_fraction (num, ~den))
            else reduced_fraction (num, den)
        end
    fun repr (a, b) = let
        val m = if (b = 0) then 0 else if (a >= 0) then a div b else ~a div b
        val n = if (b = 0) then 1 else if (a >= 0) then a mod b else ~a mod b
        val ms = Int.toString m and ns = Int.toString n and bs = Int.toString b
        in 
            if n <> 0 andalso m <> 0 andalso a < 0
            then print ("~" ^ ms ^ " - " ^ ns ^ "/" ^ bs ^ "\n")
            else if n <> 0 andalso m <> 0  
            then print (ms ^ " + " ^ ns ^ "/" ^ bs ^ "\n")
            else if n <> 0 andalso m = 0 andalso a < 0
            then print ("~" ^ ns ^ "/" ^ bs ^ "\n")
            else if n <> 0 andalso m = 0 
            then print (ns ^ "/" ^ bs ^ "\n")
            else if a < 0 
            then print ("~" ^ ms ^ "\n")
            else print (ms ^ "\n")
        end
    fun convergent (i, n, d, h_1, k_1, h_2, k_2) = 
          if i <> 0 andalso ((h_1 > (maxInt - h_2) div i)
              orelse (k_1 > (maxInt - k_2) div i))
          then (h_1, k_1)  
          else if n = 0
          then (i * h_1 + h_2, i * k_1 + k_2) 
          else convergent (d div n, d mod n, n,
                           i * h_1 + h_2, i * k_1 + k_2, h_1, k_1) 
    fun add ((a, b), (c, d)) = let
        val la = Int.toLarge a and lb = Int.toLarge b
        val lc = Int.toLarge c and ld = Int.toLarge d 
        val m = la * ld + lb * lc and n = lb * ld 
        in 
            if b = d 
            then fromIntPair (a + c, b)
            else fromLargePair (convergent (m div n, m mod n, n, 1, 0, 0, 1))
        end 
    fun sub ((a, b), (c, d)) = let
        val la = Int.toLarge a and lb = Int.toLarge b
        val lc = Int.toLarge c and ld = Int.toLarge d  
        val m = la * ld - lb * lc and n = lb * ld
        in  
            if b = d
            then fromIntPair (a - c, b)
            else if m < 0 
            then neg (fromLargePair (convergent (~m div n, ~m mod n, n, 1, 0, 0, 1)))
            else if m > 0
            then fromLargePair (convergent (m div n, m mod n, n, 1, 0, 0, 1))
            else (0, 1)
        end
    fun mul ((a, b), (c, d)) = let
        val la = Int.toLarge a and lb = Int.toLarge b
        val lc = Int.toLarge c and ld = Int.toLarge d 
        val m = la * lc and n = lb * ld 
        in  
            fromLargePair (convergent (m div n, m mod n, n, 1, 0, 0, 1))
        end
    fun op + ((a, b), (c, d)) = 
          if a < 0 andalso c < 0 
          then neg (add ((~a, b), (~c, d)))
          else if a < 0
          then sub ((c, d), (~a, b))
          else if c < 0
          then sub ((a, b), (~c, d))
          else add ((a, b), (c, d))
    fun op - ((a, b), (c, d)) = 
          if a < 0 andalso c < 0 
          then sub ((~c, d), (~a, b))
          else if a < 0
          then neg (add ((~a, b), (c, d)))
          else if c < 0
          then add ((a, b), (~c, d))
          else sub ((a, b), (c, d))
    fun op * ((a, b), (c, d)) = 
          if a < 0 andalso c < 0  
          then mul ((~a, b), (~c, d))
          else if a < 0
          then neg (mul ((~a, b), (c, d)))
          else if c < 0
          then neg (mul ((a, b), (~c, d)))
          else mul ((a, b), (c, d))
    fun op / ((a, b), (c, d)) =
          if a < 0 andalso c < 0  
          then mul ((~a, b), (d, ~c))
          else if a < 0
          then neg (mul ((~a, b), (d, c)))
          else if c < 0
          then neg (mul ((a, b), (d, ~c)))
          else mul ((a, b), (d, c))
    fun succ a = add (a, one)
    fun pred a = sub (a, one)
    fun ~ a = neg a
end
</syntaxhighlight>}}

===函子===
{{main|函子 (函数式编程)}}
函子接受指定签名的一个结构作为参数，并返回一个结构作为结果，下面示例的函子能在<code>ARITH</code>签名的结构上计算[[移动平均|移动平均]]：
<syntaxhighlight lang="sml">
signature MOVINGLIST = 
sig
    type t
    structure Arith : sig
        type t end
    val size : t -> int
    val average : t -> Arith.t
    val fromList : Arith.t list -> t
    val move : t * Arith.t -> t
    val expand : t * Arith.t -> t
    val shrink : t -> t
    val trunc : t -> t
end
</syntaxhighlight>
<syntaxhighlight lang="sml">
functor MovingList (S: ARITH) : MOVINGLIST = 
struct
    type t = S.t list * int * S.t
    structure Arith = S
    fun size (ml : t) = #2 ml
    fun average (ml : t) = #3 ml
    fun fromList (l : S.t list) = let
        val n = length l
        val sum = foldl S.+ S.zero l
        local open S in
        val m = sum / (fromInt n) end 
        in
            if (null l) then raise Empty
            else (l, n, m) 
        end
    fun move ((l, n, m) : t, new : S.t) = let
        val old = List.nth (l, n - 1) 
        local open S in
        val m' = m + (new - old) / (fromInt n) end    
        in
            (new :: l, n, m')
        end     
    fun expand ((l, n, m) : t, new : S.t) = let
        val n' = n + 1; 
        local open S in
        val m' = m + (new - m) / (fromInt n') end
        in
            (new :: l, n', m')
        end
    fun shrink ((l, n, m) : t) = let
        val old = List.nth (l, n - 1) 
        val n' = if (n > 2) then n - 1 else 1 
        local open S in 
        val m' = m + (m - old) / (fromInt n') end
        in
            (l, n', m')
        end
    fun trunc ((l, n, m) : t) =
          (List.take (l, n), n, m)
end
</syntaxhighlight>
和这个函子的简单用例：
<syntaxhighlight lang="sml">
structure R = Rational
structure MLR = MovingList (Rational)
val d = MLR.fromList [R.fromIntPair (4, 5), R.fromIntPair (2, 3)]
val d = MLR.expand (d, R.fromIntPair (5, 6))
val d = MLR.move (d, R.fromIntPair (7, 8))
val d = MLR.shrink d
val d = MLR.trunc d
</syntaxhighlight>
这个用例承上节示例，<code>Rational</code>结构采用了透明归属，有结果如：<code>val d = ([Rat (4,5),Rat (2,3)],2,Rat (11,15)) : MLR.t</code>。如果它改为不透明归属，则对应结果为：<code>val d = ([-,-],2,-) : MLR.t</code>。

==示例代码==
下列例子使用了[[Standard_ML|Standard ML]]的语法和语义。

===素数===
下面是求[[素数|素数]]的[[试除法|试除法]]实现：
<syntaxhighlight lang="sml">
fun prime n = let
    fun isPrime (l, i) = let
        fun existsDivisor [] = false 
          | existsDivisor (x :: xs) = 
              if (i mod x) = 0 then true
              else if (x * x) > i then false 
              else existsDivisor xs
        in  
            not (existsDivisor l)
        end
    fun iterate (acc, i) =
          if i > n then acc
          else if isPrime (acc, i)
          then iterate (acc @ [i], i + 2)
          else iterate (acc, i + 2)
    in 
        if n < 2 then []
        else iterate ([2], 3)
    end
</syntaxhighlight>
基本库<code>find</code>和<code>exists</code>函数在不存在符合条件元素的时候会遍历整个列表，{{efn|找出函数的实际实现：
<syntaxhighlight lang="sml">
fun find pred [] = NONE
  | find pred (a :: rest) =
      if pred a 
      then SOME a 
      else (find pred rest)
</syntaxhighlight>
存在谓词函数的实际实现：
<syntaxhighlight lang="sml">    
fun exists pred = let
    fun f [] = false
      | f (h :: t) = 
          pred h orelse f t
    in
        f
    end
</syntaxhighlight>
}}
这里采用了特殊化了的<code>existsDivisor</code>，用以在后续元素都不满足条件时立即结束运算。

下面是[[埃拉托斯特尼|埃拉托斯特尼]][[埃拉托斯特尼筛法|筛法]]实现：
<syntaxhighlight lang="sml">
fun prime n = let
    fun dropComposite (acc, [], _, _) = rev acc
      | dropComposite (acc, l as x :: xs, j, i) = 
          if j > n then List.revAppend (acc, l) 
          else if x < j  
          then dropComposite (x :: acc, xs, j, i)
          else if x > j 
          then dropComposite (acc, l, j + i, i)
          else dropComposite (acc, xs, j + i, i)
    fun init i = let
        fun loop (l, i) = 
              if i <= 2 then l
              else loop (i :: l, i - 2)
        in
            loop ([], i - (i + 1) mod 2)
        end
    fun iterate (acc, []) = rev acc     
      | iterate (acc, l as x :: xs) = 
          if x * x > n
          then 2 :: List.revAppend (acc, l)
          else iterate (x :: acc,
                 dropComposite ([], xs, x * x, x * 2))
    in 
        if n < 2 then [] 
        else iterate ([], init n)
    end
</syntaxhighlight>
这里基于列表的[[埃拉托斯特尼筛法|筛法]]实现符合[[埃拉托斯特尼|埃拉托斯特尼]]的原初算法<ref name="horsley">{{en-link|Samuel Horsley}} FRS, "[https://www.jstor.org/stable/106053 {{Wayback|url=https://www.jstor.org/stable/106053 |date=20181002215249 }} {{lang|el|Κόσκινον Ερατοσθένους}} or The Sieve of Eratosthenes.]" Being an account of his method of finding all the Prime Numbers, [[Philosophical_Transactions_of_the_Royal_Society|Philosophical Transactions]] (1683–1775), Vol. 62. (1772), pp. 327–347.</ref>。[[埃拉托斯特尼筛法|筛法]]还有基于[[数组|数组]]的直观实现。{{efn|
[[埃拉托斯特尼筛法|筛法]]基于[[数组|数组]]的实现：
<syntaxhighlight lang="sml">
fun prime n = let
    val sieve = Array.array (n + 1, true);
    fun markComposite (j, i) =
          if j > n then () 
          else (Array.update (sieve, j, false); 
                markComposite (j + i, i))
    fun iterate i =
          if i * i > n then ()
          else if Array.sub (sieve, i)
          then (markComposite (i * i, i);
                iterate (i + 1))
          else iterate (i + 1)
    fun generate (acc, i) = 
          if i < 2 then acc
          else if Array.sub (sieve, i) 
          then generate (i :: acc, i - 1)
          else generate (acc, i - 1) 
    in 
        if n < 2 then [] 
        else (iterate 2;
              generate ([], n))
    end
</syntaxhighlight>}}
下面是其解释器下命令行运行实例：
<syntaxhighlight lang="sml">
- fun printIntList (l: int list) =
=     print ((String.concatWith " " (map Int.toString l)) ^ "\n");
val printIntList = fn : int list -> unit
- val _ = printIntList (prime 100);
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
</syntaxhighlight>

===汉明数===
[[正规数_(整数)|正规数]]是形如<math>\ 2^i\cdot 3^j\cdot 5^k\ </math>的[[整数|整数]]，对于非负整数<math>\ i\ </math>、<math>\ j\ </math>和<math>\ k</math>，它是可以整除<math>\ 60^{\max(\lceil i\,/2\rceil,j,k)}\ </math>的数。计算升序的[[正规数_(整数)|正规数]]的算法经由[[艾兹赫尔·戴克斯特拉|戴克斯特拉]]得以流行<ref>{{citation | author = [[Edsger_W._Dijkstra|Edsger W. Dijkstra]] | contribution = 17. An exercise attributed to R. W. Hamming | isbn = 978-0132158718 | pages = [https://archive.org/details/disciplineofprog0000dijk/page/129 129–134] | publisher = Prentice-Hall | title = A Discipline of Programming | url = https://archive.org/details/disciplineofprog0000dijk/page/129 | year = 1976 }}<br />
{{citation | author = Edsger W. Dijkstra | title = Hamming's exercise in SASL | year = 1981 | url = http://www.cs.utexas.edu/users/EWD/ewd07xx/EWD792.PDF | id = Report EWD792. Originally a privately circulated handwritten note | accessdate = 2021-05-19 | archive-date = 2019-04-04 | archive-url = https://web.archive.org/web/20190404171350/http://www.cs.utexas.edu/users/EWD/ewd07xx/EWD792.PDF }}.</ref>，[[理查德·衛斯里·漢明|理查德·汉明]]最初提出了这个问题，故而这个问题被称为“汉明问题”，这个数列也因而被称为汉明数。Dijkstra计算这些数的想法如下：
* 汉明数的序列开始于数<code>1</code>。
* 要加入序列中的数有下述形式：<code>2h, 3h, 5h</code>，这里的<code>h</code>是序列已有的任意的汉明数。
* 因此，可以生成最初只有一个<code>1</code>的序列<code>H</code>，并接着{{en-link|归并算法|Merge algorithm|归并}}序列<code>2H, 3H, 5H</code>，并以此类推。
示例汉明数程序代码，一般用来展示，确使计算只在需要时进行的[[纯函数式编程|纯函数式编程]]方式<ref>{{cite book|title=An Overview of Miranda|2=|chapter=Lazy evaluation and infinite lists|url=https://www.cs.kent.ac.uk/people/staff/dat/miranda/Overview.html#Lazy|author=David Turner|year=1986|publisher=Computing Laboratory, University of Kent|access-date=2021-09-16|archive-date=2021-12-23|archive-url=https://web.archive.org/web/20211223210539/https://www.cs.kent.ac.uk/people/staff/dat/miranda/Overview.html#Lazy}}<br />{{cite web|author=CS3110|title=Streams and Laziness|url=https://www.cs.cornell.edu/courses/cs3110/2018sp/l/12-streams/notes.html|publisher=Cornell University|year=2018|access-date=2021-09-16|archive-date=2022-03-03|archive-url=https://web.archive.org/web/20220303040629/https://www.cs.cornell.edu/courses/cs3110/2018sp/l/12-streams/notes.html}}</ref>。
<syntaxhighlight lang="sml">
fun Hamming_number n = let
    fun merge (p, q) = let
        fun revMerge (acc, p, q) =
              if not (null p) andalso not (null q) then
                  if hd p < hd q
                  then revMerge ((hd p) :: acc, tl p, q)
                  else if hd p > hd q
                  then revMerge ((hd q) :: acc, p, tl q)
                  else revMerge ((hd p) :: acc, tl p, tl q)
              else if null p 
              then List.revAppend (q, acc)
              else List.revAppend (p, acc)
        in
            if (null p) then q
            else if (null q) then p
            else rev (revMerge ([], p, q))
        end
    fun mul m x =
          if x <= (n div m) then SOME (x * m) else NONE
    fun mapPrefix pred l = let
        fun mapp ([], acc) = rev acc
          | mapp (x :: xs, acc) = 
             (case (pred x)
                of SOME a => mapp (xs, a :: acc)
                 | NONE => rev acc)
        in
            mapp (l, [])
        end
    fun mergeWith f (m, i) = merge (f m, i)
    fun generate l = let
        fun listMul m = mapPrefix (mul m) l
        in
            foldl (mergeWith listMul) [] [2, 3, 5]
        end
    fun iterate (acc, l) =
          if (hd l) > (n div 2) then merge (l, acc)
          else iterate (merge (l, acc), generate l)
    in
        if n > 0 then iterate ([], [1]) else []
    end
</syntaxhighlight>
产生指定范围内的汉明数需要多轮运算，后面每轮中的三个列表元素乘积运算中都可能产生超出这个范围的结果，它们不需要出现在后续的运算之中。{{efn| 汉明数进一步性质演示代码：
<syntaxhighlight lang="sml">
fun printIntList (l: int list) =
    print ((String.concatWith " " (map Int.toString l)) ^ "\n");
fun diff (p, q) = let
    fun revDiff (acc, p, q) =
          if not (null p) andalso not (null q) then
              if hd p < hd q
              then revDiff ((hd p) :: acc, tl p, q)
              else if hd p > hd q
              then revDiff (acc, p, tl q)
              else revDiff (acc, tl p, tl q)
          else if null q 
          then List.revAppend (p, acc)
          else acc
    in
        if (null p) then []
        else if (null q) then p
        else rev (revDiff ([], p, q))
    end;
fun Hamming_number n = let
    fun merge (p, q) = let
        fun revMerge (acc, p, q) =
              if not (null p) andalso not (null q) then
                  if hd p < hd q
                  then revMerge ((hd p) :: acc, tl p, q)
                  else if hd p > hd q
                  then revMerge ((hd q) :: acc, p, tl q)
                  else revMerge ((hd p) :: acc, tl p, tl q)
              else if null p 
              then List.revAppend (q, acc)
              else List.revAppend (p, acc)
        in
            if (null p) then q
            else if (null q) then p
            else rev (revMerge ([], p, q))
        end
    fun mergeWith f (m, i) = merge (f m, i)
    fun mul m x = (x * m)             
    fun generate l = let
        fun listMul m = map (mul m) l
        in
            printIntList (listMul 2);
            printIntList (diff (listMul 3, listMul 2));
            printIntList (diff (listMul 5, merge (listMul 2, listMul 3)));  
            foldl (mergeWith listMul) [] [2, 3, 5]
        end
    val count = ref 1;
    fun iterate (acc, l) =
          if (hd l) > (n div 2) then merge (l, acc)
          else (print ("round " ^ (Int.toString (!count)) ^ " for " ^
                       (Int.toString(length l)) ^ " number(s)\n");
                count := !count + 1;
                iterate (merge (l, acc), generate l))
    in
        if n > 0 then iterate ([], [1]) else []
    end;
</syntaxhighlight>
<syntaxhighlight lang="sml">
val l = Hamming_number 400;
val h = List.filter (fn x => (x <= 400)) l;
val _ = print ((Int.toString (length h)) ^ " numbers from " ^ 
               (Int.toString (length l)) ^ " numbers\n");
</syntaxhighlight>}}
基本库<code>mapPartial</code>函数与它所映射的函数，通过基于<code>Option</code>结构的<code>SOME</code>和<code>NONE</code>构造子的协定，可以将所映射函数认为不符合条件的元素或者结果排除掉，它会遍历整个列表。{{efn|部份映射函数的实际实现：
<syntaxhighlight lang="sml">
fun mapPartial pred l = let
    fun mapp ([], l) = rev l
      | mapp (x :: r, l) =
         (case (pred x)
            of SOME y => mapp (r, y :: l)
             | NONE => mapp (r, l)
             (* end case *))
    in
        mapp (l, [])
    end
</syntaxhighlight>}}
由于这个算法采用升序列表，故而这里将它改写为<code>mapPrefix</code>函数，用来在特定条件不满足条件就立即结束。下面是汉明数程序在解释器下命令行运行实例：
<syntaxhighlight lang="sml">
- fun printIntList (l: int list) =
=     print ((String.concatWith " " (map Int.toString l)) ^ "\n");
val printIntList = fn : int list -> unit
- val _ = printIntList (Hamming_number 400);
1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 27 30 32 36 40 45 48 50 54 60 64 72 75 80 81 90 96 100 108 120 125 128 135 144 150 160 162 180 192 200 216 225 240 243 250 256 270 288 300 320 324 360 375 384 400
</syntaxhighlight>

===续体传递风格实例===
下面是{{en-link|续体传递风格|Continuation-passing style}}（CPS）<ref>{{cite wikisource|title=Scheme: An Interpreter for Extended Lambda Calculus|author=Gerald J. Sussman, Guy L. Steele Jr|year=1975|quote=It is always possible, ……to perform any calculation in this way: rather than reducing to its value, it reduces to an application of a continuation to its value (cf. [Fischer]). That is, in this continuation-passing programming style, a function always "returns" its result by "sending" it to another function.}}</ref>的[[高阶函数|高阶函数]][[Fold_(高阶函数)|foldr]]和[[Map_(高阶函数)|map]]的实现，和达成一个整数列表的合计函数的简单用例：
<syntaxhighlight lang="sml">
fun foldr' f b l = let
    fun f2 (k, []) = k b
      | f2 (k, a :: r) =
          f2 (fn x => k (f (a, x)), r)
    in
        f2 (fn x => x, l)
    end

fun map' f l = 
      foldr' (fn (x, y) => (f x) :: y) [] l 

fun sum l =
      foldr' (fn (x, y) => (x + y)) 0 l
</syntaxhighlight>

对于输入<code>[e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>n</sub>]</code>，<code>sum</code>函数等价于[[复合函数|函数复合]]<code>(fn x => x) o (fn x => e<sub>1</sub> + x) o (fn x => e<sub>2</sub> + x) o ... o (fn x => e<sub>n</sub> + x)</code>，它应用于<code>0</code>上得到<code>(e<sub>1</sub> + (e<sub>2</sub> + (... + (e<sub>n</sub> + 0)...)))</code>。<ref>{{cite web|title=Continuations|url=https://www.cs.cornell.edu/courses/cs312/2006sp/lectures/lec22-23.html|author=CS312|year=2006|publisher=Cornell University|access-date=2021-10-11|archive-date=2021-10-28|archive-url=https://web.archive.org/web/20211028170720/https://www.cs.cornell.edu/courses/cs312/2006sp/lectures/lec22-23.html}}<br />{{cite web|title=Continuations and CPS Conversion|url=https://www.cs.cornell.edu/courses/cs3110/2014sp/recitations/27/cps.html|author=CS3110|year=2014|publisher=Cornell University|access-date=2021-10-11|archive-date=2018-02-15|archive-url=https://web.archive.org/web/20180215045053/http://www.cs.cornell.edu/courses/cs3110/2014sp/recitations/27/cps.html}}</ref>

[[新泽西Standard_ML|SML/NJ]]支持[[头等对象|头等对象]]的[[计算续体|续体]]<ref>{{cite web|author=Bruce Duba, Robert Harper, David MacQueen|title=Typing first-class continuations in ML|url=https://www.cs.cmu.edu/~rwh/papers/callcc/popl91.pdf|year=1991|access-date=2021-10-14|archive-date=2022-01-29|archive-url=https://web.archive.org/web/20220129212748/https://www.cs.cmu.edu/~rwh/papers/callcc/popl91.pdf}}</ref>。头等续体对一门语言而言是能完全控制指令执行次序的能力。它们可以用来跳转到产生对当前函数调用的那个函数，或者跳转到此前已经退出了的函数。头等续体保存了程序执行状态，它不保存程序数据，只保存执行[[上下文_(计算机)|上下文]]。

===排序算法===
[[排序算法|排序算法]]关注[[计算复杂度|计算复杂度]]，特别是[[时间复杂度|时间复杂度]]，基本库函数的实现细节也要考虑在内，比如串接函数<code>@</code>，它被实现为<code>fun l1 @ l2 = revAppend(rev l1, l2)</code>，除非必需的情况避免使用遍历整个列表的<code>rev</code>和<code>length</code>函数。{{efn|
列表长度函数的实际实现：
<syntaxhighlight lang="sml">
fun length l = let
    (* fast add that avoids the overflow test *)
    val op + = Int.fast_add
    fun loop (n, []) = n
	  | loop (n, [_]) = n + 1
	  | loop (n, _ :: _ :: l) = loop (n + 2, l)
    in
	    loop (0, l)
    end
</syntaxhighlight>}}
通过比较于这些排序算法的周知[[过程式编程|过程式编程]]语言比如[[C语言|C]]语言的实现，可以体察到ML在控制流程和列表数据结构上的相关限制，和与之相适应的采用[[尾调用|尾递归]]的特色[[函数式编程|函数式编程]]风格。

====插入排序====
下面是简单的[[插入排序|插入排序]]算法的[[尾调用|尾递归]]和等价的普通递归实现：
{| class = wikitable
|-
! 尾递归 !! 普通递归 
|- style="vertical-align:top"
|
<syntaxhighlight lang="sml">
fun insertSort l = let
    fun insert pred (ins, l) = let
        fun loop (acc, []) =
              List.revAppend (acc, [ins])
          | loop (acc, l as x :: xs) =
              if pred (ins, x)
              then List.revAppend (acc, ins :: l)
              else loop (x :: acc, xs)
        in  loop ([], l) end
    val rec ge = fn (x, y) => (x >= y)     
    in
        rev (foldl (insert ge) [] l)
    end
</syntaxhighlight>
||
<syntaxhighlight lang="sml">
fun insertSort l = let
    fun insert pred (ins, []) =
          [ins]

      | insert pred (ins, l as x :: xs) =
          if pred (ins, x)
	      then ins :: l
	      else x :: (insert pred (ins, xs))

    val rec ge = fn (x, y) => (x >= y)     
    in
        rev (foldl (insert ge) [] l)
    end
</syntaxhighlight>
|-style="text-align:center"
| <code>x</code>保存在形式参数<code>acc</code>对应的[[动态内存分配|分配堆]]中 || <code>x</code>保存在[[调用栈|调用栈]]栈帧中
|}
插入排序算法是[[排序算法#穩定性|稳定]]的{{en-link|自适应排序|Adaptive sort}}，它在输入列表趋于正序的时候性能最佳，在输入列表趋于反序的时候性能最差，因此在算法实现中，需要<code>insert</code>函数所插入列表保持为反序，在插入都完成后经<code>rev</code>函数再反转回正序。在预期输入数据趋于随机化或者预知它经过了反转的情况下，可以采用保持要插入列表为正序的变体插入排序算法实现，它在输入列表趋于反序的时候性能最佳，在输入列表趋于正序的时候性能最差，它比自适应实现少作一次全列表反转。{{efn|变体的插入排序算法实现：
<syntaxhighlight lang="sml">
fun insertSort l = let
    fun insert pred (ins, l) = let
        fun loop (acc, []) =
              List.revAppend (acc, [ins])
          | loop (acc, l as x :: xs) =
              if pred (ins, x)
              then List.revAppend (acc, ins :: l)
              else loop (x :: acc, xs)
         in 
            loop ([], l)
        end
    val rec lt = fn (x, y) => (x < y)     
    in
        foldl (insert lt) [] l
    end
</syntaxhighlight>}}
采用<code>foldr</code>函数可以相应的保持要插入列表为正序，由于<code>fun foldr f b l = foldl f b (rev l)</code>，它等同于对反转过的列表应用变体插入排序。

====希尔排序====
[[希尔排序|希尔排序]]算法是对插入排序的改进，保持了{{en-link|自适应排序|Adaptive sort|自适应性}}，放弃了[[排序算法#穩定性|稳定性]]。{{efn|下面是希尔排序算法的原型实现，当输入列表趋于正序的时候，<code>scatter</code>函数将其分解为一组趋于反序的子列表，经过在输入趋于反序情况下性能最佳的变体插入排序后，<code>gather</code>函数再将它们合成为一个列表：
<syntaxhighlight lang="sml">
fun shellSort l = let
    fun insert pred (ins, l) = let
        fun loop (acc, []) =
              List.revAppend (acc, [ins])
          | loop (acc, l as x :: xs) =
              if pred (ins, x)
              then List.revAppend (acc, ins :: l)
              else loop (x :: acc, xs)
        in 
            loop ([], l)
        end
    val rec lt = fn (x, y) => (x < y)
    fun insertSort l = foldl (insert lt) [] l 
    fun scatter (l, n) = let
        fun dup n = let
            fun loop (acc, i) =
                  if i <= 0 then acc
                  else loop ([] :: acc, i - 1)
            in
                loop ([], n)
            end
        fun loop ([], acc, lol) =
              List.revAppend (acc, lol)
          | loop (l, acc, []) =
              loop (l, [], rev acc)
          | loop (x :: xs, acc, l :: ls) =
              loop (xs, (x :: l) :: acc, ls)
        in
            loop (l, [], dup n)
        end
    fun gather lol = let
        fun loop ([], [], l) = rev l
          | loop (acc, [], l) =
              loop ([], rev acc, l)
          | loop (acc, [] :: ls, l) =
              loop (acc, ls, l)  
          | loop (acc, (x :: xs) :: ls, l) =    
              loop (xs :: acc, ls, x :: l)
        in
            loop ([], lol, [])
        end 
    val gap = let
        fun loop (acc, i) = let
        val h = (i * 5 - 1) div 11
            in
                if i < 5 then rev (1 :: acc) 
                else loop (h :: acc, h)
            end
        in 
            loop ([], length l)
        end
    fun sort (h, l) = gather (map insertSort (scatter (l, h)))
    in
        foldl sort l gap 
    end
</syntaxhighlight>}}
下面是希尔排序的实现：
<syntaxhighlight lang="sml">
fun shellSort l = let
    fun insert pred (ins, l) = let
        fun loop (acc, []) =
              List.revAppend (acc, [ins])
          | loop (acc, l as x :: xs) =
              if pred (ins, x)
              then List.revAppend (acc, ins :: l)
              else loop (x :: acc, xs)
        in 
            loop ([], l)
        end
    val rec lt = fn (x, y) => (x < y)
    fun insertSort [] = []
      | insertSort [x] = [x]
      | insertSort [x, y] =
          if (y < x) then [y, x] else [x, y] 
      | insertSort (x :: y :: z :: xs) = let
        val (x, y, z) = 
              if (y < x) then
                  if z < y then (z, y, x) 
                  else if z < x then (y, z, x)
                  else (y, x, z)
              else
                  if z < x then (z, x, y)
                  else if z < y then (x, z, y) 
                  else (x, y, z)
        in
           foldl (insert lt) [x, y, z] xs
        end 
    fun group (lol, n) = let
        fun dup n = let
            fun loop (acc, i) =
                  if i <= 0 then acc
                  else loop ([] :: acc, i - 1)
            in
                loop ([], n)
            end    
        fun loop ([], [], accj, lol') = 
              List.revAppend (accj, lol')
          | loop (acci, [], accj, []) =
              loop ([], rev acci, [], rev accj)              
          | loop (acci, [], accj, lol') =
              loop ([], rev acci, accj, lol')
          | loop (acci, lol, accj, []) =
              loop (acci, lol, [], rev accj)    
          | loop (acci, [] :: ls, accj, lol') =
              loop (acci, ls, accj, lol')  
          | loop (acci, (x :: xs) :: ls, accj, l' :: ls') =                
              loop (xs :: acci, ls, (x :: l') :: accj, ls')
        in
            loop ([], lol, [], dup n)
        end 
    val (lol, len) = foldl
          (fn (x, (l, n)) => ([x] :: l, n + 1)) ([], 0) (rev l)
    val incs = [1, 4, 9, 20, 46, 103, 233, 525, 1182, 2660, 
                5985, 13467, 30301, 68178, 153401, 345152,
                776591, 1747331, 3931496, 8845866, 19903198,
                44782196, 100759940, 226709866, 510097200]
    val gap = let
        val v = len * 3 div 4
        val thold = if (v = 0) then 1 else v
        fun loop (acc, h) = 
              if (hd h) > thold then acc
              else loop ((hd h) :: acc, tl h)
        in 
            loop ([], incs)
        end
    fun sort (h, lol) = map insertSort (group (lol, h))
    in
        hd (foldl sort lol gap) 
    end
</syntaxhighlight>
这里采用的间隔序列是[[OEIS|OEIS]] {{OEIS link|A108870}}，即<math>\ \begin{smallmatrix} \left\lceil \frac{1}{5} \left(9\cdot \left(\frac{9}{4}\right)^{k-1} - 4 \right) \right\rceil \end{smallmatrix} \ </math>，它是徳田尚之在1992年提出的<ref>{{Cite book |editor-last=van Leeuven |editor-first=Jan |chapter=An Improved Shellsort |last=Tokuda |first=Naoyuki |title=Proceedings of the IFIP 12th World Computer Congress on Algorithms, Software, Architecture |publisher=North-Holland Publishing Co. |location=Amsterdam |year=1992 |pages=449–457 |isbn=978-0-444-89747-3}}</ref>。这个序列用递推公式表示为：<code>h<sub>k</sub> = ⌈h'<sub>k</sub>⌉</code>，这里的<code>h'<sub>k</sub> = 2.25·h'<sub>k-1</sub> + 1</code>而<code>h'<sub>1</sub> = 1</code>。假定一个列表的长度<code>s</code>位于序列两个元素之间，即<code>h<sub>k-1</sub> < h<sub>k</sub> ≤ s < h<sub>k+1</sub></code>，如果<code>h<sub>k</sub> ≤ <math>\tfrac {n}{m}</math>·s</code>，这里的<code>n ≤ m</code>，则选择初始间隔为<code>h<sub>k</sub></code>，否则为<code>h<sub>k-1</sub></code>。在这个阈值下，对于不同长度<code>s</code>的列表和对应的初始间隔<code>h</code>，每个列表的这些初始子列表的平均长度<code><math>\tfrac{s}{h}</math></code>，约在<code><math>\tfrac{m}{n}</math> ≤ <math>\tfrac{s}{h}</math> < <math>\tfrac{9}{4}</math>·<math>\tfrac{m}{n}</math></code>范围之内。间隔序列还可以采用[[OEIS|OEIS]] {{OEIS link|A102549}}，它是Marcin Ciura在2001年通过实验得到的<ref>{{Cite book |chapter-url=http://sun.aei.polsl.pl/~mciura/publikacje/shellsort.pdf |title=Proceedings of the 13th International Symposium on Fundamentals of Computation Theory |editor-last=Freiwalds |editor-first=Rusins |last=Ciura |first=Marcin |chapter=Best Increments for the Average Case of Shellsort |publisher=Springer-Verlag |location=London |year=2001 |pages=106–117 |isbn=978-3-540-42487-1 |access-date=2021-10-06 |archive-date=2011-08-30 |archive-url=https://web.archive.org/web/20110830050227/http://sun.aei.polsl.pl/~mciura/publikacje/shellsort.pdf }}</ref>。{{efn|希尔排序还可以采用Ciura提出的间隔序列：
<syntaxhighlight lang="sml">
    val incs = [1750, 701, 301, 132, 57, 23, 10, 4, 1]
    val gap = let
        fun loop (acc, i) = let
            val h = (i * 4 - 1) div 9
            fun iter incs =
                  if i >= (hd incs) * 4 div 3 then incs
                  else iter (tl incs)
            in
                if i <= ((hd incs) * 3)
                then List.revAppend (acc, iter incs) 
                else loop (h :: acc, h)
            end
        in  
            if len = 0 then [1]
            else loop ([], len)
        end
</syntaxhighlight>}}

====快速排序====
下面是[[快速排序|快速排序]]算法的自顶向下实现：
<syntaxhighlight lang="sml">
fun quickSort [] = []
  | quickSort [x] = [x]
  | quickSort [x, y] =
      if x <= y then [x, y] else [y, x]
  | quickSort [x, y, z] = let
    val (x, y) = if x <= y then (x, y) else (y, x)
    val (y, z) = if y <= z then (y, z) else (z, y)
    val (x, y) = if x <= y then (x, y) else (y, x)
    in
        [x, y, z]
    end
  | quickSort (pivot :: xs) = let
    fun partition pred l = let
        fun loop ([], p, q) = (p, q)
          | loop (h :: t, p, q) =
              if (pred h) 
              then loop (t, h :: p, q)
              else loop (t, p, h :: q)
        in
            loop (l, [], [])
        end
    val (le, gt) = partition (fn x => (x <= pivot)) xs
    in  
        (quickSort le) @ (pivot :: (quickSort gt))
    end
</syntaxhighlight>
基本库<code>partition</code>函数实现对快速排序而言有不必要的反转，{{efn|
划分函数的实际实现：
<syntaxhighlight lang="sml">
fun partition pred l = let
    fun loop ([], trueList, falseList) =
          (rev trueList, rev falseList)
      | loop (h :: t, trueList, falseList) =
          if pred h then loop (t, h :: trueList, falseList)
          else loop (t, trueList, h :: falseList)
    in
	    loop (l, [], [])
    end
</syntaxhighlight>}}
这里采用了它的简化改写。在ML中[[快速排序|快速排序]]应采用自底向上实现：
<syntaxhighlight lang="sml">
fun quickSort l = let 
    fun partition pred l = let
        fun loop ([], p, q) = (p, q)
          | loop (h :: t, p, q) =
              if (pred h) 
              then loop (t, h :: p, q)
              else loop (t, p, h :: q)
        in
            loop (l, [], [])
        end
    fun iterate (acc, []) = acc
      | iterate (acc, [] :: xs) = iterate (acc, xs)
      | iterate (acc, [x] :: xs) = iterate (x :: acc, xs)
      | iterate (acc, [x, y] :: xs) = let
        val (x, y) = if x <= y then (x, y) else (y, x) 
        in
            iterate (x :: y :: acc, xs)
        end
      | iterate (acc, [x, y, z] :: xs) = let
        val (x, y) = if x <= y then (x, y) else (y, x)
        val (x, y, z) =
              if y <= z then (x, y, z)
              else if x <= z then (x, z, y)
              else (z, x, y)
        in
            iterate (x :: y :: z :: acc, xs)
        end
      | iterate (acc, (pivot :: d) :: xs) = let
        val (le, gt) = partition (fn x => (x <= pivot)) d
        in
            iterate (acc, gt :: [pivot] :: le :: xs) 
        end       
    in
        iterate ([], [l])
    end
</syntaxhighlight>

====归并排序====
下面是[[归并排序|归并排序]]算法的自底向上法实现：
<syntaxhighlight lang="sml">
fun mergeSort l = let
    fun init (acc, []) = acc
      | init (acc, [x]) = [x] :: acc
      | init (acc, [x, y]) =
          if x <= y then [x, y] :: acc else [y, x] :: acc
      | init (acc, x :: y :: z :: xs) = let
        val (x, y, z) =
              if x <= y then
                  if y <= z then (x, y, z)
                  else if x <= z then (x, z, y)
                  else (z, x, y)
              else 
                  if x <= z then (y, x, z)
                  else if y <= z then (y, z, x)
                  else (z, y, x)
        in
            init ([x, y, z] :: acc, xs)
        end
    fun mergeWith _ (acc, [], []) = acc
      | mergeWith _ (acc, p, []) = List.revAppend (p, acc)  
      | mergeWith _ (acc, [], q) = List.revAppend (q, acc)
      | mergeWith cmp (acc, p :: ps, q :: qs) =
          if cmp (p, q)
          then mergeWith cmp (p :: acc, ps, q :: qs)
          else mergeWith cmp (q :: acc, p :: ps, qs)
    val mergeRev = mergeWith (fn (x, y) => (x > y))
    val revMerge = mergeWith (fn (x, y) => (x < y))
    fun iterate ([], _) = []
      | iterate ([x], isRev) =
          if isRev then rev x else x
      | iterate (acc, isRev) = let      
        val merge = if isRev then mergeRev else revMerge
        fun loop (acci, []) = acci
          | loop (acci, [x]) = (rev x) :: acci 
          | loop (acci, x :: y :: xs) = 
              loop (merge ([], x, y) :: acci, xs)
        in
            iterate (loop ([], acc), not isRev)
        end
    in
        iterate (init ([], l), false)
    end
</syntaxhighlight>
考虑输入列表<code>[x<sub>1</sub>, ..., x<sub>i</sub>, a<sub>0</sub>, ..., a<sub>9</sub>, x<sub>j</sub>, ..., x<sub>n</sub>]</code>，这里在<code>x<sub>i</sub></code>和<code>x<sub>j</sub></code>之间的<code>10</code>个<code>a</code>，具有相同的值并且需要保持其下标表示的次序，这里的<code>x<sub>i</sub> > a</code>并且<code>x<sub>j</sub> < a</code>，并且在这个区段前后的元素总数都能被<code>3</code>整除，则它被分解成子列表的列表<code>[X<sub>m</sub>, ..., [x<sub>j</sub>, a<sub>8</sub>, a<sub>9</sub>], [a<sub>5</sub>, a<sub>6</sub>, a<sub>7</sub>], [a<sub>2</sub>, a<sub>3</sub>, a<sub>4</sub>], [a<sub>0</sub>, a<sub>1</sub>, x<sub>i</sub>], ..., X<sub>1</sub>]</code>，这里有<code>m = n div 3</code>；假定这<code>4</code>个含有<code>a</code>的子列表两两归并，在归并正序子列表的归并条件<code>x < y</code>下，能得到<code>[X<sub>1</sub>, ..., [x<sub>i</sub>, a<sub>4</sub>, ..., a<sub>0</sub>], [a<sub>9</sub>, ..., a<sub>5</sub>, x<sub>j</sub>], ..., X<sub>k</sub>]</code>；继续推演下去，在归并反序子列表的归并条件<code>x > y</code>下，能得到<code>[X<sub>h</sub>, ..., [x<sub>j</sub>, a<sub>0</sub>, ..., a<sub>9</sub>, x<sub>i</sub>], ..., X<sub>1</sub>]</code>。可以看出这种归并操作能够保证排序算法的[[排序算法#穩定性|稳定性]]，即具有相同值的元素之间的相对次序保持不变。

分解初始的子列表采用了插入排序，还可进一步增加其大小。归并排序也有自顶向下实现。{{efn|
归并排序算法的自顶向下实现：
<syntaxhighlight lang="sml">
fun mergeSort l = let
    fun sort ([], _) = []
      | sort ([x], _) = [x]
      | sort ([x, y], _) =
          if x <= y then [x, y] else [y, x]
      | sort ([x, y, z], _) =
          if x <= y then
              if y <= z then [x, y, z]
              else if x <= z then [x, z, y] 
              else [z, x, y]
          else 
              if x <= z then [y, x, z]
              else if y <= z then [y, z, x]
              else [z, y, x] 
      | sort (l, n) = let
        val m = n div 2
        fun split (l, acc, i) = 
              if i = 0 then (rev acc, l)
              else split (tl l, (hd l) :: acc, i - 1)
        fun merge (p, q) = let
            fun revMerge (acc, p, q) =
                  if not (null p) andalso not (null q) then
                      if (hd p) <= (hd q)
                      then revMerge ((hd p) :: acc, tl p, q)
                      else revMerge ((hd q) :: acc, p, tl q)
                  else if null p 
                  then List.revAppend (q, acc)
                  else List.revAppend (p, acc)
            in
                rev (revMerge ([], p, q))
            end
        val (ls, rs) = split (l, [], m)
        in
            merge (sort (ls, m), sort (rs, n - m))
        end
    in
        sort (l, length l)
    end
</syntaxhighlight>}}

====堆排序====
下面是[[堆排序|堆排序]]的基于[[数组|数组]]的实现：
<syntaxhighlight lang="sml">
fun heapSort l = let
    val h = Array.fromList l
    val len = Array.length h
    fun get i = Array.sub (h, i)
    fun set i v = Array.update (h, i, v)
    fun siftdown (i, ins, n) = let
        fun sift k = let
            val l = k * 2 + 1
            val r = l + 1
            in 
                if (r < n) andalso
                   (get r) > (get l) then r
                else if (l < n) then l
                else k
            end
        fun loop i = let
            val j = sift i
            in
                if j = i orelse (get j) <= ins
                then set i ins
                else (set i (get j); loop j)
            end
        in
            loop i    
        end
    fun heapify () = let
        fun loop i =
              if i < 0 then ()
              else (siftdown (i, get i, len);
                    loop (i - 1))
        in
            loop (len div 2 - 1)
        end
    fun generate () = let
        fun loop (acc, i) = let
            val t = get 0
            in
               if i <= 0 then t :: acc
               else (siftdown (0, get i, i);
                     loop (t :: acc, i - 1))
            end
        in  
            if len = 0 then []
            else loop ([], len - 1)
        end
    in
        heapify (); 
        generate ()
    end
</syntaxhighlight>
在数组实现中，<code>siftdown</code>函数融合了插入和筛选功能，它首先在暂时位于堆顶的要插入的元素，和从堆顶节点左右子堆的两个堆顶元素中筛选出的那个元素，二者中选择出哪个适合作堆顶元素；如果要插入元素适合，则以它为新堆顶元素而结束整个过程，否则以筛选出元素为新堆顶元素，并自顶向下逐级处理提供了新堆顶元素的子堆，将要插入元素暂时作为其堆顶元素并对它继续进行<code>siftdown</code>；<code>siftdown</code>只要到达了某个堆底，就插入要插入的元素而结束整个过程。

在提取堆顶元素生成结果列表时，先提取走堆顶元素的内容，再摘掉最后的堆底元素将它的内容暂时放置在堆顶，这时堆的大小也相应的减一，随后的<code>siftdown</code>函数，筛选出新的堆顶元素，并把原最后堆底元素插入回堆中。

在<code>heapify</code>函数建造堆的时候，首先自列表中间将元素分为前后两组，后组中的元素被视为只有一个元素的堆，然后从后往前处理前组中的元素，这时它的左右子节点已经是已有的堆或者为空，在其上进行<code>siftdown</code>，从而合成一个新堆。建造堆也可以采用<code>siftup</code>函数来实现，它自第二个元素开始从前往后逐个处理列表元素，其前面是已有的堆，将这个新元素自堆底向上插入到这个堆中。{{efn|堆排序算法的数组实现中，堆建造函数<code>heapify</code>也可以使用<code>siftup</code>函数的数组来完成，它将新节点自堆底向上插入到合适的位置，而不对途径节点左右子树顶点进行比较：
<syntaxhighlight lang="sml">
    fun siftup i = let
        val ins = get i
        fun loop i = let
            val j = (i - 1) div 2 
            in
                if i <= 0 orelse (get j) >= ins
                then set i ins
                else (set i (get j); loop j)
            end
        in
            loop i    
        end  
    fun heapify () = let
        fun loop i =
              if i > (len - 1) then ()
              else (siftup i; loop (i + 1))
        in
            loop 1
        end
</syntaxhighlight>}}

[[堆|堆]]排序算法也可以使用[[二叉树|二叉树]][[数据结构|数据结构]]来实现[[二叉堆|二叉堆]]：
<syntaxhighlight lang="sml">
fun heapSort l = let
    datatype 'a heap
      = Nil 
      | Leaf of 'a
      | Node of 'a * int * 'a heap * 'a heap
    fun key Nil = 
          let val SOME a = Int.minInt in a end
      | key (Leaf k) = k
      | key (Node (k, _, _, _)) = k
    fun count Nil = 0
      | count (Leaf _) = 1
      | count (Node (_, c, _, _)) = c
    fun left Nil = Nil
      | left (Leaf _) = Nil
      | left (Node (_, _, l, _)) = l 
    fun insert (Nil, x) = Leaf x
      | insert (Leaf k, l) = 
          if l >= k
          then Node (l, 2, Leaf k, Nil)
          else Node (k, 2, Leaf l, Nil)
      | insert (Node (k, _, Leaf l, Nil), r) = 
          if r >= k 
          then Node (r, 3, Leaf k, Leaf l)
          else if r >= l
          then Node (k, 3, Leaf r, Leaf l)
          else Node (k, 3, Leaf l, Leaf r)
      | insert (Node (k, c, l, r), x) = let
        val (k, x) = 
              if k >= x then (k, x) else (x, k) 
        in      
            if (count l) <= (count r)
            then Node (k, c + 1, insert (l, x), r) 
            else if x >= (key l)
            then Node (k, c + 1, insert (r, x), l)
            else Node (k, c + 1, l, insert (r, x))
        end
    fun extract Nil = Nil
      | extract (Leaf _) = Nil
      | extract (Node (_, _, l, Nil)) = l
      | extract (Node (_, c, l, r)) = let
        val k = key l
        val n = left l 
        in
            if n = Nil
            then Node (k, c - 1, r, Nil)
            else if (key n) >= (key r)
            then Node (k, c - 1, extract l, r)
            else Node (k, c - 1, r, extract l)
        end
    fun heapify () = let
        fun loop (acc, []) = acc
          | loop (acc, x :: xs) =
              loop (insert (acc, x), xs)  
        in
            loop (Nil, l)
        end
    fun generate h = let
        fun loop (acc, Nil) = acc
          | loop (acc, h) =
              loop ((key h) :: acc, extract h)
        in
            loop ([], h)
        end           
    in
        generate (heapify ())
    end
</syntaxhighlight>
二叉树实现不能直接访问堆底元素，从而不适宜通过摘掉它使堆的大小减一。这里的<code>insert</code>函数，在原堆顶元素和要插入元素中选择适合者作为新的堆顶元素，将落选的另一个元素作为新的要插入元素，插入到利于保持这个堆平衡的那个子树之中。这里的<code>extract</code>函数只筛选不插入，它将堆的大小减一。

这里的<code>insert</code>和<code>extract</code>函数也可以直接转写为等价的[[尾调用|尾递归]]形式，与列表情况不同，只要树结构能保持良好的平衡，采用尾递归形式就没有太大的必要性。{{efn|在堆排序算法的二叉树实现中，树插入和提取函数也可以写为等价的尾递归形式代码：
<syntaxhighlight lang="sml">
    exception Err;   
    fun revLink ([], t) = t
      | revLink (Nil :: xs, t) = revLink (xs, t)   
      | revLink ((Leaf k) :: xs, t) = 
          revLink (xs, Node (k, (count t) + 1, t, Nil))
      | revLink (Node (k, c, Nil, r) :: xs, t) = 
          revLink (xs, Node (k, c, t, r)) 
      | revLink (Node (k, c, l, Nil) :: xs, t) = 
          revLink (xs, Node (k, c, l, t))
      | revLink (_ :: xs, t) = raise Err        
    fun insert (t, x) = let    
        fun loop (acc, Nil, x) = revLink (acc, Leaf x)
          | loop (acc, Leaf k, l) = 
              if l >= k
              then revLink (acc, Node (l, 2, Leaf k, Nil))
              else revLink (acc, Node (k, 2, Leaf l, Nil))
          | loop (acc, Node (k, _, Leaf l, Nil), r) = 
              if r >= k 
              then revLink (acc, Node (r, 3, Leaf k, Leaf l))
              else if r >= l
              then revLink (acc, Node (k, 3, Leaf r, Leaf l))
              else revLink (acc, Node (k, 3, Leaf l, Leaf r))
          | loop (acc, Node (k, c, l, r), x) = let
            val (k, x) = 
                  if k >= x then (k, x) else (x, k) 
            in      
                if (count l) <= (count r)
                then loop (Node (k, c + 1, Nil, r) :: acc, l, x) 
                else if x >= (key l)
                then loop (Node (k, c + 1, Nil, l) :: acc, r, x)
                else loop (Node (k, c + 1, l, Nil) :: acc, r, x)
            end
        in 
            loop ([], t, x)
        end
    fun extract t = let
        fun loop (acc, Nil) = revLink (acc, Nil)
          | loop (acc, Leaf _) = revLink (acc, Nil)
          | loop (acc, Node (_, _, l, Nil)) = revLink (acc, l)
          | loop (acc, Node (_, c, l, r)) = let
            val k = key l
            val n = left l 
            in
                if n = Nil
                then revLink (acc, Node (k, c - 1, r, Nil))
                else if (key n) >= (key r)
                then loop (Node (k, c - 1, Nil, r) :: acc, l)
                else loop (Node (k, c - 1, r, Nil) :: acc, l)
            end
        in 
            loop ([], t)    
        end
</syntaxhighlight>}}
在二叉树实现下，也可以采用<code>siftdown</code>函数来初始建造堆，而不需要在节点中保存关于树状态的统计信息。{{efn|堆排序算法的二叉树实现中，堆建造函数也可以主要采用<code>siftdown</code>函数来完成，这里不需要在节点中保存关于树状态的统计信息：
<syntaxhighlight lang="sml">
fun heapSort l = let
    datatype 'a heap
      = Nil 
      | Node of 'a * 'a heap * 'a heap
    fun key Nil = 
          let val SOME a = Int.minInt in a end
      | key (Node (k, _, _)) = k
    fun left Nil = Nil
      | left (Node (_, l, _)) = l
    fun right Nil = Nil
      | right (Node (_, _, r)) = r
    fun leaf k = Node (k, Nil, Nil)     
    fun sift (l, r) =
          if l <> Nil andalso r <> Nil then
              if (key l) >= (key r) then l else r
          else if l <> Nil then l
          else if r <> Nil then r
          else Nil
    fun siftdown (x, l, r) = let
        val superior = sift (l, r)
        in
            if superior = Nil then Node (x, Nil, Nil)
            else if x >= (key superior) then Node (x, l, r) 
            else if superior = l
            then Node (key l, siftdown (x, left l, right l), r)
            else Node (key r, l, siftdown (x, left r, right r))
        end
    fun insert (Nil, x) = Node (x, Nil, Nil)
      | insert (Node (k, l, r), x) = let
        val superior = sift (l, r)
        in
           if x >= k andalso superior = l
           then Node (x, l, insert (r, k))
           else if x >= k
           then Node (x, insert (l, k), r)
           else if superior = l
           then Node (k, l, insert (r, x))
           else Node (k, insert (l, x), r)
        end
    fun extract Nil = Nil
      | extract (Node (_, l, r)) = let
        val superior = sift (l, r)
        in
            if superior = Nil then Nil
            else if superior = l
            then Node (key l, extract l, r)
            else Node (key r, l, extract r)
        end
    fun join (l, r) = extract (Node (key Nil, l, r))
    fun heapify () = let
        fun init (hs, ls, [], _) = (hs, ls)
          | init (hs, ls, x :: xs, flag) =
              if flag 
              then init ((leaf x) :: hs, ls, xs, false)
              else init (hs, x :: ls, xs, true)
        val (hs, ls) = init ([], [], l, true)
        fun loop ([], [], []) = Nil
          | loop ([], [h], []) = h
          | loop ([], [], x :: xs) = 
              loop ([], [leaf x], xs)
          | loop ([], [h], x :: xs) = 
              loop ([], [insert (h, x)], xs)    
          | loop (acc, [], l) =
              loop ([], acc, l)
          | loop (acc, [h], l) = 
              loop ([], h :: acc, l)
          | loop (acc, l :: r :: hs, []) =
              loop (join (l, r) :: acc, hs, [])
          | loop (acc, l :: r :: hs, x :: xs) =
              loop (siftdown (x, l, r) :: acc, hs, xs)  
        in  
            loop ([], hs, ls)
        end
    fun generate h = let
        fun loop (acc, Nil) = acc
          | loop (acc, h) =
              loop ((key h) :: acc, extract h)
        in
            loop ([], h)
        end           
    in
        generate (heapify ())
    end
</syntaxhighlight>
稍加处理，堆建造函数也可以只用<code>siftdown</code>函数来完成：
<syntaxhighlight lang="sml">
    fun heapify () = let
        exception Err;
        fun split () = let
            val (rs, ts) = let
                  fun loop (acci, accj, [], i, n) =
                        if i = n 
                        then (List.revAppend (accj, acci), [])
                        else (acci, accj)
                    | loop (acci, accj, x :: xs, i, n) =  
                        if i = n
                        then loop (List.revAppend (accj, acci),
                                   [x], xs, i + 1, n * 2 + 1)
                        else loop (acci, x :: accj, xs, i + 1, n)
                  in
                      loop ([], [], l, 0, 1)
                  end
            fun loop (hs, ls, [], _) = (hs, ls, ts)
              | loop (hs, ls, x :: xs, flag) =
                  if flag 
                  then loop (x :: hs, ls, xs, false)
                  else loop (hs, x :: ls, xs, true)
            in
                loop ([], [], rs, true)
            end
        fun init () = let 
            val (hs, ls, ts) = split ()
            fun loop (acc, [], []) = (acc, ls)
              | loop (acc, [], ts) =
                  (acc, List.revAppend (ts, ls))
              | loop (acc, k :: hs, []) =
                  loop ((leaf k) :: acc, hs, []) 
              | loop (acc, k :: hs, [x]) = let
                val (k, x) = 
                      if k >= x then (k, x) else (x, k)  
                in
                   loop (Node (k, leaf x, Nil) :: acc, hs, [])
                end
              | loop (acc, k :: hs, l :: r :: rs) = let
                val (k, l, r) = 
                      if k >= l then
                          if l >= r then (k, l, r)
                          else if k >= r then (k, r, l)
                          else (r, k, l)
                      else
                          if k >= r then (l, k, r)
                          else if l >= r then (l, r, k)
                          else (r, l, k)
                in 
                    loop (Node (k, leaf l, leaf r) :: acc, hs, rs)
                end                   
            in  
                loop ([], hs, ts)                
            end
        val (hs, ls) = init ()
        fun loop ([], [], []) = Nil
          | loop ([], [h], []) = h
          | loop ([], [], _) = raise Err
          | loop ([], [h], _) = raise Err
          | loop (acc, [], l) = 
              loop ([], acc, l)
          | loop (acc, [h], l) =
              loop ([], h :: acc, l)
          | loop (acc, l :: r :: hs, []) = raise Err
          | loop (acc, l :: r :: hs, x :: xs) =
              loop (siftdown (x, l, r) :: acc, hs, xs)   
        in  
            loop ([], hs, ls)
        end
</syntaxhighlight>}}

====基数排序====
下面是针对[[非负整数|非负整数]]的[[基数排序|基数排序]]算法的实现：
<syntaxhighlight lang="sml">
fun radixSort l = let
    fun distribute (l, d) = let
        val t0 = ([], [], [], [], [], [], [], [])
        fun loop (t, []) = let
            fun join (acc, i) = let
                val f = case i 
                      of 1 => (#1 t) | 2 => (#2 t) | 3 => (#3 t)
                       | 4 => (#4 t) | 5 => (#5 t) | 6 => (#6 t) 
                       | 7 => (#7 t) | 8 => (#8 t) | _ => []
                in
                    if i <= 0 then acc      
                    else join (List.revAppend (f, acc), i - 1)         
                end
            in
                join ([], 8)
            end      
          | loop (t, x :: xs) = let
            val (f0, f1, f2, f3, f4, f5, f6, f7) = t
            val t = case ((x div d) mod 8)
                  of 0 => (x :: f0, f1, f2, f3, f4, f5, f6, f7)
                   | 1 => (f0, x :: f1, f2, f3, f4, f5, f6, f7)
                   | 2 => (f0, f1, x :: f2, f3, f4, f5, f6, f7)
                   | 3 => (f0, f1, f2, x :: f3, f4, f5, f6, f7)
                   | 4 => (f0, f1, f2, f3, x :: f4, f5, f6, f7)
                   | 5 => (f0, f1, f2, f3, f4, x :: f5, f6, f7)
                   | 6 => (f0, f1, f2, f3, f4, f5, x :: f6, f7)
                   | 7 => (f0, f1, f2, f3, f4, f5, f6, x :: f7)
                   | _ => t0
            in
                loop (t, xs)
            end       
        in
            loop (t0, l)
        end
    val SOME maxInt = Int.maxInt
    val max = foldl (fn (x, y) => if x > y then x else y) 0 l
    fun iterate (l, d) = let
        val l' = distribute (l, d)
        in
            if d >= (maxInt div 8 + 1) orelse
               ((max div d) div 8) = 0 then l'  
            else iterate (l', d * 8)
        end
    in
        iterate (l, 1) 
    end
</syntaxhighlight>
这里采用的[[底数_(进制)|基数]]是<code>2</code>的<code>3</code>次[[幂|幂]]<code>8</code>，代码所使用的列表元组大小与基数大小成正比，运算量与列表中元素的总数与最大数的位数的乘积成正比。

===随机数生成===
编写[[排序算法|排序算法]]进行测试除了使用简单的数列，{{efn|排序算法的简单测试代码：
<syntaxhighlight lang="sml">
fun printIntList (l: int list) =
      print ((String.concatWith " " (map Int.toString l)) ^ "\n")
fun shuffle (l, n) = let
    fun split (l, acc, i) = 
          if i = 0 then (acc, l)
          else split (tl l, (hd l) :: acc, i - 1)
    fun zip (acc, p, q, flag) =
          if null p then List.revAppend (q, acc)
          else if null q then List.revAppend (p, acc)
          else if flag then zip ((hd p) :: acc, tl p, q, false)
          else zip ((hd q) :: acc, p, tl q, true)
    val (p, q) = split (l, [], n div 2)
    in
        if (null l) then tl [0]
        else zip ([], p, q, true)
    end
fun testsort f n = let
    fun loop (acc, i) =
          if (i <= 0) then acc
          else loop (i :: acc, i - 1)
    val sl = shuffle (loop ([], n), n)
    val ssl = shuffle (sl, n) 
    in
        print ("source list is: ");
        printIntList ssl; 
        print ("result list is: ");
        printIntList (f ssl)
    end
</syntaxhighlight>}}
测试用列表还可以使用[[线性同余|线性同余]][[伪随机数|伪随机数]]函数来生成<ref>{{cite web|author=W.H. Press, B.P. Flannery, S.A. Teukolsky, W.T. Vetterling|title=Numerical Recipes in C: The Art of Scientific Computing|url=https://www.cec.uchile.cl/cinetica/pcordero/MC_libros/NumericalRecipesinC.pdf|publisher=Cambridge University Press|year=1988, 1992|access-date=2021-10-05|archive-date=2022-03-23|archive-url=https://web.archive.org/web/20220323074919/https://www.cec.uchile.cl/cinetica/pcordero/MC_libros/NumericalRecipesinC.pdf}}</ref>：
<syntaxhighlight lang="sml">
fun randList (n, seed) = let
    val randx = ref seed
    fun lcg () = (randx := (!randx * 421 + 1663) mod 7875; !randx) 
    (* fun lcg () = (randx := (!randx * 1366 + 150889) mod 714025; !randx) *)
    fun iterate (acc, i) =
          if i <= 0 then acc
          else iterate (lcg () :: acc, i - 1)
    in
        iterate ([], n)
    end
</syntaxhighlight>

===语言解释器===

定义和处理一个小型表达式语言是相对容易的：

<syntaxhighlight lang="sml">
exception Err;
 
datatype ty
  = IntTy
  | BoolTy
 
datatype exp
  = True
  | False
  | Int of int
  | Not of exp
  | Add of exp * exp
  | If of exp * exp * exp
 
fun typeOf (True) = BoolTy
  | typeOf (False) = BoolTy
  | typeOf (Int _) = IntTy
  | typeOf (Not e) = 
      if typeOf e = BoolTy
      then BoolTy
      else raise Err
  | typeOf (Add (e1, e2)) = 
      if (typeOf e1 = IntTy) andalso (typeOf e2 = IntTy)
      then IntTy
      else raise Err
  | typeOf (If (e1, e2, e3)) = 
      if typeOf e1 <> BoolTy
      then raise Err
      else if typeOf e2 <> typeOf e3 then raise Err
      else typeOf e2

fun eval (True) = True
  | eval (False) = False
  | eval (Int n) = Int n
  | eval (Not e) = (case eval e
      of True => False
       | False => True
       | _ => raise Fail "type-checking is broken")
  | eval (Add (e1, e2)) = let
    val (Int n1) = eval e1
    val (Int n2) = eval e2
    in
        Int (n1 + n2)
    end
  | eval (If (e1, e2, e3)) = 
      if eval e1 = True
      then eval e2
      else eval e3
 
fun exp_repr e = let
    val msg = case e
         of True  => "True"
          | False => "False"
          | Int n => Int.toString n
          | _ => ""     
    in
        msg ^ "\n"
    end
    
(* 忽略TypeOf的返回值，它在类型错误时发起Err *) 
fun evalPrint e = (ignore (typeOf e); print (exp_repr (eval e)));
</syntaxhighlight>

将这段代码录入文件比如<code>expr-lang.sml</code>，并在命令行下执行<code>sml expr-lang.sml</code>，可以用如下在正确类型的和不正确类型上运行的例子，测试这个新语言：
<syntaxhighlight lang="sml">
- val e1 = Add (Int 1, Int 2);  (* 正确的类型 *)
val e1 = Add (Int 1,Int 2) : exp
- val _ = evalPrint e1;
3
- val e2 = Add (Int 1, True);   (* 不正确的类型 *)
val e2 = Add (Int 1,True) : exp
- val _ = evalPrint e2;

uncaught exception Err
  raised at: expr-lang.sml:25.20-25.23
</syntaxhighlight>

==注释和附录代码==
{{Div col|2}}
{{notelist}}
{{div col end}}

== 参见 ==
* [[Standard_ML|Standard ML]]和它的实现：
** [[新泽西Standard_ML|SML/NJ]]，由[[普林斯顿大学|普林斯顿大学]]和[[贝尔实验室|贝尔实验室]]联合开发的实现，它具有并发编程扩展[[Concurrent_ML|Concurrent ML]]。
** [[MLton|MLton]]，严格遵循标准定义的强力的{{en-link|过程间优化|Interprocedural optimization|全程序优化}}编译器<ref>{{cite web|title=Whole-Program Compilation in MLton|url=http://mlton.org/References.attachments/060916-mlton.pdf|author=Stephen Weeks|publisher=Workshop on ML|year=2006|access-date=2021-09-17|archive-date=2022-01-24|archive-url=https://web.archive.org/web/20220124062014/http://www.mlton.org/References.attachments/060916-mlton.pdf}}</ref>。
** HaMLet<ref>{{cite web|url=http://www.mpi-sws.org/~rossberg/hamlet/|title=HaMLet|access-date=2021-09-04|archive-date=2016-10-14|archive-url=https://web.archive.org/web/20161014055807/http://www.mpi-sws.org/~rossberg/hamlet/}}</ref>，由{{en-link|马克斯·普朗克软件系统研究所|Max Planck Institute for Software Systems}}（MPI-SWS）的Andreas Rossberg编写，是一个SML解释器，意图成为精确且合宜接近的标准定义参考实现。
* [[OCaml|OCaml]]，由[[法国国家信息与自动化研究所|法国国家信息与自动化研究所]]（INRIA）维护，是一个“工业强度”的ML方言<ref>[http://ocaml.org/ "OCaml is an industrial strength programming language supporting functional, imperative and object-oriented styles"] {{Wayback|url=http://ocaml.org/ |date=20210528170011 }}. Retrieved on January 2, 2018.</ref>，演化自最初用来实现[[Coq|Coq]]定理证明器的[[Caml|Caml]]<ref name="caml-hist">{{cite web|url=https://caml.inria.fr/about/history.en.html|title=A History of Caml|quote=The Formel team became interested in the ML language in 1980-81. ……Gérard Huet decided to make the ML implementation compatible with various Lisp compilers (MacLisp, FranzLisp, LeLisp, ZetaLisp). This work involved Guy Cousineau and Larry Paulson. ……Guy Cousineau also added algebraic data types and pattern-matching, following ideas from Robin Milner ……. At some point, this implementation was called Le_ML, a name that did not survive. It was used by Larry Paulson to develop Cambridge LCF and by Mike Gordon for the first version of HOL ……. ……<br />Our main reason for developing Caml was to use it for sofware development inside Formel. Indeed, it was used for developing the Coq system ……. We were reluctant to adopt a standard that could later prevent us from adapting the language to our programming needs. ……We did incorporate into Caml most of the improvements brought by Standard ML over Edinburgh ML. ……The first implementation of Caml appeared in 1987 and was further developed until 1992. It was created mainly by Ascander Suarez. ……<br />In 1990 and 1991, Xavier Leroy designed a completely new implementation of Caml, based on a bytecode interpreter written in C. Damien Doligez provided an excellent memory management system. ……In 1995, Xavier Leroy released Caml Special Light, which improved over Caml Light in several ways. In 1995, Xavier Leroy released Caml Special Light, which improved over Caml Light in several ways. First, an optimizing native-code compiler was added to the bytecode compiler. ……Second, Caml Special Light offered a high-level module system, designed by Xavier Leroy and inspired by the module system of Standard ML. ……Didier Rémy, later joined by Jérôme Vouillon, designed an elegant and highly expressive type system for objects and classes. This design was integrated and implemented within Caml Special Light, leading to the Objective Caml language and implementation, first released in 1996 and renamed to OCaml in 2011.|access-date=2021-08-31|archive-date=2022-04-13|archive-url=https://web.archive.org/web/20220413084146/https://caml.inria.fr/about/history.en.html}}</ref>。
* {{en-link|Alice (programming language)|Alice (programming language)|Alice}}，由[[萨尔兰大学|萨尔兰大学]]设计的Alice ML，是基于Standard ML的函数式编程语言，扩展了对并发、分布式和约束式编程的丰富支持<ref>{{Cite web |url=https://www.ps.uni-saarland.de/alice/ |title=Alice |access-date=2021-09-04 |archive-date=2022-03-23 |archive-url=https://web.archive.org/web/20220323184436/https://www.ps.uni-saarland.de/alice/ }}</ref>。
* {{en-link|ATS (编程语言)|ATS (programming language)|ATS}}，由[[波士顿大学|波士顿大学]]的Hongwei Xi和[[卡内基·梅隆大学|卡内基·梅隆大学]]的{{en-link|Frank Pfenning}}提出的{{en-link|Dependent ML}}发展而来，它向ML扩展了[[依赖类型|依赖类型]]。
* [[F♯|F#]]，由[[微软研究院|微软研究院]]（MSR）开发，是一个基于[[OCaml|OCaml]]的一个以[[.NET_Framework|.NET]]为目标的编程语言。
* [[F*|F*]]，由[[微软研究院|MSR]]和[[法国国家信息与自动化研究所|INRIA]]主导开发，是一个基于ML的[[依赖类型|依赖类型]][[函数式编程|函数式]]编程语言。
* [[Futhark_(编程语言)|Futhark]]，由[[哥本哈根大学|哥本哈根大学]]{{en-link|UCPH计算机科学系|UCPH Department of Computer Science|计算机科学系}}（DIKU）开发，是属于ML家族的一个[[函数式编程|函数式]]、[[数据并行|数据并行]]、[[阵列编程|阵列]]编程语言<ref name="futhark">{{cite conference|url=https://futhark-lang.org/publications/pldi17.pdf|title=Futhark: Purely Functional GPU-Programming with Nested Parallelism and In-Place Array Updates|author=Troels Henriksen, Niels G. W. Serup, Martin Elsman, Fritz Henglein, Cosmin Oancea|date=2017|publisher=ACM|book-title=Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation|conference=PLDI 2017|access-date=2021-09-04|archive-date=2020-09-20|archive-url=https://web.archive.org/web/20200920221407/https://www.futhark-lang.org/publications/pldi17.pdf}}</ref>。
* [[Ur_(编程语言)|Ur]]，由[[麻省理工学院|麻省理工学院]]的Adam Chlipala开发，是语法基于Standard ML的专门用于[[網頁程式設計|web开发]]的一个[[函数式编程|函数式]]编程语言<ref name="ur">{{cite web | url = http://adam.chlipala.net/papers/UrWebPOPL15/UrWebPOPL15.pdf | author = Adam Chlipala | title = Ur/Web: A Simple Model for Programming the Web | publisher = MIT / Association for Computing Machinery (ACM) | date = January 2015 | access-date = 2021-09-04 | archive-date = 2022-01-16 | archive-url = https://web.archive.org/web/20220116210303/http://adam.chlipala.net/papers/UrWebPOPL15/UrWebPOPL15.pdf }}</ref>。
* CM-Lex和CM-Yacc，由[[卡内基·梅隆大学|卡内基·梅隆大学]]的Karl Crary开发，是用于[[Standard_ML|Standard ML]]、[[OCaml|OCaml]]和[[Haskell|Haskell]]的词法分析器和语法解析器<ref>{{cite web|title=CM-Lex and CM-Yacc|url=https://www.cs.cmu.edu/~crary/cmtool/|author=Karl Crary|year=2017|publisher=Carnegie Mellon University|access-date=2021-09-17|archive-date=2022-01-20|archive-url=https://web.archive.org/web/20220120175800/http://www.cs.cmu.edu/~crary/cmtool/}}</ref>。
* Amulet，是一个类ML的[[函数式编程|函数式]]编程语言，其编译器输出[[Lua|Lua]]文件<ref>{{Cite web|title=Amulet|url=https://amulet.works/|access-date=2021-01-12|website=amulet.works|archive-date=2021-07-25|archive-url=https://web.archive.org/web/20210725222733/https://amulet.works/}}</ref>。
* Alpaca，是一个受ML启发的运行在[[Erlang|Erlang]]{{en-link|BEAM (Erlang虚拟机)|BEAM (Erlang virtual machine)|虚拟机}}上的函数式编程语言<ref>{{cite web|url=https://github.com/alpaca-lang|title=Alpaca programming language community|access-date=2021-10-14|archive-date=2021-12-10|archive-url=https://web.archive.org/web/20211210192545/https://github.com/alpaca-lang}}</ref>。

==延伸阅读==
* {{cite web|url=https://smlfamily.github.io/sml90-defn.pdf|title=The Definition of Standard ML|year=1990|author=[[Robin_Milner|Robin Milner]], {{en-link|Mads Tofte}}, {{en-link|Robert Harper|Robert Harper (computer scientist)|Robert Harper}}|publisher=MIT Press|access-date=2021-03-01|archive-date=2021-01-14|archive-url=https://web.archive.org/web/20210114130545/https://smlfamily.github.io/sml90-defn.pdf}} 
*{{cite web|title=The Definition of Standard ML, Revised|url=https://smlfamily.github.io/sml97-defn.pdf|year=1997|4=|publisher=MIT Press|author=[[Robin_Milner|Robin Milner]], {{en-link|Mads Tofte}}, {{en-link|Robert Harper|Robert Harper (computer scientist)|Robert Harper}}, David MacQueen|ISBN=0-262-63181-4|access-date=2021-03-01|archive-date=2022-03-09|archive-url=https://web.archive.org/web/20220309034143/https://smlfamily.github.io/sml97-defn.pdf}}
* {{cite web|title=Commentary on Standard ML|url=http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.368.3752&rep=rep1&type=pdf|author=[[Robin_Milner|Robin Milner]], {{en-link|Mads Tofte}}|year=1991|5=|publisher=MIT Press|ISBN=978-0-262-63137-2|access-date=2021-08-31|archive-date=2021-08-31|archive-url=https://web.archive.org/web/20210831025351/http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.368.3752&rep=rep1&type=pdf}}
* {{cite web|author=Emden R. Gansner, John H. Reppy|title=The Standard ML Basis Library|url=http://aleteya.cs.buap.mx/~jlavalle/papers/books_on_line/The-standard-ml-basis-library.pdf|year=2004|publisher=Cambridge University Press|access-date=2021-09-17|archive-date=2022-01-29|archive-url=https://web.archive.org/web/20220129065353/http://aleteya.cs.buap.mx/~jlavalle/papers/books_on_line/The-standard-ml-basis-library.pdf}}
*{{cite web|url=https://www.cs.tufts.edu/~nr/cs257/archive/mads-tofte/four-lectures.pdf|title=Four Lectures on Standard ML|author={{en-link|Mads Tofte}}|year=1989|publisher=University of Edinburgh|access-date=2021-09-04|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128115249/https://www.cs.tufts.edu/~nr/cs257/archive/mads-tofte/four-lectures.pdf}} {{cite web|title=Code examples in lectures|url=https://web.archive.org/web/20160402020247/https://www.itu.dk/people/tofte/publ/fourlectures/interp/mytoc.html}}
*{{cite web|url=https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.208.9430&rep=rep1&type=pdf|title=Essentials of Standard ML Modules|author={{en-link|Mads Tofte}}|year=1996|publisher={{en-link|UCPH计算机科学系|UCPH Department of Computer Science|DIKU}}|access-date=2021-09-04|archive-date=2021-09-04|archive-url=https://web.archive.org/web/20210904165420/https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.208.9430&rep=rep1&type=pdf}} {{cite web|title=The SML code (uuencoded compressed tar)|url=https://web.archive.org/web/20050307191144/http://www.diku.dk/users/tofte/publ/oregon/oregonSML.tar.Z.uu}}
*{{cite web|url=https://www.cs.tufts.edu/comp/105-2017f/readings/tofte-tips.pdf|title=Tips for Computer Scientists on Standard ML (Revised)|author={{en-link|Mads Tofte}}|year=2009|publisher={{en-link|哥本哈根IT大学|IT University of Copenhagen|ITU}}|access-date=2021-09-04|archive-date=2021-11-27|archive-url=https://web.archive.org/web/20211127071158/https://www.cs.tufts.edu/comp/105-2017f/readings/tofte-tips.pdf}} {{cite web|url=https://web.archive.org/web/20170915134517/http://www.itu.dk/people/tofte/publ/tipsexamples.sml|title=Examples}}
* {{cite web |url=https://www.cs.cmu.edu/~rwh/isml/book.pdf |author={{en-link|Robert Harper|Robert Harper (computer scientist)|Robert Harper}} |title=Programming in Standard ML |publisher=Carnegie Mellon University |year=2011 |access-date=2021-02-27 |archive-date=2020-02-15 |archive-url=https://web.archive.org/web/20200215062548/https://www.cs.cmu.edu/~rwh/isml/book.pdf }} {{cite web|title=Examples|url=https://www.cs.cmu.edu/~rwh/isml/examples/|access-date=2021-09-12|archive-date=2021-09-12|archive-url=https://web.archive.org/web/20210912153229/https://www.cs.cmu.edu/~rwh/isml/examples/}}
* {{cite web|title=Introduction to Functional Programming|author={{en-link|Michael J. C. Gordon}}|publisher=Cambridge University|url=https://www.cl.cam.ac.uk/archive/mjcg/Teaching/FuncProg/FuncProg.html|year=1996|access-date=2021-09-11|archive-date=2021-04-11|archive-url=https://web.archive.org/web/20210411163835/https://www.cl.cam.ac.uk/archive/mjcg/Teaching/FuncProg/FuncProg.html}} {{cite web|title=Lecture notes|url=http://www.cl.cam.ac.uk/users/mjcg/Teaching/FuncProg/Notes/Notes.ps.gz|access-date=2021-09-11|archive-date=2006-06-23|archive-url=https://web.archive.org/web/20060623033658/http://www.cl.cam.ac.uk/users/mjcg/Teaching/FuncProg/Notes/Notes.ps.gz}}
* {{cite web|title=ML for the Working Programmer, 2nd Edition|url=https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html|author={{en-link|Lawrence Paulson}}|year=1996|5=|publisher=Cambridge University Press|ISBN=0-521-56543-X|access-date=2021-08-31|archive-date=2022-02-24|archive-url=https://web.archive.org/web/20220224163207/https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html}} {{cite web|title=Sample programs|url=https://www.cl.cam.ac.uk/~lp15/MLbook/programs/|access-date=2021-09-12|archive-date=2022-01-19|archive-url=https://web.archive.org/web/20220119140027/https://www.cl.cam.ac.uk/~lp15/MLbook/programs/}}
* {{cite web|author=David MacQueen|title=Should ML be Object-Oriented?|year=2002|url=https://www.uio.no/studier/emner/matnat/ifi/INF3110/h05/undervisningsmateriale/ShouldMLbeOO.pdf|access-date=2021-09-10|archive-date=2021-10-29|archive-url=https://web.archive.org/web/20211029194915/https://www.uio.no/studier/emner/matnat/ifi/INF3110/h05/undervisningsmateriale/ShouldMLbeOO.pdf}}
* {{cite web|url=https://smlfamily.github.io/history/index.html|title=The History of Standard ML|author=David MacQueen, {{en-link|Robert Harper|Robert Harper (computer scientist)|Robert Harper}}, John Reppy|year=2020|access-date=2021-08-31|archive-date=2021-12-01|archive-url=https://web.archive.org/web/20211201021348/https://smlfamily.github.io/history/index.html}}
*{{cite web|url=https://epdf.pub/compiling-with-continuations-pdf-5ecceecb5c10d.html|title=Compiling with Continuations|author={{en-link|Andrew W. Appel}}|publisher=Cambridge University Press|year=1992|access-date=2022-01-03|archive-date=2022-01-03|archive-url=https://web.archive.org/web/20220103170935/https://epdf.pub/compiling-with-continuations-pdf-5ecceecb5c10d.html}}
* {{cite book|url=https://vdoc.pub/documents/modern-compiler-implementation-in-ml-4nh9uoq4sg90|title=Modern Compiler Implementation in ML|author={{en-link|Andrew W. Appel}}|year=1998|5=|publisher=Cambridge University Press|access-date=2022-01-12|archive-date=2022-01-12|archive-url=https://web.archive.org/web/20220112030122/https://vdoc.pub/documents/modern-compiler-implementation-in-ml-4nh9uoq4sg90}} {{cite web|title=Tiger compiler modules for programming exercises|url=https://www.cs.princeton.edu/~appel/modern/ml/|access-date=2021-09-12|archive-date=2022-05-06|archive-url=https://web.archive.org/web/20220506175350/https://www.cs.princeton.edu/~appel/modern/ml/}}
* {{cite book|title=Elements of ML Programming, ML97 Edition|url=https://epdf.pub/elements-of-ml-programming-ml97-edition.html|author=[[Jeffrey_D._Ullman|Jeffrey D. Ullman]]|publisher=Prentice-Hall|year=1998|ISBN=0-13-790387-1|access-date=2021-12-30|archive-date=2022-03-12|archive-url=https://web.archive.org/web/20220312073533/https://epdf.pub/elements-of-ml-programming-ml97-edition.html}} {{cite web|url=http://infolab.stanford.edu/~ullman/emlp/programs.html|title=Programs from the text|access-date=2022-01-01|archive-date=2022-02-14|archive-url=https://web.archive.org/web/20220214073753/http://infolab.stanford.edu/~ullman/emlp/programs.html}}
* {{cite web|url=http://mlton.org/References.attachments/Shipman02.pdf|title=Unix System Programming with Standard ML|author=Anthony L. Shipman|year=2001|access-date=2021-09-01|archive-date=2021-01-21|archive-url=https://web.archive.org/web/20210121234300/http://mlton.org/References.attachments/Shipman02.pdf}}

==引用==
{{reflist|2}}

== 外部链接 ==
* {{cite web|title=Standard ML and Objective Caml, Side by Side|url=https://people.mpi-sws.org/~rossberg/sml-vs-ocaml.html|author=Andreas Rossberg|year=2011|access-date=2021-08-31|archive-date=2021-12-30|archive-url=https://web.archive.org/web/20211230184304/https://people.mpi-sws.org/~rossberg/sml-vs-ocaml.html}}
* {{cite web|title=Comparing Objective Caml and Standard ML|url=http://adam.chlipala.net/mlcomp/|author=Adam Chlipala|year=2020|access-date=2021-08-31|archive-date=2021-12-16|archive-url=https://web.archive.org/web/20211216223417/http://adam.chlipala.net/mlcomp/}}
*[https://smlhelp.github.io/book/ SML Help] {{Wayback|url=https://smlhelp.github.io/book/ |date=20210915034530 }}
*[https://github.com/standardml/cmlib cmlib] {{Wayback|url=https://github.com/standardml/cmlib |date=20220502085911 }}

{{程序设计语言}}

[[Category:程序设计语言|Category:程序设计语言]]
[[Category:ML語言家族|*]]
[[Category:模式匹配编程语言|Category:模式匹配编程语言]]
[[Category:学术的编程语言|Category:学术的编程语言]]
[[Category:1973年建立的程式語言|Category:1973年建立的程式語言]]