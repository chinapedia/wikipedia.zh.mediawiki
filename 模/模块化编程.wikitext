{{NoteTA
|G1 = IT
}}
{{编程范式}}

'''模块化'''（modular）编程，是强调将计算机程序的功能分离成独立的、可相互改变的“[[軟體模組|模块]]”（module）的[[软件设计|软件设计]]技术，它使得每个模块都包含着执行预期功能的一个唯一[[面向切面编程|方面]]（aspect）所必需的所有东西。

==简介==
模块[[介面_(資訊科技)|接口]]表达了这个模块所提供的和所要求的元素。这些在接口中定义的元素可以被其他模块检测到。模块实现包含了工作代码，它们对应于在接口中声明的元素。

模块化编程密切相关于[[结构化编程|结构化编程]]和[[面向对象编程|面向对象编程]]，它们有着相同目标，即通过分解成更小部份的方式，促进大型软件和系统的建构，并且都大致起源于1960年代。尽管这些术语在历史上的用法曾经是不相容的，在现代的术语运用中：
*模块化编程，指称将整个程序的代码分开成各部份的高层分解。
*结构化编程，是采用结构化[[控制流|控制流]]的低层代码使用。
*面向对象编程，是[[对象_(计算机科学)|对象]]的“数据”使用，对象是某种[[数据结构|数据结构]]。

在面向对象编程中，使用接口作为一种架构上的模式（pattern）来构造模块叫做[[基于接口编程|基于接口编程]] 。

==语言支持==
正式支持模块概念的语言包括：[[Ada|Ada]]、[[ALGOL|Algol]]、{{en-link|BlitzMax}}、[[C♯|C#]], [[Clojure|Clojure]]、[[COBOL|COBOL]]、[[D语言|D]]、[[Dart|Dart]]、{{en-link|eC (编程语言)|eC (programming language)|eC}}、[[Erlang|Erlang]]、[[Elixir|Elixir]]、[[Elm_(编程语言)|Elm]]、{{en-link|F (编程语言)|F (programming language)|F}}、[[F♯|F#]]、[[Fortran|Fortran]]、[[Go|Go]]、[[Haskell|Haskell]]、{{en-link|IBM/360}}[[汇编语言|汇编语言]]、{{en-link|IBM i控制语言|IBM i Control Language}}（CL）、{{en-link|IBM RPG}}、[[Java|Java]]{{NoteTag|The term "package" is used for the analog of modules in the JLS;<ref>James Gosling, Bill Joy, Guy Steele, Gilad Bracha, ''The Java Language Specification, Third Edition'', {{ISBN|0-321-24678-0}}, 2005. In the Introduction, it is stated "Chapter 7 describes the structure of a program, which is organized into packages similar to the modules of Modula." The word "module" has no special meaning in Java.</ref> — see [[Java_package|Java package]]. "[[Java_Module_System|Modules]]", a kind of collection of packages, are planned for [[Java_9|Java 9]] as part of [http://openjdk.java.net/projects/jigsaw/ Project Jigsaw]; these were earlier called "superpackages" and planned for Java 7.}}、[[MATLAB|MATLAB]]、[[ML语言|ML]]、[[Modula|Modula]]、[[Modula-2|Modula-2]]、[[Modula-3|Modula-3]]、Morpho、{{en-link|NEWP}}、[[Oberon|Oberon]]、{{en-link|Oberon-2}}、[[Objective-C|Objective-C]]、[[OCaml|OCaml]]、一些派生的[[Pascal_(程式语言)|Pascal]]（{{en-link|Component Pascal}}、[[Object_Pascal|Object Pascal]]、[[Turbo_Pascal|Turbo Pascal]]、[[UCSD_Pascal|UCSD Pascal]]）、 [[Perl|Perl]]、[[PL/I|PL/I]]、[[PureBasic|PureBasic]]、[[Python|Python]]、[[Ruby|Ruby]]<ref>{{Cite web |url=http://ruby-doc.org/core-2.0/Module.html |title=存档副本 |access-date=2020-04-21 |archive-date=2015-01-05 |archive-url=https://web.archive.org/web/20150105060501/http://ruby-doc.org/core-2.0/Module.html |dead-url=no }}</ref>、[[Rust|Rust]]、[[JavaScript|JavaScript]]<ref>{{Cite web |url=http://www.ecma-international.org/ecma-262/6.0/#sec-modules |title=ECMAScript® 2015 Language Specification, 15.2 Modules |access-date=2020-04-21 |archive-date=2019-05-05 |archive-url=https://web.archive.org/web/20190505083122/http://www.ecma-international.org/ecma-262/6.0/#sec-modules |dead-url=no }}</ref>、[[Visual_Basic_.NET|Visual Basic .NET]]、[[WebDNA|WebDNA]]。

==历史==
模块没有包括在最初的[[ALGOL_68|ALGOL 68]]（1968年）规定中，但是作为扩展被包括于早期的实现中，如{{en-link|ALGOL 68-R}}（1970年）和{{en-link|ALGOL 68C}}（1970年），并在此后进行了形式化<ref>{{cite journal
|title = Proposal for a Modules Facility in ALGOL 68
|url = http://archive.computerhistory.org/resources/text/algol/ACM_Algol_bulletin/1061719/p19-lindsey.pdf
|author-link = Charles H. Lindsey
|first=Charles H.
|last=Lindsey
|journal=ALGOL Bulletin
|issue=39
|date=Feb 1976
|pages=20–29
|access-date=2014-12-01
|archive-url = https://web.archive.org/web/20160303230037/http://archive.computerhistory.org/resources/text/algol/ACM_Algol_bulletin/1061719/p19-lindsey.pdf
|archive-date=2016-03-03
}}</ref>。开始就设计为模块化编程的第一个语言是[[Niklaus_Wirth|Niklaus Wirth]]的短寿的[[Modula|Modula]]（1975年）。另一个早期模块化语言是[[Xerox_PARC|Xerox PARC]]的[[Mesa语言|Mesa]]（1976年），Wirth提出了Modula和Mesa的继任者[[Modula-2|Modula-2]]（1978年），它影响了以后的语言，特别是通过它的后继者[[Modula-3|Modula-3]]（1988年）。

模块化编程从1980年代开始广泛传播：最初的[[Pascal语言|Pascal]]语言（1970年）不包括模口，但是后来的版本，特别是[[UCSD_Pascal|UCSD Pascal]]（1978年）和[[Turbo_Pascal|Turbo Pascal]]（1983年）以“单元”的形式包括了它们，受Pascal影响的[[Ada|Ada]]（1980年）也是如此。扩展Pascal ISO 10206:1990标准在模块支持上保持接近于Modula2。[[Standard_ML|Standard ML]]（1984年）是有着最完全的模块系统的语言之一<ref>{{cite journal|title=Modules for Standard ML, LFP '84 Proceedings of the 1984 ACM Symposium on LISP and functional programming|pages=198–207|author=David MacQueen|date=August 1984}}</ref>，包括了在模块间映射的[[ML语言#函子|函子]]（参数化模块）。

在1980年代和1990年代，模块化编程被遮盖于并经常被混淆于面向对象编程，特别是由于[[C++|C++]]和[[Java|Java]]的流行。例如，[[C语言|C]]语言家族中的[[C++|C++]]（最初在1980年是具有类的C）和[[Objective-C|Objective-C]]（1983年）很早就已经支持了对象和类，只在30年后甚至更久之后才支持模块。[[Java|Java]]（1995年）以包的形式支持模块，然而代码组织的主要单元是类。但是[[Python|Python]]（1991年）从开始就突出的使用模块和对象二者，使用模块作为代码组织的主要单元，使用包作为大规模的单元；而[[Perl|Perl]] 5（1994年）包括了对模块和对象二者的支持，具有能从[[CPAN|CPAN]]（1993年）获得的大量的模块。

模块化编程现在已经普及了，自从1990年代能在几乎所有主要语言的开发中找到。模块的相对重要性因语言而异，并在基于类的面向对象语言中，仍与作为组织和封装的单元的类存在重叠和混淆，而它们都被良好的确立为独立的概念。

==参见==
* [[架构描述语言|架构描述语言]]
* [[內聚性_(計算機科學)|內聚性 (計算機科學)]]
* [[基于组件的软件工程|基于组件的软件工程]]
* [[康威定律|康威定律]]
* [[耦合性_(計算機科學)|耦合性 (計算機科學)]]
* [[函式库|函式库]]
* [[模組化設計|模組化設計]]
* [[插件|插件]]
* [[片段|片段]]
* [[结构化分析|结构化分析]]
* [[结构化编程|结构化编程]]

== 注释 ==
{{NoteFoot}}

== 参考文献 ==
{{Reflist}}

== 外部链接 ==
* [https://medium.com/@wrong.about/how-to-decompose-a-system-into-modules-796bd941f036 How To Decompose a System into Modules] {{Wayback|url=https://medium.com/@wrong.about/how-to-decompose-a-system-into-modules-796bd941f036 |date=20180117070220 }}

{{Authority control}}

{{DEFAULTSORT:Modular Programming}}
[[Category:编程典范|Category:编程典范]]