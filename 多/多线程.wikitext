{{refimprove|time=2009-12-17T10:35:10+00:00}}
{{NoteTA
|G1=IT
|1=zh-cn:线程; zh-tw:執行緒; zh-hk:線程;
|2=zh-cn:多线程; zh-tw:多執行緒; zh-hk:多線程;
|3=zh-cn:进程; zh-tw:行程;
}}
{{各地中文名
|cn = 多线程
|tw = 多線、多執行緒
|hk = 多線程
}}
[[File:Multithreaded_process.svg|thumb]]
'''多執行緒'''（{{lang-en|'''multithreading'''}}），是指从[[软件|软件]]或者[[硬件|硬件]]上实现多个[[线程|线程]]并发执行的技术。具有多线程能力的计算机因有硬體支援而能够在同一时间执行多於一个[[线程|线程]]，进而提升整体处理效能。具有这种能力的系统包括[[对称多处理机|对称多处理机]]、[[多核心|多核心]]处理器以及[[芯片级多处理|芯片级多处理]]（Chip-level multithreading）或[[同时多线程|同时多线程]]（Simultaneous multithreading）处理器。

软件多线程。即便[[处理器|处理器]]只能运行一个[[线程|线程]]，[[操作系统|操作系统]]也可以通过快速的在不同线程之间进行切换，由於时间间隔很小，来给用户造成一种多个线程同时运行的假象。这样的程序运行机制被称为软件多线程。如[[微软|微软]]的Windows作业系统和[[Linux|Linux]]就是在各个不同的執行緒间来回切换，被称为单人多工作业系统。而[[DOS|DOS]]这类文字介面作业系统在一个时间只能处理一项工作，被视为单人单工作业系统。

除此之外，许多系统及处理器也支持[[多执行绪_(电脑硬件)|硬件多线程技术]]。[[对称多处理机|对称多处理机]]（SMP）系统具有多个处理器，所以具有真正的同时执行多个线程的能力；[[芯片级别的多处理|CMP]]技术通过在一块芯片上集成多个核心（[[Intel_Core|Core]]）也具有真正的多线程能力；CMT技术则稍有不同，有的是依靠硬件执行线程切换来获得多线程能力，操作系统不再负责线程切换，因而这部分开销可以减少甚至消除，这方面典型的例子是[[升阳|Sun]]的[[UltraSPARC_T1|UltraSPARC T1]]，它同时综合了CMP和CMT。[[微軟|微軟]]的[[Windows_2000|Windows 2000]]以後的作業系統皆支援多執行緒與[[超執行緒|超執行緒]]技術。

== 概觀 ==
由于程序代码中存在的数据及控制[[依赖关系|依赖关系]]，单线程中所能发掘的[[指令级并行|指令-{A]]潜力是有限的。为了发掘有限的指令级并行潜力而一味强化[[乱序执行|乱序执行]]和[[分支预测|分支预测]]，以至于处理器复杂度和功耗急剧上升，有时候是得不偿失的。因此，现代微处理器多采用硬件多线程技术来发掘线程之间的[[线程级并行|线程级并行]]潜力。這樣子允許在[[介面轉換|介面轉換]]的專業領域之運算能力大幅提升：
* 既使這樣做對於提升單一程式或是執行緒的效能相當困難，但是目前多數的系統都是使用多工的方式作業。
* 能夠明顯的提升整體系統運算能力，总体吞吐量获得提升。

有兩種提升運算能力的主要技術分別是[[多进程|多进程]]與多執行緒。

不過有些對多執行緒的批評如下：
* 當共享硬體資源（像是[[快取|快取]]或是[[轉譯後備緩衝區|TLB]]）時多執行緒會造成干預。
* 單執行緒的執行時間可能不會因為多執行緒而變短。[[Hardware_Scout|硬件侦测]]技术有可能改变这一状况。
* 多執行緒的硬體支援會牽涉到軟體支援，如此程式與作業系統就需要比多程序化更大幅度的修改。

== 粗粒度交替多线程 ==
=== 概念 ===
一個執行緒持續執行，直到該執行緒被一個事件擋住而製造出長時間的延遲(可能是-{A|zh:記憶體;zh-tw:記憶體;zh-cn:内存}-load/store操作，或者-{zh:程式;zh-tw:程式;zh-cn:程序;}-分支操作)。該延遲通常是因快取失敗而從核心外的記憶體讀寫，而這動作會使用到幾百個CPU週期才能將資料回傳。與其要等待延遲的時間，執行緒化處理器會切換執行到另一個已就緒的執行緒。只要當之前執行緒中的資料送達後，上一個執行緒就會變成已就緒的執行緒。这种方法来自各个线程的指令交替执行，可以有效的掩盖内存存取时延，填补流水线空洞。

舉例來說：
# 週期 i  ：接收執行緒 A 的指令 j
# 週期 i+1：接收執行緒 A 的指令 j+1
# 週期 i+2：接收執行緒 A 的指令 j+2，而這指令快取失敗
# 週期 i+3：執行緒排程器介入，切換到執行緒 B
# 週期 i+4：接收執行緒 B 的指令 k
# 週期 i+5：接收執行緒 B 的指令 k+1

在概念上，它與即時作業系統中使用的合作式多工類似，在該任務需要為一個事件等待一段時間的時候會主動放棄執行時段。

=== 硬體成本 ===
此種多執行緒硬體支援的目標，是允許在擋住的執行緒與已就緒的執行緒中快速切換。為了要達成這個目標，硬體成本將複製程式看得見的暫存器與一些處理器控制暫存器（像是程式計算器）。從一個執行緒切換到另一個執行緒對硬體來講意謂著從一個暫存器複製到另一個。

這些新增功能的硬體有這些優勢：
* 執行緒切換能夠在一個 CPU 週期內完成(实际上可以没有开销，上个周期在-{zh:執行;zh-tw:執行;zh-cn:运行;}-线程A，下个周期就已在运行线程B)。
* 這樣子看起來像是每個執行緒是獨自執行的，沒有其他執行緒與目前共享硬體資源。对操作系统来说，通常每个虚拟线程都被视做一个处理器。這樣就不需要很大的軟體變更（像是特別寫支援多執行緒的作業系統）。

為了要在各個現行中的執行緒有效率的切換，每個現行中的執行緒需要有自己的暫存設置（register set）。像是為了能在兩個執行緒中快速切換，硬體的暫存器需要兩次例示（instantiated）。

=== 範例 ===
*許多[[微控制器|微控制器]]與嵌入式處理器有多重的暫存器列，就能夠在中斷時快速[[環境切換|環境切換]]。這樣架構可以視為程式的執行緒與中斷執行緒之間的塊狀多執行緒處理。

== 细粒度交替式多线程 ==

{{seealso|桶形处理器}}

=== 概念 ===
另一種更高效能的多執行緒做法是將所有 CPU 週期輪流切換至不同的執行緒，来自各线程的指令按顺序交替执行。执行过程很像[[桶形处理器|桶形处理器]](Barrel Processor)就像這樣：

# 週期 i  ：接收執行緒 A 的一個指令
# 週期 i+1：接收執行緒 B 的一個指令
# 週期 i+2：接收執行緒 C 的一個指令

這種執行緒的效果是會將所有從執行[[管線|管線]]中的[[資料從屬|資料從屬]]（data dependency）關係移除掉。因為每個執行緒是相對獨立，管線中的一個指令階層需要從已跑完管線中的較舊指令代入輸出的機會就相對的變小了。

而在概念上，這種多執行緒與作業系統的[[核心先佔|核心先佔]]多工（pre-exemptive multitasking）相似。

=== 硬體成本 ===
除了討論'''塊狀'''多執行緒的硬體成本，'''交錯式'''多執行緒也因每層管線需要追蹤執行中指令的執行緒代碼而增加硬體成本。而且，當越來越多的執行緒同時在管線中執行，像是快取與 TLB 等共享資源也要加大來避免不同執行緒之間的衝突。

=== 範例 ===
* Denelcor [[Heterogeneous_Element_處理器|Heterogeneous Element 處理器]] (HEP)
* [[Intel|Intel]] [[Super-threading|Super-threading]]
* [[昇陽|昇陽]] [[UltraSPARC_T1|UltraSPARC T1]]
* [[Lexra|Lexra]] NetVortex
* 搭載 Multi-Threaded ASE 的 [[MIPS_架構|MIPS]] 34K 核心
* [[Raza_Microelectronics_Inc|Raza Microelectronics Inc]] XLR

== 同步多執行緒 ==

{{seealso|同步多线程}}

=== 概念 ===
目前最先進的多執行緒技術是應用在[[超純量|超純量]]處理器上。超純量處理器內在每個CPU周期中，單獨一個執行緒會釋出眾多的指令。套用同步多執行緒(SMT)之後，超純量處理器就可以在每個CPU周期中，從多個執行緒中釋出指令。辨識到任何一個單一執行緒擁有有限數量的指令平行處理，這種類型的多執行緒是試著利用並行的方式跨越多執行緒，以減少浪費與閒置的資源。
舉例來說：
# 週期 i：執行緒 A 的 j 指令 與 j+1 指令，還有 B 執行緒的指令 k 同時釋出
# 週期 i+1：執行緒 A 的 j+2 指令、執行緒 B 的 k+1指令，與執行緒 C 的 m 指令同時釋出
# 週期 i+2：執行緒 A 的 j+3 指令，與執行緒 C 的 m+1 與 m+2 指令同時釋出

=== 硬體成本 ===
交錯式多執行緒如果不計硬體成本，SMT在每個管線階層的追蹤執行緒指令會有多餘的花費。而且，像是快取與TLB這類共享的資源可能會因為多出來的執行緒而變得更大。

=== 範例 ===
* [[DEC_Alpha|Alpha AXP]] EV8 (未完成) 
* [[Intel|Intel]] [[超執行緒|超執行緒]]
* [[IBM|IBM]] [[Power5|Power5]]
* [[Cell|Cell 微處理器]] 內的 Power 運算元件
* [[昇陽|昇陽]] [[UltraSPARC_T2|UltraSPARC T2]]
* [[昇陽|昇陽]] [[Rock微處理器|Rock微處理器]]
* [[AMD_Bulldozer|AMD Bulldozer]]

== 實作 ==
在大多數研究領域內是要求執行緒排程器要能夠快速選擇其中一個已就緒執行緒去執行，而不是一個一個執行而降低效率。所以要讓排程器去分辨執行緒的優先順序是很重要的。而執行緒排程器可能是以硬體、軟體，或是軟硬體並存的形式存在。

而另一個研究領域則是要研究何種事件（快取失敗、內部執行續連繫、使用DMA等）會造成執行緒切換。

如果多執行緒的方案會複製'''所有'''軟體可見的狀態，包括特許的控制登錄、TLB 等，那就能夠讓[[虛擬機器|虛擬機器]]去創造各式執行緒。這樣子就允許在相同的處理器中每個執行緒跑各自的作業系統。換句話說，如果只有儲存了使用者模式的狀態，就能夠讓相同的裸晶大小的晶片在一段時間內處理更多的執行緒。

== 参见 ==
* [[线程|线程]]

== 外部链接 ==

*[https://web.archive.org/web/20100823060949/http://biz.chinabyte.com/219/2055719.shtml 兼听则明—从CMT与SMT技术之争谈起]
*[http://www.chinaunix.net/jh/45/439151.html 全方位了解-{zh:伺服器;zh-tw:伺服器;zh-cn:服务器;}-CPU【技术篇】]{{Wayback|url=http://www.chinaunix.net/jh/45/439151.html |date=20120531085905 }}
*[http://www.chinaunix.net/jh/45/465858.html 精彩图解-{zh:伺服器;zh-tw:伺服器;zh-cn:服务器;}-CPU]{{Wayback|url=http://www.chinaunix.net/jh/45/465858.html |date=20120531085910 }}
*[http://www.sigma.me/2011/03/31/CMP-improve-throughput.html 提高处理器的吞吐量（IMPROVING THROUGHPUT）]{{Wayback|url=http://www.sigma.me/2011/03/31/CMP-improve-throughput.html |date=20201024062924 }}

{{CPU technologies}}
{{平行计算}}

[[Category:電腦架構|Category:電腦架構]]
[[Category:中央處理器|Category:中央處理器]]
[[Category:微處理器|Category:微處理器]]
[[Category:并发计算|Category:并发计算]]