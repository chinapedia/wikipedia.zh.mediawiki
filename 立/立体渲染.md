[[File:CTSkullImage.png|250px]]以及[[漫反射|漫反射]]渲染的头颅]]

'''立体渲染'''（{{lang-en|Volume rendering}}），又称为''体绘制''，是一种用于显示离散三维采样数据集的二维投影的技术。

一个典型的三维数据集是[[X射线计算机断层成像|CT]]或者[[MRI|MRI]]采集的一组二维切面图像。通常这些数据是按照一定规则如每毫米一个切面，并且通常有一定数目的图像像素。这是一个常见的立体晶格的例子，每个体素用当前体素附近区域的采样值表示。

为了渲染三维数据集的二维投影，首先需要定义相机相对于几何体的空间位置。另外，需要定义每个点即[[体素|体素]]的不透明性以及颜色，这通常使用'''[[RGBA|RGBA]]'''（red, green, blue, alpha）传递函数定义每个体素可能值对应的[[RGBA|RGBA]]值。

[[File:CTWristImage.png|250px]]图]]
通过提取几何体中等值的曲面并且将它们作为多边形进行渲染，或者直接将立体作为数据块进行渲染，这两种方法都可以使几何体可见。[[Marching_Cubes|Marching Cubes]]算法是从立体数据中提取曲面的常用技术。直接体渲染是一件计算量很大的工作，可以用几种不同的方法来实现。

==直接体渲染==

直接立体渲染要求每个采样值都必须映射到对应的不透明性以及颜色，这是通过一个“传递函数”实现的，这个传递函数可能是简单的斜面、也可能是分段线性函数或这是任意的表格。一旦转换到'''RGBA'''值之后，对应的RGBA结果就会映射到帧缓冲中对应的像素。根据渲染技术的不同这个做法也有所不同。

使用多种技术的组合也是可行的。例如去除扭曲的实现可以用纹理硬件在屏幕外的缓存中绘制排列好的片断。

===体光线投射===
''主条目：[[立体光线投射|立体光线投射]]。''

投影图像最简单的方法就是立体光线投射。在这种方法中，每个图像点都生成对应的光线。按照一个简单的照相机模型，光线从照相机（通常是眼睛位置）中心开始投射，经过照相机与需要渲染的立体之间的假象平面上的图像。光线在立体的边界进行剪切以节约处理时间，然后在整个立体空间上按照一定规则对光线进行采样。在每个采样点数据进行插值计算，经过传递函数变换成RGBA采样值，这个采样添加到光线的RGBA数据集中，然后重复这个过程直到光线抵达立体内部。RGBA颜色转换到RGB颜色并且放到对应的图像像素上。屏幕上的每个像素都重复这个过程直到形成完整的图像。在[http://www.fovia.com/] 上可以看到高质量的光线投射渲染几何体的实例。

===Splatting===

这是一个通过牺牲质量换取速度的方法。每个立体元素都象雪球那样按照从后到前的顺序splatted到观察表面。这些splats按照颜色与透明度特性在直径方向正态即高斯变化渲染成圆盘。平盘与其它特性也根据应用的不同而不同。

===Shear Warp===

一个新的体渲染实现方法是Philippe Lacroute与[[Marc_Levoy|Marc Levoy]]一起开发的在论文“使用Shear-Warp分解观察角度变换的快速体渲染”[http://graphics.stanford.edu/papers/shear/]中描述的方法。在这种技术中，观察角度进行变换使得最近的体表面成为后台图像缓冲区按照体素到像素的固定尺度排列的轴，然后渲染的立体按照方便的内存排列、固定的缩放及过渡因子放到这个缓冲区中。一旦立体的所有的切片已经渲染完毕，缓冲数据就会转换到在前台显示图像中所要的方向及尺度。

这种方法通过牺牲采样精度得到了相对较快的处理速度，但是这种方法生成的图像潜在质量要比光线投射方法生成的图像质量差。

===纹理映射===

许多三维图形系统都通过[[纹理映射|纹理映射]]将图像、纹理用于几何物体。日常所用PC的[[GPU|图形处理卡]]处理纹理非常快速并且能够高效地渲染三维立体切片，并且具有实时的交互能力。

这些切片可以根据几何体进行排列然后按照观察者的角度进行渲染，也可以根据观察平面进行排列然后从立体中未经排列的切片进行采样。对于第二种技术来说需要图形硬件支持三维纹理处理。

根据立体排列纹理的方式能够生成合理的图像质量，但是当立体旋转的时候经常会产生明显的过渡。根据视角排列纹理的方式可以得到类似于光线投射的高质量图像，并且采样图案也是相同的。

===硬件加速体渲染===
最近出现的一项加速渲染的技术是使用图形处理卡加速如光线投射这样的传统的体渲染算法。从2000（？）年左右开始出现的像素着色器[[pixel_shaders|pixel shaders]]开始，人们逐渐认识到多点并行运算的威力并且开始在图形芯片上执行更加普通的计算。像素着色器[[pixel_shaders|pixel shaders]]能够随机地读写纹理内存并且执行一些基本的算术与逻辑计算。这些现在称为[[GPU|GPU]]的[[单指令流多数据流|单指令流多数据流]]处理器用于如光线跟踪多边形以及信号处理中的普通计算。在OpenGL 2.0版上，pixel shaders现在能够作为[[多指令流多数据流|多指令流多数据流]]处理器使用并且能够独立进行分支切换，能够使用高达48个并行处理单元，并且能够使用高达1 GB的纹理内存以及high bit depth数字格式。通过这样的能力，理论上象立体光线投射或者CT重建这样的算法都能够得到极大的加速。

==优化技术==

===跳过空闲空间===
立体渲染系统经常带有一个识别立体区域是否包含可见物体的部分，这个信息可以用于避免在这些透明区域进行渲染。

===光线提前终止===

这是按照从前到后顺序渲染几何体的时候所用的一项技术。对于穿过一个像素的光线，一旦达到一定程度的浓度，那么后面的采样点对于这点来说就起不到多大作用，因此可以忽略。

===八叉树及二元空间分割===

使用如[[八叉树|八叉树]]或者[[二元空间分割|二元空间分割]]树的层次结构对于体数据压缩以及优化体光线投影过程来说都非常有用。

===体分割===

通过分割出渲染前不需要关心的部分，就可以大幅度地减少光线投影或者纹理混合所需要的计算量。

==来源==
* R. A. Drebin, L. Carpenter, P. Hanrahan: ''Volume Rendering.'' 1988

==参见==
* [[计算机图形学|计算机图形学]]
* [[可视化|可视化]]
:* [[信息可视化|信息可视化]]
:* [[科学可视化|科学可视化]]
{{可视化}}

[[Category:可视化|Category:可视化]]
[[Category:三维计算机图形学|Category:三维计算机图形学]]
[[Category:三维成像|Category:三维成像]]