{{NoteTA
|G1 = IT
|G2 = Math
}}
'''AKS質數測試'''（又被稱為'''Agrawal–Kayal–Saxena質數測試'''和'''Cyclotomic AKS test'''）是一個[[確定性演算法|決定型]][[素性測試|質數測試]][[演算法|演算法]] ，由三個來自{{tsl|en|Indian Institute of Technology Kanpur|印度坎普爾理工學院}}的計算機科學家，{{tsl|en|Manindra Agrawal}}、{{tsl|en|Neeraj Kayal}}和{{tsl|en|Nitin Saxena}}，在2002年8月6日發表於一篇題為'''質數屬於P'''的論文。<ref name="AKS">Manindra Agrawal, Neeraj Kayal, Nitin Saxena, "[http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf PRIMES is in P] {{Wayback|url=http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf |date=20171207171714 }}", ''Annals of Mathematics'' 160 (2004), no. 2, pp. 781–793.</ref>作者們因此獲得了許多獎項，包含了2006年的[[哥德爾獎|哥德爾獎]]和2006年的[[富尔克森奖|富尔克森奖]]。這個演算法可以在[[多項式時間|多項式時間]]之內，決定一個給定整數是[[質數|質數]]或者[[合數|合數]]。

== 重要性 ==
AKS最關鍵的重要性在於它是第一個被發表的'''一般的'''、'''多項式的'''、'''確定性的'''和'''無仰賴的'''質數判定算法。先前的算法至多達到了其中三點，但從未達到全部四個。
* AKS算法可以被用於檢測任何'''一般的'''給定數字是否為質數。很多已知的高速判定算法只適用於滿足特定條件的質數。例如，[[卢卡斯-莱默检验法|卢卡斯-莱默检验法]]僅對[[梅森質數|梅森質數]]適用，而{{link-en|Pépin測試|Pépin's test}}僅對[[費馬質數|費馬數]]適用。
* 算法的最長運行時間可以被表為一個目標數字長度的'''[[多項式|多項式]]'''。[[橢圓曲線質數測試|ECPP]]和[[Adleman–Pomerance–Rumely質數測試|APR]]能夠判斷一個給定數字是否為質數，但無法對所有輸入給出多項式時間範圍。
* 算法可以'''[[确定性算法|確定性]]'''地判斷一個給定數字是否為質數。隨機測試演算法，例如[[米勒-拉宾检验|米勒-拉宾检验]]和[[Baillie–PSW|Baillie–PSW]]，可以在多項式時間內對給定數字進行校驗，但只能給出概率性的結果。
* AKS算法並未“仰賴”任何未證明[[猜想|猜想]]。一個反例是[[米勒-拉宾检验|确定性米勒检验]]：該算法可以在多項式時間內對所有輸入給出確定性結果，但其正確性卻基於尚未被證明的[[廣義黎曼猜想|廣義黎曼猜想]]。

== 概念 ==
AKS質數測試主要是基於以下定理：整數''n'' (≥ 2)是質數，若且唯若
{{NumBlk|:|<math>(x + a)^{n} \equiv (x^{n} + a) \pmod{n}</math>|{{EquationRef|1}}}}

這個[[同餘|同餘]]多項式對所有與''n''[[互質|互質]]的整數''a''均成立。 這個定理是[[費馬小定理|費馬小定理]]的一般化，並且可以簡單的使用[[二項式定理|二項式定理]]跟[[二項式係數|二項式係數]]的這個特徵:
:<math>{n \choose k} \equiv 0 \pmod{n}</math> ，對任何 <math>0<k<n</math> ，若且唯若 ''n'' 是質數
來證明出此定理。

雖然說關係式 (1) 基本上構成了整個質數測試，但是驗證花費的時間卻是[[指數時間|指數時間]]。因此，為了減少[[計算複雜性理論|計算複雜度]]，AKS改為使用以下的同餘多項式：
{{NumBlk|:|<math>(x + a)^{n} \equiv (x^{n} + a) \pmod{x^{r}-1, n}</math>|{{EquationRef|2}}}}
這個多項式與存在多項式''f''與''g''，令:
{{NumBlk|:|<math>(x + a)^n - (x^n + a) = (x^r - 1)g + nf</math>|{{EquationRef|3}}}}
意義是等同的。

這個同餘式可以在多項式時間之內檢查完畢。這裡我們要注意所有的質數必定滿足此條件式（令''g'' = 0則 (3) 等於 (1)，因此符合''n''必定是質數）。 然而，有一些合數也會滿足這個條件式。有關AKS正確性的證明包含了推導出存在一個夠小的''r''以及一個夠小的整數集合''A''，令如果此同餘式對所有''A''裡面的整數都滿足，則''n''必定為質數。

== 歷史以及運算時間 ==

在上文引用的論文的第一版本中，作者們證明了算法的漸近時間為[[大O符號|O]]<math>(\log^{12}(n))</math>。換言之，算法使用少於''n''的[[二進制|二進制]]數字長度的十二次方。但是，論文證明的時間上界卻過於寬鬆；事實上，一個被普遍相信的關於[[索菲熱爾曼質數|索菲熱爾曼質數]]分佈的假設如果為真，則會立即將最壞情況減至O<math>(\log^6(n))</math>。

在這一發現後的幾個月中，新的變體陸續出現（Lenstra 2002, Pomerance 2002, Berrizbeitia 2003, Cheng 2003, Bernstein 2003a/b, Lenstra和Pomerance 2003）並依次提高了算法的速度（以改進幅度為序）。由於這些變體的出現，Crandall和Papadopoulos在其科學論文“AKS-類質數測試的實現”（2003年三月發表）中將其稱為算法的“AKS-類”。

出於對這些變體和其他回复的回應，論文“質數屬於P”稍後被進行了更新，新版本包括了一個AKS算法的正規公式化表述和其正確性證明。（這一版本在[[数学年刊|数学年刊]]上發表。）雖然基本思想沒有變化，<math>r</math>卻被採用了新方法進行選擇，而正確性證明也變得更加緊緻有序。與舊證明依賴於許多不同的方法不同，新版本幾乎只依賴於[[有限域|有限域]]上的分圓多項式的特徵。新版本同時也優化了時間複雜度的邊界到O<math>(\log^{10.5}(n))</math>。通過[[篩法|篩法]]獲得的其他結果可以將其進一步簡化到O<math>(\log^{7.5}(n))</math>。

在2005年，[[Carl_Pomerance|Carl Pomerance]]和[[endrik_Lenstra|H. W. Lenstra, Jr.]]展示了一個AKS的變體，可以在<math>O(\log^6(n))</math>次操作內完成測試（<math>n</math>是被測試數）。對於原算法的<math>O(\log^{12}(n))</math>邊界而言，這是一個顯著的改進。<ref name="lenstra_pomerance_2005">[[亨德里克·倫斯特拉|亨德里克·倫斯特拉]] and [[Carl_Pomerance|Carl Pomerance]], "[http://www.math.dartmouth.edu/~carlp/PDF/complexity12.pdf Primality Testing with Gaussian Periods] {{Wayback|url=http://www.math.dartmouth.edu/~carlp/PDF/complexity12.pdf |date=20110520092516 }}", preliminary version July 20, 2005.</ref>

== 演算法 ==
整個演算法的操作如下：<ref name="AKS" />

: 輸入：整數 ''n'' > 1
# 若存在整數''a'' > 0 且''b'' > 1 ，令 ''n'' = ''a''<sup>''b''</sup> ；則輸出''合數''
# 找出最小的 ''r'' 令 ''ord''<sub>''r''</sub>(''n'') > log<sup>2</sup>(''n'').
# 若 對某些''a'' ≤ ''r''，1 < gcd(''a'',''n'') < ''n''，輸出''合數''。(gcd是指[[最大公因數|最大公因數]])。
# 若 ''n'' ≤ ''r'', 輸出''質數''。
# 對 ''a'' = 1 到 <math>\scriptstyle\lfloor \scriptstyle\sqrt{\varphi(r)}\log(n) \scriptstyle\rfloor</math>的所有數，
#: 如果 (''X''+''a'')<sup>''n''</sup>≠ ''X''<sup>''n''</sup>+''a'' (mod ''X''<sup>''r''</sup> − 1,''n''), 輸出''合數''。
# 輸出 ''質數''。

這裡的 ''ord''<sub>''r''</sub>(''n'')是''n'' [[同餘|mod]] ''r''的阶。 另外，這裡的''log'' 代表以二為底的對數，<math>\scriptstyle\varphi(r)</math>則是''r''的[[歐拉函數|歐拉函數]]。

下面說明若''n''是個質數，那麼算法總是會返回''質數''：由於''n''是質數，步驟1和3永遠不會返回''合數''。步驟5也不會返回''合數''，因為(2)對所有質數''n''為真。因此，算法一定會在步驟4或6返回''質數''。

對應地，如果''n''是合數，那麼算法一定返回''合數''：如果算法返回''質數''，那麼則一定是從步驟4或6返回。對於前者，因為''n'' ≤ ''r''， ''n''必然有因子''a'' ≤ ''r''符合1 < gcd(''a'',''n'') < ''n''，因此會返回''合數''。剩餘的可能性就是步驟6，在文章<ref name="AKS" />中，這種情況被證明不會發生，因為在步驟5中檢驗的多個等式可以確保輸出一定是''合數''。

=== 例子：''n'' = 31為質數 === 
:輸入：整數''n''  =  31 > 1。
{{ordered list
|1 = <div>
   若存在整數''a'' > 0 且''b'' > 1 ，令 ''n''  =  ''a''<sup>''b''</sup> ；則輸出「合數」。
     for ( b = 2; b < =  log<sub>2</sub>(n); b +  +  ){
       a = n<sup>1/b</sup>;
       If ( a是整數 ) 輸出「合數」;
     }
     // a = n<sup>1/2</sup>...n<sup>1/4</sup> = {5.568, 3.141, 2.360}，計算結果不是整數
</div>

|2 = <div>
   找出最小的 ''r'' 令 ''ord''<sub>''r''</sub>(''n'') > log<sup>2</sup>(''n'')。
     nextR = True;
     r = 1;
     while ( nextR =  = True ) {
       r +  + ;
       nextR = False
       for ( k = 1;(!nextR) &&k ≤ log<sup>2</sup>(n); k +  +  ){
         nextR = (n<sup>k</sup> % r =  = 1 {{!!}} n<sup>k</sup> % r =  = 0);
       }
     }
     // 計算結果為：r  =  29
</div>

|3 = <div>
   若 對某些''a'' ≤ ''r''，1 < gcd(''a'',''n'') < ''n''，輸出「合數」。
     for ( a = r; a > 1; a-- ){
       If ( 1 < gcd(''a'',''n'') < ''n'' ) 輸出「合數」;
     }
      
     // gcd(29,31) = 1, gcd(28,31) = 1, ..., gcd(2,31) = 1，計算結果為找不到符合的''a''使得1 < gcd(''a'',''n'') < ''n''為真
</div>

|4 = <div>
   若 ''n'' ≤ ''r'', 輸出「質數」。
     If ( n ≤ r ) 輸出「質數」;
      
     // 31 > 29，計算結果''n''比''r''大
</div>

|5 = <div>
   對 ''a''  =  1 到 <math>\scriptstyle\lfloor \scriptstyle\sqrt{\varphi(r)}\log(n) \scriptstyle\rfloor</math>的所有數，
      如果 (''X'' + ''a'')<sup>''n''</sup>≠ ''X''<sup>''n''</sup> + ''a'' (mod ''X''<sup>''r''</sup> − 1,''n''), 輸出「合數」。
      
     for ( a = 1; a ≤ <math>\scriptstyle\lfloor \scriptstyle\sqrt{\varphi(r)}\log(n) \scriptstyle\rfloor</math>, a +  +  )
       if ( ((''X'' + ''a'')<sup>''n''</sup>-(''X''<sup>''n''</sup> + ''a'')) % (''X''<sup>''r''</sup>−1,''n'') ≠ 0 ) 輸出「合數」。
     }
      
     / *  *  * 
     (x + a)<sup>31</sup> % (x<sup>29</sup>-1,31)
       = (((x + a)<sup>29</sup> % (x<sup>29</sup>-1,31)) * (x + a)<sup>2</sup> % 31) % (x<sup>29</sup>-1,31)
       = ((1 + a<sup>29</sup> + 29a<sup>28</sup>x + (406 % 31)a<sup>27</sup>x<sup>2</sup> + (3654 % 31)a<sup>26</sup>x<sup>3</sup> + (23751 % 31)a<sup>25</sup>x<sup>4</sup> + (118755 % 31)a<sup>24</sup>x<sup>5</sup> + (475020 % 31)a<sup>23</sup>x<sup>6</sup> + (1560780 % 31)a<sup>22</sup>x<sup>7</sup> + (4292145 % 31)a<sup>21</sup>x<sup>8</sup> + (10015005 % 31)a<sup>20</sup>x<sup>9</sup> + (20030010 % 31)a<sup>19</sup>x<sup>10</sup> + (34597290 % 31)a<sup>18</sup>x<sup>11</sup> + (51895935 % 31)a<sup>17</sup>x<sup>12</sup> + (67863915 % 31)a<sup>16</sup>x<sup>13</sup> + (77558760 % 31)a<sup>15</sup>x<sup>14</sup> + (77558760 % 31)a<sup>14</sup>x<sup>15</sup> + (67863915 % 31)a<sup>13</sup>x<sup>16</sup> + (51895935 % 31)a<sup>12</sup>x<sup>17</sup> + (34597290 % 31)a<sup>11</sup>x<sup>18</sup> + (20030010 % 31)a<sup>10</sup>x<sup>19</sup> + (10015005 % 31)a<sup>9</sup>x<sup>20</sup> + (4292145 % 31)a<sup>8</sup>x<sup>21</sup> + (1560780 % 31)a<sup>7</sup>x<sup>22</sup> + (475020 % 31)a<sup>6</sup>x<sup>23</sup> + (118755 % 31)a<sup>5</sup>x<sup>24</sup> + (23751 % 31)a<sup>4</sup>x<sup>25</sup> + (3654 % 31)a<sup>3</sup>x<sup>26</sup> + (406 % 31)a<sup>2</sup>x<sup>27</sup> + 29ax<sup>28</sup>) * (a<sup>2</sup> + 2ax + x<sup>2</sup>)) % (x<sup>29</sup>-1,31)
       = ((1 + a<sup>29</sup> + 29a<sup>28</sup>x + 3a<sup>27</sup>x<sup>2</sup> + 27a<sup>26</sup>x<sup>3</sup> + 5a<sup>25</sup>x<sup>4</sup> + 25a<sup>24</sup>x<sup>5</sup> + 7a<sup>23</sup>x<sup>6</sup> + 23a<sup>22</sup>x<sup>7</sup> + 9a<sup>21</sup>x<sup>8</sup> + 21a<sup>20</sup>x<sup>9</sup> + 11a<sup>19</sup>x<sup>10</sup> + 19a<sup>18</sup>x<sup>11</sup> + 13a<sup>17</sup>x<sup>12</sup> + 17a<sup>16</sup>x<sup>13</sup> + 15a<sup>15</sup>x<sup>14</sup> + 15a<sup>14</sup>x<sup>15</sup> + 17a<sup>13</sup>x<sup>16</sup> + 13a<sup>12</sup>x<sup>17</sup> + 19a<sup>11</sup>x<sup>18</sup> + 11a<sup>10</sup>x<sup>19</sup> + 21a<sup>9</sup>x<sup>20</sup> + 9a<sup>8</sup>x<sup>21</sup> + 23a<sup>7</sup>x<sup>22</sup> + 7a<sup>6</sup>x<sup>23</sup> +  25a<sup>5</sup>x<sup>24</sup> + 5a<sup>4</sup>x<sup>25</sup> + 27a<sup>3</sup>x<sup>26</sup> + 3a<sup>2</sup>x<sup>27</sup> + 29ax<sup>28</sup>) * (a<sup>2</sup> + 2ax + x<sup>2</sup>)) % (x<sup>29</sup>-1,31)
       = ((1 + 2 * 29 + 3) % 31)a<sup>2</sup> + a<sup>31</sup> + ((2 + 29) % 31)ax + ((29 + 2 * 1) % 31)a<sup>30</sup>x + x<sup>2</sup> + ((3 + 2 * 29 + 1) % 31)a<sup>29</sup>x<sup>2</sup> + ((27 + 2 * 3 + 29) % 31)a<sup>28</sup>x<sup>3</sup> + ((5 + 2 * 27 + 3) % 31)a<sup>27</sup>x<sup>4</sup> + ((25 + 2 * 5 + 27) % 31)a<sup>26</sup>x<sup>5</sup> + ((7 + 2 * 25 + 5) % 31)a<sup>25</sup>x<sup>6</sup> + ((23 + 2 * 7 + 25) % 31)a<sup>24</sup>x<sup>7</sup> + ((9 + 2 * 23 + 7) % 31)a<sup>23</sup>x<sup>8</sup> + ((21 + 2 * 9 + 23) % 31)a<sup>22</sup>x<sup>9</sup> + ((11 + 2 * 21 + 9) % 31)a<sup>21</sup>x<sup>10</sup> + ((19 + 2 * 11 + 21) % 31)a<sup>20</sup>x<sup>11</sup> + ((13 + 2 * 19 + 11) % 31)a<sup>19</sup>x<sup>12</sup> + ((17 + 2 * 13 + 19) % 31)a<sup>18</sup>x<sup>13</sup> + ((15 + 2 * 17 + 13) % 31)a<sup>17</sup>x<sup>14</sup> + ((15 + 2 * 15 + 17) % 31)a<sup>16</sup>x<sup>15</sup> + ((17 + 2 * 15 + 15) % 31)a<sup>15</sup>x<sup>16</sup> + ((13 + 2 * 17 + 15) % 31)a<sup>14</sup>x<sup>17</sup> + ((19 + 2 * 13 + 17) % 31)a<sup>13</sup>x<sup>18</sup> + ((11 + 2 * 19 + 13) % 31)a<sup>12</sup>x<sup>19</sup> + ((21 + 2 * 11 + 19) % 31)a<sup>11</sup>x<sup>20</sup> + ((9 + 2 * 21 + 11) % 31)a<sup>10</sup>x<sup>21</sup> + ((23 + 2 * 9 + 21) % 31)a<sup>9</sup>x<sup>22</sup> + ((7 + 2 * 23 + 9) % 31)a<sup>8</sup>x<sup>23</sup> + ((25 + 2 * 7 + 23) % 31)a<sup>7</sup>x<sup>24</sup> + ((5 + 2 * 25 + 7) % 31)a<sup>6</sup>x<sup>25</sup> + ((27 + 2 * 5 + 25) % 31)a<sup>5</sup>x<sup>26</sup> + ((3 + 2 * 27 + 5) % 31)a<sup>4</sup>x<sup>27</sup> + ((29 + 2 * 3 + 27) % 31)a<sup>3</sup>x<sup>28</sup>
       = a<sup>31</sup> + x<sup>2</sup>
      
     (x<sup>31</sup> + a) % (x<sup>29</sup>-1,31) = a + x<sup>2</sup>
      
     (a<sup>31</sup> + x<sup>2</sup>)-(a + x<sup>2</sup>) = a<sup>31</sup>-a
      
     <math>\sqrt{\varphi(r)}\log_2(n) = \sqrt{28} * log_2(31) = 26.215</math>
      
     (1<sup>31</sup>-1) % 31 = 0, (2<sup>31</sup>-2) % 31 = 0, (3<sup>31</sup>-3) % 31 = 0, ..., (26<sup>31</sup>-26) % 31 = 0，計算結果為找不到符合的''a''使得(''X'' + ''a'')<sup>''n''</sup>≠ ''X''<sup>''n''</sup> + ''a'' (mod ''X''<sup>''r''</sup> − 1,''n'')為真
      *  *  * /
</div>

|6 = <div>
   輸出「質數」。
     31必為質數。
</div>
}}

==註釋==
{{Reflist|2}}

==延伸閱讀==
{{refbegin}}
* {{cite book | last=Dietzfelbinger | first=Martin | title=Primality testing in polynomial time. From randomized algorithms to ``PRIMES is in P | series=Lecture Notes in Computer Science | volume=3000 | location=Berlin | publisher=[[施普林格科学+商业媒体|施普林格科学+商业媒体]] | year=2004 | isbn=3-540-40344-2 | zbl=1058.11070 }}
{{refend}}

== 外部連結 ==
* {{MathWorld|urlname=AKSPrimalityTest|title=AKS Primality Test}}
* [https://web.archive.org/web/20140219064936/http://www.dm.unito.it/~cerruti/ac/aks-crandall.pdf R. Crandall, Apple ACG, and J. Papadopoulos (March 18, 2003): On the implementation of AKS-class primality tests] (PDF)
* [http://www.ams.org/notices/200305/fea-bornemann.pdf Article by Borneman, containing photos and information about the three Indian scientists]{{Wayback|url=http://www.ams.org/notices/200305/fea-bornemann.pdf |date=20090318110722 }} (PDF)
* [http://www.ams.org/bull/2005-42-01/S0273-0979-04-01037-7/home.html Andrew Granville: It is easy to determine whether a given integer is prime]{{Wayback|url=http://www.ams.org/bull/2005-42-01/S0273-0979-04-01037-7/home.html |date=20090308081230 }}
* [http://www.scottaaronson.com/writings/prime.pdf The Prime Facts: From Euclid to AKS]{{Wayback|url=http://www.scottaaronson.com/writings/prime.pdf |date=20100806151808 }}, by [[Scott_Aaronson|Scott Aaronson]] (PDF)
* [http://www.instantlogic.net/publications/PRIMES%20is%20in%20P%20little%20FAQ.htm The PRIMES is in P little FAQ]{{Wayback|url=http://www.instantlogic.net/publications/PRIMES%20is%20in%20P%20little%20FAQ.htm |date=20100223084530 }} by Anton Stiglic
* [https://web.archive.org/web/20150327071905/http://www.sigact.org/Prizes/Godel/2006.html 2006 Gödel Prize Citation]
* [http://www.ams.org/notices/200611/comm-fulkerson.pdf 2006 Fulkerson Prize Citation]{{Wayback|url=http://www.ams.org/notices/200611/comm-fulkerson.pdf |date=20160303183420 }}
* [http://fatphil.org/maths/AKS The AKS "PRIMES in P" Algorithm Resource]{{Wayback|url=http://fatphil.org/maths/AKS |date=20100927064107 }}
*  {{cite web|last=Grime|first=Dr. James|title=Fool-Proof Test for Primes - Numberphile|url=https://www.youtube.com/watch?v=HvMSRWTE2mI&feature=youtu.be|publisher=[[布雷迪·哈蘭|布雷迪·哈蘭]]|format=video|accessdate=2018-05-10|archive-date=2018-03-23|archive-url=https://web.archive.org/web/20180323152934/https://www.youtube.com/watch?v=HvMSRWTE2mI&feature=youtu.be|dead-url=no}} [the video describes the exponential time relation (1), which it calls AKS]

{{数论算法}}

[[Category:素性测试|Category:素性测试]]
[[Category:有限域|Category:有限域]]
[[Category:带有伪代码示例的条目|Category:带有伪代码示例的条目]]