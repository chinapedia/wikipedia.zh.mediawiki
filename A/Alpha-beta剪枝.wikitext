{{NoteTA
|G1 = Games
|G2 = IT
}}
'''Alpha-beta剪枝'''是一种搜索[[算法|算法]]，用以减少[[极小化极大算法|极小化极大算法（Minimax算法）]]搜索树的节点数。这是一种对抗性搜索算法，主要应用于机器游玩的二人游戏（如[[井字棋|井字棋]]、[[象棋|象棋]]、[[围棋|围棋]]）。当算法评估出某策略的后续走法比之前策略的还差时，就会停止计算该策略的后续发展。该算法和极小化极大算法所得结论相同，但剪去了不影响最终决定的分枝<ref name="RN10">{{Cite book| first = Stuart J.| last = Russell| first2 = Peter| last2 = Norvig| title = Artificial Intelligence: A Modern Approach| url = http://aima.cs.berkeley.edu/| year = 2010| edition = 3rd| publisher = Pearson Education, Inc.| publication-place = Upper Saddle River, New Jersey| isbn = 0-13-604259-7| author-link = Stuart J. Russell| author2-link = Peter Norvig| page = 167| access-date = 2016-02-05| archive-date = 2011-02-28| archive-url = https://web.archive.org/web/20110228023805/http://aima.cs.berkeley.edu/| dead-url = yes}}</ref>。

== 历史 ==

Allen Newell和Herbert A. Simon在1958年，使用了[[约翰·麦卡锡|John McCarthy]]所谓的“近似”alpha-beta算法<ref name="JMC">{{cite web | author = McCarthy, John | title = Human Level AI Is Harder Than It Seemed in 1955 | date = LaTeX2HTML 27 November 2006 | url = http://www-formal.stanford.edu/jmc/slides/wrong/wrong-sli/wrong-sli.html | accessdate = 2006-12-20 | archive-date = 2012-04-08 | archive-url = https://www.webcitation.org/66mXcqCVV?url=http://www-formal.stanford.edu/jmc/slides/wrong/wrong-sli/wrong-sli.html | dead-url = no }}</ref>，此算法当时“应已重新改造过多次”<ref name="NS">{{cite journal | author=Newell, Allen and Herbert A. Simon | title=Computer Science as Empirical Inquiry: Symbols and Search | journal=Communications of the ACM | volume=19 | issue=3 | date=March 1976 | url=http://archive.computerhistory.org/projects/chess/related_materials/text/2-3.Computer_science_as_empirical_inquiry/2-3.Computer_science_as_empirical_inquiry.newell_simon.1975.ACM.062303007.pdf | format=PDF | accessdate=2006-12-21 | doi=10.1145/360018.360022 | archive-url=https://www.webcitation.org/5PwLLXQSN?url=http://archive.computerhistory.org/projects/chess/related_materials/text/2-3.Computer_science_as_empirical_inquiry/2-3.Computer_science_as_empirical_inquiry.newell_simon.1975.ACM.062303007.pdf | archive-date=2007-06-28 | dead-url=yes }}</ref>。Arthur Samuel有一个早期版本，同时Richards、Hart、Levine和/或Edwards在美国分别独立发现了alpha-beta<ref name="AIM30">{{cite web | author = Edwards, D.J. and Hart, T.P. | title = The Alpha–beta Heuristic (AIM-030) | publisher = Massachusetts Institute of Technology | date = 4 December 1961 to 28 October 1963 | url = http://hdl.handle.net/1721.1/6098 | accessdate = 2006-12-21 | archive-date = 2012-04-08 | archive-url = https://www.webcitation.org/66mXdL4XI?url=http://dspace.mit.edu/handle/1721.1/6098 | dead-url = no }}</ref>。McCarthy在1956年达特默思会议上提出了相似理念，并在1961年建议给他的一群学生，其中包括MIT的Alan Kotok<ref name="AIM41">{{cite web | last=Kotok | first=Alan | title=MIT Artificial Intelligence Memo 41 | date=2004-12-03| url=http://www.kotok.org/AI_Memo_41.html | accessdate=2006-07-01 | archive-date=2012-04-08 | archive-url=https://www.webcitation.org/66mXdpr6i?url=http://www.kotok.org/AI_Memo_41.html | dead-url=no }}</ref>。Alexander Brudno独立发现了alpha-beta算法，并在1963年发布成果<ref name="Marsland">{{cite web |author=[http://www.cs.ualberta.ca/~tony/ Marsland, T.A.] |title=Computer Chess Methods (PDF) from Encyclopedia of Artificial Intelligence. S. Shapiro (editor) |publisher=J. Wiley & Sons |date=May 1987 |pages=159–171 |url=http://www.cs.ualberta.ca/~tony/OldPapers/encyc.mac.pdf |format=PDF |accessdate=2006-12-21 |deadurl=yes |archiveurl=https://web.archive.org/web/20081030023047/http://www.cs.ualberta.ca/~tony/OldPapers/encyc.mac.pdf |archivedate=2008-10-30 }}</ref>。[[高德纳|Donald Knuth]]和Ronald W. Moore在1975年优化了算法<ref name="Knuth">* {{cite journal | author = Knuth, D. E., and Moore, R. W. | title = An Analysis of Alpha–Beta Pruning | journal = Artificial Intelligence | volume = 6 | issue = 4 | year = 1975 | pages = 293–326 | accessdate =  | url = http://www.fileserve.com/file/ZgR5t3j/An_Analysis_of_Alpha-Beta_Pruning.pdf | doi = 10.1016/0004-3702(75)90019-3 }}{{Dead link|date=2019年5月 |bot=InternetArchiveBot |fix-attempted=yes }} Reprinted as Chapter 9 in {{cite book | last = Knuth | first = Donald E. | title = Selected Papers on Analysis of Algorithms | year = 2000 | publisher = Stanford, California: Center for the Study of Language and Information - CSLI Lecture Notes, no. 102 | url = http://www-cs-faculty.stanford.edu/~knuth/aa.html | isbn = 1-57586-212-3 | oclc = 222512366 | access-date = 2016-02-05 | archive-date = 2010-11-15 | archive-url = https://www.webcitation.org/5uGGImqN4?url=http://www-cs-faculty.stanford.edu/~knuth/aa.html | dead-url = no }}</ref><ref name="Abramson">{{cite journal |author=Abramson, Bruce |title=Control Strategies for Two-Player Games |journal=ACM Computing Surveys |date=June 1989 |url=http://www.theinformationist.com/pdf/constrat.pdf/ |accessdate=2008-08-20 |doi=10.1145/66443.66444 |volume=21 |issue=2 |pages=137 |deadurl=yes |archiveurl=https://web.archive.org/web/20080820030859/http://www.theinformationist.com/pdf/constrat.pdf/ |archivedate=2008-08-20 }}</ref>，Judea Pearl在1982年证明了其最优性<ref>{{cite journal|last=Pearl|first=Judea|title=The Solution for the Branching Factor of the Alpha–beta Pruning Algorithm and its Optimality|journal=Communications of the ACM|date=August 1982|volume=25|issue=8|pages=559–564|doi=10.1145/358589.358616}}</ref>。

== 对原版极小化极大算法的改进 ==

Alpha-beta的优点是减少搜索树的分枝，将搜索时间用在“更有希望”的子树上，继而提升搜索深度。该算法和极小化极大算法一样，都是分支限界类算法。若节点搜索顺序达到最优化或近似最优化（将最佳选择排在各节点首位），则同样时间内搜索深度可达极小化极大算法的两倍多。

在（平均或恒定）分枝因子为''b''，搜索深度为''d''层的情况下，要评估的最大（即招法排序最差时）叶节点数目为[[大O符号|''O'']](''b''*''b''*...*''b'') = ''O''(''b''<sup>''d''</sup>)——即和简单极小化极大搜索一样。若招法排序最优（即始终优先搜索最佳招法），则需要评估的最大叶节点数目按层数奇偶性，分别约为''O''(''b''*1*''b''*1*...*''b'')和''O''(''b''*1*''b''*1*...*1)（或''O''(''b''<sup>''d''/2</sup>) = ''O''(√''b''<sup>''d''</sup>)）。其中层数为偶数时，搜索因子相当于减少了其[[平方根|平方根]]，等于能以同深度搜索两次<ref name="RN03">{{Citation| first = Stuart J.| last = Russell| first2 = Peter| last2 = Norvig| title = Artificial Intelligence: A Modern Approach| url = http://aima.cs.berkeley.edu/| year = 2003| edition = 2nd| publisher = Prentice Hall| publication-place = Upper Saddle River, New Jersey| isbn = 0-13-790395-2| author-link = Stuart J. Russell| author2-link = Peter Norvig| accessdate = 2016-02-05| archive-date = 2011-02-28| archive-url = https://web.archive.org/web/20110228023805/http://aima.cs.berkeley.edu/| dead-url = yes}}</ref>。''b''*1*''b''*1*...意义为，对第一名玩家必须搜索全部招法找到最佳招式，但对于它们，只用将第二名玩家的最佳招法截断——alpha-beta确保无需考虑第二名玩家的其他招法。但因节点生成顺序随机，实际需要评估的节点平均约为''O''(''b''<sup>3''d''/4</sup>)<ref name="JMC" />。

一般在alpha-beta中，子树会由先手方优势或后手方优势暂时占据主导。若招式排序错误，这一优势会多次切换，每次让效率下降。随着层数深入，局面数量会呈指数性增长，因此排序早期招式价值很大。尽管改善任意深度的排序，都以能指数性减少总搜索局面，但排序临近根节点深度的全部局面相对经济。在实践中，招法排序常由早期、小型搜索决定，如通过[[迭代加深深度优先搜索|迭代加深]]。

算法使用两个值alpha和beta，分别代表大分玩家放心的最高分，以及小分玩家放心的最低分。alpha和beta的初始值分别为正负无穷大，即双玩家都以可能的最低分开始游戏。在选择某节点的特定分枝后，可能发生小分玩家放心的最小分小于大分玩家放心的最大分（beta <= alpha）。这种情况下，父节点不应选择这个节点，否则父节点分数会降低，因此该分枝的其他节点没有必要继续探索。

== 伪代码 ==

下面为一有限可靠性版本的Alpha-beta剪枝的虛擬代碼<ref name="RN03" />：

'''function''' alphabeta(node, depth, α, β, maximizingPlayer) ''// node = 节点，depth = 深度，maximizingPlayer = 大分玩家''
      '''if''' depth = 0 '''or''' node是终端節點
          '''return''' 節點的啟發值
      '''if''' maximizingPlayer
          v := -∞
          '''for''' 每个子節點
              v := max(v, alphabeta(child, depth - 1, α, β, FALSE)) ''// child = 子節點''
              α := max(α, v)
              '''if''' β ≤ α
                  '''break''' ''// β裁剪''
          '''return''' v
      '''else'''
          v := ∞
          '''for''' 每个子節點
              v := min(v, alphabeta(child, depth - 1, α, β, TRUE))
              β := min(β, v)
              '''if''' β ≤ α
                  '''break''' ''// α裁剪''
          '''return''' v

 '''''(* 初始調用 *)'''''
 alphabeta(origin, depth, -[[Infinity|∞]], +[[Infinity|∞]], TRUE) ''// origin = 初始節點''

在這個有限可靠性的alpha-beta中，當v超出調用參數α和β構成的集合時（v < α或v > β），alphabeta函數返回值v。而與此相對，強化的有限可靠性alpha-beta限制函數返回在α與β包括範圍中的值。
<!--
== Heuristic improvements ==

Further improvement can be achieved without sacrificing accuracy, by using ordering [[heuristic|heuristic]]s to search parts of the tree that are likely to force alpha–beta cutoffs early. For example, in chess, moves that take pieces may be examined before moves that do not, or moves that have scored highly in [[Iterative_deepening_depth-first_search|earlier passes]] through the game-tree analysis may be evaluated before others. Another common, and very cheap, heuristic is the [[killer_heuristic|killer heuristic]], where the last move that caused a beta-cutoff at the same level in the tree search is always examined first. This idea can also be generalized into a set of [[refutation_table|refutation table]]s.

Alpha–beta search can be made even faster by considering only a narrow search window (generally determined by guesswork based on experience). This is known as ''aspiration search''. In the extreme case, the search is performed with alpha and beta equal; a technique known as ''zero-window search'', ''null-window search'', or ''scout search''. This is particularly useful for win/loss searches near the end of a game where the extra depth gained from the narrow window and a simple win/loss evaluation function may lead to a conclusive result. If an aspiration search fails, it is straightforward to detect whether it failed ''high'' (high edge of window was too low) or ''low'' (lower edge of window was too high). This gives information about what window values might be useful in a re-search of the position.

Over time, other improvements have been suggested, and indeed the Falphabeta (fail-soft alpha-beta) idea of Fishburn is nearly universal and is already incorporated above in a slightly modified form. Fishburn also suggested a combination of the killer heuristic and zero-window search under the name Lalphabeta ("last move with minimal window alpha-beta search".)

== Other algorithms ==

More advanced algorithms that are even faster while still being able to compute the exact minimax value are known, such as SCOUT,<ref>Pearl, J., "SCOUT: A Simple Game-Searching Algorithm With Proven Optimal Properties," ''Proceedings of the First Annual National Conference on Artificial Intelligence,'' Stanford University, August 18–21, 1980, pp. 143-145.</ref> [[Negascout|Negascout]] and [[MTD-f|MTD-f]].

Since the minimax algorithm and its variants are inherently [[depth-first_search|depth-first]], a strategy such as [[Iterative_deepening_depth-first_search|iterative deepening]] is usually used in conjunction with alpha–beta so that a reasonably good move can be returned even if the algorithm is interrupted before it has finished execution. Another advantage of using iterative deepening is that searches at shallower depths give move-ordering hints, as well as shallow alpha and beta estimates, that both can help produce cutoffs for higher depth searches much earlier than would otherwise be possible.

Algorithms like [[SSS*|SSS*]], on the other hand, use the [[best_first_search|best-first]] strategy.  This can potentially make them more time-efficient, but typically at a heavy cost in space-efficiency.<ref>{{citation|doi=10.1146/annurev.cs.02.060187.002315|title=Search techniques|journal=Annual Review of Computer Science|volume=2|pages=451–467|year=1987|first1=Judea|last1=Pearl|author1-link=Judea Pearl|first2=Richard|last2=Korf|quote=Like its A* counterpart for single-player games, SSS* is optimal in terms of the average number of nodes examined; but its superior pruning power is more than offset by the substantial storage space and bookkeeping required.}}</ref>

== See also ==

* [[Pruning_(algorithm)|Pruning (algorithm)]]
* [[Branch_and_bound|Branch and bound]]
* [[Minimax|Minimax]]
* [[Combinatorial_optimization|Combinatorial optimization]]
* [[Negamax|Negamax]]
* [[Principal_variation_search|Principal variation search]]
* [[Transposition_table|Transposition table]]

 -->

== 参考文献 ==

* {{cite book | author=George T. Heineman, Gary Pollice, and Stanley Selkow | title= Algorithms in a Nutshell | publisher=[[Oreilly_Media|Oreilly Media]] | year=2008 | chapter=Chapter 7: Path Finding in AI | pages = 217–223 | isbn=978-0-596-51624-6 }}
* [[Judea_Pearl|Judea Pearl]], ''Heuristics'', Addison-Wesley, 1984
* {{cite book | author=John P. Fishburn | title= Analysis of Speedup in Distributed Algorithms (revision of 1981 PhD thesis) | url=https://archive.org/details/analysisofspeedu0000fish | publisher=[[UMI_Research_Press|UMI Research Press]] | year=1984 | chapter=Appendix A: Some Optimizations of α-β Search | pages = [https://archive.org/details/analysisofspeedu0000fish/page/107 107]-111 | isbn=0-8357-1527-2 }}

<references/>
== 外部链接 ==

* http://www.emunix.emich.edu/~evett/AI/AlphaBeta_movie/sld001.htm{{Wayback|url=http://www.emunix.emich.edu/~evett/AI/AlphaBeta_movie/sld001.htm |date=20160128234024 }}
* http://sern.ucalgary.ca/courses/CPSC/533/W99/presentations/L1_5B_McCullough_Melnyk/{{Wayback|url=http://sern.ucalgary.ca/courses/CPSC/533/W99/presentations/L1_5B_McCullough_Melnyk/ |date=20071203235704 }}
* http://sern.ucalgary.ca/courses/CPSC/533/W99/presentations/L2_5B_Lima_Neitz/search.html{{Wayback|url=http://sern.ucalgary.ca/courses/CPSC/533/W99/presentations/L2_5B_Lima_Neitz/search.html |date=20071208131617 }}
* https://web.archive.org/web/20021223103359/http://www.maths.nott.ac.uk/personal/anw/G13GAM/alphabet.html
* https://web.archive.org/web/20041123061044/http://chess.verhelst.org/search.html
* http://www.frayn.net/beowulf/index.html{{Wayback|url=http://www.frayn.net/beowulf/index.html |date=20160310130920 }}
* http://hal.inria.fr/docs/00/12/15/16/PDF/RR-6062.pdf{{Wayback|url=http://hal.inria.fr/docs/00/12/15/16/PDF/RR-6062.pdf |date=20140211064951 }}
* [http://ksquared.de/gamevisual/launch.php?agent=2 Minimax (with or without alpha–beta pruning) algorithm visualization - game tree solving (Java Applet), for balance or off-balance trees]{{Wayback|url=http://ksquared.de/gamevisual/launch.php?agent=2 |date=20120426081822 }}
* [http://homepage.ufp.pt/jtorres/ensino/ia/alfabeta.html Demonstration/animation of minimax game search algorithm with alpha–beta pruning (using html5, canvas, javascript, css)]{{Wayback|url=http://homepage.ufp.pt/jtorres/ensino/ia/alfabeta.html |date=20160202082614 }}
* [https://github.com/ykaragol/checkersmaster/blob/master/CheckersMaster/src/checkers/algorithm/AlphaBetaAlgorithm.java Java implementation used in a Checkers Game]{{Wayback|url=https://github.com/ykaragol/checkersmaster/blob/master/CheckersMaster/src/checkers/algorithm/AlphaBetaAlgorithm.java |date=20160103031631 }}

{{博弈论}}

{{DEFAULTSORT:剪枝}}

[[Category:搜尋演算法|Category:搜尋演算法]]
[[Category:图算法|Category:图算法]]
[[Category:带有伪代码示例的条目|Category:带有伪代码示例的条目]]