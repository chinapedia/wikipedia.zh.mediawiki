在系统的设计时刻常常遇到这样一个问题：[[類別_(電腦科學)|类]]Client的实例instanceClient希望使用另一个对象instanceX提供的服务service，但在设计时刻并不能确定对象instanceX究竟属于哪个类。常见的解决办法是：将对象instanceX提供的服务service抽象为一个[[接口_(计算机科学)|接口]]ServiceProvider，然后让对象instanceClient通过持有接口ServiceProvider的实例来使用服务service。这种通过接口间接获得服务的解决方案就是'''接口模式'''。

[[File:Interface_pattern.png|center]]

接口模式还可以有一些变化的形式：不止用一个接口抽象一个对象提供的服务，还可以用一组接口抽象一群对象的交互。

==效果==
接口模式有如下效果：
*类Client不直接依赖于任何实在（concrete）的服务提供者，而仅仅依赖于轻量的接口，这样就降低了系统的[[耦合力_(計算機科學)|耦合]]程度。
*因为接口将服务独立出来，服务的提供者就可以变化。
*因为引入了接口来间接提供服务，所以设计方案变得更加复杂。

==评论==

接口模式直接体现了[[面向对象设计|面向对象设计]]的原则之一：“针对接口编程，而不是针对实现编程”。

许多其他的模式都应用了接口模式，只不过更为特殊。下表列出了作为接口模式特例的其他模式，并且指明了这些模式将哪些服务抽象为接口。

{|
| '''模式'''
| '''抽象为接口的服务'''
|-
| [[代理模式|代理模式]]
| 对对象的访问
|-
| [[抽象工厂模式|抽象工厂模式]]
| 创建对象家族
|-
| [[生成器模式|生成器模式]]
| 创建多个对象的组合
|-
| [[工厂方法模式|工厂方法模式]]
| 对象的实例化
|-
| [[原型模式|原型模式]]
|  对象的实例化
|-
| [[单例模式|单例模式]]
| 类的唯一实例的创建
|-
| [[命令模式|命令模式]]
| 对请求的处理
|-
| [[迭代器模式|迭代器模式]] 
| 对成员的遍历
|-
| [[观察者模式|观察者模式]]
| 因目标（Subject）发生变化而作出反映
|-
| {{le|状态模式|State pattern}}
| 状态与状态的变化
|-
| [[策略模式|策略模式]]
| 算法、策略
|-
| [[访问者模式|访问者模式]]
| 作用于一组对象上的操作
|}

[[Category:软件设计模式|Category:软件设计模式]]