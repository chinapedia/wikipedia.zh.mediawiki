{{NoteTA|G1=IT|G2=FL}}
{{distinguish|occam}}
{{Infobox programming language
|name = OCaml
|logo = OCaml Logo.svg
|paradigm = [[编程范型|多范型]]：[[函数式编程|函数式]]，[[指令式編程|指令式]]，[[模块化编程|模块化]]<ref name=“module”>{{cite web|author=Xavier Leroy|title=Manifest types, modules, and separate compilation|publisher=Principles of Programming Languages|year=1994|url=https://caml.inria.fr/pub/papers/xleroy-manifest_types-popl94.pdf|access-date=2021-09-06|archive-date=2021-10-22|archive-url=https://web.archive.org/web/20211022073638/https://caml.inria.fr/pub/papers/xleroy-manifest_types-popl94.pdf}}</ref>，[[面向对象程序设计|面向对象]]<ref name="objective" />
| family = [[ML语言|ML]]
|released = {{Start date and age|1996}}
|typing = [[静态类型|静态]]，[[强类型|强]]，[[类型推论|类型推论]]
|designer = {{en-link|Xavier Leroy}}, {{en-link|Damien Doligez}}, Didier Rémy, Jérôme Vouillon 
|developer = [[INRIA|INRIA]]
 | latest release version = {{wikidata|property|edit|reference|P548=Q2804309|P348}}
 | latest release date    = {{wikidata|qualifier|P548=Q2804309|P348|P577}}，{{Time ago|{{wikidata|qualifier|raw|P548=Q2804309|P348|P577}}}}
|operating_system = [[跨平台|跨平台]]
|influenced by  = [[C语言|C]], [[Caml|Caml]], [[Modula-2|Modula-2]]<ref name=“module” />, [[Standard_ML|Standard ML]]
|influenced = {{en-link|ATS (编程语言)|ATS (programming language)|ATS}}, [[Coq|Coq]], [[Elm_(编程语言)|Elm]], [[F♯|F#]], [[F*|F*]], [[Haxe|Haxe]], {{en-link|Opa (编程语言)|Opa (programming language)|Opa}}, [[Rust|Rust]], [[Scala|Scala]]
|dialects = [[F♯|F#]], {{en-link|JoCaml}}, MetaOCaml<ref name = "Meta">{{cite web|url=http://okmij.org/ftp/ML/MetaOCaml.html|title=MetaOCaml -- an OCaml dialect for multi-stage programming|access-date=2021-08-28|archive-date=2021-08-29|archive-url=https://web.archive.org/web/20210829183523/http://okmij.org/ftp/ML/MetaOCaml.html}}</ref>
|license = [[GNU宽通用公共许可证|GNU宽通用公共许可证]]
}}

'''OCaml'''（{{IPAc-en|oʊ|ˈ|k|æ|m|əl}} {{respell|oh|KAM|əl}}），是一个[[函数式编程|函数式]]、[[指令式編程|指令式]]、[[模块化编程|模块化]]<ref name=“module” />、[[面向对象程序设计|面向对象]]的[[通用编程语言|通用]]的[[编程语言|编程语言]]。在{{en-link|Xavier Leroy}}和{{en-link|Damien Doligez}}，于1990年和1991年实现的[[ML语言|ML]]方言[[Caml|Caml Light]]之上<ref>{{cite web|url=https://caml.inria.fr/pub/docs/manual-caml-light/|title=The Caml Light system Release 0.74, documentation and user's guide|author={{en-link|Xavier Leroy}}|year=1997|access-date=2021-09-02|archive-date=2022-03-08|archive-url=https://web.archive.org/web/20220308045958/https://caml.inria.fr/pub/docs/manual-caml-light/}}</ref>，Didier Rémy和Jérôme Vouillon，于1996年增加了[[面向对象编程|面向对象]]特征<ref name="objective">{{cite web|author=Didier Rémy|title=Type inference for records in a natural extension of ML|publisher=Research Report RR-1431, INRIA|year=1991|url=https://hal.inria.fr/inria-00075129/document|access-date=2021-09-10|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406233611/https://hal.inria.fr/inria-00075129/document}}<br />{{cite web|author=Didier Rémy, Jérôme Vouillon|title=Objective ML: a simple object-oriented extension of ML|url=http://gallium.inria.fr/~remy/ftp/objective-ml!popl97.pdf|year=1997|access-date=2021-09-06|archive-date=2022-01-21|archive-url=https://web.archive.org/web/20220121031810/http://gallium.inria.fr/~remy/ftp/objective-ml!popl97.pdf}}<br />{{cite web|author=Didier Rémy, Jérôme Vouillon|title=Objective ML: An effective object-oriented extension to ML|url=https://caml.inria.fr/pub/papers/remy_vouillon-objective_ml-tapos98.pdf|year=1998|access-date=2021-09-06|archive-date=2022-01-20|archive-url=https://web.archive.org/web/20220120081109/https://caml.inria.fr/pub/papers/remy_vouillon-objective_ml-tapos98.pdf}}</ref>，从而形成了“Objective Caml”<ref>{{cite web|title=The Objective Caml system release 1.07, Documentation and user's manual|url=https://caml.inria.fr/pub/distrib/ocaml-1.07/ocaml-1.07-refman.txt|author=Xavier Leroy|year=1997|access-date=2021-09-02|archive-date=2022-01-23|archive-url=https://web.archive.org/web/20220123211218/https://caml.inria.fr/pub/distrib/ocaml-1.07/ocaml-1.07-refman.txt}}</ref>，在2011年时重命名为“OCaml”<ref name="caml-hist">{{cite web|url=https://caml.inria.fr/about/history.en.html|title=A History of Caml|quote=Our main reason for developing Caml was to use it for sofware development inside Formel. Indeed, it was used for developing the Coq system ……. We were reluctant to adopt a standard that could later prevent us from adapting the language to our programming needs. ……We did incorporate into Caml most of the improvements brought by Standard ML over Edinburgh ML. ……The first implementation of Caml appeared in 1987 and was further developed until 1992. It was created mainly by Ascander Suarez. ……<br />In 1990 and 1991, Xavier Leroy designed a completely new implementation of Caml, based on a bytecode interpreter written in C. Damien Doligez provided an excellent memory management system. ……In 1995, Xavier Leroy released Caml Special Light, which improved over Caml Light in several ways. In 1995, Xavier Leroy released Caml Special Light, which improved over Caml Light in several ways. First, an optimizing native-code compiler was added to the bytecode compiler. ……Second, Caml Special Light offered a high-level module system, designed by Xavier Leroy and inspired by the module system of Standard ML. ……Didier Rémy, later joined by Jérôme Vouillon, designed an elegant and highly expressive type system for objects and classes. This design was integrated and implemented within Caml Special Light, leading to the Objective Caml language and implementation, first released in 1996 and renamed to OCaml in 2011.|access-date=2021-09-02|archive-date=2022-04-13|archive-url=https://web.archive.org/web/20220413084146/https://caml.inria.fr/about/history.en.html}}</ref>。

OCaml[[工具链|工具链]]包括交互式顶层[[解释器|解释器]]、[[字节码|字节码]][[编译器|编译器]]、优化的[[机器语言|本机代码]]编译器，可逆[[调试器|调试器]]和一个[[包管理器|包管理器]]（OPAM）。OCaml最初开发于[[自动定理证明|自动定理证明]]的场景中，并在[[静态程序分析|静态分析]]和[[形式方法|形式方法]]软件中有超凡的存在感。此外，它在[[系统编程|系统编程]]、[[网页编程|网页编程]]和[[金融工程|金融工程]]及其他应用领域都有严肃的应用。

历史上，Ascánder Suárez于1987年基于{{fr-link|Guy Cousineau}}的{{en-link|范畴抽象机器|Categorical abstract machine}}（CAM）<ref>{{cite web|author=G. Cousineau, P.-L. Curien, M. Mauny|title=The categorical abstract machine|year=1985|url=https://www.sciencedirect.com/science/article/pii/0167642387900207|access-date=2021-09-03|archive-date=2021-09-03|archive-url=https://web.archive.org/web/20210903015705/https://www.sciencedirect.com/science/article/pii/0167642387900207}} LNCS, 201, Functional programming languages computer architecture, pp.~50-64.<br />{{cite web|title=Implementing functional languages in the Categorical Abstract Machine|author=Michel Mauny, Ascánder Suárez|year=1986|url=http://michel.mauny.net/data/papers/mauny-suarez-1986.pdf|access-date=2021-09-07|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128115221/http://michel.mauny.net/data/papers/mauny-suarez-1986.pdf}} LFP '86: Proceedings of the 1986 ACM conference on LISP and functional programming, Pages 266–278.</ref>，重新实现了{{en-link|Gérard Huet}}早先的ML方言<ref name="handbook">{{cite book|title=The ML Handbook, Version 6.2|series=Internal document|author= G. Cousineau, M. Gordon, G. Huet, R. Milner, L. C. Paulson, C. Wadsworth |publisher=Project Formel, INRIA|date=July 1985}}<br />{{cite web|title=Introduction to Classic ML|author=Christoph Kreitz, Vincent Rahli|year=2011|url=http://www.nuprl.org/crash/eventml/KreitzandRahli-ClassicML.pdf|quote=This handbook is a revised edition of Section 2 of ‘Edinburgh LCF’, by M. Gordon, R. Milner, and C. Wadsworth, published in 1979 as Springer Verlag Lecture Notes in Computer Science no 78. ……The language is somewhere in between the original ML from LCF and standard ML, since Guy Cousineau added the constructors and call by patterns. This is a LISP based implementation, compatible for Maclisp on Multics, Franzlisp on VAX under Unix, Zetalisp on Symbolics 3600, and Le Lisp on 68000, VAX, Multics, Perkin-Elmer, etc... Video interfaces have been implemented by Philippe Le Chenadec on Multics, and by Maurice Migeon on Symbolics 3600. The ML system is maintained and distributed jointly by INRIA and the University of Cambridge.|access-date=2021-09-11|archive-date=2022-01-29|archive-url=https://web.archive.org/web/20220129103018/http://www.nuprl.org/crash/eventml/KreitzandRahli-ClassicML.pdf}}</ref>，并用“范畴抽象机语言”的首字母简写将其命名为[[Caml|Caml]]<ref name="caml-doc">{{cite web|title=The CAML primer Version 2.6.1|author=Guy Cousineau, {{en-link|Gérard Huet}}|url=https://hal.inria.fr/inria-00070045/document|year=1990|access-date=2021-09-07|archive-date=2022-05-04|archive-url=https://web.archive.org/web/20220504232145/https://hal.inria.fr/inria-00070045/document}} RT-0122, INRIA. pp.78.<br />{{cite web|title=The CAML reference manual Version 2.6.1|url=https://hal.inria.fr/inria-00070046/document|author=Pierre Weis, Maria Virginia Aponte, Alain Laville, Michel Mauny, Ascander Suarez|year=1990|access-date=2021-09-07|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406231614/https://hal.inria.fr/inria-00070046/document}} [Research Report] RT-0121, INRIA. pp.491.</ref>，Caml Light放弃了这个[[抽象机器|抽象机器]]又进行了重新实现<ref>{{cite web|author=Xavier Leroy|title=The ZINC experiment : an economical implementation of the ML language|year=1990|url=https://hal.inria.fr/inria-00070049/document|access-date=2021-09-06|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406232126/https://hal.inria.fr/inria-00070049/document}} RT-0117, INRIA.</ref>。OCaml是[[开放源代码|开放源代码]]项目，此项目的管理和大部分维护工作，已经交由[[法国国家信息与自动化研究所|法国国家信息与自动化研究所]]（INRIA）。在[[2000年代|2000年代]]早期，来自OCaml的元素被很多语言接纳，特别是[[F♯|F#]]和[[Scala|Scala]]。

==哲学==
[[ML语言|ML]]派生语言最著称的是静态[[类型系统|类型系统]]和[[类型推论|类型推论]]编译器。OCaml将[[函数式编程|函数式]]、[[指令式编程|指令式]]和[[面向对象编程|面向对象编程]]统一于类ML的类型系统之下。因此编程者不需要为了使用OCaml而非常熟悉[[纯函数式编程|纯函数式编程]]范型。

通过要求编程者在静态类型系统的约束下工作，OCaml消除了关联于动态类型语言的很多有关于类型的运行时间问题。还有，OCaml的类型推论编译器，极大的减少了在多数静态类型语言中对手工类型标注的需要。例如，变量的[[数据类型|数据类型]]和函数的[[类型签名|签名]]，通常不需要像[[Java|Java]]和[[C♯|C#]]语言中那样显式的声明，因为它们可以从应用于这个变量和代码中其他值的算符和其他函数推论出来。有效的使用OCaml的类型系统可能要求一个编程者面对一些复杂性，但是这种规矩能得到可靠的、高性能软件作为回报。

OCaml与源于学术界的其他语言的最显著区别可能是强调了性能。它的静态类型系统防止了运行时间类型不匹配，从而排除了动态类型语言运行时间类型和安全检查的性能负担，却在除了关闭数组边界检查，和使用一些类型不安全特征比如序列化之外的情况下，仍能保证运行时间安全性。这些运行时间检查需求足够罕见，在实践中完全可以避免。

在类型检查开销之外，[[函数式编程|函数式编程]]语言，要编译成高效的机器语言代码，由于如{{en-link|函数参数问题|funarg problem}}这样的要点，一般而言是具有挑战性的。与标准的循环、寄存器和指令{{en-link|优化编译器|Optimizing compiler|优化}}一起，OCaml的优化编译器采用[[静态程序分析|静态程序分析]]方法，来优化值{{en-link|对象类型 (面向对象编程)|Object type (object-oriented programming)|包装}}（boxing）和[[闭包_(计算机科学)|闭包]]分配，帮助结果代码得到最大化的性能，即使它大量使用了函数式编程构造。

{{en-link|Xavier Leroy}}曾经宣称：“OCaml至少提供了像样的C编译器的50%的性能”<ref name = "LWN">[https://lwn.net/Articles/19378/ Linux Weekly News] {{Wayback|url=https://lwn.net/Articles/19378/ |date=20210830120637 }}.</ref>，尽管直接比较是不可能的。在OCaml标准库中的一些函数，是采用比在其他语言标准库中等价的函数更快的算法实现的。例如，在OCaml标准库中集合并集的实现，在理论上比指令式语言（例如C++、Java）的标准库中的等价函数，要渐进性的更快，因为OCaml实现利用了集合的不可变性，而在输出中重用了输入集合的一些部份（参见[[可持久化数据结构|可持久化数据结构]]）。

==特征==
OCaml的特征包括：静态[[类型系统|类型系统]]、[[类型推论|类型推论]]、[[参数多态|参数多态]]、[[尾递归|尾递归]]、[[模式匹配|模式匹配]]、[[头等对象|头等]][[作用域|词法]][[闭包_(计算机科学)|闭包]]、[[函子_(函数式编程)|函子]]（参数化模块）、[[异常处理|异常处理]]和增量分代[[垃圾回收_(计算机科学)|自动垃圾回收]]。

OCaml著称于将[[ML语言|ML]]风格类型推论，扩展到通用语言中的[[对象_(计算机科学)|对象]]系统。这允许了{{en-link|结构类型系统|Structural type system|结构子类型}}，这里的对象类型是兼容的，如果它们的[[方法_(计算机科学)|方法]][[类型签名|签名]]是兼容的，不用管它们声明的[[继承_(计算机科学)|继承]]，这是在静态类型语言中不寻常的特征。

OCaml提供了[[链接器|链接]]到[[C语言|C]]原语的{{en-link|外界函数接口|foreign function interface}}，包括了兼容于C和[[Fortran|Fortran]]二者格式的对高效数值[[数组|数组]]的语言支持。OCaml还支持建立可以链接到用C写的<code>main</code>程序的OCaml[[函数库|函数库]]。

OCaml发行包含了：
* [[词法分析|词法分析]]和[[语法分析|语法解析]]工具分别叫做<code>ocamllex</code>和<code>ocamlyacc</code>。
* 支持步进回溯的[[调试器|调试器]]用来调查错误。
* {{en-link|文档生成器|Documentation generator}}。
* [[性能分析|剖析器]]用来测量性能。
* 很多通用[[函数库|函数库]]。

本机代码编译器可以在很多平台上获得，包括[[Unix|Unix]]、[[Microsoft|Microsoft]] [[Microsoft_Windows|Windows]]和[[苹果公司|Apple]] [[macOS|macOS]]。可移植性是通过至此主要架构的本机{{en-link|代码生成 (编译器)|code generation (compiler)|代码生成}}实现的：[[IA-32|IA-32]]、[[X86-64|X86-64]]（AMD64）、{{en-link|Power ISA|Power ISA|Power}}、[[RISC-V|RISC-V]]、[[ARM架构|ARM]]和[[ARM64|ARM64]]<ref>{{cite web|url=https://github.com/ocaml/ocaml/tree/trunk/asmcomp|title=ocaml/asmcomp at trunk · ocaml/ocaml · GitHub|work=GitHub|access-date=2 May 2015|archive-date=2022-05-07|archive-url=https://web.archive.org/web/20220507042329/https://github.com/ocaml/ocaml/tree/trunk/asmcomp}}</ref>。

OCaml字节码和本机代码程序可以用[[线程|多线程]]风格书写，具有抢占式上下文切换。但是由于当前唯一可得的语言完全实现INRIA OCaml的垃圾回收器，不是为[[并发性|并发性]]而设计的，[[对称多处理|对称多处理]]是不支持的<ref name = "INRIA">{{cite web|url=https://inbox.ocaml.org/caml-list/462B3929.9080608@inria.fr/|title=Archives of the Caml mailing list > Message from Xavier Leroy|access-date=2021-09-10|archive-date=2022-03-31|archive-url=https://web.archive.org/web/20220331094724/https://inbox.ocaml.org/caml-list/462B3929.9080608@inria.fr/}}</ref>。在相同进程中的OCaml线程只能分时执行。但是有一些分布式计算库比如Functory<ref>{{Cite web |url=http://functory.lri.fr/About.html |title=Functory |access-date=2021-08-30 |archive-date=2022-01-20 |archive-url=https://web.archive.org/web/20220120060011/http://functory.lri.fr/About.html }}</ref>和Plasma<ref>{{Cite web |url=http://projects.camlcity.org/projects/ocamlnet.html |title=ocamlnet/Plasma |access-date=2021-08-30 |archive-date=2022-03-23 |archive-url=https://web.archive.org/web/20220323041312/http://projects.camlcity.org/projects/ocamlnet.html }}</ref>。

==代码例子==
OCaml的代码片段可以通过键入到顶层[[读取﹣求值﹣输出循环|REPL]]中来很容易的研习。这是一个交互式的OCaml会话，它打印结果或定义的表达式的推论出的类型<ref>{{Cite web|title=OCaml - The toplevel system or REPL (ocaml)|url=https://ocaml.org/manual/toplevel.html|access-date=2021-05-17|website=ocaml.org|archive-date=2021-09-11|archive-url=https://web.archive.org/web/20210911132917/https://ocaml.org/manual/toplevel.html}}</ref>。OCaml顶层可以通过简单执行OCaml程序来启动：
<syntaxhighlight lang="console">
$ ocaml
        OCaml version 4.11.1

# 
</syntaxhighlight>
可以接着在<code>#</code>提示符处键入代码。例如计算<code>1+2*3</code>:
<syntaxhighlight lang="OCaml" highlight="2">
# 1 + 2 * 3;;
- : int = 7
</syntaxhighlight>

OCaml推论出这个表达式的类型是<code>int</code>（[[字_(计算机)|机器精度]][[整数_(计算机科学)|整数]]）并给出结果<code>7</code>。

===Hello World===
下面的程序<code>hello.ml</code>:
<syntaxhighlight lang="OCaml">
print_endline "Hello World!"
</syntaxhighlight>
可以被编译成字节码可执行文件：
<syntaxhighlight lang="console">
$ ocamlc hello.ml -o hello
</syntaxhighlight>
或者被编译成优化的本地代码可执行文件：
<syntaxhighlight lang="console">
$ ocamlopt hello.ml -o hello
</syntaxhighlight>
接着执行它：

<syntaxhighlight lang="console">
$ ./hello
Hello World!
</syntaxhighlight>

给ocamlc的第一个实际参数<code>hello.ml</code>，指定要编译的源文件而<code>-o hello</code>标志指定了输出文件<ref>[https://ocaml.org/manual/comp.html Batch compilation (ocamlc)] {{Wayback|url=https://ocaml.org/manual/comp.html |date=20211230184313 }}.</ref>。

===阶乘函数===
很多数学函数，比如[[阶乘|阶乘]]，可以很自然的表示为纯粹的函数形式：
<syntaxhighlight lang="OCaml">
let rec fact n =
  if n=0 then 1 else n * fact(n - 1);;
</syntaxhighlight>
这个函数可以使用[[模式匹配|模式匹配]]等价的写为：
<syntaxhighlight lang="OCaml">
let rec fact = function
  | 0 -> 1
  | n -> n * fact(n - 1);;
</syntaxhighlight>
后者形式是阶乘作为[[递推关系|递推关系]]的数学定义。

编译器将这个函数的类型推论为<code>int -> int</code>，意味着这个函数将<code>int</code>映射到<code>int</code>。例如，<code>12!</code>：
<syntaxhighlight lang="OCaml" highlight="2">
# fact 12;;
- : int = 479001600
</syntaxhighlight>

===斐波那契序列===
下列代码计算输入数<code>n</code>的[[斐波那契数|斐波那契数列]]。它使用了[[尾递归|尾递归]]和[[模式匹配|模式匹配]]。
<syntaxhighlight lang = OCaml>
let fib n =
  let rec fib_aux m a b =
    match m with
    | 0 -> a
    | _ -> fib_aux (m - 1) b (a + b)
  in fib_aux n 0 1;;
</syntaxhighlight>

===生日问题===
下列程序计算在一个屋子里面有完全唯一的生日概率小于50%的最少人数，在[[生日问题|生日问题]]中，对于1个人这个概率是365/365（或100%），对于2个人是364/365，对于3个人是364/365 × 363/365，最终答案是23个人：
<syntaxhighlight lang="OCaml">
let year_size = 365.
let rec birthday_paradox prob people =
  let prob = (year_size -. float people) /. year_size *. prob  in
  if prob < 0.5 then
    Printf.printf "answer = %d\n" (people+1)
  else
    birthday_paradox prob (people+1);;
</syntaxhighlight>
<syntaxhighlight lang = OCaml highlight="2,3">
# birthday_paradox 1.0 1;;
answer = 23
- : unit = ()
</syntaxhighlight>

===合计整数列表===
列表是OCaml中的基础数据类型之一。下面的代码例子定义[[递归_(计算机科学)|递归]]函数<code>sum</code>，它接受一个实际参数<code>integers</code>，而它被假定为整数的列表。注意关键字<code>rec</code>指示了这个函数是递归的。这个函数递归的在给定整数列表之上进行迭代，并提供这些元素的一个总和。<code>match</code>语句类似于[[C语言|C]]的<code>{{en-link|Switch语句|Switch statement|switch}}</code>语句，但要更加一般性。

<syntaxhighlight lang="ocaml">
let rec sum integers =                   (* 关键字rec含义为递归。 *)
  match integers with
  | [] -> 0                              (* 产生0，如果integers为空列表 []。 *)
  | first :: rest -> first + sum rest;;  (* 递归调用，如果integers是非空列表；
                                            first是这个列表的第一个元素，
                                            而rest是余下元素的列表，可能是[]。 *)
</syntaxhighlight>
<syntaxhighlight lang="OCaml" highlight="2">
# sum [1;2;3;4;5];;
- : int = 15
</syntaxhighlight>

另一种方式是对列表使用标准的[[fold_(高阶函数)|fold]]高阶函数:

<syntaxhighlight lang="ocaml">
let sum integers =
  List.fold_left (fun accumulator x -> accumulator + x) 0 integers;;
</syntaxhighlight>
<syntaxhighlight lang="OCaml" highlight="2">
# sum [1;2;3;4;5];;
- : int = 15
</syntaxhighlight>

因为[[匿名函数|匿名函数]]是简单的<code>+</code>算符应用，它可以简写为：

<syntaxhighlight lang="ocaml">
let sum integers =
  List.fold_left (+) 0 integers
</syntaxhighlight>

进一步的，还可以通过采用{{en-link|部份应用|Partial application}}省略列表实际参数：
<syntaxhighlight lang="OCaml">
let sum =
  List.fold_left (+) 0
</syntaxhighlight>

===快速排序===
OCaml自身可提供对递归算法的简介表达。下列代码例子实现了类似于以升序排序一个列表的[[quicksort|quicksort]]的一个算法：
<syntaxhighlight lang="OCaml">
 let rec qsort = function
   | [] -> []
   | pivot :: rest ->
     let is_less x = x < pivot in
     let left, right = List.partition is_less rest in
     qsort left @ [pivot] @ qsort right;;
</syntaxhighlight>

===高阶函数===
函数可以接受函数作为参数并且返回函数作为结果。例如，应用<code>twice</code>到函数<code>f</code>产生应用<code>f</code>到它的实际参数两次的一个函数：
<syntaxhighlight lang = OCaml>
let twice (f : 'a -> 'a) = fun (x : 'a) -> f (f x);;
let inc (x : int) : int = x + 1;;
let add2 = twice inc;;
let inc_str (x : string) : string = x ^ " " ^ x;;
let add_str = twice(inc_str);;
</syntaxhighlight>
<syntaxhighlight lang = OCaml highlight="2,4">
# add2 98;;
- : int = 100
# add_str "Test";;
- : string = "Test Test Test Test"
</syntaxhighlight>
函数<code>twice</code>使用类型变量<code>'a</code>，来指示它可以应用于映射一个类型<code>'a</code>到自身的任何<code>f</code>，而非只应用于<code>int->int</code>函数。特别是，<code>twice</code>甚至可以应用于自身：
<syntaxhighlight lang = OCaml highlight="2,4,6">
# let fourtimes f = (twice twice) f;;
val fourtimes : ('a -> 'a) -> 'a -> 'a = <fun>
# let add4 = fourtimes inc;;
val add4 : int -> int = <fun>
# add4 98;;
- : int = 102
</syntaxhighlight>

===邱奇数===
下列代码定义[[自然数|自然数]]的[[邱奇数|邱奇编码]]，具有后继（succ）和加法（add）。邱奇数<code>n</code>是接受一个函数<code>f</code>和一个值<code>x</code>的一个[[高阶函数|高阶函数]]，它应用<code>f</code>到<code>x</code>精确的<code>n</code>次：
<syntaxhighlight lang="OCaml">
let zero f x = x
let succ n f x = f (n f x)
let one = succ zero
let two = succ (succ zero)
let add n1 n2 f x = n1 f (n2 f x)
let to_string n = n (fun k -> "S" ^ k) "0";;
</syntaxhighlight>
为了将一个邱奇数从函数值转换成一个字符串，这里把它传递给向其输入和常量字符串<code>"0"</code>前置上字符串<code>"S"</code>的函数<code>to_string</code>：
<syntaxhighlight lang = OCaml highlight="2">
# let _ = to_string (add (succ two) two);;
- : string = "SSSSS0"
</syntaxhighlight>

===对象例子===
在OCaml中[[对象_(计算机科学)|对象]]，通过它们的[[方法_(计算机科学)|方法]]的名字和类型，按结构来确定类型。对象可以直接创建（立即对象），而不用通过有名称的类。例如：
<syntaxhighlight lang="ocaml" highlight="7">
# let x =
    object
      val mutable x = 5
      method get_x = x
      method set_x y = x <- y
    end;;
val x : < get_x : int; set_x : int -> unit > = <obj>
</syntaxhighlight>

这里OCaml交互式运行时间系统打印出这个对象的推论类型。它的类型<code>< get_x : int; set_x : int -> unit ></code>，只由它的方法来定义。换句话说，<code>x</code>的类型由方法类型<code>get_x : int</code>和<code>set_x : int -> unit</code>而非任何名字来定义<ref>{{cite web|title=Object types|url=https://ocaml.org/manual/types.html|access-date=2021-09-10|archive-date=2022-03-10|archive-url=https://web.archive.org/web/20220310050115/https://ocaml.org/manual/types.html}}</ref>。[[类_(计算机科学)|类]]只充当建立对象的函数，例如上例中的对象可以用类来定义，并接着用<code>new</code>算符来建立：
<syntaxhighlight lang="ocaml">
# class simple_cls =
    object (self)
      val mutable x = 5
      method get_x = x
      method set_x y = x <- y
    end;;
  let x = new simple_cls;;
</syntaxhighlight>
要定义有相同的方法和方法类型的另一个对象：
<syntaxhighlight lang="ocaml" highlight="6">
# let y =
    object
      method get_x = 2
      method set_x y = Printf.printf "%d\n" y
    end;;
val y : < get_x : int; set_x : int -> unit > = <obj>
</syntaxhighlight>
OCaml将它们视为有相同的类型。例如，等式算符被确定类型为只接受有相同类型的两个值：
<syntaxhighlight lang="ocaml" highlight="2">
# x = y;;
- : bool = false
</syntaxhighlight>
所有尽管它们有不同的值，却必定是相同类型的，否则连类型检查都不会做完。这展示了类型等价是结构性的。可以定义调用一个方法的函数：
<syntaxhighlight lang="ocaml"  highlight="2">
# let set_to_10 a = a#set_x 10;;
val set_to_10 : < set_x : int -> 'a; .. > -> 'a = <fun>
</syntaxhighlight>
第一个实际参数的推论类型<code>< set_x : int -> 'a; .. ></code>是值得关注的。<code>..</code>意味着第一个实际参数，可以是有接受一个<code>int</code>作为实际参数的<code>set_x</code>方法的任何对象。所以它可以用在对象<code>x</code>之上：
<syntaxhighlight lang="ocaml" highlight="2">
# set_to_10 x;;
- : unit = ()
</syntaxhighlight>

另一个对象可以碰巧有这个方法和方法类型；其他方法是无关紧要的：
<syntaxhighlight lang="ocaml"  highlight="6">
# let z =
    object
      method blahblah = 2.5
      method set_x y = Printf.printf "%d\n" y
    end;;
val z : < blahblah : float; set_x : int -> unit > = <obj>
</syntaxhighlight>

<code>set_to_10</code>函数对它也有效：
<syntaxhighlight lang="ocaml"  highlight="2,3">
# set_to_10 z;;
10
- : unit = ()
</syntaxhighlight>
这展示了对于事物比如方法调用的兼容性是由结构来确定的。下面为只有一个<code>get_x</code>方法而没有其他方法的对象定义一个类型同义词（synonym）：
<syntaxhighlight lang="ocaml" highlight="2">
# type simpler_obj = < get_x : int >;;
type simpler_obj = < get_x : int >
</syntaxhighlight>

对象<code>x</code>不是这个类型的；但在结构上<code>x</code>是这个类型的一个子类型，因为<code>x</code>包含它的方法的一个超集。所以<code>x</code>可以[[类型转换|强制]]（coerce）成这个类型：
<syntaxhighlight lang="ocaml" highlight="2,4">
# (x :> simpler_obj);;
- : simpler_obj = <obj>
# (x :> simpler_obj)#get_x;;
- : int = 10
</syntaxhighlight>
但是对象<code>z</code>不行，因为它不是一个结构子类型：
<syntaxhighlight lang="console" highlight="2-4">
# (z :> simpler_obj);;
Error: Type < blahblah : float; set_x : int -> unit > is not a subtype of
         simpler_obj = < get_x : int > 
       The first object type has no method get_x
</syntaxhighlight>
这展示了拓宽强制的兼容性是结构性的。

===任意精度阶乘函数===
可以从OCaml访问各种各样的库。比如，OCaml有内建的[[高精度计算|任意精度算术]]。由于阶乘函数增长得非常迅速，会很快溢出机器精度的整数。因此阶乘很适合选用任意精度算术。

在OCaml中，<code>Num</code>模块（现在被<code>ZArith</code>所取代）提供了任意精度算术，比如在[[Ubuntu|Ubuntu]]中安装它：<code>sudo apt install libnum-ocaml-dev</code>，它可以如下这样装载到运行中的顶层中：
<syntaxhighlight lang=ocaml>
#use "topfind";;
#require "num";;
open Num;;
</syntaxhighlight>

阶乘函数可以使用任意精度算符<code>{{=}}/</code>、<code>*/</code>和<code>-/</code>写为：
<syntaxhighlight lang="OCaml">
let rec fact n =
  if n =/ Int 0 then Int 1 else n */ fact(n -/ Int 1);;
</syntaxhighlight>

这个函数可以计算非常大的阶乘比如<code>120!</code>：
<syntaxhighlight lang="OCaml"  highlight="2,3">
# string_of_num (fact (Int 120));;
- : string =
"6689502913449127057588118054090372586752746333138029810295671352301633557244962989366874165271984981308157637893214090552534408589408121859898481114389650005964960521256960000000000000000000000000000"
</syntaxhighlight>

===绘制图形例子===
下列程序<code>simple.ml</code>使用[[OpenGL|OpenGL]]呈现一个缓慢旋转的2D三角形:
<syntaxhighlight lang="OCaml">
let () =
  ignore (Glut.init Sys.argv);
  Glut.initDisplayMode ~double_buffer:true ();
  ignore (Glut.createWindow ~title:"OpenGL Demo");
  let angle t = 10. *. t *. t in
  let render () =
    GlClear.clear [ `color ];
    GlMat.load_identity ();
    GlMat.rotate ~angle: (angle (Sys.time ())) ~z:1. ();
    GlDraw.begins `triangles;
    List.iter GlDraw.vertex2 [-1., -1.; 0., 1.; 1., -1.];
    GlDraw.ends ();
    Glut.swapBuffers () in
  GlMat.mode `modelview;
  Glut.displayFunc ~cb:render;
  Glut.idleFunc ~cb:(Some Glut.postRedisplay);
  Glut.mainLoop ()
</syntaxhighlight>

需要事先安装负责绑定到OpenGL的LablGL，比如在[[Ubuntu|Ubuntu]]中安装它：<code>sudo apt install liblablgl-ocaml-dev</code>，这个程序可以如下这样编译成字节码：
<syntaxhighlight lang="console">
$ ocamlc -I +lablGL lablglut.cma lablgl.cma simple.ml -o simple
</syntaxhighlight>
或编译成本机代码：
<syntaxhighlight lang="console">
$ ocamlopt -I +lablGL lablglut.cmxa lablgl.cmxa simple.ml -o simple
</syntaxhighlight>
或者简单的使用<code>ocamlfind</code>建造命令：
<syntaxhighlight lang="console">
$ ocamlfind opt simple.ml -package lablgl.glut -linkpkg -o simple
</syntaxhighlight>
然后运行：
<syntaxhighlight lang="console">
$ ./simple
</syntaxhighlight>
可以使用OCaml开发非常复杂、高性能的2D和3D图形程序。使用OpenGL和OCaml，结果的程序可以跨平台编译而在主要平台上无需改动。

== 用OCaml写成的程序 ==
{{Div col|2}}
* [[Coq|Coq]]，一个形式证明辅助器<ref>[http://coq.inria.fr Coq]{{Wayback|url=http://coq.inria.fr/ |date=20040825085246 }}</ref>。
* {{en-link|HOL Light}}，一个形式证明辅助器。
* {{en-link|Coccinelle|Coccinelle (software)|Coccinelle}}，用于[[C语言|C]]程序源代码{{en-link|程序变换|program transformation|变换}}的实用工具。
* {{en-link|Frama-C}}，分析C程序的一个框架。
* Flow，[[Facebook|Facebook]]创建的用于推论和检查[[JavaScript|JavaScript]]的[[静态类型|静态类型]]的一个[[静态程序分析|静态分析器]]<ref>{{cite web|url=https://flow.org/en/|title=Flow: A Static Type Checker for JavaScript|access-date=2021-08-29|archive-date=2022-04-08|archive-url=https://web.archive.org/web/20220408204727/https://flow.org/en/}}</ref>。
* Infer，[[Facebook|Facebook]]创建的用于[[Java|Java]]、C、[[C++|C++]]和[[Objective-C|Objective-C]]的[[静态程序分析|静态分析器]]，用来检测[[iOS|iOS]]和[[Android|Android]]应用中的缺陷<ref>{{cite web|url=https://fbinfer.com/|title=Infer static analyzer|access-date=2021-08-29|archive-date=2022-05-12|archive-url=https://web.archive.org/web/20220512061858/https://fbinfer.com/}}</ref>。
* pyre-check，[[Facebook|Facebook]]创建的用于[[Python|Python]]的类型检查器<ref>{{cite web|url=https://github.com/facebook/pyre-check|title=GitHub - facebook/pyre-check: Performant type-checking for python.|date=9 February 2019|via=GitHub|access-date=2021-08-29|archive-date=2022-05-05|archive-url=https://web.archive.org/web/20220505121154/https://github.com/facebook/pyre-check}}</ref>。
* [[Hack_(程式語言)|Hack]]编程语言编译器，[[Facebook|Facebook]]创建，扩展[[PHP|PHP]]具有静态类型。
* [[Haxe|Haxe]]编程语言编译器。
* [[WebAssembly|WebAssembly]]参考解释器，它是意图在[[web浏览器|web浏览器]]内执行的低层[[字节码|字节码]]<ref>{{cite web|url=https://github.com/WebAssembly/spec|title=WebAssembly/spec: WebAssembly specification, reference interpreter, and test suite.|date=5 December 2019|publisher=[[World_Wide_Web_Consortium|World Wide Web Consortium]]|access-date=2021-05-14|via=GitHub|archive-date=2022-05-12|archive-url=https://web.archive.org/web/20220512050549/https://github.com/WebAssembly/spec}}</ref>。
* {{en-link|FFTW}}，[[C语言|C]]的[[快速傅立叶变换|FFT]]库，它的多数性能关键代码是由用OCaml写的一个程序生成的<ref>[http://www.fftw.org FFTW]{{Wayback|url=http://www.fftw.org/ |date=20190925140738 }}</ref>。
* {{en-link|Owl科学计算|Owl Scientific Computing}}，用于科学和工程计算的专用系统。
* MirageOS，用纯OCaml写的一个[[单一内核|单一内核]]编程框架<ref>{{Cite web |url=https://mirage.io/ |title=MirageOS |access-date=2021-08-29 |archive-date=2022-04-20 |archive-url=https://web.archive.org/web/20220420230221/https://mirage.io/ }}</ref>。
* {{en-link|Ocsigen}}，一个OCaml的[[web应用框架|web应用框架]]。
* {{en-link|Opa (编程语言)|Opa (programming language)|Opa}}，用于Web开发的自由和开源的一个编程语言。
* {{en-link|Zero Install|Zero Install|0install}}，一个多平台包管理器。
* [[MLDonkey|MLDonkey]]，一个多网络[[点对点|P2P]]程序。
* {{en-link|Unison (软件)|Unison (software)|Unison}}，一个文件同步器<ref>{{Cite web |url=https://github.com/bcpierce00/unison |title=Unison |access-date=2021-08-28 |archive-date=2021-07-12 |archive-url=https://web.archive.org/web/20210712165632/https://github.com/bcpierce00/unison }}</ref>。
{{div col end}}

== 参见 ==
* [[Caml|Caml]]，OCaml的先驱语言。
* [[F♯|F#]]，由[[微软研究院|MSR]]开发，是一个基于OCaml的一个以[[.NET_Framework|.NET]]为目标的编程语言。
* [[F*|F*]]，由[[微软研究院|MSR]]和[[法国国家信息与自动化研究所|INRIA]]主导开发，是一个基于OCaml的[[依赖类型|依赖类型]][[函数式编程|函数式]][[程序语言|程序语言]]。
* [[Reason_(编程语言)|Reason]]，OCaml的语法扩展和工具链，也可以转译成[[JavaScript|JavaScript]]。

== 有关书籍 ==
* {{cite web|title=Real World OCaml, Functional programming for the masses, 2nd Edition|year=2021|author=Yaron Minsky, Anil Madhavapeddy|url=https://dev.realworldocaml.org/|access-date=2021-09-10|archive-date=2022-05-14|archive-url=https://web.archive.org/web/20220514090626/https://dev.realworldocaml.org/}}
* {{cite web|title=Developing Applications With Objective Caml|url=https://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf|author=Emmanuel Chailloux, Pascal Manoury, Bruno Pagano|year=2000|access-date=2021-09-10|archive-date=2022-02-23|archive-url=https://web.archive.org/web/20220223135753/https://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf}}
* {{cite web|title=Introduction to the Objective Caml Programming Language|url=https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.132.9566&rep=rep1&type=pdf|author=Jason Hickey|year=2002|access-date=2021-09-10|archive-date=2021-09-10|archive-url=https://web.archive.org/web/20210910112045/https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.132.9566&rep=rep1&type=pdf}}

==引用==
{{reflist|2}}

== 外部链接 ==
{{wikibooks|en:OCaml|OCaml}}
* {{Official website}}
* [https://ocaml.org/manual/ OCaml manual] {{Wayback|url=https://ocaml.org/manual/ |date=20220404034329 }}
* [https://opam.ocaml.org/ OCaml Package Manager] {{Wayback|url=https://opam.ocaml.org/ |date=20220512061740 }}
* [https://github.com/ocaml-community/awesome-ocaml Awesome OCaml] {{Wayback|url=https://github.com/ocaml-community/awesome-ocaml |date=20220418072759 }}

{{程序设计语言|Logo}}

[[Category:函数式编程语言|Category:函数式编程语言]]
[[Category:ML語言家族|Category:ML語言家族]]
[[Category:面向对象的编程语言|Category:面向对象的编程语言]]
[[Category:静态类型编程语言|Category:静态类型编程语言]]
[[Category:模式匹配编程语言|Category:模式匹配编程语言]]
[[Category:1996年建立的程式語言|Category:1996年建立的程式語言]]
[[Category:带有代码示例的条目|Category:带有代码示例的条目]]