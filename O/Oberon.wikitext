{{Otheruses|other=歐洲民間傳說的妖精王|奧伯隆}}
{{Use dmy dates|date=January 2021}}
{{Infobox programming language
| name = Oberon
| logo = Oberon programming language logo.svg
| logo size = 160px
| paradigms = [[指令式编程|指令式]], [[结构化编程|结构化]], [[模块化编程|模块化]], [[面向对象编程|面向对象]]
| family = [[Niklaus_Wirth|Wirth]] Oberon
| designer = [[Niklaus_Wirth|Niklaus Wirth]]
| developer = [[苏黎世联邦理工学院|苏黎世联邦理工学院]]
| released = {{Start date and age|1987}}
| latest release version = Oberon-07
| latest release date = {{Start date and age|2020|03|06|df=yes}}
| typing = [[类型系统|强类型]], 混合（[[静态类型|静态]]和[[动态类型|动态]]）
| scope = [[作用域|词法]]
| programming language = 
| platform = [[ARM架构|ARM]], [[StrongARM|StrongARM]]; [[IA-32|IA-32]], [[x86-64|x86-64]]; [[SPARC|SPARC]], {{en-link|Ceres (工作站)|Ceres (workstation)|Ceres}} ({{en-link|NS32000|NS32000|NS32032}})
| operating system = [[Microsoft_Windows|Windows]], [[Linux|Linux]], [[Solaris|Solaris]], [[classic_Mac_OS|classic Mac OS]], [[Atari_TOS|Atari TOS]], [[AmigaOS|AmigaOS]]
| license = 
| file ext = 
| file format = <!-- or: | file formats = -->
| website = {{URL|www.projectoberon.com}}
| implementations = 
| dialects = 
| influenced by = [[Modula-2|Modula-2]]
| influenced = [[Modula-3|Modula-3]], {{en-link|Oberon-2}}, {{en-link|Component Pascal}}, {{en-link|Active Oberon}}, Oberon-07, [[Nim|Nim]], [[Go|Go]], {{en-link|Zonnon}}
}}

'''Oberon'''是一种通用[[编程语言|编程语言]]，最初由[[尼克劳斯·维尔特|尼克劳斯·维尔特]]在1987年推出，是维尔特风格的类[[ALGOL|ALGOL]]语言中的最后一员（继{{en-link|Euler (编程语言)|Euler (programming language)|Euler}}、[[ALGOL_W|ALGOL W]]、[[Pascal语言|Pascal]]、[[Modula|Modula]]和[[Modula-2|Modula-2]]之后）<ref name=ETH>{{Cite report |last=Wirth |first=Niklaus |title=From Modula to Oberon and the programming language Oberon |series=ETH Technical Reports D-INFK |volume=Band 82 |publisher=Wiley |url=https://doi.org/10.3929/ethz-a-005363226 |date= |access-date=2021-06-18 |archive-date=2021-12-17 |archive-url=https://web.archive.org/web/20211217025831/https://www.research-collection.ethz.ch/handle/20.500.11850/68917 }}</ref><ref name=PLO>{{Cite journal |last=Wirth |first=Niklaus |date=July 1988 |title=The Programming Language Oberon |url=https://archive.org/details/sim_software-practice-experience_1988-07_18_7/page/661 |journal=Software: Practice and Experience |volume=18 |issue=7 |pages=661–670}}</ref><ref name=M2O>{{Cite journal |last=Wirth |first=Niklaus |date=July 1988 |title=From Modula to Oberon |journal=Software: Practice and Experience |volume=18 |issue=7 |pages=671–690}}</ref><ref name=TE>{{Cite journal |last=Wirth |first=Niklaus |date=April 1988 |title=Type Extensions |journal=ACM Transactions on Programming Languages |volume=10 |issue=2 |pages=204–214}}</ref>。Oberon是增进[[Pascal语言|Pascal]]的直接后继者[[Modula-2|Modula-2]]的能力，并减少其复杂度的集中努力的结果。它的原理性新特征是记录类型的类型扩展的概念<ref>{{Cite magazine |last=Pountain |first=D. March 1991 |title=Modula's Children, Part II: Oberon |url=https://archive.org/stream/byte-magazine-1991-03/1991_03_BYTE_16-03_Network_Management#page/n187/ |magazine={{en-link|Byte (杂志)|Byte (magazine)|Byte}} |volume=16 |issue=3 |pages=135–142}}</ref>。它允许新数据类型构造在现存数据类型之上并关联于它们，脱离了严格的[[静态类型|静态类型]]数据的教条。Oberon是在[[瑞士|瑞士]]的[[苏黎世联邦理工学院|苏黎世联邦理工学院]]作为{{en-link|Oberon (操作系统)|Oberon (operating system)|Oberon操作系统}}实现的一部份而开发的。这个名字来自[[天王星|天王星]]的卫星[[天卫四|奧伯隆]]。

Oberon的当前版本是2007年修订的Oberon-07，它仍由维尔特来维护而Oberon计划编译器仍在随时更新<ref>{{cite web |last=Wirth |first=Niklaus |title=Oberon Change Log |url=https://www.inf.ethz.ch/personal/wirth/news.txt |publisher=ETH Zurich |access-date=16 January 2021 |archive-date=2019-04-07 |archive-url=https://web.archive.org/web/20190407152152/https://inf.ethz.ch/personal/wirth/news.txt }}</ref>。

==设计==
Oberon的基本指导原则是集中于基础和根本的特征，并忽略短暂性的问题。另一个因素是认识到了在语言如[[C++|C++]]和[[Ada|Ada]]中复杂度的增长。与它们相反，Oberon强调使用[[函数库|库]]概念来扩展语言。在Modula-2中提供的枚举和子范围类型被省略了；类似的集合类型被限制为小的整数集合，而低层设施的数量被大幅度缩减（特别是省略了类型转移函数）。省略余下的潜在不安全设施，是得到真正的高级语言的最根本步骤。甚至跨越模块的非常紧密的[[类型检查|类型检查]]，严格的[[执行期|运行时间]][[边界检查|索引检查]]，[[空指针|空指针]]检查，和安全的类型扩展概念，在很大程度上允许编程单独的依仗于语言规则。

这种策略的意图是产生易于学习、实现更简单和高效的语言。Oberon编译器被认为是简明和快速的，却提供了可比拟于商业编译器的代码质量<ref>{{cite web |last=Mössenböck |first=Hanspeter |title=Compiler Construction: The Art of Niklaus Wirth |url=ftp://ftp.ssw.uni-linz.ac.at/pub/Papers/Moe00b.pdf |publisher=Johannes Kepler University}}</ref>。

==特征==
[[File:ETHOberon.png|right]]
刻画Oberon语言的特征包括<ref>{{Cite web |author1=[[Niklaus_Wirth|Niklaus Wirth]] |author2={{en-link|Jürg Gutknecht}} |date=1987–2021 |url=http://www.projectoberon.com/ |title=Project Oberon |access-date=2021-06-18 |archive-date=2021-07-19 |archive-url=https://web.archive.org/web/20210719214651/http://www.projectoberon.com/ }}</ref>：
* 具有大写关键字的大小写敏感语法。
* 具有类型测试的类型扩展。
* 模块和分离编译。
* 字符串操作。
* 孤立不安全代码。
* 支持系统编程。

==面向对象示例==
Oberon支持对记录类型的扩展，用于抽象和异构结构的构造。不同于后期方言即1991年提出的{{en-link|Oberon-2}}和1998年提出的{{en-link|Active Oberon}}，最初的Oberon缺乏作为语言特征的分派机制，而是把它作为一种编程技术或设计模式。这给出了在OOP上的巨大灵活性。在{{en-link|Oberon (操作系统)|Oberon (operating system)|Oberon操作系统}}中，两种技术被一起用于分派调用：方法套件和消息处理器。

===方法套件===
在这种技术中，泛化模块定义[[子程序|过程]][[变量_(计算机科学)|变量]]的一个表格类型，而扩展模块中声明这个类型的一个共享变量，泛化模块中的方法要访问这个表格的对应项目，而扩展模块将这个表格的项目指派到自己相应的过程：
<syntaxhighlight lang="modula2">
MODULE Figures; (* 抽象模块 *)
  TYPE
    Figure* = POINTER TO FigureDesc;
    Interface* = POINTER TO InterfaceDesc;
 
    InterfaceDesc* = RECORD
      draw* : PROCEDURE (f : Figure);
      clear* : PROCEDURE (f : Figure);
      mark* : PROCEDURE (f : Figure);
      move* : PROCEDURE (f : Figure; dx, dy : INTEGER);
    END;
 
    FigureDesc* = RECORD
      if : Interface;
    END;
 
  PROCEDURE Init* (f : Figure; if : Interface);
  BEGIN
    f.if := if;
  END Init;
 
  PROCEDURE Draw* (f : Figure);
  BEGIN
    f.if.draw(f);
  END Draw;
 
(* 这里是其他过程Clear、Mark和Move *)
 
END Figures.
</syntaxhighlight>
扩展泛化类型<code>Figure</code>为特定形状<code>Rectangles</code>：
<syntaxhighlight lang="modula2">
MODULE Rectangles;
 
  IMPORT Figures;
 
  TYPE
    Rectangle* = POINTER TO RectangleDesc;
 
    RectangleDesc* = RECORD
      (Figures.FigureDesc)
      x, y, w, h : INTEGER;
    END;
 
VAR
  if : Figures.Interface;
 
  PROCEDURE New* (VAR r : Rectangle);
  BEGIN
    NEW(r);
    Figures.Init(r, if);
  END New;
 
  PROCEDURE Draw* (f : Figure);
  VAR
    r : Rectangle;
  BEGIN
    r := f(Rectangle); (* f具有Rectangle类型 *)
    (* ... *)
  END Draw;
 
(* 这里是其他过程Clear、Mark和Move *)
 
BEGIN (* 模块初始化 *)
  NEW(if);
  if.draw := Draw;
  if.clear := Clear;
  if.mark := Mark;
  if.move := Move;
END Rectangles.
</syntaxhighlight>
[[动态分派|动态分派]]只能通过泛化模块的<code>Figures</code>中的方法集合完成，比如这里的<code>Draw</code>、<code>Clear</code>、<code>Mark</code>和<code>Move</code>过程，它们通过接口表格调用了扩展模块<code>Rectangles</code>中的同名过程。

===消息处理器===
这种技术形成于，在泛化模块中定义一个单一的处理器过程类型，并在扩展模块中声明这个类型的一个过程，用它处理对应各种方法并包含了相应的实际参数的消息记录：
<syntaxhighlight lang="modula2">
MODULE Figures; (* 抽象模块 *)
 
  TYPE
    Figure* = POINTER TO FigureDesc;
 
    Message* = RECORD END;
    DrawMsg* = RECORD (Message) END;
    ClearMsg* = RECORD (Message) END;
    MarkMsg* = RECORD (Message) END;
    MoveMsg* = RECORD (Message) dx*, dy* : INTEGER END;
 
    Handler* = PROCEDURE (f : Figure; VAR msg : Message);
 
    FigureDesc* = RECORD
      (* 抽象 *)
      handle : Handler;
    END;
 
  PROCEDURE Handle* (f : Figure; VAR msg : Message);
  BEGIN
    f.handle(f, msg);
  END Handle;
 
  PROCEDURE Init* (f : Figure; handle : Handler);
  BEGIN
    f.handle := handle;
  END Init;
 
END Figures.
</syntaxhighlight>
扩展泛化类型<code>Figure</code>为特定形状<code>Rectangles</code>：
<syntaxhighlight lang="modula2">
MODULE Rectangles;
 
  IMPORT Figures;
 
  TYPE
    Rectangle* = POINTER TO RectangleDesc;
 
    RectangleDesc* = RECORD (Figures.FigureDesc)
      x, y, w, h : INTEGER;
    END;
 
  PROCEDURE Draw* (r : Rectangle);
  BEGIN
    (* ... *)
  END Draw;
 
  (* 这里是其他过程Clear、Mark和Move *)
 
  PROCEDURE Handle* (f: Figure; VAR msg: Figures.Message);
  VAR
    r : Rectangle;
  BEGIN
    r := f(Rectangle);
    IF msg IS Figures.DrawMsg THEN Draw(r)
    ELSIF msg IS Figures.MarkMsg THEN Mark(r)
    ELSIF msg IS Figures.MoveMsg THEN 
      Move(r, msg(Figures.MoveMsg).dx, msg(Figures.MoveMsg).dy)
    ELSE (* 忽略 *)
    END
  END Handle;
 
  PROCEDURE New* (VAR r : Rectangle);
  BEGIN
    NEW(r);
    Figures.Init(r, Handle);
  END New;
 
END Rectangles.
</syntaxhighlight>
在Oberon操作系统中，这两种技术都用于动态分派。前者用于已知的方法集合；后者用于在扩展模块中声明的任何新方法。例如，如果扩展模块<code>Rectangles</code>要实现一个新的<code>Rotate()</code>过程，在扩展模块之外只能通过它的消息处理器过程来调用。

==参见==
* {{en-link|Oberon (操作系统)|Oberon (operating system)}}

==引用==
{{Reflist|2}}

==外部资源链接==
===一般性===
{{div col|2}}
* [https://web.archive.org/web/20191219125640/http://www.ethoberon.ethz.ch/ Official website (latest available copy at archive org)] at ETH-Zürich
* [http://people.inf.ethz.ch/wirth/Oberon/ Niklaus Wirth's Oberon Page] {{Wayback|url=http://people.inf.ethz.ch/wirth/Oberon/ |date=20210613111906 }} at ETH-Zürich
* [http://www.ssw.uni-linz.ac.at/Research/Projects/Oberon.html Oberon Page] {{Wayback|url=http://www.ssw.uni-linz.ac.at/Research/Projects/Oberon.html |date=20200202121719 }} at SSW, Linz
* [http://www.mathematik.uni-ulm.de/oberon/reports/ Oberon: The Programming Language] {{Wayback|url=http://www.mathematik.uni-ulm.de/oberon/reports/ |date=20201104204152 }} at Ulm
* [http://people.inf.ethz.ch/wirth/ProjectOberon1992.pdf Project Oberon, The Design of an Operating System and a Compiler] {{Wayback|url=http://people.inf.ethz.ch/wirth/ProjectOberon1992.pdf |date=20210708170913 }}, book in PDF by Niklaus Wirth and Jürg Gutknecht, 2005 Edition
* [https://web.archive.org/web/20130529020132/http://www.ethoberon.ethz.ch/genealogy.html Oberon Language Genealogy]
* [http://www.astrobe.com Astrobe] {{Wayback|url=http://www.astrobe.com/ |date=20210716123433 }} ARM Oberon-07 Development System
* [http://modulaware.com/mwovms.htm Oberon System V4 for HP OpenVMS Alpha] with source code upward-compatible 64 bit addressing
* [http://modulaware.com/mwcvms.htm 64 bit Oberon-2 compiler] for HP OpenVMS Alpha
* [http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler Oxford Oberon-2 Compiler] {{Wayback|url=http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler |date=20070705213044 }} and its [http://bitbucket.org/Spivey/obc-3/downloads/obcman.pdf User Manual]{{Dead link}}
* [https://github.com/rochus-keller/Oberon Free Oberon-07 IDE] {{Wayback|url=https://github.com/rochus-keller/Oberon |date=20210724030721 }} Free Oberon-07 IDE for Windows, Macintosh, and Linux with syntax colouring, semantic navigation and source code debugger
* [https://www.drdobbs.com/architecture-and-design/the-oberon-programming-language/184409405 Oberon article by Joseph Templ] {{Wayback|url=https://www.drdobbs.com/architecture-and-design/the-oberon-programming-language/184409405 |date=20210121211627 }} in the January 1994 issue of Dr.Dobbs
{{div col end}}
===Oberon的演化===
{{div col|2}}
* [http://people.inf.ethz.ch/wirth/Articles/Modula-Oberon-June.pdf Modula-2 and Oberon] {{Wayback|url=http://people.inf.ethz.ch/wirth/Articles/Modula-Oberon-June.pdf |date=20210716132245 }} Wirth (2005)
* [http://people.inf.ethz.ch/wirth/Oberon/Oberon.Report.pdf The Programming Language Oberon] {{Wayback|url=http://people.inf.ethz.ch/wirth/Oberon/Oberon.Report.pdf |date=20210324033840 }} Wirth, (1988/90)
* [http://people.inf.ethz.ch/wirth/Oberon/Oberon07.Report.pdf The Programming Language Oberon (Oberon-7, Revised Oberon)] {{Wayback|url=http://people.inf.ethz.ch/wirth/Oberon/Oberon07.Report.pdf |date=20210720152716 }} Wirth, (2016, most current language report)
* [http://people.inf.ethz.ch/wirth/Oberon/Oberon07.pdf Differences between Oberon-07 and Oberon] {{Wayback|url=http://people.inf.ethz.ch/wirth/Oberon/Oberon07.pdf |date=20210121231504 }} Wirth (2011)
* [ftp://ftp.ethoberon.ethz.ch/Oberon/OberonV4/Docu/Oberon2.Report.ps The Programming Language Oberon-2]{{Dead link}} H. Mössenböck, N. Wirth, Institut für Computersysteme, ETH Zürich, January 1992
* [ftp://ftp.ethoberon.ethz.ch/Oberon/OberonV4/Docu/Oberon2.Differences.ps Differences between Oberon and Oberon-2]{{Dead link}} Mössenböck and Wirth (1991)
* [https://web.archive.org/web/20110515111149/http://www.oberon.ch/pdf/CP-New.pdf What's New in Component Pascal] (Changes from Oberon-2 to CP), Pfister (2001)
{{div col end}}

{{程序设计语言}}
{{Authority control}}
[[Category:过程式编程语言|Category:过程式编程语言]]
[[Category:系統程式語言|Category:系統程式語言]]
[[Category:基于类的编程语言|Category:基于类的编程语言]]
[[Category:Modula程式語言家族|Category:Modula程式語言家族]]
[[Category:1986年建立的程式語言|Category:1986年建立的程式語言]]