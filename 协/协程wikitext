{{NoteTA
|G1 = IT
|1 = zh-cn:协程; zh-tw:共常式
}}
'''协程'''（{{Lang-en|coroutine}}）是计算机程序的一类组件，推广了[[协作式多任务|协作式多任务]]的[[子例程|子例程]]，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程更适合于用来实现彼此熟悉的程序组件，如[[协作式多任务|协作式多任务]]、[[异常处理|异常处理]]、[[事件循环|事件循环]]、[[迭代器|迭代器]]、[[惰性求值|无限列表]]和[[管道_(软件)|管道]]。

根据[[高德纳|高德纳]]的说法，[[马尔文·康威|马尔文·康威]]于1958年发明了术语“coroutine”并用于构建[[汇编语言|汇编程序]]<ref name="KnuthVol1_1_4_5">{{Cite book | first = Donald Ervin | last = Knuth | series = The Art of Computer Programming | volume = 1 | title = Fundamental Algorithms | edition = 3rd | publisher = Addison-Wesley | year = 1997 | isbn = 978-0-201-89683-1 | at = Section 1.4.5: History and Bibliography, pp. 229 | url = https://seriouscomputerist.atariverse.com/media/pdf/book/Art%20of%20Computer%20Programming%20-%20Volume%201%20(Fundamental%20Algorithms).pdf | archive-url = https://web.archive.org/web/20191021162138/https://seriouscomputerist.atariverse.com/media/pdf/book/Art%20of%20Computer%20Programming%20-%20Volume%201%20(Fundamental%20Algorithms).pdf | archive-date = 2019-10-21 | access-date = 2019-11-23 | dead-url = no }}</ref> <!--pages = 229-->，关于协程的最初解说在1963年发表<ref name="Conway1963">{{Cite journal|last=Conway|first=Melvin E.|author-link=Melvin Conway|date=July 1963|title=Design of a Separable Transition-diagram Compiler|url=http://melconway.com/Home/pdf/compiler.pdf|journal=[[Communications_of_the_ACM|Communications of the ACM]]|publisher=ACM|volume=6|issue=7|pages=396–408|doi=10.1145/366663.366704|issn=0001-0782|via=ACM Digital Library|access-date=2019-11-23|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406043438/http://melconway.com/Home/pdf/compiler.pdf}}</ref>。

==同子例程的比较==
协程可以通过<code>yield</code>（取其“让步”之义而非“出产”）来调用其它协程，接下来的每次协程被调用时，从协程上次<code>yield</code>返回的位置接着执行，通过<code>yield</code>方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。由于协程不如子例程那样被普遍所知，下面对它们作简要比较：
*子例程可以调用其他子例程，调用者等待被调用者结束后继续执行，故而子例程的生命期遵循后进先出，即最后一个被调用的子例程最先结束返回。协程的生命期完全由对它们的使用需要来决定。
*子例程的起始处是惟一的入口点，每当子例程被调用时，执行都从被调用子例程的起始处开始。协程可以有多个入口点，协程的起始处是第一个入口点，每个<code>yield</code>返回出口点都是再次被调用执行时的入口点。
*子例程只在结束时一次性的返回全部结果值。协程可以在<code>yield</code>时不调用其他协程，而是每次返回一部份的结果值，这种协程常称为[[生成器_(计算机编程)|生成器]]或[[迭代器|迭代器]]。
*现代的[[指令集架构|指令集架构]]通常提供对[[调用栈|调用栈]]的指令支持，便于实现可[[递归|递归]]调用的子例程。在以[[Scheme|Scheme]]为代表的提供[[计算续体|续体]]的语言环境下<ref>{{cite web|title =call-with-current-continuation for C programmers|url =http://community.schemewiki.org/?call-with-current-continuation-for-C-programmers|website =http://community.schemewiki.org/|quote =If you're a C programmer then you've probably read the various introductions and tutorials on call-with-current-continuation (call/cc) and come out not much wiser about what it all really means. Here's the secret: it's setjmp/longjmp. But on no account say that to any Scheme programmers you know, it'll send them into paroxysms of rage as they tell you you don't know what you're talking about.|accessdate =2019-11-27|archive-date =2008-12-16|archive-url =https://web.archive.org/web/20081216073850/http://community.schemewiki.org/?call-with-current-continuation-for-C-programmers|dead-url =yes}}</ref>，恰好可用此[[控制流|控制状态]][[抽象化_(計算機科學)|抽象表示]]来实现协程。
子例程可以看作是特定状况的协程<ref name="KnuthVol1_1_4_2">{{Cite book | first = Donald Ervin | last = Knuth | series = The Art of Computer Programming | volume = 1 | title = Fundamental Algorithms | edition = 3rd | publisher = Addison-Wesley | year = 1997| isbn = 978-0-201-89683-1 | at = Section 1.4.2: Coroutines, pp. 193–200}}</ref>，任何子例程都可转写为不调用<code>yield</code>的协程<ref name="Perlis1982_6">{{Cite journal
| last1 = Perlis
| first1 = Alan J.
| doi = 10.1145/947955.1083808
| title = Epigrams on programming
| journal = ACM SIGPLAN Notices
| volume = 17
| issue = 9
| pages = 7–13
| date = September 1982
| url = http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html
| archiveurl = https://web.archive.org/web/19990117034445/http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html
| archivedate = 1999-01-17
| quote = 6. Symmetry is a complexity reducing concept (co-routines include sub-routines); seek it everywhere
| access-date = 2019-11-23
| dead-url = no
}}</ref>。

==示例==
这里是一个简单的例子证明协程的实用性。假设这样一种生产者－消费者的关系，一个协程生产产品并将它们加入队列，另一个协程从队列中取出产品并消费它们。[[伪码|伪码]]表示如下：

 ''var'' q := 新建队列
 
 '''coroutine''' 生产者
     '''loop'''
         '''while''' q 不满载
             建立某些新产品
             向 q 增加这些产品 
         '''yield''' 消费者
 
 '''coroutine''' 消费者
     '''loop'''
         '''while''' q 不空载
             从 q 移除某些产品
             使用这些产品
         '''yield''' 生产者

队列用来存放产品的空间有限，同时制约生产者和消费者：为了提高效率，生产者协程要在一次执行中尽量向队列多增加产品，然后再放弃控制使得消费者协程开始运行；同样消费者协程也要在一次执行中尽量从队列多取出产品，从而倒出更多的存放产品空间，然后再放弃控制使得生产者协程开始运行。尽管这个例子常用来介绍[[多线程|多线程]]，实际上简单明了的使用协程的<code>yield</code>即可实现这种协作关系。

==同线程的比较==
协程非常类似于[[线程|线程]]。但是协程是[[协作式多任务|协作式]]多任务的，而线程典型是[[抢占式多任务|抢占式]][[多任务|多任务]]的。这意味着协程提供[[并发性|并发性]]而非[[并行计算|并行性]]。协程超过线程的好处是它们可以用于[[实时计算|硬性实时]]的语境（在协程之间的[[上下文切换|切换]]不需要涉及任何[[系统调用|系统调用]]或任何[[阻塞_(计算)|阻塞]]调用），这里不需要用来守卫[[关键区段|关键区段]]的同步性原语（primitive）比如[[互斥锁|互斥锁]]、信号量等，并且不需要来自操作系统的支持。有可能以一种对调用代码透明的方式，使用抢占式调度的线程实现协程，但是会失去某些利益（特别是对硬性实时操作的适合性和相对廉价的相互之间切换）。

[[线程|线程]]是[[协作式多任务|协作式]]多任务的轻量级线程，本质上描述了同协程一样的概念。其区别，如果一定要说有的话，是协程是语言层级的构造，可看作一种形式的[[控制流|控制流]]，而线程是系统层级的构造，可看作恰巧没有并行运行的线程。这两个概念谁有优先权是争议性的：线程可看作为协程的一种实现<ref name="flounder">{{Cite web |url=http://www.flounder.com/fibers.htm |title=A Fiber Class |accessdate=2019-11-22 |archive-date=2017-10-23 |archive-url=https://web.archive.org/web/20171023011826/http://www.flounder.com/fibers.htm |dead-url=no }}</ref>，也可看作实现协程的基底<ref name="msdn-wrap" />。

==生成器==
[[生成器_(计算机编程)|生成器]]，也叫作“半协程”<ref name="Dahl1972" />，是协程的子集。尽管二者都可以<code>yield</code>多次，挂起（<code>suspend</code>）自身的执行，并允许在多个入口点重新进入，但它们特别差异在于，协程有能力控制在它让位之后哪个协程立即接续它来执行，而生成器不能，它只能把控制权转交给调用生成器的调用者<ref>{{cite web|title=The Python Language Reference - Yield expressions|url=https://docs.python.org/reference/expressions.html#yieldexpr|quote=All of this makes generator functions quite similar to coroutines; they yield multiple times, they have more than one entry point and their execution can be suspended. The only difference is that a generator function cannot control where should the execution continue after it yields; the control is always transferred to the generator's caller.|access-date=2019-11-22|archive-date=2012-10-26|archive-url=https://web.archive.org/web/20121026064102/https://docs.python.org/reference/expressions.html#yieldexpr}}</ref>。在生成器中的<code>yield</code>语句不指定要跳转到的协程，而是向父例程传递返回值。

尽管如此，仍可以在生成器设施之上实现协程，这需要通过顶层的分派器（dispatcher）例程（实质上是{{en-link|trampoline|trampoline (computing)|}}）的援助，它显式的把控制权传递给由生成器传回的令牌（token）所标识出的子生成器：

 ''var'' q := 建立新队列
 
 '''generator''' 生产者
     '''loop'''
         '''while''' q 不满载
             建立某些新产品
             向 q 增加这些产品
         '''yield''' 消费者
 
 '''generator''' 消费者
     '''loop'''
         '''while''' q 不空载
             从 q 移除某些产品
             使用这些产品
         '''yield''' 生产者
 
 '''subroutine''' 分派器
     ''var'' d := 创建新字典('''generator''' → '''iterator''')
     d[生产者] := '''start''' 生产者
     d[消费者] := '''start''' 消费者
     ''var'' 当前 := 生产者
     '''loop'''
         '''call''' 当前
         当前 := '''next''' d[当前]
 
 '''call''' 分派器

在不同作者和语言之间，术语“生成器”和“迭代器”的用法有着微妙的差异<ref>{{cite web
 |url         = http://www.csd.uwo.ca/
 |title       = A Technique for Generic Iteration and Its Optimization
 |last1       = Watt
 |first1      = Stephen M.
 |format      = PDF
 |work        = 
 |publisher   = The University of Western Ontario, Department of Computer Science
 |archiveurl  = https://web.archive.org/web/20120806072711/http://www.csd.uwo.ca/
 |archivedate = 2012-08-06
 |quote       = Some authors use the term iterator, and others the term generator. Some make subtle distinctions between the two.
 |accessdate  = 2012-08-08
 |dead-url    = no
}}</ref>。有人说所有生成器都是[[迭代器|迭代器]]<ref>{{Cite web |url=https://stackoverflow.com/q/1022564 |title=What is the difference between an Iterator and a Generator? |accessdate=2019-11-29 |archive-date=2020-06-25 |archive-url=https://web.archive.org/web/20200625225541/https://stackoverflow.com/questions/1022564/what-is-the-difference-between-an-iterator-and-a-generator/ |dead-url=no }}</ref>，生成器看起来像函数而表现得像迭代器。在[[Python|Python]]中，生成器是迭代器[[构造器|构造子]]：它是返回迭代器的函数。

==同尾调用互递归的比较==
{{seealso|互递归|尾调用}}
使用协程用于[[状态机|状态机]]或并发运行类似于使用经由[[尾调用|尾调用]]的[[互递归|互递归]]，在二者情况下控制权都变更给一组例程中的另一个不同例程。但是，协程更灵活并且一般而言更有效率。因为协程是<code>yield</code>而非<code>return</code>返回，接着恢复执行而非在起点重新开始，它们有能力保持状态，包括变量（同于[[闭包_(计算机科学)|闭包]]）和执行点二者，并且<code>yield</code>不限于位于尾部位置；互递归子例程必须要么使用共享变量，要么把状态作为参数传递。进一步的说，每一次子例程的互递归调用都需要一个新的栈帧（除非实现了[[尾调用|尾调用]]消去），而在协程之间传递控制权使用现存上下文并可简单地通过跳转来实现。

==协程之常见用例==

协程有助于实现：

*[[状态机|状态机]]：在一个子例程里实现状态机，这里状态由该过程当前的出口/入口点确定；这可以产生可读性更高的代码。
*[[演员模型|演员模型]]：[[并发计算|并发]]的演员模型，例如计算机游戏。每个演员有自己的[[过程式编程|过程]]（这又在逻辑上分离了代码），但他们自愿地向顺序执行各演员过程的中央调度器交出控制（这是合作式多任务的一种形式）。
*[[生成器_(计算机编程)|生成器]]：可用于[[字串流|串流]]，特别是输入/输出流，和对数据结构的通用遍历。
*[[通信顺序进程|通信顺序进程]]：这里每个子[[进程|进程]]都是协程。[[通道_(编程)|通道]]输入/输出和阻塞操作会<code>yield</code>协程，并由调度器在有完成事件时对其解除阻塞（unblock）。可作为替代的方式是，每个子进程可以是在数据[[流水线_(计算机)|管道]]中位于其后的子进程的父进程（或是位于其前者之父，这种情况下此模式可以表达为嵌套的生成器）。

==支持协程的编程语言==
协程起源于一种[[汇编语言|汇编语言]]方法，但有一些[[高级编程语言|高级编程语言]]支持它。早期的例子包括[[Simula|Simula]]<ref name="Dahl1972">{{cite book|title=Structured Programming|author1= [[Ole-Johan_Dahl|O. -J. Dahl]]|author2= [[C._A._R._Hoare|C. A. R. Hoare]]|editor=[[C._A._R._Hoare|C. A. R. Hoare]]|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175–220|chapter=Hierarchical Program Structures|url=https://dl.acm.org/doi/pdf/10.5555/1243380.1243383|quote=In SIMULA, a coroutine is represented by an object of some class, co-operating by means of resume instructions with objects of the same or another class, which are named by means of reference variables. ……<br />Thus a main program may establish a coroutine relationship with an object that it has generated, using the call/detach mechanism instead of the more '''symmetric''' resume/resume mechanism. In this case, the generated object remains subordinate to the main program, and for this reason is sometimes known as a '''Semicoroutine'''. ……<br />Let X and Y be objects, generated by a "master program" M. Assume that M issues a call (X), thereby invoking an "'''active phase'''" of X, terminated by a detach operation in X; and then issues a call (Y), and so forth. In this way M may act as a "supervisor" sequencing a pattern of active phases of X, Y, and other objects. Each object is a "slave", which responds with an active phase each time it is called for, whereas M has the responsibility to define the large scale pattern of the entire computation. <br />Alternatively the decision making may be "decentralised", allowing an object itself to determine its dynamic successor by a resume operation. The operation resume (Y), executed by X, '''combines''' an exit out of X (by detach) and a subsequent call (Y), thereby bypassing M. Obligation to return to M is transferred to Y.}}</ref>、[[Smalltalk|Smalltalk]]和[[Modula-2|Modula-2]]。更新近的例子是[[Ruby|Ruby]]、[[Lua|Lua]]、[[Julia_(编程语言)|Julia]]和[[Go|Go]]。
{{Div col|colwidth=18em}}
* Aikido
* {{en-link|AngelScript}}
* {{en-link|Ballerina (编程语言)|Ballerina (programming language)|Ballerina}}
* [[BCPL|BCPL]]
* [[Pascal_(程式語言)|Pascal]]（Borland [[Turbo_Pascal|Turbo Pascal]] 7.0带有uThreads模块）
* [[BETA_(编程语言)|BETA]]
* {{en-link|BLISS}}
* [[C++|C++]]（自从[[C++20|C++20]]）
* [[C♯|C#]]（自从2.0）
* [[ChucK|ChucK]]
* [[CLU|CLU]]
* [[D语言|D]]
* Dynamic C
* [[Erlang|Erlang]]
* [[F♯|F#]]
* [[Factor_(编程语言)|Factor]]
* {{en-link|GameMonkey Script}}
* [[Godot|GDScript]]（Godot的脚本语言）
* [[Go|Go]]
* [[Haskell|Haskell]]<ref>{{cite web
| title = Coroutine: Type-safe coroutines using lightweight session types
| url = http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Coroutine
| accessdate = 2019-11-24
| archive-date = 2013-01-20
| archive-url = https://web.archive.org/web/20130120062237/http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Coroutine
| dead-url = yes
}}</ref><ref>{{cite web
| title = Co-routines in Haskell
| url = https://axman6.com/posts/2016-07-10-Linear-resources-in-haskell.html
| accessdate = 2019-11-24
| archive-date = 2020-01-09
| archive-url = https://web.archive.org/web/20200109052929/https://axman6.com/posts/2016-07-10-Linear-resources-in-haskell.html
| dead-url = yes
}}</ref>
* [[高階組合語言|高级汇编语言]]<ref>{{cite web
| title = The Coroutines Module (coroutines.hhf)
| url = http://www.plantation-productions.com/Webster/HighLevelAsm/HLADoc/HLAStdlib/1_HTML/HLAStdlib.htm#50618574_pgfId-998318
| work = HLA Standard Library Manual
| accessdate = 2019-11-24
| archive-date = 2019-04-27
| archive-url = https://web.archive.org/web/20190427211627/http://plantation-productions.com/Webster/HighLevelAsm/HLADoc/HLAStdlib/1_HTML/HLAStdlib.htm#50618574_pgfId-998318
| dead-url = yes
}}</ref>
* [[Icon_(编程语言)|Icon]]
* [[Io_(编程语言)|Io]]
* [[JavaScript|JavaScript]]（自从1.7，标准化于ECMAScript 6<ref>{{cite web
| title = New in JavaScript 1.7
| url = https://developer.mozilla.org/en/docs/New_in_JavaScript_1.7
| accessdate = 2019-11-24
| archive-date = 2009-03-08
| archive-url = https://web.archive.org/web/20090308111529/https://developer.mozilla.org/en//docs//New_in_JavaScript_1.7
| dead-url = yes
}}</ref><!-- Does JavaScript belong here? See the link. -->，ECMAScript 2017还包括[[async/await|async/await]]支持）
* [[Julia_(编程语言)|Julia]]<ref>{{cite web| title=Julia Manual - Control Flow - Tasks (aka Coroutines)| url=http://docs.julialang.org/en/latest/manual/control-flow#man-tasks-1| accessdate=2019-11-24| archive-date=2020-06-13| archive-url=https://web.archive.org/web/20200613175413/https://docs.julialang.org/en/latest/manual/control-flow/#man-tasks-1| dead-url=yes}}</ref>
* [[Kotlin|Kotlin]]（自从1.1）<ref>{{cite web| title=What's New in Kotlin 1.1| url=https://kotlinlang.org/docs/reference/whatsnew11.html#coroutines-experimental| accessdate=2019-11-24| archive-date=2019-08-11| archive-url=https://web.archive.org/web/20190811233854/https://kotlinlang.org/docs/reference/whatsnew11.html#coroutines-experimental| dead-url=yes}}</ref>
* [[Limbo_(程式語言)|Limbo]]
* [[Lua|Lua]]<ref>{{Cite web|url=http://www.lua.org/manual/5.2/manual.html#2.6|title=Lua 5.2 Reference Manual|website=www.lua.org|accessdate=2019-11-24|archive-date=2018-01-13|archive-url=https://web.archive.org/web/20180113023237/http://www.lua.org/manual/5.2/manual.html#2.6|dead-url=yes}}</ref>
* [[Lucid_(编程语言)|Lucid]]
* {{en-link|µC++}}
* [[Modula-2|Modula-2]]
* [[Nemerle|Nemerle]]
* [[Perl_5|Perl 5]]（使用Coro模块<ref>{{Cite web |url=https://metacpan.org/pod/Coro |title=Coro |accessdate=2019-11-24 |archive-date=2019-05-29 |archive-url=https://web.archive.org/web/20190529202912/https://metacpan.org/pod/Coro |dead-url=no }}</ref>）
* [[PHP|PHP]]（带有hiphop-php<ref>[https://github.com/facebook/hiphop-php]] {{Wayback|url=https://github.com/facebook/hiphop-php |date=20121224062933 }}</ref>，原生支持自从PHP 5.5）
* [[Picolisp|Picolisp]]
* [[Prolog|Prolog]]
* [[Python|Python]]（自从2.5<ref name="py2.5" />，带有改进支持自从3.3<ref name="py3.3" />，带有显式语法自从3.5<ref>{{Cite web|url=https://docs.python.org/3/reference/compound_stmts.html#async-def|title=8. Compound statements — Python 3.8.0 documentation|website=docs.python.org|accessdate=2019-11-24|archive-date=2019-11-27|archive-url=https://web.archive.org/web/20191127123528/https://docs.python.org/3/reference/compound_stmts.html#async-def|dead-url=yes}}</ref>）
* [[Raku|Raku]]<ref>{{cite web|title=Gather and/or Coroutines|url=https://perl6advent.wordpress.com/2012/12/19/gather-andor-coroutines/|date=2012-12-19|accessdate=2019-11-24|archive-date=2020-06-13|archive-url=https://web.archive.org/web/20200613175447/https://perl6advent.wordpress.com/2012/12/19/gather-andor-coroutines/|dead-url=yes}}</ref>
* [[Ruby|Ruby]]
* {{en-link|Sather}}
* [[Scheme|Scheme]]
* [[Self|Self]]
* [[Simula_67|Simula 67]]
* [[Smalltalk|Smalltalk]]
* {{en-link|Squirrel (编程语言)|Squirrel (programming language)|Squirrel}}
* [[Stackless_Python|Stackless Python]]
* [[SuperCollider|SuperCollider]]<ref>McCartney, J. [http://portal.acm.org/citation.cfm?id=1245228 "Rethinking the Computer Music Programming Language: SuperCollider"]. Computer Music Journal, 26(4):61-68. MIT Press, 2002.</ref>
* [[Tcl|Tcl]]（自从8.6）
* {{en-link|urbiscript}}
{{div col end}}
由于[[计算续体|续体]]可被用来实现协程，支持续体的编程语言也非常容易就支持协程。

==实现==
到2003年，很多最流行的编程语言，包括C语言和它的后继者，都未在语言内或其标准库中直接支持协程。（这在很大程度上是受基于堆栈的子例程实现的限制）。C++的Boost.Context<ref>[http://www.boost.org/doc/libs/1_55_0/libs/context/doc/html/index.html Boost.Context]{{Wayback|url=http://www.boost.org/doc/libs/1_55_0/libs/context/doc/html/index.html |date=20190831230026 }}</ref>库是个例外，它是[[Boost_C++_Libraries|Boost C++ Libraries]]的一部分，它在POSIX、Mac OS X和Windows上支持ARM、MIPS、PowerPC、SPAR和x86的上下文切换。可以在Boost.Context之上建造协程。

在协程是某种机制的最自然的实现方式，却不能获得可用协程的情况下，典型的解决方法是使用[[闭包_(计算机科学)|闭包]]，它是用状态变量（[[静态变量|静态变量]]常为布尔标志值）来在调用之间维持内部状态，并转移控制权至正确地点的子例程。基于这些状态变量的值，在代码中的条件语句导致在后续调用时有着不同代码路径的执行。另一种典型的解决方法实现一个显式[[状态机|状态机]]，采用某种形式的大量而复杂的{{en-link|switch语句|Switch statement}}或[[goto|goto]]语句特别是“计算goto”。这种实现被认为难于理解和维护，更是想要有协程支持的动机。

在当今的主流编程环境里，协程的合适的替代者是[[线程|线程]]和适用范围较小的[[线程|线程]]。线程提供了用来管理“同时”执行的代码段实时协作交互的功能，在支持C语言的环境中，线程是广泛有效的，[[POSIX|POSIX]].1c（[[IEEE|IEEE]] Std 1003.1c-1995）规定了被称为[[POSIX线程|pthreads]]的一个标准线程[[API|API]]，它在[[类Unix系统|类Unix系统]]中被普遍实现。线程被很好地实现、文档化和支持，很多程序员对其也比较熟悉。但是，线程包括了许多强大和复杂的功能用以解决大量困难的问题，这导致了困难的学习曲线，当任务仅需要协程就可完成时，使用线程似乎就是用力过猛了。[[GNU可移植线程库|GNU Pth]]可被视为[[类Unix系统|类Unix系统]]上[[线程|线程]]的代表，有人尝试过用[[Windows|Windows]]的线程机制实现协程<ref name="msdn-wrap">{{cite web|url=https://docs.microsoft.com/en-us/archive/msdn-magazine/2003/september/implement-coroutines-for-net-by-wrapping-the-unmanaged-fiber-api|title=Implementing Coroutines for .NET by Wrapping the Unmanaged Fiber API|date=2005-09-16|accessdate=2019-11-26|archive-date=2020-06-13|archive-url=https://web.archive.org/web/20200613175503/https://docs.microsoft.com/en-us/archive/msdn-magazine/2003/september/implement-coroutines-for-net-by-wrapping-the-unmanaged-fiber-api|dead-url=no}}Ajai Shankar, [[MSDN_Magazine|MSDN Magazine]]</ref>。

=== C语言实现 ===

[[C标准库|C标准库]]里有“非局部跳转”函数[[setjmp.h|setjmp和longjmp]]，它们分别保存和恢复：[[栈指针|栈指针]]、[[程序计数器|程序计数器]]、被调用者保存的[[寄存器|寄存器]]和[[应用程序二进制接口|ABI]]要求的任何其他内部状态。在[[C99|C99]]标准中，跳转到已经用<code>return</code>或<code>longjmp</code>终止的函数是未定义的<ref name="ISO/IEC 9899:1999">[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf ISO/IEC 9899:1999] {{WebCite|url=https://www.webcitation.org/618HUIDTw?url=http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1124.pdf |date=20110822170431 |dateformat=iso }}, 2005, 7.13.2.1:2 and footnote 211</ref>，但是大多数<code>longjmp</code>实现在跳转时不专门销毁[[调用栈|调用栈]]中的[[局部变量|局部变量]]，在被后续的函数调用等覆写之前跳转回来恢复时仍是原样，这允许在实现协程时谨慎的用到它们。

[[POSIX|POSIX]].1-2001/[[Single_UNIX_Specification|SUSv3]]和此前的SUSv2进一步提供了操纵{{en-link|上下文 (计算)|Context (computing)|上下文}}的强力设施：{{en-link|setcontext|setcontext|setcontext、getcontext、makecontext和swapcontext}}，可方便地用来实现协程，但是由于<code>makecontext</code>的参数定义不符合[[C99|C99]]标准要求，这些函数在POSIX.1-2004中被废弃，并在POSIX.1-2008中被删除<ref>{{Cite web|url=http://man7.org/linux/man-pages/man3/getcontext.3.html|title=getcontext(3) - Linux manual page|website=man7.org|accessdate=2019-11-21|archive-date=2019-11-27|archive-url=https://web.archive.org/web/20191127031557/http://man7.org/linux/man-pages/man3/getcontext.3.html|dead-url=no}}</ref>。[[POSIX|POSIX]].1-2001/[[Single_UNIX_Specification|SUSv3]]和此前的SUSv2定义了<code>sigaltstack</code>，可用来在不能获得<code>makecontext</code>的情况下稍微迂回的实现协程<ref>{{Cite web|url = https://www.gnu.org/software/pth/pth-manual.html#implementation_notes|title = GNU Pth - IMPLEMENTATION NOTES|quote = Pth is very portable because it has only one part which perhaps has to be ported to new platforms (the machine context initialization). But it is written in a way which works on mostly all Unix platforms which support makecontext(2) or at least sigstack(2) or sigaltstack(2) [seepth_mctx.c for details].|accessdate = 2019-11-27|archive-date = 2019-12-19|archive-url = https://web.archive.org/web/20191219195423/http://www.gnu.org/software/pth/pth-manual.html#implementation_notes|dead-url = no}}<br />{{cite journal | author-link = Ralf S. Engelschall | title = Portable multithreading: the signal stack trick for user-space thread creation | journal = ATEC '00 Proceedings of the annual conference on USENIX Annual Technical Conference | pages = 20-20 | url = https://www.gnu.org/software/pth/rse-pmt.ps | date = 2000-06-18 | via = ACM Digital Library | access-date = 2019-11-27 | archive-date = 2019-10-31 | archive-url = https://web.archive.org/web/20191031120105/http://www.gnu.org/software/pth/rse-pmt.ps | dead-url = no }}</ref>。[[极简主义|极简]]实现不采用有关的标准[[API|API]]函数进行[[上下文交换|上下文交换]]，而是写一小块[[內联汇编|內联汇编]]只对换栈指针和程序计数器故而速度明显的要更快。

由于缺乏直接的语言支持，很多作者写了自己的含藏上述技术细节的协程库，以Russ Cox的libtask协程库为代表<ref>{{Cite web |url=http://swtch.com/libtask/ |title=libtask |accessdate=2019-11-21 |archive-date=2019-11-15 |archive-url=https://web.archive.org/web/20191115104620/http://swtch.com/libtask/ |dead-url=no }}</ref>，它自称能够“写[[事件驱动|事件驱动]]程序而没有麻烦的事件”，并可用在FreeBSD、Linux、Mac OS X和SunOS之上。知名的实现还有：libpcl<ref>[http://xmailserver.org/libpcl.html Portable Coroutine Library] {{Wayback|url=http://xmailserver.org/libpcl.html |date=20051214201518 }} - C library using POSIX/SUSv3 facilities</ref>、lthread<ref>[https://github.com/halayli/lthread lthread: a multicore enabled coroutine library written in C ] {{Wayback|url=https://github.com/halayli/lthread |date=20200613175536 }} - lthread is a multicore/multithread coroutine library written in C</ref>、libCoroutine<ref>{{cite web|url=http://dekorte.com/projects/opensource/libcoroutine/|title=libcoroutine: A portable coroutine implementation|accessdate=2019-11-21|archive-date=2019-11-12|archive-url=https://web.archive.org/web/20191112231845/http://dekorte.com/projects/opensource/libcoroutine/|dead-url=yes}} for FreeBSD, Linux, OS X PPC and x86, SunOS, Symbian and others</ref>、libconcurrency<ref>{{cite web|url=http://code.google.com/p/libconcurrency/libconcurrency|title=libconcurrency - A scalable concurrency library for C}} a simple C library for portable stack-switching coroutines</ref>、libcoro<ref>{{cite web|url=http://software.schmorp.de/pkg/libcoro.html|title=libcoro: C-library that implements coroutines (cooperative multitasking) in a portable fashion|accessdate=2019-11-21|archive-date=2019-12-02|archive-url=https://web.archive.org/web/20191202064402/http://software.schmorp.de/pkg/libcoro.html|dead-url=no}} used as the basis for the Coro perl module.</ref>、ribs2<ref>{{Cite web|url=https://github.com/aolarchive/ribs2|title=RIBS (Robust Infrastructure for Backend Systems) version 2|date=August 13, 2019|via=GitHub|accessdate=2019-11-21|archive-date=2020-04-22|archive-url=https://web.archive.org/web/20200422015941/https://github.com/aolarchive/ribs2|dead-url=no}}</ref>、libdill<ref>{{Cite web|url=http://libdill.org/|title=libdill: Structured Concurrency for C|website=libdill.org|accessdate=2019-11-21|archive-date=2019-12-02|archive-url=https://web.archive.org/web/20191202174632/http://libdill.org/|dead-url=no}}</ref>、libaco<ref>{{Cite web|url=https://github.com/hnes/libaco|title=极速的轻量级C异步协程库: hnes/libaco|date=October 21, 2019|via=GitHub|accessdate=2018-10-16|archive-date=2018-11-29|archive-url=https://web.archive.org/web/20181129154044/https://github.com/hnes/libaco|dead-url=no}}</ref>、libco<ref name="libco">{{Cite web|url=https://code.byuu.org/libco|title=libco: cooperative multithreading library written in C89.|website=code.byuu.org}}{{Dead link}}</ref>等等。

此外人们做了用C语言的子例程和[[宏|宏]]实现协程的大量尝试，并取得了不同程度的成功。[[Simon_Tatham|Simon Tatham]]作出的贡献是这一方法的很好示例<ref name="tatham">{{cite web|url=http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html|author=Simon Tatham|title=Coroutines in C|year=2000|accessdate=2019-11-22|archive-date=2019-11-09|archive-url=https://web.archive.org/web/20191109155253/https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html|dead-url=yes}}</ref>，它受到了[[达夫设备|达夫设备]]利用swtich语句“掉落”特性的启发，并且是[[Protothreads|Protothreads]]和类似实现的基础<ref>{{Cite web|url=https://github.com/jsseldenthuis/coroutine|title=Stackless coroutine implementation in C and C++: jsseldenthuis/coroutine|date=March 18, 2019|via=GitHub|accessdate=2019-11-26|archive-date=2020-06-13|archive-url=https://web.archive.org/web/20200613175624/https://github.com/jsseldenthuis/coroutine|dead-url=no}}</ref>。这种方法的确可以提高代码段的可写性、可读性，但可维护性是存在争议的<ref>{{cite web|url=http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html|author=Simon Tatham|title=Coroutines in C|year=2000|quote=这一技巧破坏了书本中的每一个编码标准……［但是］任何试图牺牲算法明晰来确保语法清晰的编码标准都应该被重写。如果你的老板因为你使用了这些技巧而解雇你，在保安把你从大楼里拖出来的同时不断地告诉他们我的这句话。|accessdate=2019-11-22|archive-date=2019-11-09|archive-url=https://web.archive.org/web/20191109155253/https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html|dead-url=yes}}</ref>。这种不为每个协程维护独立的栈帧的实现方式主要缺点是，[[局部变量|局部变量]]在经过从函数<code>yield</code>之后是不保存的，控制权只能从顶层例程<code>yield</code><ref name="duff">{{Cite web | url=https://brainwagon.org/2005/03/05/coroutines-in-c/#comment-1878 | title=Coroutines in C – brainwagon | accessdate=2019-11-22 | archive-date=2019-07-23 | archive-url=https://web.archive.org/web/20190723071827/https://brainwagon.org/2005/03/05/coroutines-in-c/#comment-1878 | dead-url=no }}</ref>。

=== Python实现 ===
[[Python|Python]] 2.5基于扩展的[[生成器_(计算机编程)|生成器]]实现对类似协程功能的更好支持<ref name="py2.5">{{Cite web |url=https://www.python.org/dev/peps/pep-0342/ |title=PEP 342 -- Coroutines via Enhanced Generators |accessdate=2019-11-21 |archive-date=2020-05-29 |archive-url=https://web.archive.org/web/20200529003739/https://www.python.org/dev/peps/pep-0342/ |dead-url=no }}</ref>。Python 3.3通过支持委托给子生成器增进了这个能力<ref name="py3.3">{{Cite web |url=https://www.python.org/dev/peps/pep-0380/ |title=PEP 380 -- Syntax for Delegating to a Subgenerator |accessdate=2019-11-21 |archive-date=2020-06-04 |archive-url=https://web.archive.org/web/20200604233821/https://www.python.org/dev/peps/pep-0380/ |dead-url=no }}</ref>。Python 3.4介入了综合性的[[异步I/O|异步I/O]]框架标准化，在其中扩展了利用子生成器委托的协程<ref>{{Cite web |url=https://www.python.org/dev/peps/pep-3156/#coroutines |title=PEP 3156 -- Asynchronous IO Support Rebooted: the "asyncio" Module |accessdate=2019-11-21 |archive-date=2019-11-14 |archive-url=https://web.archive.org/web/20191114154241/https://www.python.org/dev/peps/pep-3156/#coroutines |dead-url=no }}</ref>，这个扩展在Python 3.8中被弃用<ref>{{cite web|url=https://docs.python.org/3/library/asyncio-task.html#generator-based-coroutines|title=Generator-based Coroutines|accessdate=2020-10-29|archive-date=2018-12-31|archive-url=https://web.archive.org/web/20181231143720/https://docs.python.org/3/library/asyncio-task.html#generator-based-coroutines|dead-url=no}}</ref>。Python 3.5通过[[async/await|async/await]]语法介入了对协程的显式支持<ref>{{Cite web |url=https://www.python.org/dev/peps/pep-0492/ |title=PEP 492 -- Coroutines with async and await syntax |accessdate=2019-11-21 |archive-date=2019-01-05 |archive-url=https://web.archive.org/web/20190105061843/https://www.python.org/dev/peps/pep-0492/ |dead-url=no }}</ref>。从Python 3.7开始async/await成为保留关键字<ref>{{Cite web |url=https://docs.python.org/3/whatsnew/3.7.html#summary-release-highlights |title=What’s New In Python 3.7 |accessdate=2019-11-21 |archive-date=2019-11-28 |archive-url=https://web.archive.org/web/20191128153844/https://docs.python.org/3/whatsnew/3.7.html#summary-release-highlights |dead-url=no }}</ref>。例如：
<syntaxhighlight lang="Python">
import asyncio
import random

async def produce(queue, n):
    for item in range(n):
        # 生产一个项目，使用sleep模拟I/O操作
        print('producing item {} ->'.format(item)) 
        await asyncio.sleep(random.random())
        # 将项目放入队列
        await queue.put(item)
    # 指示生产完毕
    await queue.put(None)

async def consume(queue):
    while True:
        # 等待来自生产者的项目
        item = await queue.get()
        if item is None:
            break
        # 消费这个项目，使用sleep模拟I/O操作
        print('consuming item {} <-'.format(item))
        await asyncio.sleep(random.random()) 

async def main():
    queue = asyncio.Queue()
    task1 = asyncio.create_task(produce(queue, 10))
    task2 = asyncio.create_task(consume(queue))
    await task1
    await task2

asyncio.run(main())
</syntaxhighlight>
实现协程的第三方库：
{{Div col|colwidth=15em}}
*Eventlet<ref>{{Cite web |url=http://eventlet.net/ |title=Eventlet |accessdate=2019-11-21 |archive-date=2019-11-15 |archive-url=https://web.archive.org/web/20191115223317/http://eventlet.net/ |dead-url=no }}</ref>
*Greenlet<ref>{{Cite web |url=https://github.com/python-greenlet/greenlet |title=Greenlet |accessdate=2019-11-21 |archive-date=2019-08-25 |archive-url=https://web.archive.org/web/20190825220345/https://github.com/python-greenlet/greenlet |dead-url=no }}</ref>
*gevent<ref>{{Cite web |url=http://www.gevent.org/ |title=gevent |accessdate=2020-10-02 |archive-date=2020-09-16 |archive-url=https://web.archive.org/web/20200916085654/http://www.gevent.org/ |dead-url=no }}</ref>
*[[Stackless_Python|Stackless Python]]<ref>{{Cite web |url=http://www.stackless.com/ |title=Stackless Python |accessdate=2019-11-21 |archive-date=2015-12-08 |archive-url=https://web.archive.org/web/20151208123930/http://www.stackless.com/ |dead-url=no }}</ref>
{{div col end}}

=== Perl实现 ===
*Coro<ref>{{Cite web |url=http://search.cpan.org/~mlehmann/Coro-6.31/Coro.pm |title=Coro |accessdate=2013-06-01 |archive-date=2013-06-01 |archive-url=https://web.archive.org/web/20130601153658/http://search.cpan.org/~mlehmann/Coro-6.31/Coro.pm |dead-url=no }}</ref>，它是Perl5中的一种协程实现，使用C作为底层，所以具有良好的执行性能，而且可以配合AnyEvent共同使用，极大的弥补了Perl在线程上劣势。

===Scheme实现===
[[Scheme|Scheme]]提供了对[[计算续体|续体]]的完全支持，实现协程是很轻易的，只需维护一个续体的队列。在[[计算续体|续体]]条目中有使用续体将协程实现为独立线程的一个用例<ref>Haynes, C. T., Friedman, D. P., and Wand, M. 1984. Continuations and coroutines. In Proceedings of the 1984 ACM Symposium on LISP and Functional Programming (Austin, Texas, United States, August 06–08, 1984). LFP '84. ACM, New York, NY, 293-298.</ref>。

===Smalltalk实现===
在大多数[[Smalltalk|Smalltalk]]环境中，执行堆栈是头等公民，实现协程不需要额外的库或VM支持。

=== Tcl实现 ===
从 Tcl 8.6 开始，Tcl 核心内置协程支持，成为了继事件循环、线程后的另一种内置的强大功能。

==引用==
{{reflist|2}}
==参见==
*[[生成器_(计算机编程)|生成器]]
*[[管道_(软件)|管道 (软件)]]
*[[通道_(编程)|通道 (编程)]]
*[[绿色线程|绿色线程]]
*[[Future与promise|Future与promise]]

==延伸阅读==
* {{cite journal|author1=Ana Lucia de Moura|author2=Roberto Ierusalimschy|title=Revisiting Coroutines|url=http://www.inf.puc-rio.br/~roberto/docs/MCC15-04.pdf|journal=ACM Transactions on Programming Languages and Systems|volume=31|issue=2|pages=1–31|year=2004|doi=10.1145/1462166.1462167|access-date=2019-11-27|archive-date=2019-05-13|archive-url=https://web.archive.org/web/20190513083247/http://www.inf.puc-rio.br/%7Eroberto/docs/MCC15-04.pdf|dead-url=no}}

==外部链接==
* [http://www.softpanorama.org/Lang/coroutines.shtml Softpanorama coroutine page]{{Wayback|url=http://www.softpanorama.org/Lang/coroutines.shtml |date=20191202061946 }}{{snd}}包含很多汇编协程链接

[[Category:并发计算|Category:并发计算]]
[[Category:子程序|Category:子程序]]