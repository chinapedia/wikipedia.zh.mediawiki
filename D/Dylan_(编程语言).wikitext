{{NoteTA|G1=IT}}
{{Infobox programming language
| name = Dylan
| logo = 
| paradigm = [[编程范型|多范型]]: [[函数式编程|函数式]], [[面向对象编程|面向对象]], [[多分派|多分派]]
| released = {{Start date and age|1992|04}}
| designer = 
| developer = [[苹果公司|苹果公司]], {{en-link|Harlequin (软件公司)|Harlequin (software company)|Harlequin}}, [[卡内基·梅隆大学|卡内基·梅隆大学]]
| latest release version = 2020.1
| latest release date = {{Start date and age|2020|10|10}}
| typing = 强类型, 动态
| scope = 
| programming language = 
| family = [[Lisp|Lisp]]
| platform = [[IA-32|IA-32]], [[x86-64|x86-64]]
| operating system = [[跨平台|跨平台]]
| license = 
| file ext = dylan
| file format = <!-- or: | file formats = -->
| website = {{URL|opendylan.org}}
| implementations        = [https://opendylan.org Open Dylan], [http://www.gwydiondylan.org/ Gwydion Dylan]
| dialects = 中缀dylan, 前缀dylan
| influenced by = [[Common_Lisp对象系统|CLOS]], [[ALGOL|ALGOL]], [[Scheme|Scheme]], {{en-link|EuLisp}}
| influenced = {{en-link|Lasso (编程语言)|Lasso (programming language)|Lasso}}, [[Python|Python]], [[Ruby|Ruby]],
[[Julia_(编程语言)|Julia]]<ref name="goldilocks">{{cite web |last1=Stokel-Walker |first1=Chris |title=Julia: The Goldilocks language |url=https://increment.com/programming-languages/goldilocks-language-history-of-julia/ |website=Increment |publisher=Stripe |access-date=23 August 2020 |archive-date=2020-11-09 |archive-url=https://web.archive.org/web/20201109024158/https://increment.com/programming-languages/goldilocks-language-history-of-julia/ |dead-url=no }}</ref>
}}

'''Dylan'''是多范型的[[编程语言|编程语言]]，包括了支持[[函数式编程|函数式]]和[[面向对象编程|面向对象编程]]（OOP），它是[[动态编程语言|动态]]和[[反射式编程|反射式]]的，却提供了设计用于支持生成高效机器代码的编程模型，包括了在动态和静态行为上的细粒度的控制。它是在1990年代早期由[[苹果公司|苹果公司]]领导的群组创造的。

==概述==
在Dylan参考手册中有简明而彻底的语言概述<ref name="refman"/>。Dylan派生自[[Scheme|Scheme]]和[[Common_Lisp|Common Lisp]]，并增加了派生自[[Common_Lisp对象系统|Common Lisp对象系统]]（CLOS）的集成的对象系统。在Dylan中，所有的值（包括数值、字符、函数和[[类_(计算机科学)|类]]）都是[[头等对象|头等对象]]。Dylan支持[[多重继承|多重继承]]、[[多态_(计算机科学)|多态]]、[[多分派|多分派]]、{{en-link|关键字参数|Named parameter}}、对象内省、基于[[模式匹配|模式]]的[[宏|语法扩展宏]]和很多其他高级特征。程序可以表达在动态性上的细粒度的控制，允许程序占据在动态和静态编程之间的连续区，并支持演进式开发（允许先快速原型随后增进精制和优化）。

Dylan的主要设计目标是成为适合开发[[商业软件|商业软件]]的动态语言。Dylan尝试解决潜在的性能问题，通过向完全灵活性的[[Lisp|Lisp]]系统介入“本性”限制，允许[[编译器|编译器]]清晰的理解可编译单元比如[[函数库|函数库]]。Dylan从Scheme和其他Lisp派生出了它的很多语义；某些Dylan实现最初建造在现存Lisp系统之内。但是Dylan有着类似[[ALGOL|ALGOL]]的语法而非类似Lisp的前缀语法。

==历史==
{{Further|{{en-link|Dylan编程语言的历史|History of the Dylan programming language}}}}

Dylan是在1990年代早期由[[苹果公司|苹果公司]]领导的一个群组创建的。在它开发的时候，它被意图用于[[Apple_Newton|Apple Newton]]计算机，但是Dylan实现那时还没有达到充分成熟，而Newton转而使用了C和Walter Smith开发的[[NewtonScript|NewtonScript]]二者的混合。Apple在1995年终止了其Dylan开发努力，尽管他们制作了一个可获得的“技术发行”版本（{{en-link|Apple Dylan}} TR1），并包括了一个高级[[集成开发环境|集成开发环境]]（IDE）。

其他两个小组对语言设计和开发实现做出了贡献：{{en-link|Harlequin (软件公司)|Harlequin (software company)|Harlequin公司}}发行了[[Microsoft_Windows|Microsoft Windows]]下的商业IDE，[[卡内基·梅隆大学|卡内基·梅隆大学]]发行了叫作Gwydion Dylan的[[Unix|Unix]]下的编译器。二者的实现分别于2004年和1998年开放了源代码。Harlequin实现当前叫作Open Dylan并由一组志愿者维护。

Dylan语言的代号是Ralph。James Joaquin选择名字Dylan表示“动态语言”（'''Dy'''namic '''lan'''guage）。

==语法==
Dylan的多数语法特征来自它的Lisp传承。Dylan最初使用类似Lisp的前缀语法，它基于了[[S-表达式|S-表达式]]。到了语言设计完成的时候，语法被变更为类似ALGOL的语法，预期广泛的编程者受众会更加熟悉它。语法由Michael Kahl设计。它在Dylan参考手册中有详尽描述<ref name="refman"/>。

===词法===
Dylan不是[[大小写敏感性|大小写敏感]]的。Dylan的[[词法分析|词法]]允许使用[[连字暨减号|连字暨减号]]的命名约定，来连接多单词标识符的各部份（有时叫做“[[命名规则_(程序设计)#多个单词组成的标识符|lisp-case]]”或“[[字母大小写|kebab case]]”）。这个约定在Lisp语言中是常见的，但不适用于将不是数值{{en-link|文字 (计算机编程)|Literal (computer programming)|文字}}一部份的连字号暨减号，当作一个单一[[词法分析#标记|词法记号]]处理的那些编程语言，即使在它没有包围着{{en-link|空白字符|Whitespace character}}的时候。

除了[[文数字|字母数字]]字符和连字暨减号之外，Dylan允许特定非字母数字字符作为标识符的一部份。标识符不可以单独的由非字母数字字符或数字字符组成<ref name="refman"/>。如果有任何歧义，应使用空白。

===样例代码===
有几个槽的一个简单的类：

<syntaxhighlight lang="dylan">
define class <point> (<object>)
  slot point-x :: <integer>,
    required-init-keyword: x:;
  slot point-y :: <integer>,
    required-init-keyword: y:;
end class <point>;
</syntaxhighlight>

在约定上，类使用[[尖括号|尖括号]]（即小于号和大于号）来命名，比如这个代码例子中的类名字<code><point></code>。

在<code>end class <point></code>中，<code>class</code>和<code><point></code>二者都是可选的。对所有<code>end</code>子句都是如此。例如，可以写<code>end if</code>或只写<code>end</code>来终止一个<code>if</code>语句。

同样的类，可以用极小化方式重写为：

<syntaxhighlight lang="dylan">
define class <point> (<object>)
  slot point-x;
  slot point-y;
end;
</syntaxhighlight>

槽现在都确定类型为<code><object></code>。槽必须被手动初始化。

在约定上，常量名字开始于<code>$</code>：

<syntaxhighlight lang="dylan">
define constant $pi :: <double-float> = 3.1415927d0;
</syntaxhighlight>

阶乘函数：
<syntaxhighlight lang="dylan">
define method factorial (n :: <integer>) => (n! :: <integer>)
  case
    n < 0     => error("Can't take factorial of negative integer: %d\n", n);
    n = 0     => 1;
    otherwise => n * factorial(n - 1);
  end
end;
</syntaxhighlight>

这里的<code>n!</code>和<code><integer></code>就是正常的标识符。

这里没有显式的[[返回语句|返回语句]]。一个方法或函数的结果是最后求值的那个表达式。除掉在返回位置上的表达式后面的分号是常见的风格。

==模块与命名空间==
在很多面向对象语言中，类是封装和[[模块化编程|模块化]]的主要方式；每个类定义一个名字空间并控制哪些定义是在外部可见的。进一步的，在很多语言中类定义必须被用作一个整体的不可见单元。例如，使用<code>String</code>串接函数要求导入并编译全部的<code>String</code>。

某些语言包括Dylan，还包括一个分立的显式的[[命名空间|命名空间]]或模块系统，可以用更一般性的方式进行封装。

在Dylan中，编译单元和导入单元的概念是分开的，类对于二者都没有什么特殊可以言。“库”定义应当被一起编译和处理的项目，而“模块”定义一个命名空间。类可以一起放置在模块中，或分拆至其中，随编程者意愿。经常是一个类的完全定义不存在于一个单一的模块中，而是延展于进行选择性收集的多个模块至上。不同的程序可以有相同的类的不同的定义，并只包括它们所需要的。

例如，考虑支持<code>String</code>的一个附加库[[正则表达式|regex]]。在某些语言中，一个功能要被包括在字符串中，这个功能就必须被增加到<code>String</code>命名空间。随着这种事情不断发生，<code>String</code>类变得越来越大，而不需要使用regex的函数仍必须为增加了库大小付出代价。为此，这种附加件典型的放置在它们自己的命名空间和对象之中。这种方式的缺点是新函数不再是<code>String</code>的一部份；它转而被隔离在单独声明的它自己的函数集合之中。不再使用<code>myString.parseWith(myPattern)</code>，从OO视角这是自然的组织方式，而是使用像 <code>myPattern.parseString(myString)</code>这样的东西，它在效果上反转了次序。

在Dylan之下，可以为相同代码定义很多接口，例如<code>String</code>串接方法可以给放置在<code>String</code>接口和<code>concat</code>接口二者之中，后者将不同的类中的不同的串接函数收集在一起。这常用于数学库中，这里的函数意图适用于广泛的不同对象类型。

接口构造的更实际用法是建造一个模块的公开和私有版本，在其他语言中这被包括为一个附带特征，并总是导致问题并增加语法。在Dylan之下，所有的函数调用可以简单的放置在“私有”或“开发”接口中，而把可公开访问的函数收集在<code>Public</code>接口之中。在[[Java|Java]]或[[C++|C++]]之下，一个对象的可见性是定义在代码中的，意味着要提供类似的变更，编程者将被强制的去完全重写定义，并且不能同时有两个版本。

==类==
在Dylan中以类似于大多数OO语言的风格，类描述了对象的<code>slot</code>（槽，数据成员，字段，ivar等）。 所有对槽的访问都要通过方法，就像[[Smalltalk|Smalltalk]]那样。缺省的<code>getter</code>和<code>setter</code>方法基于槽名字而自动生成。对比于多数其他OO语言，可应用于类的其他方法经常定义于这个类的外部，因此在Dylan中类定义典型的只包括存储的定义。例如：

<syntaxhighlight lang=dylan>
define class <window> (<view>)
  slot title :: <string> = "untitled", init-keyword: title:;
  slot position :: <point>, required-init-keyword: position:;
end class;
</syntaxhighlight>

在这个例子中，定义了类<code><window></code>。<code><类名字></code>语法只是约定，使得类名字显得突出，尖括号只是这个类名字的一部份。与之相对比，在一些语言中，约定为大写类名字的首字母，或给名字前缀上C或T（举个例子）。<code><window></code>继承了一个单一类<code><view></code>，并包含二个槽：<code>title</code>持有这个窗口标题的字符串，和<code>position</code>持有这个窗口一角的X-Y点。在这个例子中，标题给出为缺省值，而位置还没有值。可选的<code>init-keyword</code>语法允许编程者在初始化这个类的对象时指定这个槽的初始值。

在语言比如C++或Java中，类还定义了它的接口。所以在这二种语言中，如果像上述案例中，类定义没有显式的对可见性的指令，则对数据成员和方法的访问都被当作是<code>protected</code>，意味着它们只能被子类使用。要使得无关代码使用这个窗口的实例，它们必须给声明为<code>public</code>。

在Dylan中，这些槽的可见性规则不被当作这个代码的一部份，而是模块/接口系统的一部份。这增加了相当大的灵活性。例如，在早期开发中用的接口可以声明所有东西为<code>public</code>，而用在测试和部署中用的接口会加以限制。对于C++或Java，这种变更会需要改变源代码，所有人们就不做了，而在Dylan中，这是完全无关的概念。

尽管这个例子没有用到，Dylan还支持[[多重继承|多重继承]]。

==方法和泛化函数==
在Dylan中，方法不是固有的关联于任何特定的类；方法可以被认为存在于这个类之外。就像[[Common_Lisp对象系统|CLOS]]，Dylan是基于[[多分派|多分派]]（多方法）的，这里特定方法的调用是基于它的所有实际参数的类型来选择的。方法不需要在编译时间就知道，基于用户的偏好，所要求的函数可以是能获得到的也可以不能。

在Java之下，相同的方法被隔离在特定的类之中。要使用这个功能，编程者被强制去<code>import</code>这个类并显式的引用它来调用这个方法。如果这个类不可获得，或在编译时间未知，这个应用简单的不能编译。

在Dylan中，泛化函数表示零或多个类似的方法，用<code>define method</code>方式创建的所有方法自动的包含在同名的泛化函数之内。泛化函数也可以显式的用<code>define generic</code>声明，允许编程者精确控制可以增加哪种方法。代码被隔离于存储而位于泛化函数中。很多类在其中拥有它们自己的方法，因此在感官上就像多数其他OO语言一样。但是代码实际上位于[[泛化函数|泛化函数]]之中，意味着它们不附属于特定的类，并可以被任何人自然的调用。下例将类<code><window></code>的方法<code>turn-blue</code>并入同名的泛化函数之内：

<syntaxhighlight lang=dylan>
define method turn-blue (w :: <window>)
  w.color := $blue;
end method;
</syntaxhighlight>

这个定义类似于其他语言的定义，并有可能被封装到<code><window></code>类之中。注意<code>:=</code>这个<code>setter</code>调用，它是<code>color-setter($blue, w)</code>的[[语法糖|语法糖]]。

泛化函数的自主利用可见于更泛化的例子之中。例如，在多数语言中的一个常见函数<code>to-string</code>，它返回这个对象的某种[[人类可读介质|人类可读]]形式。比如说一个窗口可能返回它的标题和它在父窗口中的位置，而一个字符串将返回它自身。在Dylan中，这些方法可以给收集到叫作<code>to-string</code>的一个单一模块中，因而这个代码被从这个类自身的定义中移除。如果一个特定对象不支持<code>to-string</code>，可以简单的在<code>to-string</code>模块中增加上它。

==扩展性==
上述的整体概念可能让读者觉得很奇怪。处理一个窗口的<code>to-string</code>不定义在<code><window></code>之中。除非考虑到Dylan对<code>to-string</code>调用的处理方式，否则就可能变得没有意义。在多数语言中，在程序编译的时候，查找给<code><window></code>的<code>to-string</code>并把它替代为到这个方法的一个指针（或多或少）。在Dylan中，这发生在程序初次运行的时候，[[运行时系统|运行时系统]]建造一个方法名字/形式参数细节的表格，并通过这个表格来动态的查找方法。这意味着一个特定方法可以位于任何地方，不只是在编译时间单元中。最后编程者得到了在放置其代码上的相当大的灵活性，只要合适，可以收集在它的类之中，也可以与相同功能的方法收集在泛化函数中。

这里隐含着编程者可以通过在单独文件中定义函数，来向现存的类增加功能。例如人们可能希望向所有<code><string></code>增加拼写检查，这在多数语言中将需要访问到字符串类的源代码，而这种基本类很少以源代码形式给出。在Dylan（和其他可扩展语言）中，拼写检查方法可以增加到<code>spell-check</code>模块中，通过<code>define method</code>构造定义它可以适用的所有的类。在这种情况下，实际功能可以定义在一个单一的泛化函数中，它接受一个字符串并返回错误。当<code>spell-check</code>模块被编译入程序的时候，所有字符串（和其他对象）都会得到这个增加的功能。

==引用==
{{reflist|refs=
<ref name="refman">{{cite book
 |title        = The Dylan Reference Manual
 |author1      = Andrew Shalit
 |author2      = David Moon
 |author3      = Orca Starbuck
 |publisher    = [[Addison-Wesley|Addison-Wesley]]
 |series       = Apple Press
 |date         = 11 September 1996
 |isbn         = 9780201442113
 |url          = http://opendylan.org/books/drm/
 |access-date  = 2021-03-13
 |archive-date = 2021-05-30
 |archive-url  = https://web.archive.org/web/20210530060705/https://opendylan.org/books/drm/
 |dead-url     = no
}}</ref>
}}

==外部链接==
*{{Official website|opendylan.org}}, Open Dylan – hosts open source, optimizing Dylan compiler targeting Unix/Linux, macOS, Microsoft Windows
*[http://opendylan.org/books/drm/Language_Overview Overview of the language] {{Wayback|url=http://opendylan.org/books/drm/Language_Overview |date=20201031071858 }}
*[http://opendylan.org/documentation/intro-dylan/ An Introduction to Dylan] {{Wayback|url=http://opendylan.org/documentation/intro-dylan/ |date=20210120132722 }}
*[https://web.archive.org/web/20140516043246/http://opendylan.org/about/apple-dylan/ Apple Dylan TR1]
*[http://www.cise.ufl.edu/~jnw/Marlais/ The Marlais Dylan Interpreter] {{Wayback|url=http://www.cise.ufl.edu/~jnw/Marlais/ |date=20181106064414 }} – An implementation of a subset of Dylan, suitable for bootstrapping a compiler
*{{Curlie|Computers/Programming/Languages/Lisp/Dylan/|Dylan}}

{{Lisp programming language}}
{{程序设计语言}}

[[Category:函数式编程语言|Category:函数式编程语言]]
[[Category:跨平台软件|Category:跨平台软件]]
[[Category:LISP程式语言家族|Category:LISP程式语言家族]]
[[Category:1992年建立的程式語言|Category:1992年建立的程式語言]]