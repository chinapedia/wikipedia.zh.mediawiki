{{NoteTA
|G1 = IT
}}
'''调度'''在计算机中是分配工作所需资源的方法。资源可以指虚拟的计算资源，如[[线程|线程]]、[[进程|进程]]或[[数据流|数据流]]；也可以指硬件资源，如[[处理器|处理器]]、网络连接或[[扩展卡|扩展卡]]。

进行调度工作的程序叫做调度器。调度器通常的实现使得所有计算资源都处于忙碌状态（在负载均衡中），允许多位用户有效地同时共享系统资源，或达到指定的[[服务质量|服务质量]]。调度是计算自身的基础，同时也是[[编程语言|编程语言]]计算模型固有的部分。调度器使得在单处理器上通过[[多任务处理|多任务处理]]，从而让执行多个进程成为可能。

调度器可能会针对不同的目标设计，例如：[[吞吐率|吞吐率]]最大化、响应时间最小化、最低延迟<ref>{{cite book
 | url = http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf
 | title = Operating Systems: Three Easy Pieces
 | section = Chapter 7: Scheduling: Introduction, Section 7.6: A New Metric: Response Time
 | date = January 4, 2015
 | accessdate = February 2, 2015
 | author1 = Remzi H. Arpaci-Dusseau
 | author2 = Andrea C. Arpaci-Dusseau
 | format = PDF
 | page = 6
 | archive-date = 2018-10-13
 | archive-url = https://web.archive.org/web/20181013015022/http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf
 | dead-url = yes
 }}</ref>、或最大化公平。在实践中，这些目标通常是互相冲突的，因此，调度器会实现一个权衡利弊的折中方案，而侧重点则可能是前文提到的任何一种，这取决于用户的需求和目的。

在实时环境，例如工业上用于自动控制（如机器人）的[[嵌入式系统|嵌入式系统]]，调度器必须保证进程的调度不能超过最后期限 —— 这是保持系统稳定运行的关键因素。调度也可能是通过一个管理性的后端进行，而任务是通过网络发配到若干远程设备上的。

== 操作系统调度器的种类 ==

调度器是[[操作系统|操作系统]]的一个模块，它能够选择将被系统处理的下一个任务，或执行的下一个进程。操作系统可能会提供三种不同类型的调度器：长期调度器、中期调度器和短期调度器。这些名字表明了任务被执行的频率。

=== 进程调度器 ===

进程调度器是操作系统的一部分，决定了何时运行什么进程。它通常能够暂停一个运行中的进程，将它放回到运行队列当中，并运行一个新进程，我们把这样的调度器叫做抢占调度器。否则，它就是协同调度器。

==== 长期调度器 ====

长期调度器，决定了任务或进程是否会被就绪队列（内存中）所接纳。当一个运行程序的尝试被做出后，长期调度器或允许，或是延迟将它作为当前执行的一个进程。因此，这种调度器掌控着能在系统上运行的进程。调度器同时还决定并发的程度：同时执行程序的多少，在I/O密集型和CPU密集型进程之前做出划分。

通常，大多数进程可以分为I/O密集型<ref>{{cite web
|author = Priya Ranjan
|url = https://en.wikipedia.org/wiki/I/O_bound
|title = I/O-Bound
|accessdate = 2014-08-09
|archive-date = 2014-09-28
|archive-url = https://web.archive.org/web/20140928230251/http://en.wikipedia.org/wiki/I/O_bound
|dead-url = no
}}</ref>和CPU密集型。I/O密集型程序将大多数时间都花在了I/O操作而不是运算上，而CPU密集型程序正好相反，将大多数时间花在了运算上，而很少产生I/O操作。选出一个I/O密集型和CPU密集型程序的良好组合，对于长期调度器是非常重要的。否则，假如所有的程序都是CPU密集型的，那么I/O队列将会几乎永远都是空的，这样就会导致一些设备从来没被人用过，系统资源分配就是不均衡的。显然，性能极佳的系统必然是CPU密集型和I/O密集型程序的组合。在现代操作系统中，这被用来保证实时进程能获得足够的CPU时间来完成任务。<ref name="galvin">{{cite book
| authors = [[Abraham_Silberschatz|Abraham Silberschatz]], [[Peter_Baer_Galvin|Peter Baer Galvin]] and [[Greg_Gagne_(academic)|Greg Gagne]]
| title = Operating System Concepts
| volume = 9
| year= 2013
| publisher= John Wiley & Sons,Inc.
| isbn= 978-1-118-06333-0
}}</ref>

长期调度对大型系统，例如批处理系统、计算机集群、超级计算机和渲染场来说同样重要。例如，在并发系统中，为了避免交互的多个进程，把时间都花在等待对方而产生阻塞，通常是需要进行协同调度的。在这种情况下，处理操作系统底层的调度器之外，还需要符合要求的额外调度程序来实现必要的功能。

==== 中期调度器 ====


中期调度器临时将进程从内存中去除，放入第二储存设备（如[[硬盘|硬盘]]）中，或亦而反之。这通常被称为“换出”和“换入”（同时也被错误叫做“分页入”和“分页出”）。中期调度器可能会将那些一直不活跃的进程，优先级低的进程，频繁产生[[页错误|页错误]]的进程，或者占用大量内存的进程放入[[交换区|交换区]]，为其它程序释放内存。当系统内存充足时，或者程序不再处于阻塞状态时，调度器又会将刚刚被放入交换区中的进程重新放入内存中。

==== 短期调度器 ====

短期调度器（也就是CPU调度器）决定了在一个时钟[[中断|中断]]、I/O中断、系统调用其它种类的信号之后，应该执行（分配CPU）给哪些内存中的进程。可见，短期调度器作出决定的频率比长期或中期调度器更加频繁 —— 每隔一段非常短的固定时间，调度器就将做出一次决定。这种调度器可以是抢占式的，能够强行把一个在CPU运行中的程序中断，然后分配给其它进程；也可以是非抢占式的，这类调度器无法强行把进程从CPU上中断。

抢占式调度器的功能需要一个运行在[[内核态|内核态]]，能被[[中断处理程序|中断处理程序]]捕获的可编程定时器才能实现。

== 调度规则 ==

调度规则就是在同时占用资源的多方之间进行资源分配的算法。在[[路由器|路由器]]、[[操作系统|操作系统]]、[[硬盘|硬盘]]、[[打印机|打印机]]，大多数[[嵌入式系统|嵌入式系统]]等设备中，都能看到调度规则的应用。

调度算法的主要目标，是使资源饥饿最小化，并保证使用资源多方的公平性。调度器需要处理在大量请求下如何分配资源的难题。调度算法种类很多，在这一章，将会介绍几种常见算法。

在[[封包交换|封包交换]]的计算机网络和其它统计多路复用领域，需要一个合适的调度算法而不是一个先到先得的数据包队列。

== 参考来源 ==
{{reflist}}


{{操作系统}}
{{软件设计模式}}

[[Category:软件设计模式|Category:软件设计模式]]
[[Category:计算机科学|Category:计算机科学]]
[[Category:操作系统|Category:操作系统]]