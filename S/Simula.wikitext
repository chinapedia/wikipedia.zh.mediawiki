{{noteTA 
|G1 = IT
}}
{{Infobox programming language
| name                   = Simula
| logo                   = Simula - logo.svg
| logo size              = 160px
| paradigms = [[编程范型|多范型]]: [[指令式编程|指令式]], [[过程式编程|过程式]], [[结构化编程|结构化]], [[物件導向程式設計|物件導向]], [[并发计算|并发]]
| year                   = {{start date and age|1962}}（Simula I）<br />{{start date and age|1967}}（Simula 67）
| designer               = [[奧利-約翰·達爾|奧利-約翰·達爾]]
| developer              = [[克利斯登·奈加特|克利斯登·奈加特]]
| latest_release_version = Standard SIMULA<ref name="std86" />
| latest_release_date    = {{start date and age|1986|08|25}}
| latest_test_version    = 
| latest_test_date       =
| typing                 = [[静态类型|静态]]、{{en-link|名称式类型系统|Nominal type system|名称式}}
| programming language   =  主要为[[ALGOL_60|ALGOL 60]]（有一些[[Simscript|Simscript]]构件）
| dialects               =
| implementations        = Portable Simula Revisited<ref name="psim" />, GNU Cim<ref name="cim" />
| influenced_by          = [[ALGOL_60|ALGOL 60]], [[Simscript|Simscript]]<ref>{{cite web |title=The Development of the Simula Languages |url=https://phobos.ramapo.edu/~ldant/datascope/simula%20history.pdf |author1=[[Kristen_Nygaard|Kristen Nygaard]] |author2=[[Ole-Johan_Dahl|Ole-Johan Dahl]] |date=1978 |quote=SIMSCRIPT was the only simulation language that we were closely acquainted with during the design phase of SIMULA. From the preceding sections it will be evident that it had a considerable impact through its list processing and time scheduling mechanisms. It also contained a set of random drawing and other utility routines, which served as a model for our procedure library. |access-date=2022-03-14 |archive-date=2022-01-20 |archive-url=https://web.archive.org/web/20220120192521/https://phobos.ramapo.edu/~ldant/datascope/simula%20history.pdf }}</ref>
| influenced             = [[Smalltalk|Smalltalk]]、[[CLU|CLU]]<ref>{{cite web|title=A history of CLU|author=[[Barbara_Liskov|Barbara Liskov]]|url=https://pmg.csail.mit.edu/ftp.lcs.mit.edu/pub/pclu/CLU/3.Documents/clu-history.PDF|year=1992|quote=Programming languages that existed when the concept of [[数据抽象|data abstraction]] arose did not support [[抽象数据类型|abstract data types]], but some languages contained constructs that were precursors of this notion. …… The mechanism that matched the best was the class mechanism of Simula 67. A Simula class groups a set of procedures with some variables. A class can be instantiated to provide an object containing its own copies of the variables; the class contains code that initializes these variables at instantiation time. However, Simula classes did not enforce encapsulation ……, and Simula was lacking several other features needed to support data abstraction, …….|access-date=2022-04-27|archive-date=2021-11-05|archive-url=https://web.archive.org/web/20211105133631/https://pmg.csail.mit.edu/ftp.lcs.mit.edu/pub/pclu/CLU/3.Documents/clu-history.PDF}}</ref>、[[C++|C++]]、[[BETA_(编程语言)|BETA]]、[[Object_Pascal|Object Pascal]]、[[Modula-3|Modula-3]]、[[Java|Java]]
| operating system       = [[类Unix系统|类Unix系统]]、[[Windows|Windows]]、[[z/OS|z/OS]]、[[TOPS-10|TOPS-10]]、{{en-link|MVS}}
| license                =
| website                =
}}
'''Simula'''，一種[[編譯語言|編譯式]]的[[程式語言|程式語言]]，由[[奧利-約翰·達爾|奧利-約翰·達爾]]與[[克利斯登·奈加特|克利斯登·奈加特]]，在1960年代於[[奧斯陸|奧斯陸]]的{{en-link|挪威计算中心|Norwegian Computing Center}}，開發出來了Simula I與Simula 67兩代。它承繼了[[ALGOL_60|ALGOL 60]]作為基礎，被認為是第一個[[物件導向程式設計|物件導向程式設計]]的程式語言。

Simula 67介入了[[对象_(计算机科学)|对象]]、[[类_(计算机科学)|类]]、[[子类_(计算机科学)|子类]]（后来惯称为子类[[继承_(计算机科学)|继承]]超类）、[[虚函数|虚过程]]<ref name="virt" />，还有[[协程|协程]]、[[离散事件模拟|离散事件模拟]]和特征性的[[垃圾回收_(计算机科学)|垃圾收集]]<ref name="gc"/>。Simula的影響经常被低估<ref name="infl" />，在[[C++|C++]]、[[Object_Pascal|Object Pascal]]、[[Modula-3|Modula-3]]、[[Java|Java]]和后来的很多编程语言中，都实现了受Simula启发的对象。[[BETA_(编程语言)|BETA]]是Simula的现代后继者。

== 歷史 ==
[[File:Simula_-_discrete-event_network.en.svg|thumb]]
[[克利斯登·奈加特|克利斯登·奈加特]]在1957年開始在自己的電腦上寫[[模擬器|模擬器]]。為了發展他的模擬器，他需要更強大的程式語言。1962年1月，[[奧利-約翰·達爾|奧利-約翰·達爾]]開始跟他合作。他們受到[[ALGOL_60|ALGOL 60]]的啟發，在同年5月，發展出第一個[[模拟器语言|模擬器程式語言]]，取名為Simula I。此時，[[克利斯登·奈加特|克利斯登·奈加特]]受到{{en-link|Sperry公司|Sperry Corporation|Sperry Rand公司}}邀請，去協助他們開發{{en-link|UNIVAC 1100/2200系列|UNIVAC 1100/2200 series|UNIVAC 1107}}電腦。[[UNIVAC|UNIVAC]]軟體部門的主管{{en-link|鮑伯·貝莫|Bob Bemer}}，力邀[[克利斯登·奈加特|克利斯登·奈加特]]前往{{en-link|國際資訊處理協會|International Federation for Information Processing}}（IFIP）舉行的第二次國際會議上，發表了論文「SIMULA－擴展ALGOL到離散事件網路的描述」<ref>
{{cite paper|author=[[Kristen_Nygaard|Kristen Nygaard]]|title=SIMULA: An  Extension of ALGOL to the Description of Discrete-Event Networks| publisher=Proceedings  of the  IFIP congress  62, Munich. North-Holland  Publ., pages 520-522.|date= Aug 1962}}</ref>。

1963年8月，{{en-link|挪威計算中心|Norwegian Computing Center}}（NCC）購買到{{en-link|UNIVAC 1100/2200系列|UNIVAC 1100/2200 series|UNIVAC 1107}}，在UNIVAC的合約同意下，[[奧利-約翰·達爾|奧利-約翰·達爾]]在這台電腦上安裝以[[ALGOL_60|ALGOL 60]]的編譯器來實作的Simula I。1965年1月，Simula I終於可以在UNIVAC 1107上完全的運作。接下來幾年，[[克利斯登·奈加特|克利斯登·奈加特]]與[[奧利-約翰·達爾|奧利-約翰·達爾]]致力於教授Simula I。Simula I也被移植到{{en-link|Burroughs大型系统|Burroughs large systems|Burroughs}} B5500電腦，以及蘇聯的{{en-link|Ural (计算机)|Ural (computer)|URAL-16}}電腦上。

1965年，[[東尼·霍爾|東尼·霍爾]]首次提出“記錄類別”（record class）構造的概念<ref>{{cite paper|author=[[C._A._R._Hoare|C. A. R. Hoare]]|url=http://archive.computerhistory.org/resources/text/Knuth_Don_X4100/PDF_index/k-9-pdf/k-9-u2293-Record-Handling-Hoare.pdf|title=Record Handling|publisher=ALGOL Bulletin no. 21|year=1965|journal=|access-date=2022-03-14|archive-date=2022-04-07|archive-url=https://web.archive.org/web/20220407173051/http://archive.computerhistory.org/resources/text/Knuth_Don_X4100/PDF_index/k-9-pdf/k-9-u2293-Record-Handling-Hoare.pdf}}</ref>，1966年，[[克利斯登·奈加特|克利斯登·奈加特]]與[[奧利-約翰·達爾|奧利-約翰·達爾]]通过將Simula I的進程當作由前綴層和主要層二者構成，把它擴展成了具有了記錄類別屬性的通用進程，他們當時所稱“進程”隨即被稱為“[[对象_(计算机科学)|物件]]”<ref>
{{cite web |author=Jan Rune  Holmevik|url=http://staff.um.edu.mt/jskl1/simula.html |title=Compiling Simula |year=1994|quote=During the summer and autumn of 1963, …… Instead Dahl and Nygaard introduced the far more powerful process concept which came to constitute the basic, unifying feature of the SIMULA I language. In short, a '''process''' can be understood as a generalized ALGOL '''procedure''' with quasi-parallel properties. ……<br />they became more and more preoccupied with the opportunities embedded in Tony Hoare's record class construct, first presented in ALGOL bulletin no. 21, 1965. …… What they were really looking for was some kind of generalized process concept with record class properties. The answer to their problem suddenly appeared in December 1966, when the idea of prefixing was introduced. A '''process''', later called an '''object''', could now be regarded as consisting of two '''layers''': A '''prefix''' layer containing references to its predecessor and successor along with a number of other properties, and a '''main''' layer containing the attributes of the object in question. In addition to this important new feature, they also introduced the '''class''' concept, which can roughly be described as a highly refined version of SIMULA I's '''activity''' concept. This powerful new concept made it possible to establish class and subclass hierarchies of concatenated objects.|publisher=Institute for Studies in Research and Higher Education |location=Oslo, Norway|archive-date=2020-01-11 |archive-url=https://web.archive.org/web/20200111193325/http://staff.um.edu.mt/jskl1/simula.html |dead-url=no }}</ref>。1967年5月，奈加特和達爾在奧斯陸舉辦的IFIP工作小組論壇中，發表了關於[[类_(计算机科学)|類別]]與[[繼承_(電腦科學)|子類別]]聲明的論文，形成Simula 67的第一份定義文件<ref>{{cite paper|author1=[[Ole-Johan_Dahl|Ole-Johan Dahl]]|author2=[[Kristen_Nygaard|Kristen Nygaard]]|url=https://www.ub.uio.no/fag/naturvitenskap-teknologi/informatikk/faglig/dns/dokumenter/classandsubclass1968.pdf|title=Class and Subclass Declarations|publisher=J. Buxton,ed.: Simulation Programming Languages. Proceedings from the IFIP Working Conference in Oslo, May 1967.|location=North Holland|year=1968|journal=|access-date=2020-05-16|archive-date=2022-04-08|archive-url=https://web.archive.org/web/20220408041211/https://www.ub.uio.no/fag/naturvitenskap-teknologi/informatikk/faglig/dns/dokumenter/classandsubclass1968.pdf}}</ref>。

1968年召開的會議，組成了SIMULA標準小組，並發表了第一份官方Simula標準文件「SIMULA 67通用基础语言」<ref name="CommonBase">{{cite book |author1=[[Ole-Johan_Dahl|Ole-Johan Dahl]] |author2=Bjørn Myhrhaug |author3=[[Kristen_Nygaard|Kristen Nygaard]] |date=1968, 1970 |url=https://www.ics.uci.edu/~jajones/INF102-S18/readings/10_Simula.pdf |title=SIMULA 67 Common Base Language |publisher=Norwegian Computing Center |access-date=2022-02-13 |archive-date=2022-04-07 |archive-url=https://web.archive.org/web/20220407173033/https://www.ics.uci.edu/~jajones/INF102-S18/readings/10_Simula.pdf }}</ref>。在1960年代后期和1970年代早期，Simula 67主要实现于四个系统之上：{{en-link|挪威计算中心|Norwegian Computing Center}}的[[UNIVAC|UNIVAC]] {{en-link|UNIVAC 1100/2200系列|UNIVAC 1100/2200 series|1100系列}}，挪威计算中心的[[IBM|IBM]] [[System/360|System/360]]和{{en-link|IBM System/370|IBM System/370|System/370}}，[[奥斯陆大学|奥斯陆大学]]在{{en-link|Kjeller}}联合安装的[[控制資料公司|CDC]] {{en-link|CDC 3000系列|CDC 3000 series|3000系列}}，和{{en-link|瑞典国防研究所|Swedish National Defence Research Institute}}（FOA）的[[DEC|DEC]] [[TOPS-10|TOPS-10]]。

当前的Simula 67业界标准，是在1986年修订的“标准SIMULA”<ref name="std86">{{cite web|url=https://portablesimula.github.io/github.io/doc/SimulaStandard.pdf|title=SIMULA Standard|author=SIMULA Standards Group|year=1986|quote=In this Standard the name SIMULA is considered synonymous with SIMULA 67. …… It is recommended that the language defined in this Standard be referred to as "Standard SIMULA". <br />SIMULA includes most of the ALGOL 60 language. Wherever ALGOL is used in this Standard it relates to the STANDARD ALGOL 60 definition (ISO 1538).|access-date=2022-03-23|archive-date=2022-04-07|archive-url=https://web.archive.org/web/20220407173033/https://portablesimula.github.io/github.io/doc/SimulaStandard.pdf}}</ref>，它在1987年被接受为瑞典国家标准<ref>{{cite web|url=https://www.edelweb.eu/Simula/SS636114.pdf|title=Swedish standard SS 63 61 14|access-date=2022-04-14|archive-date=2022-04-16|archive-url=https://web.archive.org/web/20220416103328/https://www.edelweb.eu/Simula/SS636114.pdf}}</ref>。它有四个主要实现：{{en-link|Simula研究实验室|Simula Research Laboratory|Simula AS}}、[[隆德|Lund]] Simula、GNU Cim<ref name="cim">{{cite web  |url=https://savannah.gnu.org/projects/cim  |title=GNU Cim  |access-date=2022-04-02  |archive-date=2022-04-14  |archive-url=https://web.archive.org/web/20220414211642/https://savannah.gnu.org/projects/cim  }}</ref>和Portable Simula Revisited<ref name="psim">{{cite web |title=Portable Simula Revisited |url=https://portablesimula.github.io/github.io/ |access-date=2022-03-15 |archive-date=2022-05-11 |archive-url=https://web.archive.org/web/20220511181015/https://portablesimula.github.io/github.io/ }}</ref>。

Simula影响了[[Smalltalk|Smalltalk]]<ref name="History">{{cite web|author=[[Alan_Kay|Alan Kay]]|url=http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html|title=The Early History of Smalltalk|quote=I wound up in graduate school at the University of Utah in the Fall of 1966, ……. …… The documentation was incomprehensible. Supposedly, this was the [[凱斯西儲大學|Case-Western Reserve]] {{en-link|UNIVAC 1100/2200系列|UNIVAC 1100/2200 series|1107}} [[Algol|Algol]] – but it had been doctored to make a language called Simula; the documentation read like Norwegian transliterated into English, which in fact it was. There were uses of words like activity and process that didn’t seem to coincide with normal English usage. ……<br />The weirdest part was the '''storage allocator''', which did not obey a stack discipline as was usual for Algol. …… What Simula was allocating were structures very much like the instances of [[Sketchpad|Sketchpad]]. There wee descriptions that acted like masters and they could create instances, each of which was an independent entity. What Sketchpad called masters and instances, Simula called activities and processes. Moreover, Simula was a procedural language for controlling Sketchpad-like objects, thus having considerably more flexibility than constraints (though at some cost in elegance) ……. ……<br />For the first time I thought of the whole as the entire computer and wondered why anyone would want to divide it up into weaker things called data structures and procedures. Why not divide it up into little computers, as time sharing was starting to? But not in dozens. Why not thousands of them, each simulating a useful structure? ……<br />It is not too much of an exaggeration to say that most of my ideas from then on took their roots from Simula – but not as an attempt to improve it. It was the promise of an entirely new way to structure computations that took my fancy. As it turned out, it would take quite a few years to understand how to use the insights and to devise efficient mechanisms to execute them.|access-date=2022-04-11|archive-date=2011-04-29|archive-url=https://web.archive.org/web/20110429192453/http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html}}</ref>，和后来的[[面向对象编程|面向对象编程]]语言<ref name="infl">{{cite web|url=https://www.mn.uio.no/ifi/english/about/ole-johan-dahl/bibliography/the-birth-of-object-orientation-the-simula-languages.pdf|title=The Birth of Object Orientation: the Simula Languages|author=[[Ole-Johan_Dahl|Ole-Johan Dahl]]|year=2001|quote=The main impact of Simula 67 has turned out to be the very wide acceptance of many of its basic concepts: objects, but usually '''without own actions''', classes, inheritance, and virtuals, often the default or only way of binding “methods”, (as well as pointers and dynamic object generation). <br />There is universal use of the term “object orientation”, OO. Although no standard definition exists, some or all of the above ideas enter into the OO paradigm of system development. There is a large flora of OO languages around for programming and system specification. …… The importance of the OO paradigm today is such that one must '''assume''' something similar would have come about also '''without the Simula effort'''. The fact remains, however, that the OO principle was introduced in the mid 60’s through these languages.<br />Simula 67 had an immediate success as a simulation language, and was, for instance extensively used in the design of VLSI chips, e.g. at INTEL. As a general programming language, its impact was enhanced by lectures at {{en-link|北约和平与安全科学|NATO Science for Peace and Security|NATO}} {{en-link|马克特奥伯多夫暑期学校|Summer School Marktoberdorf|Summer Schools}} given by OJD, materialized as a chapter in a book on structured programming. The latter has influenced research on the use of [[抽象数据类型|abstract data types]], e.g., the [[CLU|CLU]] language, as well as research on {{en-link|驻留监控器|Resident monitor|monitors}} and [[操作系统|operating system]] design. <br />A major new impact area opened with the introduction of [[工作站|workstations]] and [[个人计算机|personal computers]]. Alan Kay and his team at Xerox PARC developed [[Smalltalk|Smalltalk]], an interactive language building upon Simula’s objects, classes and inheritance. It is oriented towards organising the cooperation between a user and her/his personal computer.|access-date=2022-04-13|archive-date=2021-08-10|archive-url=https://web.archive.org/web/20210810223830/https://www.mn.uio.no/ifi/english/about/ole-johan-dahl/bibliography/the-birth-of-object-orientation-the-simula-languages.pdf}}</ref>。Simula经由Smalltalk启发了并发计算的[[演员模型|演员模型]]<ref name="hewitt1973">{{cite paper |url=https://www.ijcai.org/Proceedings/73/Papers/027B.pdf |author={{en-link|Carl Hewitt}} |coauthors=Peter Bishop, Richard Steiger |title=A Universal Modular Actor Formalism for Artificial Intelligence |publisher=IJCAI |date=1973 |quote=Alan Kay whose FLEX and SMALLTALK machines have influenced our work. Alan emphasized the crucial importance of using intentional definitions of data structures and of passing messages to them. This paper explores the consequences of generalizing the message mechanism of SMALLTALK and SIMULA-67; ……. |journal= |access-date=2022-04-11 |archive-date=2021-02-25 |archive-url=https://web.archive.org/web/20210225043811/https://www.ijcai.org/Proceedings/73/Papers/027B.pdf }}</ref>。[[C++|C++]]語言和[[Java|Java]]語言的創始人，都認可自己受到了Simula的重要影響<ref>{{cite paper |author=[[Bjarne_Stroustrup|Bjarne Stroustrup]] |date=1996 |pages=699–769 |url=https://www.stroustrup.com/hopl2.pdf |title=A history of C++: 1979-1991 |work=History of programming languages---II |publisher=[[Association_for_Computing_Machinery|ACM]] |doi=10.1145/234286.1057836 |quote=C++ was designed to provide Simula’s facilities for program organization together with C’s efficiency and flexibility for systems programming. |journal= |access-date=2022-03-22 |archive-date=2022-04-23 |archive-url=https://web.archive.org/web/20220423010110/https://www.stroustrup.com/hopl2.pdf }}<br />{{cite paper|url=https://www.win.tue.nl/~evink/education/avp/pdf/feel-of-java.pdf|title=The Feel of Java|authors=[[James_Gosling|James Gosling]]|year=1997|quote=Java is a blue collar language. It’s not PhD thesis material but a language for a job. Java feels very familiar to many different programmers because I had a very strong tendency to prefer things that had been used a lot over things that just sounded like a good idea. …… It has an object-oriented flavor that derives from a number of languages—Simula, C/C++, Objective C, Cedar/Mesa, Modula, and Smalltalk.|journal=|access-date=2022-04-27|archive-date=2022-02-28|archive-url=https://web.archive.org/web/20220228102847/https://www.win.tue.nl/~evink/education/avp/pdf/feel-of-java.pdf}}</ref>。

==特征概念==
Simula 67包含通用算法语言[[ALGOL_60|ALGOL 60]]的多数特征作为自己的子集<ref name="std86" />。它是[[大小写敏感性|大小写不敏感]]的。

===块与过程===
[[ALGOL_60|ALGOL 60]]中最强力的编程构造机制之一，就是[[块_(编程)|块]]和[[子程序|过程]]的概念。

====语法====
块是一种[[陳述式|语句]]<ref>{{cite book|title=Structured Programming|author1= [[Ole-Johan_Dahl|O. -J. Dahl]]|author2= [[C._A._R._Hoare|C. A. R. Hoare]]|editor=[[C._A._R._Hoare|C. A. R. Hoare]]|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175–220|chapter=Hierarchical Program Structures|url=https://dl.acm.org/doi/pdf/10.5555/1243380.1243383|quote=useful properties from the standpoint of concept modelling. ……<br />⑷ Language element. A block is itself a statement, which is a syntactic category of the language. Furthermore, through the procedure mechanism, reference to a block may be dissociated from its defining text.}}</ref>，在Simula 67中，它包括子块和有前缀（prefixed）块。子块就是未加前缀的常规意义上的块，下面分别用字母<code>D</code>表示任意声明，<code>S</code>表示任意语句，<code>L</code>表示可选的任意[[標記_(程式語言)|标签]]，子块的语法单元采用的形式为：
<syntaxhighlight lang="ObjectPascal">
L: L: ... begin D; D; ... D; S; S; ... S; S end
</syntaxhighlight>

[[声明_(编程)|声明]]担当定义在程序中用到的量的特定[[属性_(编程)|属性]]，并给它们关联上[[标识符_(计算机语言)|标识符]]，这里的[[量_(物理)|量]]（quantity）包括：简单变量、数组、<code>switch</code><ref name="switch">{{cite web|url=http://www.masswerk.at/algol60/report.htm|title=Revised Report on the Algorithmic Language Algol 60|author=Peter Naur, et al|quote=A switch declaration defines the set of values of the corresponding switch designators. These values are given one by one as the values of the designational expressions entered in the switch list. With each of these designational expressions there is associated a positive integer, 1, 2, ..., obtained by counting the items in the list from left to right. The value of the switch designator corresponding to a given value of the subscript expression ( …… ) is the value of the designational expression in the switch list having this given value as its associated integer.|access-date=2022-04-14|archive-date=2007-06-25|archive-url=https://web.archive.org/web/20070625171638/http://www.masswerk.at/algol60/report.htm}}</ref>、过程、类和外来声明。块中的每个语句，都可以是完全的复合语句或块。复合语句与块相比没有声明。所有的块，自动地介入一层新的{{en-link|命名法|Nomenclature}}（nomenclature）<ref>{{cite web|url=http://www.masswerk.at/algol60/report.htm|title=Revised Report on the Algorithmic Language Algol 60|author=Peter Naur, et al|quote=Every block automatically introduces a new level of nomenclature. This is realized as follows: Any identifier occurring within the block my through a suitable declaration ( …… ) be specified to be local to the block in question. This means ⒜ that the entity represented by this identifier inside the blocks has no existence outside it and ⒝ that any entity represented by this identifier outside the block is completely inaccessible inside the block. <br />Identifiers (except those representing labels) occurring within a block and not being declared to this block will be non-local to it, i.e. will represent the same entity inside the block and in the level immediately outside it. A label separated by a colon from a statement, i.e. labelling that statement, behaves as though declared in the head of the smallest embracing block, i.e. the smallest block whose brackets <code>begin</code> and <code>end</code> enclose that statement. In this context a procedure body must be considered as if it were enclosed by <code>begin</code> and <code>end</code> and treated as a block. <br />Since a statement of a block may again itself be a block the concepts local and non-local to a block must be understood recursively. Thus an identifier, which is non-local to a block A, may or may not be non-local to the block B in which A is one statement.|access-date=2022-04-14|archive-date=2007-06-25|archive-url=https://web.archive.org/web/20070625171638/http://www.masswerk.at/algol60/report.htm}}</ref>：
*在这个块内出现的[[标识符_(计算机语言)|标识符]]，可以通过合适的声明，而被指定为局部于所论及的这个块。在这个块内侧的这个标识符所表示的实体，不[[存在|存在]]于它的外侧。在这个块外侧的这个标识符所表示的任何实体，在这个块内侧是不可见的；在Simula 67中，可通过连接或远程访问使它成为可见的。
*除了表示标签的标识符之外，一个标识符，如果出现在一个块中，而且并非声明于这个块中，则它非局部于这个块，就是说它所表示的这个块内侧实体，与在紧接它外侧的层级中出现的同名实体是同一个实体。因为块中的语句自身可以是一个块，局部和非局部于一个块的概念，必须[[递归|递归]]地去理解，就是说非局部于一个块<code>A</code>的一个标识符，可是亦可否地，非局部于<code>A</code>是其中语句的块<code>B</code>。

====语义====
[[块_(编程)|块]]是一种形式描述或[[模式|模式]]，关乎聚集的[[数据结构|数据结构]]和关联的[[算法|算法]]以及行动<ref>{{cite book|title=Structured Programming|author1= [[Ole-Johan_Dahl|O. -J. Dahl]]|author2= [[C._A._R._Hoare|C. A. R. Hoare]]|editor=[[C._A._R._Hoare|C. A. R. Hoare]]|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175–220|chapter=Hierarchical Program Structures|url=https://dl.acm.org/doi/pdf/10.5555/1243380.1243383|quote=One of the most powerful mechanisms for program structuring in ALGOL 60 is the block and procedure concept. It has the following useful properties from the standpoint of concept modelling. <br />⑴ [[二元论|Duality]]. A block head and block tail together define an entity which has properties and performs actions. Furthermore the properties may include a data structure as well as associated operators (local procedures). }}</ref>。一个块实例，可以被认为是它的形式描述的文字复本。一个块的任何内部块，仍然是一个模式，但是在其中出现的{{en-link|非局部变量|Non-local variable|非局部}}标识符，确认了局部于字面上包围的块实例的项目<ref>{{cite book|title=Structured Programming|author1= [[Ole-Johan_Dahl|O. -J. Dahl]]|author2= [[C._A._R._Hoare|C. A. R. Hoare]]|editor=[[C._A._R._Hoare|C. A. R. Hoare]]|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175–220|chapter=Hierarchical Program Structures|url=https://dl.acm.org/doi/pdf/10.5555/1243380.1243383|quote=useful properties from the standpoint of concept modelling.  ……<br />⑵ [[分解_(计算机科学)|Decomposition]]. A block where only local quantities are referenced is a completely selfcontained program component, which will function as specified in any context. Through a procedure heading a block (procedure) instance may {{en-link|交互|Interaction|interact}} with a calling sequence. Procedures which reference or change non-local variables represent a partial decomposition of the total task, which is useful for direct {{en-link|交互|Interaction|interaction}} with the program environment.}}</ref>。
*当一个块执行的时候，生成这个块的一个动态实例<ref >{{cite book|title=Structured Programming|author1= [[Ole-Johan_Dahl|O. -J. Dahl]]|author2= [[C._A._R._Hoare|C. A. R. Hoare]]|editor=[[C._A._R._Hoare|C. A. R. Hoare]]|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175–220|chapter=Hierarchical Program Structures|url=https://dl.acm.org/doi/pdf/10.5555/1243380.1243383|quote=In ALGOL 60, the rules of the language have been carefully designed to ensure that the lifetimes of block instances are '''nested''', in the sense that those instances that are latest activated are the first to go out of existence. It is this feature that permits an ALGOL 60 implementation to take advantage of a '''stack''' as a method of '''dynamic''' storage allocation and relinquishment. But it has the disadvantage that a program which creates a new block instance can never interact with it as an object which exists and has attributes, since it has disappeared by the time the calling program regains control. Thus the calling program can observe only the results of the actions of the procedures it calls. Consequently, the operational aspects of a block are overemphasised; and algorithms (for example, matrix multiplication) are the only concepts that can be modelled.}}</ref>。在计算机中，一个块实例可以采用一种形式的[[内存|内存]]区域，它包含需要的动态块信息，并包括[[地址空间|空间]]来持有局部于这个块的变量的内容<ref name="cls">{{cite book|title=Structured Programming|author1= [[Ole-Johan_Dahl|O. -J. Dahl]]|author2= [[C._A._R._Hoare|C. A. R. Hoare]]|editor=[[C._A._R._Hoare|C. A. R. Hoare]]|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175–220|chapter=Hierarchical Program Structures|url=https://dl.acm.org/doi/pdf/10.5555/1243380.1243383|quote=useful properties from the standpoint of concept modelling. ……<br />⑶ Class of instances. In ALGOL 60 a sharp distinction is made between a block, which is a piece of program text, and a dynamic block instance, which is (a component of) a computing process. An immediate and useful consequence is that a block may be identified with the class of its potential activations. (Strictly speaking a "block" in this context means either the outermost block or a block immediately enclosed by a dynamic block instance.) Through the recursion mechanism of ALGOL 60 different instances of the same block may co-exist in a computing process at the same time.}}</ref>。
*块实例中的[[局部变量|局部变量]]，标识了分配给块实例的内存片段。{{en-link|非局部变量|Non-local variable|非局部}}于内部块的标识符[[名字绑定|绑定]]，对这个内部块的任何随后的动态实例，保持有效<ref>{{Cite web|url=https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf|author={{en-link|David Turner|David Turner (computer scientist)|D. A. Turner}}|title=Some History of Functional Programming Languages|publisher=in an invited lecture TFP12, St Andrews University|date=12 June 2012|quote=Algol 60 allowed textually nested procedures and passing procedures as parameters (but not returning procedures as results). The requirement in the copying rule for systematic change of identifiers has the effect of enforcing static (that is lexicographic) binding of [[自由变量和约束变量|free variables]]. <br />In their book “Algol 60 Implementation”, Randell and Russell (1964, Sect. 2.2) handle this by two sets of links between stack frames. The dynamic chain links each stack frame, representing a procedure call, to the frame that called it. The static chain links each stack frame to that of the textually containing procedure, which might be much further away. Free variables are accessed via the static chain. <br />This mechanism works well for Algol 60 but in a language in which functions can be returned as results, a free variable might be held onto after the function call in which it was created has returned, and will no longer be present on the stack. <br />[[彼得·兰丁|Landin]] (1964) solved this in his [[SECD抽象机|SECD machine]]. A function is represented by a [[闭包|closure]], consisting of code for the function plus the environment for its free variables. The environment is a linked list of name-value pairs. Closures live in the heap.|access-date=2022-05-04|archive-date=2020-04-15|archive-url=https://web.archive.org/web/20200415053847/https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf}}</ref>。

任何声明的[[变量_(程序设计)|变量]]，在进入这个变量所局部于的那个块之中的时候，都会被[[初始化|初始化]]。局部于一个块的一个变量，是一个内存设备，其内容依据这个变量的类型，要么是一个[[值_(计算机科学)|值]]，要么是一个[[参照|引用]]。值类型可特征化为直接关联着一个可能值的集合（这个类型的“值范围”）。引用概念，对应于一个名字或一个“[[指针|指针]]”的直观想法。它提供了引用值的机制，还反映了[[随机存取机|机器]]的[[地址空间|寻址]]可能性。在特定简单情况下，一个引用可以被实现为一个存储的值的[[内存地址|内存地址]]。对于值类型不关联着引用概念。

过程与块相比，它有一个名字，可以在程序的多个不同地方提及，并且在调用时可以给出参数<ref name="proc">{{cite book|author1=[[Ole-Johan_Dahl|Ole-Johan Dahl]]|author2=Bjørn Myhrhaug|url=https://www.edelweb.eu/Simula/sig-5.pdf|title=The Simula Implementation Guide|date=1967, 1973|quote=A procedure deviates from a block in that ⑴ it has a name and ⑵ may be referred to at several different places in the program, and ⑶ that parameters may be given to it when invoked. A procedure shares the property of a block that it is impossible to establish a reference to it or to its interior.|access-date=2022-04-17|archive-date=2022-04-26|archive-url=https://web.archive.org/web/20220426145927/https://www.edelweb.eu/Simula/sig-5.pdf}}</ref>；过程的参数传送模态，除了有[[求值策略#传值调用|传值调用]]和[[求值策略#传名调用|传名调用]]<ref>{{cite web|url=http://www.masswerk.at/algol60/report.htm|title=Revised Report on the Algorithmic Language Algol 60|author=Peter Naur, et al|quote=Name replacement (call by name). Any formal parameter not quoted in the value list is replaced, throughout the procedure body, by the corresponding actual parameter, after enclosing this latter in parentheses wherever syntactically possible. Possible '''conflicts''' between identifiers '''inserted''' through this process and other identifiers already present within the procedure body will be avoided by suitable systematic changes of the formal or local identifiers involved.|access-date=2022-04-14|archive-date=2007-06-25|archive-url=https://web.archive.org/web/20070625171638/http://www.masswerk.at/algol60/report.htm}}<br />{{Cite web|url=https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf|author={{en-link|David Turner|David Turner (computer scientist)|D. A. Turner}}|title=Some History of Functional Programming Languages|publisher=in an invited lecture TFP12, St Andrews University|date=12 June 2012|quote=Algol 60 is not normally thought of as a functional language but its rules for procedures (the Algol equivalent of functions) and variable binding were closely related to those of [[λ演算|λ-calculus]]. <br />The Revised Report on Algol 60 (Naur 1963) is a model of precise technical writing. It defines the effect of a procedure call by a copying rule with a requirement for systematic change of identifiers where needed to avoid variable capture — exactly like β-reduction. <br />Although formal parameters could be declared value the default parameter passing mode was call by name, which required the actual parameter to be copied unevaluated into the procedure body at every occurrence of the formal parameter. This amounts to normal order reduction (but not {{en-link|图归约|Graph reduction|graph reduction}}, there is no sharing). The use of call by name allowed an ingenious programming technique: {{en-link|Jensen设备|Jensen's device|Jensen’s Device}}.|access-date=2022-05-04|archive-date=2020-04-15|archive-url=https://web.archive.org/web/20200415053847/https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf}}</ref>，在Simula 67中，又增加了[[求值策略#传引用调用|传引用调用]]。过程和块都不可能建立到它或它内部的引用<ref name="proc" />；对于一个给定块，有可能生成它的一些可以共存和交互的实例<ref name="cls" />，例如[[递归|递归]]过程的实例<ref>{{cite web|url=http://www.masswerk.at/algol60/report.htm|title=Revised Report on the Algorithmic Language Algol 60|author=Peter Naur, et al|quote=Any occurrence of the procedure identifier within the body of the procedure other than in a left part in an assignment statement denotes activation of the procedure.|access-date=2022-04-14|archive-date=2007-06-25|archive-url=https://web.archive.org/web/20070625171638/http://www.masswerk.at/algol60/report.htm}}</ref>。
*定义函数指示符的值的过程，以类型声明符作为其过程声明的最先{{en-link|符号 (编程)|Symbol (programming)|符号}}<ref>{{cite web|url=http://www.masswerk.at/algol60/report.htm|title=Revised Report on the Algorithmic Language Algol 60|author=Peter Naur, et al|quote=Values of function designators. For a procedure declaration to define the value of a function designator there must, within the procedure declaration body, occur one or more explicit assignment statements with the procedure identifier in a left part; at least one of these must be executed, and the type associated with the procedure identifier must be declared through the appearance of a type declarator as the very first symbol of the procedure declaration. The last value so assigned is used to continue the evaluation of the expression in which the function designator occurs.|access-date=2022-04-14|archive-date=2007-06-25|archive-url=https://web.archive.org/web/20070625171638/http://www.masswerk.at/algol60/report.htm}}</ref>。此外的真正（proper）过程，在Simula 67中，被称为具有普遍（universal）类型，任何类型都从属（subordinate）于普遍类型。在Simula 67中，过程的参数列表<code>( … <small><参数分界符></small> … )</code>，舍弃了其中对[[ALGOL_60|ALGOL 60]]是可选的“<code>) <small><字母串></small>: (</code>”样式的参数{{en-link|分界符|Delimiter}}<ref>{{cite web|url=http://www.masswerk.at/algol60/report.htm|title=Revised Report on the Algorithmic Language Algol 60|author=Peter Naur, et al|quote=Parameter delimiters. All parameter delimiters are understood to be equivalent. No correspondence between the parameter delimiters used in a procedure statement and those used in the procedure heading is expected beyond their number is the same. Thus the information conveyed by using the elaborate ones is entirely optional.|access-date=2022-04-14|archive-date=2007-06-25|archive-url=https://web.archive.org/web/20070625171638/http://www.masswerk.at/algol60/report.htm}}</ref>。
*过程的缺省的传送模态，在Simula 67中，对于值类型的参数是传值调用，对于所有其他类型的参数是传引用调用；故而在过程声明的参数规定中，增加了以<code>name</code>为前导的名字部份，用来指定所述及的参数采用传名调用。在过程主体内传名调用的形式参数的每次出现，都引起对实际参数的一次[[eval|求值]]。在Simula 67中，这个求值发生在过程语句的上下文中，就是说不会出现标识符冲突，因为过程主体和它的变量此时是不可见的。
*过程调用的执行，在有参数的情况下要经历如下步骤：建立形式参数块实例；求值对应于传值调用或传引用调用的实际参数，并将其结果赋值给形式参数块实例的对应变量<ref>{{cite web|url=http://www.masswerk.at/algol60/report.htm|title=Revised Report on the Algorithmic Language Algol 60|author=Peter Naur, et al|quote=Value assignment (call by value). All formal parameters quoted in the value part of the procedure declaration heading are assigned the values ( …… ) of the corresponding actual parameters, these assignments being considers as being performed explicitly before entering the procedure body. The effect is as though an additional block embracing the procedure body were created in which these assignments were made to variables local to this fictitious block with types as given in the corresponding specifications ( …… ). As a consequence, variables called by value are to be considered as '''nonlocal''' to the body of the procedure, but local to the fictitious block ( …… ).|access-date=2022-04-14|archive-date=2007-06-25|archive-url=https://web.archive.org/web/20070625171638/http://www.masswerk.at/algol60/report.htm}}</ref>；过程主体被初始化并开始执行。

块实例的想法，在Simula 67中还进一步产生出，一个块作为“[[对象_(计算机科学)|对象]]”的“[[类_(计算机科学)|类]]”的概念，这些对象每个都是这个块的动态实例，因此符合相同的模式。介入扩展的块概念，要通过类声明和关联的交互机制，比对象引用、远程访问、准并行运算和块串接。

===对象与类===
Simula 67的中心概念是[[对象_(计算机科学)|对象]]，一个对象是一段{{en-link|自给自足|Self-sustainability|自备式}}（self-contained）程序（块实例），它拥有由一个[[类_(计算机科学)|类]]声明定义的自己的局部数据和行动（action）。操纵对象和相互关联对象的需要，致使语言必须介入[[列表_(抽象数据类型)|列表]]处理设施。

类是一种[[子程序|过程]]<ref>{{cite book|title=Structured Programming|author1= [[Ole-Johan_Dahl|O. -J. Dahl]]|author2= [[C._A._R._Hoare|C. A. R. Hoare]]|editor=[[C._A._R._Hoare|C. A. R. Hoare]]|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175–220|chapter=Hierarchical Program Structures|url=https://dl.acm.org/doi/pdf/10.5555/1243380.1243383|quote=A procedure which is capable of giving rise to block instances which survive its call will be known as a class; and the instances will be known as objects of that class. A class may be declared, with or without parameters, in exactly the same way as a procedure ……}}</ref>，它有能力引起在它被调用后仍存活的一个块实例，而这些实例就叫做这个类的对象。类声明定义一个程序（数据和行动）[[模式|模式]]，而符合（conforming）这个模式的对象被称为“属于相同的类”。
*对于一个给定对象，形式参数，在由<code>virtual:</code>前导的[[虚拟|虚拟]]部份中规定的[[量_(物理)|量]]，和声明为局部于类主体（body）的量，叫做这个对象的[[特性_(计算机科学)|特性]]（attribute）。一个特性的声明或规定叫做特性定义。在1986年修订的语言标准中，通过由<code>hidden</code>亦或<code>protected</code>前导的保护规定，可以限制类特性标识符的可见性。
*类声明的形式参数，不适用[[求值策略#传名调用|传名调用]]<ref name="byname" />。在规定部份中需要对每个形式参数进行规定，这些参数被当作局部于类主体的变量，可以接受如下规定符（specifier）：<code><small><类型></small></code>、<code>[[数组|array]]</code>和<code><small><类型></small> array</code>。
*类主体通常是一个[[块_(编程)|块]]，即使它如语法形式所允许的那样是块以外的一个语句，也表现得如同一个块。一个分裂（split）主体，担当其中符号<code>inner</code>表示一个[[虚设代码|虚设]]（dummy）语句的块。

不同于后来的将对象作为[[记录|记录]]或[[结构体_(C语言)|结构]]的扩展的[[面向对象编程|面向对象编程]]语言，Simula 67的类主体中除了有定义特性的声明，还可以有定义行动的语句。如果有行动定义在一个类声明中，则符合这个模式的行动，可以由属于这个类的所有对象执行。如果在类声明中没有指定行动，则定义了一类纯[[数据结构|数据结构]]。例如：
<syntaxhighlight lang="ObjectPascal">
class Order (number); integer number;
    begin integer numberOfUnits, arrivalDate;
          real processingTime;
    end;
</syntaxhighlight>
属于特定类的对象，通过对象表达式，用对象生成语句<code>new</code>来生成。例如，想要多少就能生成多少属于这个<code>Order</code>类的一个新对象：
<syntaxhighlight lang="ObjectPascal">
new Order (103);
</syntaxhighlight>

属于一个对象的行动，可以都在就一个过程而言的一个序列中执行。这些行动，还可以作为一系列的独立子序列或“活动阶段”（active phase）来执行。在一个给定对象的两个活动阶段之间，可以出现任何数目的其他对象的活动阶段。

Simula 67为了将整个程序执行组织为属于对象的活动阶段的一个序列，而包含了其所必需的基本特征。在[[模拟|模拟器]]类<code>Simulation</code>的声明中，定义了叫做“定序集合”（sequencing set）的一个“[[时间轴|时间轴]]”，它也是充当[[队列|队列]]的一个双向列表，还有[[进程|进程]]类<code>Process</code>，它给与对象将其活动阶段通过时间轴来组织的一种[[属性_(编程)|属性]]。

===子类===
一个类可以被用作到另一个类声明的“[[子串|前缀]]”，从而将前缀所定义的属性，建造入这个新的类声明定义的对象之中。具有前缀<code>C</code>和类标识符<code>D</code>的一个类声明，定义了类<code>C</code>的一个[[子类_(计算机科学)|子类]]<code>D</code>。不同于后来的[[面向对象编程|面向对象编程]]语言所称谓的派生类扩展基础类，或子类[[继承_(计算机科学)|继承]]超类（父类），在Simula 67中，类<code>D</code>被称为内部（inner）于类<code>C</code>，而类<code>C</code>被称为外部（outer）于类<code>D</code>。

设<code>C<sub>n</sub></code>是具有前缀序列<code>C<sub>1</sub>, C<sub>2</sub>, ...... C<sub>n-1</sub></code>的一个类，这里<code>C<sub>k</sub></code>（<code>k = 1,2,...,n</code>）的下标<code>k</code>叫做前缀层级，则属于<code>C<sub>n</sub></code>的对象是一个复合对象，它可以用[[串接|串接]]的类声明来正式的描述，串接的过程被认为先于程序执行而发生。
设<code>X</code>是属于<code>C<sub>n</sub></code>的的一个对象。非正式的说，串接机制有如下结果：
*<code>X</code>拥有的特性[[集合_(数学)|集合]]，是在<code>C<sub>1</sub>, C<sub>2</sub>, ... , C<sub>n</sub></code>中所定义集合的[[并集|并集]]。在<code>C<sub>k</sub></code>（<code>1 <= k <= n</code>）中定义的特性，被称为定义在前缀层级<code>k</code>。
*<code>X</code>拥有的“运算规则”，构成自来自在这些类的主体的语句，并且它们依据了预先规定的次序。来自<code>C<sub>k</sub></code>的语句，被称为属于<code>X</code>的前缀层级<code>k</code>。
*在<code>X</code>的前缀层级<code>k</code>的语句，能访问在<code>X</code>的等于或外部于<code>k</code>的前缀层级上定义的它的所有特性，但是不能直接访问由于在外部于<code>k</code>层级的冲突定义而导致不可见的特性。这些不可见特性仍然可以访问，例如通过使用过程或<code>this</code>。
*在<code>X</code>的前缀层级<code>k</code>的语句，不能立即访问在<code>X</code>的内部于<code>k</code>的前缀层级上定义的它的那些特性，除非通过[[虚拟|虚拟]]量。
*在前缀层级<code>k</code>的分裂主体中，符号<code>inner</code>，表示<code>X</code>的属于内部于<code>k</code>的前缀层级的运算规则的那些语句，或者在<code>k = n</code>时表示[[虚设代码|虚设]]语句。如果<code>C<sub>1</sub>, ... , C<sub>n-1</sub></code>都没有分裂主体，则在<code>X</code>的运算规则中的那些语句，依据升序前缀层级来排序。
下面是一个简单例子：
<syntaxhighlight lang="ObjectPascal">
Order class BatchOrder;
    begin integer batchSize;
          real setupTime;
    end;

Order class SingleOrder;
    begin real setupTime, finishingTime, weight; end;

SingleOrder class Plate;
    begin real length, width; end;
</syntaxhighlight>
属于这些[[子类|子类]]如<code>BatchOrder</code>、<code>SingleOrder</code>和<code>Plate</code>的新对象，都有为<code>Order</code>定义的数据，再加上在各种类声明中定义的补充数据。例如，属于类<code>Plate</code>的对象，构成自如下信息片段：<code>Order</code>定义的<code>number</code>、<code>numberOfUnits</code>、<code>arrivalDate</code>和<code>processingTime</code>，<code>SingleOrder</code>定义的<code>setupTime</code>和<code>finishingTime</code>，<code>Plate</code>定义的<code>weight</code>、<code>length</code>和<code>width</code>。

有前缀（prefixed）块的一个实例，是由块前缀生成的对象，与这个主体块的实例，串接而成一个复合对象，其串接定义类似于类的串接规则。块前缀的类的形式参数，按块前缀的实际参数所示初始化。对有前缀块有两个限制：在其中通过使用<code>this</code>来引用到类自身的类，是非法的块前缀。一个块前缀的类标识符所提及的类，必须局部于最小的包围这个有前缀块的块。

===引用===
当属于各种类的很多对象，作为同一个程序的各部份而共存的时候，需要能够对个体对象指定名字，为此介入了叫做“[[参照|引用]]”的新的基本[[数据类型|类型]]；还要能相互关联对象，比如通过二叉树和各种其他类型的[[列表_(抽象数据类型)|列表]]结构，为此将叫做“[[集合_(数学)|集合]]”的[[链表|循环双向链表]]，作为一个系统类<code>Simset</code>介入为语言的一部份。

在Simula 67中有两种引用类型，对象引用类型和[[文本|文本]]引用。对于一个类对象（类实例），有一个关联的唯一的“对象引用”确认这个对象，并且对于任何类<code>C</code>，都有一个关联的对象[[引用类型|引用类型]]<code>ref (C)</code>。这种类型的[[量_(物理)|量]]，被称为由类<code>C</code>限定；它的值，要么是一个对象，要么是表示“没有对象”特殊值<code>none</code>。

限定（qualification）将值的范围，限制至包括在限定类中的这些类的对象。不管何种限定，值的范围都包括值<code>none</code>。一个对象引用的限定，是一个类标识符，它因此服从声明的作用域和{{en-link|可见性 (去歧义)|Visibility (disambiguation)|可见性}}规则。限定关联于所提及的类声明局部于的那个块的一个实例。这蕴涵着特定的关于限定有效性的检查，不能单独在程序正文的基础上进行，因此这种测试必须在程序执行期间完成。

[[参照|引用]]是有限定的，蕴涵着一个给定引用所提及的对象，只能属于这个限定中提到的类，或属于这个限定类的子类。如果一个对象引用类型的限定，是另一个对象引用类型的限定类的子类，则前者被称为从属于后者。例如：
<syntaxhighlight lang="ObjectPascal">
ref(Order) next, previous;
</syntaxhighlight>

对象表达式是获得对一个对象的引用的一种规则。对象表达式的值，是被引用的对象或<code>none</code>。制作一个引用来提及一个特定对象的[[算子_(編程)|运算符]]，写为<code>:-</code>并读作“指称”（denote），它指示将一个引用，[[赋值语句|赋值]]给在引用赋值左侧的、引用类型[[变量_(计算机科学)|变量]]或引用类型[[子程序|过程]]标识符。例如：
<syntaxhighlight lang="ObjectPascal">
next :- new Oreder(101);
previous :- next;
next :- new Plate(50);
</syntaxhighlight>
而运算符<code>:=</code>读作“成为”（become），指示将一个值，赋值给在值赋值左侧的、值类型变量或值类型过程标识符，或者将一个[[文本|文本]]值，赋值给在左侧者所引用的文本[[帧|帧]]（frame）。

===对象表达式===
对象{{en-link|表达式 (计算机科学)|Expression (computer science)|表达式}}，具有[[数据类型|类型]]<code>ref(<small>限定</small>)</code>。对象表达式的限定规则包括：对象生成式、局部对象或限定对象，分别由跟随符号<code>new</code>、<code>this</code>或<code>qua</code>的标识符的类来限定。

对象生成式（generator），涉及到属于所确认的类的对象的生成和执行。这个对象是相应的（串接成的）类的一个新实例。对象生成式的求值构成自如下行动：
#生成这个对象，并且这个对象生成式如果有实际参数，则求值它们，将得到的这些值{{en-link|及或|And/or}}引用传送给形式参数。
#[[控制|控制]]经过这个对象最初的<code>begin</code>进入其中，借此它变成在“系附”状态下运行。在生成的对象执行了<code>detach</code>基本过程，或者经过这个对象最终的<code>end</code>退出的两种情况之一时，对象生成式的求值完成。
求值之后的对象的状态，要么是“脱离”要么是“终止”，详见后面的[[#块实例|块实例]]章节。

{{en-link|this (计算机科学)|this (computer programming)|局部对象}}{{code|this C|"java"}}，如果用在类<code>C</code>或<code>C</code>的任何子类的类主体中，或用在其块限定为类<code>C</code>或<code>C</code>的一个子类的连接块中，则这个对象表达式是有效的。在一个给定的上下文中，一个局部对象的值，是一个对象或连接到一个对象，它是这个对象表达式在其中有效的、最小的字面上包围的块实例；如果没有这样的块，则这个对象表达式在这个上下文中是非法的。对于一个过程或类主体的实例（上下文），“字面上包围”意为包含它的声明。如此定义的内涵参见示例章节中的[[#二叉树|二叉树]]实例。

设<code>X</code>表示一个简单的引用表达式，而<code>C</code>和<code>D</code>是类标识符，使得类<code>D</code>是对象<code>X</code>的限定。对于限定对象<code>X qua C</code>，如果类<code>C</code>外部于或等于类<code>D</code>，或者是<code>D</code>的一个子类，则这个对象表达式是合法的，否则是为非法。如果<code>X</code>的值是<code>none</code>，或者是属于外部于<code>C</code>的类的一个对象，则这个对象表达式求值形成一个运行时间错误；在其他情况下，<code>X qua C</code>的值，就是<code>X</code>的值。这种对一个串接的类对象的即时限定，约束或扩展它的特性通过检视或远程访问的可见性。

对象[[二元关系|关系]]表达式，使用运算符<code>is</code>和<code>in</code>，来测试一个对象的类[[元素_(数学)|成员]][[二元关系|关系]]。关系<code>X is C</code>，在<code>X</code>引用属于类<code>C</code>的对象之时，值为<code>true</code>，否则值为<code>false</code>。关系<code>X in C</code>，在<code>X</code>是引用属于<code>C</code>的对象，或者<code>X</code>是内部于<code>C</code>的类之时，值为<code>true</code>，否则值为<code>false</code>。

不同于[[算术|算术]][[二元关系|关系]]表达式使用比较运算符<code>=</code>和<code><></code>，对象引用关系表达式，使用比较运算符<code>==</code>和<code>=/=</code>，来比较引用，从而区别于对应的被引用的值。两个对象引用<code>X</code>和<code>Y</code>，在它们都引用相同的对象，或者它们都是<code>none</code>之时，被称为是“{{en-link|同一性 (面向对象编程)|Identity (object-oriented programming)|同一}}”的。关系<code>X==Y</code>，在这种情况下拥有的值为<code>true</code>，否则值为<code>false</code>。关系<code>X=/=Y</code>的值，是<code>X==Y</code>的值的[[否定|否定]]。

===远程访问===
一个对象的一个特定[[特性_(计算机科学)|特性]]，由下列三项信息来完全确认（identify）：
#这个[[对象_(计算机科学)|对象]]。
#外部于或等于这个对象的类的一个[[类_(计算机科学)|类]]。
#在这个类中或在属于它的前缀序列的任何类中定义的一个[[特性_(计算机科学)|特性]][[标识符_(计算机语言)|标识符]]。

对于任何特性确认，第2项类信息都是在字面上定义的，从而形成[[名字绑定|静态绑定]]<ref>{{cite web|url=https://www.mn.uio.no/ifi/english/about/ole-johan-dahl/bibliography/the-birth-of-object-orientation-the-simula-languages.pdf|title=The Birth of Object Orientation: the Simula Languages|author=[[Ole-Johan_Dahl|Ole-Johan Dahl]]|year=2001|quote=In general attribute identifiers may be redeclared in subclasses, as is the case of inner blocks. The identity of an attribute is determined by the prefix level of the accessing occurrence, or, if the access is remote, by the class qualifying the object reference in question. In this way any ambiguity of identifier binding is resolved textually, i.e at compile time; we call it '''static binding'''.|access-date=2022-04-13|archive-date=2021-08-10|archive-url=https://web.archive.org/web/20210810223830/https://www.mn.uio.no/ifi/english/about/ole-johan-dahl/bibliography/the-birth-of-object-orientation-the-simula-languages.pdf}}</ref>。属于其他对象的特性，可以要么通过“远程标识符”（“[[点表示法|点表示法]]”），要么通过“连接”（connection）机制，从其外侧“远程访问”来引用和使用。远程标识符的形式为：<code><small>简单对象表示式</small>.<small>特性标识符</small></code>，它可用作简单变量、数组变量、函数指示符（designator）<ref name="func">{{cite web|url=http://www.masswerk.at/algol60/report.htm|title=Revised Report on the Algorithmic Language Algol 60|author=Peter Naur, et al|quote=Function designators define single numerical or logical values which result through the application of given sets of rules defined by a procedure declaration ( …… ) to fixed sets of actual parameters.|access-date=2022-04-14|archive-date=2007-06-25|archive-url=https://web.archive.org/web/20070625171638/http://www.masswerk.at/algol60/report.htm}}</ref>和过程语句<ref>{{cite web|url=http://www.masswerk.at/algol60/report.htm|title=Revised Report on the Algorithmic Language Algol 60|author=Peter Naur, et al|quote=A procedure statement serves to invoke (call for) the execution of a procedure body ( …… ). Where the procedure body is a statement written in Algol the effect of this execution will be equivalent to the effect of performing the following operations on the program at the time of execution of the procedure statement.|access-date=2022-04-14|archive-date=2007-06-25|archive-url=https://web.archive.org/web/20070625171638/http://www.masswerk.at/algol60/report.htm}}</ref>中的标识符，这种点表示法给出对信息的单独片段的访问，例如：
<syntaxhighlight lang="ObjectPascal">
if next.number >= previous.number then ......;
</syntaxhighlight>
它将名为<code>next</code>的类<code>Order</code>的对象的特性<code>number</code>，比较于名为<code>previous</code>的类<code>Order</code>的对象的特性<code>number</code>。

“组访问”可通过“连接语句”来完成，连接机制的用途，是为在连接块中的特定识别，提供上述第1项对象信息和第2项类信息的隐式定义。例如：
<syntaxhighlight lang="ObjectPascal">
inspect next when Plate do begin ...... end;
inspect new Plate(50) do begin ...... end;
</syntaxhighlight>
在检视（inspection）块的<code>begin</code>和<code>end</code>之间的语句中，可以直接提及<code>next</code>所引用的在<code>Plate</code>中包含的所有信息片段。<code>do</code>后面的语句，如果是块以外的一个语句，它表现得也如同一个块。连接语句进而表现得如同被叫做“连接块”的第二个[[虚构|虚构]]（fictitious）的块所包围。

设对象表达式求值为<code>X</code>，在连接块执行期间，称对象<code>X</code>为“被连接上”了。连接块有一个关联的“块限定”，它是连接块的前导类标识符，而对于没有<code>when</code>子句的情况，它是连接块的前导对象表达式的限定。

===虚过程===
[[虚拟|虚拟]]（virtual）[[量_(物理)|量]]，有双重用途：
*允许在一个对象的一个前缀层级上，访问在内部前缀层级上声明的特性。
*允许在一个前缀层级上的特性重新定义，在外部前缀层级上有效。

在类声明的虚拟部份中，可以接受如下规定符：<code>[[標記_(程式語言)|label]]</code>、<code>switch</code><ref name="switch" />、<code>procedure</code>和<code><small><类型> </small>procedure</code>。不同于一般的特性确认，[[虚函数|虚过程]]形成半[[动态分派|动态绑定]]<ref name="virt">{{cite web|url=https://www.mn.uio.no/ifi/english/about/ole-johan-dahl/bibliography/the-birth-of-object-orientation-the-simula-languages.pdf|title=The Birth of Object Orientation: the Simula Languages|author=[[Ole-Johan_Dahl|Ole-Johan Dahl]]|year=2001|quote=On the other hand, if a procedure <code>P</code> is specified as '''virtual''' in a class <code>C</code> the binding scheme is '''semi-dynamic'''. Any call for <code>P</code> occurring in <code>C</code> or in any subclass of <code>C</code> will bind to that declaration of <code>P</code> which occurs at the innermost prefix level of the actual object containing such a declaration (and similarly for remote accesses). Thus, the body of the procedure <code>P</code> may, at the prefix level of <code>C</code>, be postponed to occur in any subclass of <code>C</code>. It may even be replaced by more appropriate ones in further subclasses.<br />This binding scheme is dynamic in the sense that it depends on the class membership of the actual object. But there is nevertheless a degree of compiler control; the access can be implemented as indirect through a '''{{en-link|虚方法表|Virtual method table|table}}''' produced by the compiler for <code>C</code> and for each of its subclasses. ……<br />a virtual procedure can be seen as a '''parameter''', where the actual parameter is a procedure residing safely within the object itself, at an appropriate prefix level. There is the additional advantage that the procedure has direct access to attributes of the object containing it.|access-date=2022-04-13|archive-date=2021-08-10|archive-url=https://web.archive.org/web/20210810223830/https://www.mn.uio.no/ifi/english/about/ole-johan-dahl/bibliography/the-birth-of-object-orientation-the-simula-languages.pdf}}</ref>，在某种意义上类似于[[ALGOL_60|ALGOL 60]]的[[求值策略#传名调用|传名调用]]机制<ref name="byname">{{cite web |title=The Development of the Simula Languages |url=https://phobos.ramapo.edu/~ldant/datascope/simula%20history.pdf |author1=[[Kristen_Nygaard|Kristen Nygaard]] |author2=[[Ole-Johan_Dahl|Ole-Johan Dahl]] |date=1978 |quote=the ALGOL-like '''call by name''' parameters were out of the question for reasons of security and storage allocation strategy: the actual parameter could be lost during the lifetime of an object. The problem then was to find a '''name-parameter-like''' mechanism that would guarantee a safe place for the actual parameter. After much trial and error we hit on the virtual quantity concept where the actual would have to be declared in the object itself, but at a deeper subclass level than that of the '''virtual''' specification. Now generalized objects could be defined whose behaviour pattern could be left partly unspecified in a prefix class body. Different subclasses could contain different actual procedure declarations. |access-date=2022-03-14 |archive-date=2022-01-20 |archive-url=https://web.archive.org/web/20220120192521/https://phobos.ramapo.edu/~ldant/datascope/simula%20history.pdf }}</ref>。

一个对象的一个虚拟量，要么是“无匹配的”的，要么被确认为具有一个“匹配”特性，它是在这个虚拟量的前缀层级上或在内部前缀层级上声明的，其标识符{{en-link|重合|Coincidence}}（coincide）于虚拟量的标识符的一个特性。匹配特性必须与虚拟特性有相同的种类。在一个给定前缀层级上的匹配量的类型，必须重合或从属于这个虚拟规定的类型，和在任何外部前缀层级上声明的任何匹配量的类型。

在1986年修订的语言标准中，[[虚函数|虚过程]]量可选的可使用<code>procedure <small><过程标识符></small> <small><过程规定></small></code>方式来指定，即凭借它的类型，并且如果它有形式参数，则还凭借它们的类型、种类和传送模态。含有[[子程序|过程]]规定<code>is <small><过程声明></small></code>的虚过程量，只能由有相同类型的过程来匹配，并它与这个过程规定具有相同的过程头部。

例如，下面实现[[散列表|散列表]]的<code>Hashing</code>类，声明了虚过程<code>hash</code>并随即实现了它，又定义了要用到[[散列函数|散列过程]]<code>hash</code>的查找过程<code>lookup</code>:
<syntaxhighlight lang="ObjectPascal">
class Hashing (n); integer n;
    virtual: integer procedure hash;
begin 
    integer procedure hash(t); text t;
    begin ...... end hash;
    text array table (0:n-1); integer entries;
    integer procedure lookup (t,old);
        name old; Boolean old; text t;
    begin ...... end lookup;
end Hashing;

Hashing class ALGOL_hash;
begin
    integer procedure hash(T); text T;
    begin ...... end hash;
end ALGOL_hash;

Hashing(64) begin
    integer procedure hash(T); text T;
    begin ...... end hash;
    ......
end
</syntaxhighlight>
子类<code>ALGOL_hash</code>和有前缀块，用自己的<code>hash</code>过程实现替代了其前缀中的实现。在子类的类主体和有前缀块的主要块中，能获得到过程<code>lookup</code>，而它用到的过程<code>hash</code>是这里提供的替代实现。

===作用域和可见性===
一个标识符[[定义|定义]]及其关联的标识符，在其[[作用域|作用域]]与{{en-link|可见性 (去歧义)|Visibility (disambiguation)|可见性}}之间需要做出区别。
*一个标识符定义的[[作用域|作用域]]，是它在其中可能有作用的那一部份程序正文。相同的标识符，可以定义在程序的很多地方，因此可以关联于不同的量。这种相同的标识符的作用域，因而可能重叠，例如当一个标识符在内部块中被重新声明的情况下。
*一个标识符定义，这个标识符在程序的一个给定点上，如果能够涉及到所论及声明的量，则这个定义被称为在这个点上是{{en-link|可见性 (去歧义)|Visibility (disambiguation)|可见}}的。在给定标识符于此可见的程序正文的一个特定点上，最多只能有一个定义关联于这个标识符，例如在上述重新声明的情况下，在它们作用域的并集内任何给定点上，只有一个定义是可见的。

一个[[标识符|标识符]][[定义|定义]]的局部块，是在字面上最近的包围块，即子块、前缀块、过程主体或类主体，还包括围绕<code>for</code>语句的受控语句、过程声明或类声明的虚构的块、连接块等等。这个标识符和它的定义，被称为局部于这个块。
标识符[[定义|定义]]，只在它们的[[作用域|作用域]]内是可见的。一个特定定义的可见性，在它的作用域内可以受到下列限制：
*具有相同标识符的一个标识符定义，即这个标识符的重新定义，出现在以前的定义的局部块所包围的某个构造内。在它们共同的作用域内，只有最内部的重新定义是可见的。
*一个重新定义，出现在类的某个内部前缀层级。
*远程访问，可以导致某些标识符定义在检视块或点表示法内变成不可见的。
*使用<code>this</code>或<code>qua</code>，可以导致一个或多个重新定义被临时停止。
*这个定义所局部于的类声明的保护部份。
一个标识符的重新定义，不允许出现在它的局部块的头部，这禁止了在同一个块中出现相同标识符的两个定义。

具有形式参数的过程，在特定意义上表现得如同有一个虚构的块包围着过程主体。形式参数因而对应于声明为局部于这个虚构的块的变量。因此，一个过程的形式参数，可以在属于这个过程声明的过程主体的头部内被重新定义。这种重新定义，将这个形式参数的可见性，有效的限制至与它有关的<code>value</code>部份、<code>name</code>部份和规定部份。因此这种参数的唯一作用，是来自其[[eval|求值]]可能有的[[副作用_(计算机科学)|副作用]]。

除非在它的定义之内，一个标识符的所有出现，都具有动态方面。这样的一个标识符，不仅涉及它的静态定义，还涉及到从这个定义所局域于的那个声明生成的某个对象。例如，在一个过程或类声明之内出现的一个形式参数标识符，参照这个过程或类的某个实例化的对象。

===块实例===
一个{{en-link|执行 (计算)|Execution (computing)|程序执行}}的组成部份，都是[[块_(编程)|块]]即子块、有前缀块、连接块和类主体的动态实例。一个块实例，被称为“局部于”直接包含它的描述文本的那个块实例。例如一个给定类的实例，局部于包含这个类声明的块实例。最外层块的实例不局部于块实例。

在任何时间，“程序顺序控制”（Program Sequence Control），首字母简写为PSC，[[参照|参照]]在一个块实例中当前被执行的[[顺序点|程序点]]；PSC被“[[記憶體位址|定位]]”于这个程序点并被这个块实例所“包含”。进入任何块，都涉及到生成这个块的一个实例，于是PSC进入这个块实例，到达它的第一个可执行语句上。

一个块实例在任何时间，都是处在四种执行{{en-link|状态 (计算机科学)|State (computer science)|状态}}之一：系附（attached）、脱离（detached）、恢复（resumed）或终止（terminated）。没有在字面上给出前缀的任何类，都被定义为前缀了一个[[虚构|虚构]]（fictitious）的类，它只有一个特性即<code>detach</code>过程，因此所有类对象或有前缀块的实例，都拥有<code>detach</code>过程。在[[运行时系统|环境]]类<code>ENVIRONMENT</code>中，还定义了用于[[调度_(计算机)|调度]]的<code>call</code>过程和<code>resume</code>过程。
*一个非类块实例，也就是有前缀块、子块、过程主体或连接块的实例，总是在系附状态下，这个实例被称为系附到了导致它生成的那个块上。因此一个过程体的实例，系附到包含对应函数指示符或过程语句的块实例上。非类、非过程块实例，系附到它所局部的块实例。在PSC到达非类块实例的最终的<code>end</code>的时候，PSC返回到紧随导致这个块实例生成的语句或表达式的程序点。
*一个对象，最初是在系附状态下，并被称为系附到包含对应对象生成语句的那个块实例上。一个对象，可以通过执行<code>detach</code>语句，进入脱离状态。通过执行<code>call</code>语句，可以使一个脱离状态的对象重新进入系附状态，它借此变为系附到包含这个调用语句的那个块实例上。通过执行<code>resume</code>语句，可以使一个脱离状态的对象进入恢复状态。不使用<code>detach</code>、<code>call</code>或<code>resume</code>语句的一个程序执行，是一个简单的系附状态的块的嵌套结构。
*当PSC通过一个对象的最终<code>end</code>，或通过<code>goto</code>语句离开它的时候，这个对象进入终止状态。没有块实例系附到一个终止状态的类对象上。终止状态的对象，仍作为一个数据项而存在，它可以通过针对这个对象的包括过程和函数特性的这些特性的远程标识来引用。

每当一个块实例不复存在，局部于或系附于它的所有块实例也不复存在。一个对象的动态作用域，因而受限于它的类声明的作用域。在Simula 67最初标准中曾提到过，语言实现可以使用[[垃圾回收_(计算机科学)|垃圾回收]]技术<ref name="gc">{{cite book|title=Structured Programming|author1= [[Ole-Johan_Dahl|O. -J. Dahl]]|author2= [[C._A._R._Hoare|C. A. R. Hoare]]|editor=[[C._A._R._Hoare|C. A. R. Hoare]]|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175–220|chapter=Hierarchical Program Structures|url=https://dl.acm.org/doi/pdf/10.5555/1243380.1243383|quote=In SIMULA 67, a block instance is permitted to outlive its calling statement, and to remain in existence for as long as the program needs to refer to it. It may even outlive the block instance that called it into existence. As a consequence, it is no longer possible to administer storage allocation as a simple stack; a general '''garbage-collector''', including a scan-mark operation, is required to detect and reclaim those areas of store (local workspace of block instances) which can no longer be referenced by the running program. The reason for accepting this extra complexity is that it permits a wider range of concepts to be conveniently expressed. In particular, it clarifies the relationship between data and the operations which may be performed upon it, in a way which is awkward or impossible in ALGOL 60.}}</ref>，来进一步缩减一个对象的有效寿命的[[跨度|跨度]]。一个数组声明的动态作用域，可以扩展超出包含这个声明的块实例的作用域，因为[[求值策略#传引用调用|传引用调用]]参数传送模态适用于数组。

===准并行系统===
一个准[[并行计算|并行]][[系统|系统]]<ref>{{cite web |title=The Development of the Simula Languages |url=https://phobos.ramapo.edu/~ldant/datascope/simula%20history.pdf |author1=[[Kristen_Nygaard|Kristen Nygaard]] |author2=[[Ole-Johan_Dahl|Ole-Johan Dahl]] |date=1978 |quote=In ALGOL, blocks (including procedures) are seen externally as generalized operations. By introducing mechanisms for '''quasi-parallel''' sequencing, essentially the same construct could play the role of processes in parallel, and through mechanisms for naming block instances and accessing their contents they could function as generalized data objects. The essential benefits of combining data and operations in a single construct were already there to be explored. |access-date=2022-03-14 |archive-date=2022-01-20 |archive-url=https://web.archive.org/web/20220120192521/https://phobos.ramapo.edu/~ldant/datascope/simula%20history.pdf }}</ref>，由一个子块或有前缀块的任何实例所标识，它包含局部的类声明。这个标识一个系统的块实例，叫做“系统头领”。最外层的标识一个系统的块实例，被称为“最外层系统”。一个准并行系统，由“[[基于组件的软件工程|组件]]”（component）构成。组件是块实例组成的[[树_(数据结构)|嵌套结构]]，其中标识这个组件的一个块实例，叫做“组件头领”。

在每个系统中，组件中有一个被称为“主干组件”，在Simula 67最初标准中叫做“主程序”，其他组件叫做“对象组件”。一个系统的主干组件的头领（head），{{en-link|重合|Coincidence}}（coincide）于系统头领，它总是处在系附状态。一个系统的对象组件的头领，确切的就是局部于系统头领的那些脱离状态的或恢复状态的对象。
*在任何时间，在一个系统的组件之中，有确切的一个组件被称为“生效”（operative）的。不生效的组件，有关联的“重新激活点”，它标识在这个组件被激活（activate）时，要在它那里继续执行的程序点。一个对象组件是生效的，当且仅当这个组件的头领处在恢复状态。
*除了系统组件，程序执行还可以包含不属于特定系统的“独立对象组件”。任何这种组件的头领，都是一个脱离状态的对象，它局部于一个类对象或过程主体的一个实例，也就是说不局部于系统头领（子块或有前缀块的实例）。根据定义，独立组件总是不生效的。

称谓一个块实例<code>X</code>被一个块实例<code>Y</code>“动态包围”，当且仅当存在一个块实例序列：<code>(X = Z<sub>0</sub>) → Z<sub>1</sub> → .... → Z<sub>n-1</sub> → (Z<sub>n</sub> = Y)</code> <code>(n>=0)</code>，使得对于<code>i= 1,2,...,n</code>有着：<code>Z<sub>i-1</sub></code>系附到<code>Z<sub>i</sub></code>；或者<code>Z<sub>i-1</sub></code>是一个恢复状态的对象，它关联的系统头领系附到<code>Z<sub>i</sub></code>（而这个系统头领自身不在这个序列中）。终止状态和脱离状态的对象，不被除了自身之外的块实例动态包围。
*将当前包含PSC的块实例动态包围起来的块实例链，叫做“运行[[全序集合|链]]”。在运行链上的块实例，被称为“运行”（operating）的，最外层的块实例总是运行的。一个系统如果有一个组件是运行的，它就是运行的；在任何时间，一个系统最多有一个组件是运行的；运行的系统的头领，可以是不运行的（不在运行链上）。一个运行的组件 ，总是生效的；如果一个系统的生效组件是不运行的，则这个系统也是不运行的。在不运行的系统中的生效的组件，是当这个系统成为不运行的时候在运行的组件，当这个系统再次成为运行的时候它将仍是运行的。
*对于一个不生效的组件<code>C</code>，如果一个块实例<code>P</code>包含了它的重新激活点（而<code>C</code>的重新激活点关联于<code>C</code>的头领），则<code>P</code>被<code>C</code>的头领动态包围，并且<code>P</code>除了自身之外不动态包围块实例。由<code>P</code>与<code>C</code>的头领<code>X</code>“动态{{en-link|合围 (去歧义)|Enclosure (disambiguation)|合围}}”的块实例序列<code>(P = Z<sub>0</sub>) → Z<sub>1</sub> → .... → Z<sub>n-1</sub> → (Z<sub>n</sub> = X)</code> <code>(n>=0)</code>，被称谓为<code>C</code>的“重新激活链”。除了<code>C</code>的头领<code>X</code>（脱离状态的对象）之外，这个链上的所有组件头领（恢复状态的对象），标识了生效而不运行的组件。在<code>C</code>成为运行的时候，在它的重新激活链上所有块也成为运行的。

组件的定序（sequencing），由<code>detach</code>、<code>call</code>和<code>resume</code>支配。<code>detach</code>针对隐式指定的一个对象进行操作，而<code>call</code>和<code>resume</code>显式指定所操作的对象。

===定序===
准并行系统的<code>detach</code>/<code>resume</code>机制，是一种[[协程|协程]]<ref name="cons">{{cite web |title=The Development of the Simula Languages |url=https://phobos.ramapo.edu/~ldant/datascope/simula%20history.pdf |author1=[[Kristen_Nygaard|Kristen Nygaard]] |author2=[[Ole-Johan_Dahl|Ole-Johan Dahl]] |date=1978 |quote=An object would start its life like an instance of a function procedure, invoked by the evaluation of a generating expression. During this phase the object might initialize its own local variables. Then, on passage through the end of the object or as the result of a new basic operation "detach", control would return to the generating expression delivering a reference to the object as the function value. In the former case the object was "terminated" with no further own actions, in the latter case it had become a "detached object" capable of functioning as a "'''coroutine'''". <br />The basic coroutine call "resume (<object reference>)" would make control leave the active object, leaving behind a reactivation point at the end of the resume statement, and enter the referenced object at its reactivation point. |access-date=2022-03-14 |archive-date=2022-01-20 |archive-url=https://web.archive.org/web/20220120192521/https://phobos.ramapo.edu/~ldant/datascope/simula%20history.pdf }}</ref>。在Simula 67最初标准中，没有恢复状态，并且没有规定<code>call</code>，但<code>call</code>通常会出现在当时的语言实现中<ref>{{cite book|author1=[[Ole-Johan_Dahl|Ole-Johan Dahl]]|author2=Bjørn Myhrhaug|url=https://www.edelweb.eu/Simula/sig-16.pdf|title=The Simula Implementation Guide|date=1967, 1973|quote=The procedure "call" is not a part of the Common Base, but is a natural part of a SIMULA 67 Common Base implementation. ……This definition of call is tentative, since the problem is currently being studied by a Technical Committee under the SIMULA Standards Group.|access-date=2022-04-16|archive-date=2022-04-16|archive-url=https://web.archive.org/web/20220416192742/https://www.edelweb.eu/Simula/sig-16.pdf}}</ref>。<code>detach</code>/<code>call</code>机制，相当于现在称为[[生成器_(计算机编程)|生成器]]的“半协程”，而最初标准中的<code>resume</code>可理解为<code>detach</code>与<code>call</code>的组合<ref>{{cite book|title=Structured Programming|author1= [[Ole-Johan_Dahl|O. -J. Dahl]]|author2= [[C._A._R._Hoare|C. A. R. Hoare]]|editor=[[C._A._R._Hoare|C. A. R. Hoare]]|publisher=Academic Press|year=1972|isbn=978-0122005503|location=London, UK|pages=175–220|chapter=Hierarchical Program Structures|url=https://dl.acm.org/doi/pdf/10.5555/1243380.1243383|quote=In SIMULA, a coroutine is represented by an object of some class, co-operating by means of resume instructions with objects of the same or another class, which are named by means of reference variables. ……<br />Thus a main program may establish a coroutine relationship with an object that it has generated, using the call/detach mechanism instead of the more '''symmetric''' resume/resume mechanism. In this case, the generated object remains subordinate to the main program, and for this reason is sometimes known as a '''Semicoroutine'''. ……<br />Let <code>X</code> and <code>Y</code> be objects, generated by a "master program" <code>M</code>. Assume that <code>M</code> issues a <code>call (X)</code>, thereby invoking an "'''active phase'''" of <code>X</code>, terminated by a detach operation in <code>X</code>; and then issues a <code>call (Y)</code>, and so forth. In this way <code>M</code> may act as a "supervisor" sequencing a pattern of active phases of <code>X</code>, <code>Y</code>, and other objects. Each object is a "slave", which responds with an active phase each time it is called for, whereas M has the responsibility to define the large scale pattern of the entire computation. <br />Alternatively the decision making may be "decentralised", allowing an object itself to determine its dynamic successor by a resume operation. <br />The operation <code>resume (Y)</code>, executed by <code>X</code>, combines an exit out of <code>X</code> (by <code>detach</code>) and a subsequent <code>call (Y)</code>, thereby bypassing <code>M</code>. Obligation to return to <code>M</code> is transferred to <code>Y</code>.}}</ref>。1986年修订的语言标准，增补定义了<code>call</code>，新增了恢复状态，并且重新定义了<code>resume</code>，它不可再理解为<code>detach</code>与<code>call</code>的组合。

准并行系统，被创建于进入包含局部的类声明的一个子块或有前缀块的时候，借此生成的实例成为这个新系统的头领。初始时，这个主干组件是生效的，并且是这个系统唯一的组件。

建立一个对象组件，要通过针对一个系附状态的对象，执行<code>detach</code>，借此PSC返回到这个对象系附到的那个块实例。这个对象进入脱离状态，并成为一个新的不生效的组件的头领，这个组件的重新激活点被定位到紧后于这个<code>detach</code>。如果这个对象局部于一个系统头领，则这个新的组件成为这个关联的系统的[[元素_(數學)#符号和术语|成员]]。

通过<code>detach</code>和<code>call</code>，可以形成“半对称定序”，这只涉及到对象组件，而不区分它们是属于系统的组件还是独立组件。
*对于一个不生效的对象组件，通过针对它的脱离状态的头领，执行一个<code>call</code>，可以重新激活这个组件，借此PSC移动到它的重新激活点上。这个头领重新进入系附状态，并变成系附到包含这个<code>call</code>的块实例上。这个组件正式的失去了本身（作为组件）的状态。

通过<code>detach</code>和<code>resume</code>，可以形成“对称组件定序”，这只涉及到属于一个准并行系统的那些组件。对立于半对称定序中的“调用者”与它的“被调用者”，在对称组件定序中的“恢复者”与它的“被恢复者”，具有完全的[[对称关系|对称]]联系。
*对于这个系统的一个不生效的对象组件，通过针对它的脱离状态的头领，执行一个<code>resume</code>，可以重新激活这个组件，借此PSC移动到它的重新激活点上；这个组件的头领进入恢复状态，而这个组件变成生效的。这个系统以前生效的组件变成不生效的，并且它重新激活点被定位到紧后于这个<code>resume</code>；如果这个组件是一个对象组件，则它的头领进入脱离状态。
*对于当前生效的对象组件，通过针它的恢复状态的头领，执行一个<code>detach</code>，这个系统的主干组件重获生效的状态，借此PSC移动回到主干组件的重新激活点上。以前生效的组件变成不生效的，并且它重新激活点被定位到紧后于这个<code>detach</code>。这个组件的头领进入脱离状态。

PSC经过一个类对象的最终<code>end</code>的效果，除了使这个对象成为终止状态，而非脱离状态之外，相同于针对这个对象执行<code>detach</code>的效果。其结果是它不会得到重新激活点，并且在它已经拥有作为组件头领的状态时，失去这种状态。

== 程式範例 ==

=== 最小程序 ===
按[[源代码|源代码]]大小来衡量的话，空[[计算机文件|计算机文件]]是Simula 67中最小的[[计算机程序|程序]]，它只包含一个东西，就是虚设[[语句_(程式设计)|语句]]。但是，最小的程序更经常表示为空块：
<syntaxhighlight lang="ObjectPascal">
Begin
End;
</syntaxhighlight>
它开始执行并立即终止。语言缺乏来自程序的任何[[返回语句|返回值]]。

=== Hello, World! ===
Simula 67的经典[[Hello_World|Hello, World!]]範例：
<syntaxhighlight lang="ObjectPascal">
Begin
    OutText ("Hello, World!");
    OutImage;
End;
</syntaxhighlight>
<code>OutText</code>过程将字符串输出到[[缓冲区|缓冲区]]，而<code>OutImage</code>过程将缓冲区内容输出到标准文件，二者都定义在输出文件类<code>OutFile</code>中，而它是文件类<code>File</code>的子类。

===传名调用===
使用传名调用可以轻易实现{{en-link|Jensen设备|Jensen's Device}}，一个简单的例子是{{en-link|算数函数|Arithmetic function|合计函数}}<math>\sum_{k=m}^{n}{u}</math>，它可以实现如下：
<syntaxhighlight lang="ObjectPascal">
Real Procedure Sigma (k, m, n, u);
    Name k, u;
    Integer k, m, n; Real u;
Begin
    Real s;
    k:= m;
    While k <= n Do Begin s:= s + u; k:= k + 1; End;
    Sigma:= s;
End;
</syntaxhighlight>
这个例子对受控变量<code>k</code>和表达式<code>u</code>使用了传名调用。这允许将受控变量<code>k</code>用于表达式<code>u</code>之中。由于Simula 67的<code>[[for循环|for]]</code>循环中受控变量，不能是传名调用的形式参数或过程标识符，故而上述代码使用了<code>while</code>循环。

公式<math> Z = \sum_{i=1}^{100}{1 \over (i + a)^2}</math>可以实现为如下：
<syntaxhighlight lang="ObjectPascal">
Z:= Sigma (i, 1, 100, 1 / (i + a) ** 2);
</syntaxhighlight>

===协程===
Simula 67标准通过如下实例来诠释叫做“准并行系统”的[[协程|协程]]机制：
<syntaxhighlight lang="ObjectPascal" line>
begin comment S1;
    ref(C1) X1;
    class C1;
    begin procedure P1; detach;
        P1
    end C1;
    ref(C2) X2;
    class C2;
    begin procedure P2;
        begin detach;
            ! 可尝试detach或resume(X1);
        end P2;
        begin comment system S2;
            ref(C3) X3;
            class C3;
            begin detach;
                P2
            end C3;
            X3:- new C3;
            resume(X3)
        end S2
    end C2;
    X1:- new C1;
    X2:- new C2;
    call(X2); ! 可尝试resume(X2);
end S1;
</syntaxhighlight>
这个例子程序中，有两个准并行系统<code>S1</code>和<code>S2</code>。<code>S1</code>是最外层系统，它包含了两个类声明<code>C1</code>和<code>C2</code>。<code>S2</code>嵌套入了类<code>C2</code>的类主体之中，它包含了一个类声明<code>C3</code>。

在PSC进入最外层子块后产生系统<code>S1</code>的系统头领，到达第23行的系统<code>S1</code>主干组件的第一个可执行语句，开始生成对象<code>X1</code>，进入类<code>C1</code>，PSC到达第5行的类主体的第一个可执行语句，调用了类<code>C1</code>的特性过程<code>P1</code>，进入第4行的过程体的第一个可执行语句，这时的状况是：
<pre>
[S1] ← (X1) ← (P1) ← PSC
</pre>
这里方括号表示系统头领，圆括号表示其他块实例，左向箭头表示系附。执行第4行的<code>detach</code>语句后，保存对象<code>X1</code>的重新激活点为第4行过程结束，回溯到第23行结束，系统<code>S1</code>的对象<code>X1</code>生成完毕，这时的情况是：
<pre>
[S1] ← PSC
 |
(X1) ← (P1) ← X1重新激活点
</pre>
这里的竖杠连接一个系统的组件头领。PSC到达系统<code>S1</code>主干组件第24行，开始生成对象<code>X2</code>，进入类<code>C2</code>，PSC到达第13行的类主体的第一个可执行语句，进入这个子块产生系统<code>S2</code>的系统头领，PSC到达第19行的系统<code>S2</code>主干组件的第一个可执行语句，开始生成对象<code>X3</code>，进入类<code>C3</code>，PSC到达第16行类主体的第一个可执行语句，这时的情况是：
<pre>
[S1] ← (X2) ← [S2] ← (X3) ← PSC
 |
(X1) ← (P1) ← X1重新激活点
</pre>
执行第16行类主体内的<code>detach</code>语句后，保存对象<code>X3</code>的重新激活点为第17行，回溯到第19行结束，系统<code>S2</code>的对象<code>X3</code>生成完毕，这时的情况是：
<pre>
[S1] ← (X2) ← [S2] ← PSC
 |             |
 |            (X3) ← X3重新激活点
 |
(X1) ← (P1) ← X1重新激活点
</pre>
PSC到达系统<code>S2</code>主干组件的第20行，执行<code>resume(X3)</code>语句后，保存系统<code>S2</code>主干组件的重新激活点为第21行，PSC恢复到第17行的对象<code>X3</code>的类主体之中，这时的情况是：
<pre>
[S1] ← (X2) ← [S2] ← S2重新激活点
 |             |
 |            (X3) ← PSC
 |
(X1) ← (P1) ← X1重新激活点
</pre>
执行第17行的类<code>C2</code>的特性过程<code>P2</code>，到达在第10行的过程体的第一个可执行语句，这时的情况如下，并标记为“状况A”：
<pre>
                                   ! 状况A
[S1] ← (X2) ← [S2] ← S2重新激活点
 |             |
 |            (X3) ← (P2) ← PSC
 |
(X1) ← (P1) ← X1重新激活点
</pre>
执行在第10行<code>P2</code>过程体的<code>detach</code>语句后，保存对象<code>X2</code>的重新激活点为第11行，回溯到第24行结束，系统<code>S1</code>的对象<code>X2</code>生成完毕，这时的情况如下，并标记为“状况B”：
<pre>
                                   ！状况B
[S1] ← PSC
 |
(X1) ← (P1) ← X1重新激活点
 |
(X2) ← [S2] ← S2重新激活点
        |
       (X3) ← (P2) ← X2重新激活点
</pre>
注意对象<code>X3</code>仍是系统<code>S2</code>的生效组件，它并没有自己的重新激活点。PSC进入系统<code>S1</code>主干组件第25行，执行<code>call(X2)</code>后，PSC恢复为第11行的<code>P2</code>过程体之中，这时的情况重现为前面的“状况A”。如果将第25行改写为一个<code>resume(X2)</code>语句，执行后保存系统<code>S1</code>主干组件的重新激活点为第26行，PSC恢复为第11行的<code>P2</code>过程体之中，会出现如下情况：
<pre>
[S1] ← S1重新激活点
 |
(X1) ← (P1) ← X1重新激活点
 |
(X2) ← [S2] ← S2重新激活点
        |
       (X3) ← (P2) ← PSC
</pre>
如果将第11行的注释替换为一个<code>detach</code>语句，执行后保存对象<code>X2</code>的重新激活点是第12行，PSC恢复到第26行的系统<code>S1</code>主干组件之中，这时的情况重现为前面的“状况B”。如果将第11行的注释替换为一个<code>resume(X1)</code>语句，执行后保存对象<code>X2</code>的重新激活点为第12行，PSC恢复到第4行的<code>P1</code>过程体的过程结束，会出现如下情况：
<pre>
[S1] ← S1重新激活点
 |
(X1) ← (P1) ← PSC
 |
(X2) ← [S2] ← S2重新激活点
        |
       (X3) ← (P2) ← X2重新激活点
</pre>

===二叉树===
下面例子中的<code>Tree</code>类，是[[二叉树|二叉]][[树_(数据结构)|树]][[数据结构|数据结构]]实现：
<syntaxhighlight lang="ObjectPascal">
class Tree (val); integer val;
begin
    ref (Tree) left, right;
    procedure insert (x); integer x;
    begin
        if x < val then
        begin
            if left == none then
                left :- new Tree (x)
            else left.insert (x)
        end
        else if right == none then
            right :- new Tree (x)
        else right.insert (x);
    end     
    ref (Tree) procedure find (x); integer x;
    begin
        if x = val then
            this Tree
        else if x < val then
            (if left == none then none
             else left.find (x))
        else if right == none then none
        else right.find (x);
    end
end of tree;
</syntaxhighlight>
在<code>find</code>的过程体中出现了表达式{{code|this Tree|"java"}}，它意图产生的值是到当前节点的引用，就是说这个节点拥有<code>find</code>特性的“这个”特定实例。例如，如果通过函数指示符<code>X.find (x)</code>，来调用<code>X</code>的<code>find</code>过程，并且<code>X.val = x</code>，则这个函数的结果是<code>X</code>自身的引用值。

=== 抽象类 ===
下面例子中，定义了一个[[抽象类型|抽象]][[继承_(计算机科学)|基础类]]：[[字形|字形]]类<code>Glyph</code>，它有二个[[实现|实现]][[子类|子类]]：[[字符_(计算机科学)|字符]]类<code>Char</code>和{{en-link|行 (文本文件)|Line (text file)|行}}类<code>Line</code>：
<syntaxhighlight lang="ObjectPascal">
Begin
    Class Glyph;
        Virtual: Procedure print Is Procedure print;
    Begin
    End;
    
    Glyph Class Char (c);
        Character c;
    Begin
        Procedure print;
            OutChar(c);
    End;
    
    Glyph Class Line (elements);
        Ref (Glyph) Array elements;
    Begin
        Procedure print;
        Begin
            Integer i;
            For i:= 1 Step 1 Until UpperBound (elements, 1) Do
                elements (i).print;
            OutImage;
        End;
    End;

    ! 主程序;
    Ref (Glyph) rg;
    Ref (Glyph) Array rgs (1 : 4);
    
    rgs (1):- New Char ('A');
    rgs (2):- New Char ('b');
    rgs (3):- New Char ('b');
    rgs (4):- New Char ('a');
    rg:- New Line (rgs);
    rg.print;
End;
</syntaxhighlight>
这里的虚过程量<code>print</code>具有过程规定<code>Is Procedure print</code>，它匹配既没有形式参数也没有返回值的<code>print</code>过程，如果不加以这种过程规定，则它可以匹配具有任何形式参数和任何返回值的<code>print</code>过程。在Simula 67中，没有不可以{{en-link|实例 (计算机科学)|Instance (computer science)|实例化}}带有纯虚过程类的特定限制，因而缺乏真正的[[抽象类型|抽象类]]的概念，所有类都可以被实例化，但是调用纯虚过程会产生[[执行期|运行时间]]{{en-link|错误消息|Error message|错误}}。

=== 模拟器 ===
在下面的[[离散事件模拟|离散事件模拟]]例子中，Sam、Sally和Andy正在逛商店买衣服，他们必须共享一个[[试衣间|试衣间]]。他们每人只能浏览商店大约12分钟，并接着独占的使用试衣间大约3分钟，每个活动都服从[[正态分布|正态分布]]，他们的试衣间经历被模拟如下：
<syntaxhighlight lang="ObjectPascal">
Simulation Begin
    Class FittingRoom;
    Begin
        Ref (Head) door;
        Boolean inUse;
        Procedure request;
        Begin
            If inUse Then Begin
                Wait (door);
                door.First.Out;
            End;
            inUse:= True;
        End;
        Procedure leave;
        Begin
            inUse:= False;
            Activate door.First;
        End;
        door:- New Head;
    End;
    
    Procedure report (message); Text message;
    Begin
        OutFix (Time, 2, 0); OutText (": " & message); OutImage;
    End;
    
    Process Class Person (pname); Text pname;
    Begin
        While True Do
        Begin
            Hold (Normal (12, 4, u));
            report (pname & " 要求用试衣间");
            fittingroom1.request;
            report (pname & " 已进入试衣间");
            Hold (Normal (3, 1, u));
            fittingroom1.leave;
            report (pname & " 已离开试衣间");
        End;
    End;
    
    Integer u;
    Ref (FittingRoom) fittingRoom1;
    
    fittingRoom1:- New FittingRoom;
    Activate New Person ("Sam");
    Activate New Person ("Sally");
    Activate New Person ("Andy");
    Hold (100);
End;
</syntaxhighlight>
主程序是前缀着[[模拟|模拟器]]类<code>Simulation</code>的有前缀块。模拟器类可在任何块上使用，而且模拟器甚至可以嵌套，比如在模拟某人做模拟的时候<ref>{{cite web|url=https://staff.um.edu.mt/jskl1/talk.html|title=INTRODUCTION TO OOP IN SIMULA|year=1997|author=Jaroslav Sklenar|quote=The system class Simulation introduces the notion of time. It means that if nested, there will be other local (nested) times.|access-date=2022-02-13|archive-date=2022-05-11|archive-url=https://web.archive.org/web/20220511181024/https://staff.um.edu.mt/jskl1/talk.html}}</ref>。激活语句<code>Activate</code>，只在包括在<code>Simulation</code>中的类的对象之中，或在其前缀部份是这种对象的有前缀块之中，才是有效的。激活语句的作用，被定义为调用<code>ACTIVAT</code>过程所得到效果。<code>ACTIVAT</code>过程和等待过程<code>Wait</code>，定义在[[进程|进程]]类<code>Process</code>中，而<code>Process</code>类是<code>Simulation</code>类的[[内部类|内部类]]。

表示集合[[容器_(数据类型)|整体]]的<code>Head</code>类，和表示集合[[元素_(数学)|元素]]的<code>Link</code>类，都是[[集合_(数学)|集合]]类<code>Simset</code>的[[内部类|内部类]]；而<code>Simset</code>类，是<code>Simulation</code>类声明中的前缀。首位过程<code>First</code>，定义在<code>Head</code>类中；退出过程<code>Out</code>和在<code>Wait</code>过程中用到的进入过程<code>Into</code>，定义在<code>Link</code>类中。

对象<code>fittingRoom1</code>是试衣间类<code>FittingRoom</code>的实例，为了让人们排队等待访问试衣间，它使用了一个[[队列|队列]]实例即门对象<code>door</code>。当某人要求用试衣间的时候，如果它正在由他人使用，则必须等待于它的门队列之中，即<code>Wait (door)</code>，当经过排队后得以使用试衣间的时候，相应的从它的门队列中移除自己，即<code>door.First.Out</code>。当某人离开试衣间的时候，在它的门队列中有人的情况下释放出第一个人，即<code>Activate door.First</code>。

个人类<code>Person</code>是<code>Process</code>类的子类，而它的活动，即用来浏览商店的时间，和在试衣间度过的时间，使用<code>Process</code>类的保持过程<code>Hold</code>来描述，并调用在试衣间对象中的过程，来要求和离开试衣间。[[正态分布|正态分布]]的[[随机|随机]][[抽签|抽签]]过程<code>Normal</code>，定义在<code>ENVIRONMENT</code>类中，它的最后的参数，必须是指定一个[[伪随机数|伪随机数]][[串流|串流]]的一个整数。主程序建立所有对象，并激活所有<code>Person</code>对象，从而将他们放置入事件队列之中。主程序在程序终止前，保持100分钟的模拟时间。

== 参见 ==
*[[面向对象编程|面向对象编程]]

== 注释 ==
{{Reflist|2}}

==延伸阅读==
* {{cite web|url=http://www.edelweb.eu/Simula/|title=IBM System 360/370 Compiler and Historical Documentation|type=The Simula Standard and other historical documentation|last=Sylvester|first=Peter|accessdate=2020-05-15|archive-date=2019-10-01|archive-url=https://web.archive.org/web/20191001062349/http://www.edelweb.eu/Simula/|dead-url=no}}
* {{Citation
 |last = Pooley
 |first = Rob
 |title = An Introduction to Programming in Simula
 |url = https://portablesimula.github.io/github.io/doc/SimulaTextBook.pdf
 |publisher = Alfred Waller Ltd
 |year = 1987
 |isbn = 0632016116
 |accessdate = 2022-03-15
 |archive-date = 2022-04-07
 |archive-url = https://web.archive.org/web/20220407173101/https://portablesimula.github.io/github.io/doc/SimulaTextBook.pdf
 }}

==外部链接==
*{{GitHub|portablesimula|Portable Simula Revisited}}
*重建中的{{Official website|www.simula67.info}}

{{Authority control}}
{{程序设计语言}}

{{DEFAULTSORT:Simula}}
[[Category:面向对象的编程语言|S]]
[[Category:基于类的编程语言|Category:基于类的编程语言]]
[[Category:模拟器编程语言|Category:模拟器编程语言]]
[[Category:ALGOL程式语言家族|Category:ALGOL程式语言家族]]