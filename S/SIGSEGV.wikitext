{{noteTA
|G1=IT
|1=zh-cn:宏;zh-tw:巨集
|2=zh-cn:段;zh-tw:區段
|3=zh-cn:栈;zh-tw:堆疊
}}
{{Infobox Computing signal
|description = 无效内存引用
|action      = 进程异常终止
| SEGV_MAPERR | 地址没有映射到对象
| SEGV_ACCERR | 对映射的对象没有权限
}}
在[[POSIX|POSIX]]<!-- Original: [[POSIX|POSIX]] -->兼容的平台上，'''SIGSEGV'''是当一个[[行程|进程]]<!-- Original: [[process_(computing)|process]] -->执行了一个无效的内存引用，或发生[[段错误|段错误]]时发送给它的[[信号_(计算机科学)|信号]]。SIGSEGV的[[C语言预处理器|符号常量]]在[[头文件|头文件]]<!-- Original: [[header_file|header file]] --><code>signal.h</code>中定义。因为在不同平台上，信号数字可能变化，因此符号信号名被使用。通常，它是信号#11。<ref>{{ cite web | url = http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/signum.h | title = sourceware.org Git - glibc.git/blob - bits/signum.h | accessdate = 2009-11-18 | date = 2001-07-06 }}{{dead link|date=2017年11月 |bot=InternetArchiveBot |fix-attempted=yes }}</ref>

== 语源 ==
''SIG''是信号名的通用[[詞綴|前缀]]<!-- Original: [[Prefix_(linguistics)|prefix]] -->。''SEGV''是''segmentation violation''（段违例）的[[縮寫|缩写]]<!-- Original: [[abbreviation|abbreviation]] -->。

== 使用 ==
对于不正确的内存处理（见[[段错误|段错误]]），计算机程序可能抛出SIGSEGV。[[操作系统|操作系统]]<!-- Original: [[operating_system|operating system]] -->可能使用信号[[堆栈|-{zh-cn:栈;zh-tw:堆疊}-]]<!-- Original: [[Stack_(data_structure)|stack]] -->向一个处于自然状态的应用程序通告错误，由此，开发者可以使用它来[[调试|调试]]<!-- Original: [[debug|debug]] -->程序或处理错误。

在一个程序接收到SIGSEGV时的默认动作是异常终止。这个动作也許會结束[[行程|进程]]<!-- Original: [[process_(computing)|process]] -->，但是可能生成一个[[核心文件|核心文件]]<!-- Original: [[core_file|core file]] -->以帮助调试，或者执行<!-- perform -->一些其他特定于某些平台的动作。例如，使用了[[grsecurity|grsecurity]]补丁的[[Linux|Linux]]<!-- Original: [[Linux|Linux]] -->系统可能记录SIGSEGV信号以监视可能的使用[[缓存溢出|缓存溢出]]<!-- Original: [[buffer_overflow|buffer overflow]] -->的攻击尝试。

SIGSEGV可以被捕获。也就是说，应用程序可以请求它们想要的动作，以替代默认发生<!-- occur -->的动作。这样的动作可以是忽略它、调用一个[[子程序|函数]]<!-- Original: [[subroutine|function]] -->，或恢复默认的动作。在一些情形下，忽略SIGSEGV导致[[未定义行为|未定义行为]]。<ref>{{cite web | url = http://www.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_04.html | title = System Interfaces Chapter 2 | date = 2004年 | accessdate = 2009-11-18 | archive-date = 2009-03-03 | archive-url = https://web.archive.org/web/20090303103437/http://opengroup.org/onlinepubs/009695399/functions/xsh_chap02_04.html | dead-url = no }}</ref>

一个应用程序可能处理SIGSEGV的例子是[[调试工具|调试器]]<!-- Original: [[debugger|debugger]] -->，它可能检查信号栈并通知[[软件设计师|开发者]]<!-- Original: [[Software_developer|developer]] -->目前所发生的，以及程序终止的位置。

SIGSEGV通常由[[操作系统|操作系统]]<!-- Original: [[operating_system|operating system]] -->生成，但是有适当权限的用户可以在需要时使用<code>kill</code>[[系统调用|系统调用]]或[[kill_(Unix)|kill]]命令（一个[[用户级_(计算机科学)|用户级]]程序，或者一个[[Unix_shell|shell]]内建命令）来向一个进程发送信号。

== 参考 ==
{{reflist}}

== 外部链接 ==
* [http://www.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html The Open Group Base Specifications Issue 6 signal.h]{{Wayback|url=http://www.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html |date=20091025174604 }}

{{Computing signals}}

[[Category:计算机错误|Category:计算机错误]]