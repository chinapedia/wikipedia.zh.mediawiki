{{noteTA|G1=IT}}
{{Infobox Computing signal
|description = “杀死”信号
|action      = 进程异常终止
}}
在[[POSIX|POSIX]]<!-- Original: [[POSIX|POSIX]] -->兼容的平台上，'''SIGKILL'''是发送给一个[[行程|进程]]<!-- Original: [[process_(computing)|process]] -->来导致它立即终止的[[信号_(计算机科学)|信号]]。SIGKILL的[[C语言预处理器|符号常量]]在[[头文件|头文件]]<!-- Original: [[header_file|header file]] --><code>[[signal.h|signal.h]]</code>中定义。因为在不同平台上，信号数字可能变化，因此符号信号名被使用，然而在大量主要的系统上，SIGKILL是信号#9。<ref>{{ cite web | url = http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/signum.h | title = sourceware.org Git - glibc.git/blob - bits/signum.h | accessdate = 2009-11-18 | date = 2001-07-06 }}{{dead link|date=2017年11月 |bot=InternetArchiveBot |fix-attempted=yes }}</ref>

== 语源 ==
''SIG''是信号名的通用[[詞綴|前缀]]<!-- Original: [[Prefix_(linguistics)|prefix]] -->。''KILL''是指让一个[[行程|进程]]<!-- Original: [[Process_(computing)|process]] -->立即终止的动作的[[计算机行话|计算机行话]]<!-- Original: [[computer_jargon|computer jargon]] -->。

== 使用 ==
当SIGKILL被发送给一个程序时，它使程序立即终止。与[[SIGTERM|SIGTERM]]和[[SIGINT_(POSIX)|SIGINT]]相比，这个信号不能被捕获或忽略，同时接收这个信号的进程在收到这个信号时不能执行任何清理。

* [[僵尸进程|僵尸进程]]不能被杀死，因为它们已经死亡，只等待它们的父进程回收<!-- 收割？reap -->它们。

* 处于阻塞状态的进程不会死亡，直到它们再次醒来。

* ''[[init|init]]<!-- Original: [[init|init]] -->''进程是特殊的：它不获得它不想处理的信号，因此它可以忽略SIGKILL。

* 因为SIGKILL不给进程任何在终止时做清理操作的机会，在大部分系统关闭过程中，在采取<!-- 借助？求助？ -->SIGKILL之前，使用信号SIGTERM使进程终止的尝试先被作出。

* 为了加速计算机关闭过程，[[Mac_OS_X_10.6|Mac OS X 10.6]]会将SIGKILL发送给已经标记它们自己为“干净”的应用程序，以加快关机速度<!-- 以实现一个更快的关机时间／resulting in faster shutdown times -->，同时，很可能地，没有坏作用。<ref>{{cite web | url = http://developer.apple.com/mac/library/releasenotes/MacOSX/WhatsNewInOSX/Articles/MacOSX10_6.html#//apple_ref/doc/uid/TP40008898-SW22 | title = Mac Dev Center: What's New in Mac OS X: Mac OS X v10.6 | date = 2009-08-28 | accessdate = 2009-11-18 | archive-date = 2009-12-08 | archive-url = https://web.archive.org/web/20091208151435/http://developer.apple.com/Mac/library/releasenotes/MacOSX/WhatsNewInOSX/Articles/MacOSX10_6.html#//apple_ref/doc/uid/TP40008898-SW22 | dead-url = no }}</ref>

* 即使SIGKILL被发送给它，一个正在{{tsl|en|Uninterruptible sleep|不可中断睡眠}}的进程也可能不会终止（并且释放它的资源）。这是少数几个一个UNIX系统可能需要被重新启动来解决临时软件问题的例子中的一个。

==参考==
{{reflist}}

{{Computing signals}}