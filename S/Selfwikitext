{{noteTA
|G1=IT
|1=zh-hans:对象; zh-hant:物件;
}}
{{Infobox programming language
| name                   = Self
| logo                   = [[File:Self-logo.svg|200px]]
| paradigm               = [[面向对象编程语言|面向对象]], [[基于原型编程|基于原型]]
| year                   = {{Start date and age|1987}}
| designer               = {{en-link|David Ungar}}, Randall Smith
| developer              = David Ungar, Randall Smith, [[斯坦福大学|斯坦福大学]], [[Sun微系统|Sun微系统]]
| latest release version = 2017.1<ref>{{cite web|title=Self "Mandarin" 2017.1|url=https://blog.selflanguage.org/2017/05/24/self-mandarin-2017-1/|date=24 May 2017|accessdate=24 May 2017|archive-url=https://web.archive.org/web/20170524053153/https://blog.selflanguage.org/2017/05/24/self-mandarin-2017-1/|archive-date=2017-05-24|dead-url=yes}}</ref>

| latest release date    = {{Start date and age|2017|05|24}}
| typing                 = [[类型系统|动态]], [[强类型编程语言|强类型]]
| implementations        = Self
| family                 = [[Smalltalk|Smalltalk]]
| dialects               = 
| influenced_by          = [[Smalltalk|Smalltalk]], [[APL语言|APL]]<ref>{{cite journal|doi=10.1145/1238844.1238853|title=Self|journal=Proceedings of the Third ACM SIGPLAN Conference on History of Programming Languages (HOPL III)|year=2007|author1=David Ungar|author2=Randall B. Smith|isbn=9781595937667|s2cid=220937663|url=https://www.cs.tufts.edu/~nr/cs257/archive/david-ungar/self-hopl.pdf|quote=Ungar always missed the productivity of APL and was drawn to Smalltalk not only for its conceptual elegance, but also because it was the only other language he knew that let him build working programs as quickly as in the good old days of APL. The design of Self was also influenced by APL; after all, APL had no such thing as classes: arrays were created either ab initio or by copying other arrays, just as objects are in Self.}}</ref>
| influenced             = [[NewtonScript|NewtonScript]], [[JavaScript|JavaScript]], [[Io_(编程语言)|Io]], {{en-link|Agora (编程语言)|Agora (programming language)|Agora}}, [[Squeak|Squeak]], [[Lua|Lua]], [[Factor_(编程语言)|Factor]], [[REBOL|REBOL]]
| operating_system       =
| license                = 类BSD许可证
| website                = {{URL|www.selflanguage.org}}
}}
'''Self语言'''，是一种[[基于原型编程|基于原型]]的[[面向对象编程语言|面向对象]]的[[程序设计语言|程序设计语言]]，也是一个[[集成开发环境|集成开发环境]]和[[运行环境|运行环境]]，由David Ungar和Randy Smith，最初在1986年于[[施乐帕罗奥多研究中心|施乐帕罗奥多研究中心]]设计。Self语言在[[Smalltalk|Smalltalk]]的基础上，去除了变量，从而彻底体现了一切都是对象的风格。在实现Self系统的过程中，设计研究人员发展出了一种[[动态自适应编译|动态自适应编译]]技术。

== 简介 ==
Self语言把在概念上精简[[Smalltalk|Smalltalk]]作为设计原则。它在把[[消息|消息]]作为最基本的操作的同时，取消了[[类_(计算机科学)|类]]的概念，只有[[对象_(计算机科学)|对象]]的概念。它把对象的特性，理解为获取或更改特性的这两种方法，从而把特性的概念简化为[[方法_(電腦科學)|方法]]，即取消了[[变量|变量]]及其[[赋值|赋值]]，并以通过消息来读槽和写槽的方式来取代之。Self提出了[[Traits_(计算机科学)|特质]]的概念，用{{en-link|动态绑定|Late binding}}实现了[[委托_(面向对象编程)|委托]]。

尽管Self系统一次运行在一个[[进程|进程]]中，但实际上可以分成两个部分：Self[[虚拟机|虚拟机]]和Self世界（Self world）。Self世界是一个Self对象库，Self对象包括数据对象和方法对象，方法对象的代码部份，是用一种指令非常简单的[[字节码|字节码]]（bytecode）表示的，字节码由Self虚拟机来解释。当Self程序从[[终端|终端]]、[[文件|文件]]或者[[图形用户界面|图形用户界面]]输入到系统之中时，Self系统把[[源程序|源程序]]解析转化为Self世界里的对象。

[[动态自适应编译|动态自适应编译]]技术的采用，提高了Self代码的执行效率。对经常执行的方法，虚拟机将进一步把字节码转化为[[机器语言|本机代码]]。Self虚拟机还提供了一些可供调用的{{en-link|语言原语|Language primitive|原语}}，用来实现[[算术#算術運算|算术运算]]、对象复制、[[输入输出|输入输出]]等。

Self也拥有一个[[图形用户界面|图形用户界面]][[Morphic|Morphic]]，Self的编程环境，也是基于Morphic来实现的。Self在精简语言概念的同时，也把大量的工作转交给环境来处理，语言中的[[反射式编程|反射机制]]也同环境密切相关。

== 历史 ==
在1986年，David Ungar和Randy Smith在[[施乐帕罗奥多研究中心|施乐帕罗奥多研究中心]]，提出了Self语言的最初设计，并在1987年的[[OOPSLA|OOPSLA]]'87的论文《Self：简单性的能力》中给出了描述<ref>{{cite journal|title=Self: The Power of Simplicity|journal=OOPSLA ‘87 Conference Proceedings|year=1987|author1=David Ungar|author2=Randall B. Smith|url=https://bibliography.selflanguage.org/_static/self-power.pdf|page=227-241|publisher=SIGPLAN Notices 22(12)|access-date=2022-05-06|archive-date=2022-04-09|archive-url=https://web.archive.org/web/20220409215225/https://bibliography.selflanguage.org/_static/self-power.pdf}}</ref>，此文在2006年被评为1986年到1996年间三个最有影响的[[OOPSLA|OOPSLA]]论文之一<ref>{{cite web |author=ACM |title=SIGPLAN - Awards |url=http://www.sigplan.org/Awards/OOPSLA/ |access-date=2022-02-23 |archive-date=2022-05-10 |archive-url=https://web.archive.org/web/20220510070332/http://www.sigplan.org/Awards/OOPSLA/ }}</ref>。

1987年初，Craig Chambers、Elgin Lee和Martin Rinard，在Smalltalk上给出了Self的第一个实验性[[解释器|解释器]]。1987年夏，Self项目在[[斯坦福大学|斯坦福大学]]正式开始，1988年夏给出了第一个有效率的实现，并发布了1.0和1.1两个版本。1991年初，Self项目移至[[Sun微系统|Sun微系统]]，并且在1992年发布了2.0版。1993年1月，Self 3.0版发布。

1995年7月，Self 4.0版发布。在这个版本中包括了一个全新的图形用户环境Morphic。在2016年发行了4.3版本并可运行在Mac OS X和Solaris上。在2010年发行了版本4.4<ref>{{cite web|title=Self 4.4 released|url=https://blog.selflanguage.org/2010/07/16/self-4-4-released/|date=16 July 2010|access-date=24 May 2017|archive-url=https://web.archive.org/web/20171205194557/https://blog.selflanguage.org/2010/07/16/self-4-4-released/|archive-date=5 December 2017|url-status=dead}}</ref>，由最初团队的某些人和独立编程者形成的小组开发，它和所有后续版本可以运行在Mac OS X和Linux上。2014年1月发行了4.5版本<ref>{{cite web|title=Self Mallard (4.5.0) released|url=http://blog.selflanguage.org/2014/01/12/self-mallard-4-5-0-released/|date=12 January 2014|access-date=24 May 2017|archive-url=https://web.archive.org/web/20171206074534/https://blog.selflanguage.org/2014/01/12/self-mallard-4-5-0-released/|archive-date=6 December 2017|url-status=dead}}</ref>。2017年5月发行了版本2017.1。

Self的发展基本已经停滞，但在发展Self过程中探索出的一些技术，在其他的系统中得到了应用。在Self的实现中采用的各种编译优化技术，直接导致了[[HotSpot_(java)|Java Hotspot]]虚拟机的产生；在Smalltalk的一个实现[[Squeak|Squeak]]中，采用了Self图形用户界面[[Morphic|Morphic]]的设计方案，放弃了Smalltalk-80中采用的[[MVC|MVC]]的方案。Self是对[[JavaScript|JavaScript]]编程语言设计有最主要影响者之一<ref>{{Cite journal |last=Severance |first=C. |date=February 2012 |title=JavaScript: Designing a Language in 10 Days |journal=Computer |volume=45 |issue=2 |pages=7–8 |doi=10.1109/MC.2012.57 |s2cid=29215508 |issn=0018-9162}}</ref>。

== 基于原型编程 ==
{{main|基于原型编程}}
传统的基于类的面向对象语言，基于了根深蒂固的二元性：
#[[类_(计算机科学)|类]]，定义对象的基本[[品质|品质]]（quality）和[[行为|行为]]（Behavior）。
#[[对象_(计算机科学)|对象]][[实例|实例]]，是类的特定{{en-link|体现|Manifestation}}（manifestation）。

例如，假设类<code>Vehicle</code>（[[载具|车辆]]）的对象有一个“名字”，和进行各种动作的能力，比如“开车上班”和“运送建材”。<code>Bob's car</code>是类<code>Vehicle</code>的特定对象（实例），它的“名字”是“Bob's car”。在理论上，你可以向<code>Bob's car</code>发送消息，告诉它去“运送建材”。

这个例子展示了这种方式的一个问题：Bob的[[汽车|汽车]]，恰巧是一个[[跑车|跑车]]，在任何意义上都不能装载和运送建材，但这是建模<code>Vehicle</code>所必须拥有的能力。通过从<code>Vehicle</code>建立特殊化的[[子类|子类]]，可产生一个更有用的模型；比如建立类<code>SportsCar</code>（[[跑车|跑车]]）和类<code>FlatbedTruck</code>（[[平板卡车|平板卡车]]）。只有<code>FlatbedTruck</code>的实例需要提供“运送建材”的机能；<code>SportsCar</code>的实例不适合这种工作，它只需要“快速行驶”。但是，这种深入建模在设计期间，需要更多的洞察力，洞察那些可能只在引起了问题时才显现出的事情。

这个问题是在原型（prototype）这个概念背后的动机因素之一。除非你能必然性的预测出一组对象和类，在遥远未来时所要有的品质，你不能恰当的设计好一个类的层级。程序最终需要增加行为，实在是太频繁了，而系统的很多节段将需要重新设计（或[[代码重构|重新构建]]），来以不同的方式迸发出对象。早期的面向对象语言如[[Smalltalk|Smalltalk]]的实验，显示出这种问题反反复复的出现。系统趋向于增长到一定程度后，就变得非常僵化，因为在编程者的代码下的深层的基本类，简直就像是逐渐变成了一个“错误”；没有变更原来的类的容易方式，就会出现严重的问题。

动态语言如Smalltalk，允许通过周知的按照类的方法进行这种变更；即通过改变类，基于它的对象就可以改变它们的行为。但是，进行这种变更必须非常小心，因为基于相同类的其他对象，可能把它当作“错误行为”：“错误”经常是依赖于场景的，这是{{en-link|脆弱基类|Fragile base class}}问题的一种形式。进一步的说，在静态语言如[[C++|C++]]中，这里的子类可以从[[超类|超类]]分别的编译，对超类的变更实际上可以破坏预编译的子类方法；这是脆弱基类问题的另一种形式，也是{{en-link|脆弱二进制接口问题|Fragile binary interface problem}}的一种形式。

在Self和其他基于原型的编程语言中，消除了在类和对象之间的这种二元性。不再有基于某种“类”的一个对象“实例”，在Self中，你可以复制一个现存的对象，并改变它。故而<code>Bob's car</code>可以通过制作现存的<code>Vehicle</code>对象的复本来建立，并增加“快速行驶”方法，建模它恰好是一辆[[保时捷911|保时捷911]]的事实。

主要用来制作复本的基本对象叫做“原型”。这种技术被称为是一种非常简化的机制。如果一个现存的对象或对象的集合，被证明是个不适当的模型，编程者可以简单的建立有正确行为的一个修改的对象，并转而使用它。使用现存对象的代码不会改变。

== 语法和语义 ==
下面简要描述Self语言的语法和语义。

===对象===
{{en-link|文字 (计算机编程)|Literal (computer programming)|文字}}（literal）包括：数、用<code>'</code>包围起来的字符串对象，[[块_(编程)|块]]和一般的[[对象_(计算机科学)|对象]]。对象文字用圆括号来界定。在圆括号内，对象描述构成自竖杠<code>|</code>界定的一个槽列表，随后是在这个对象被求值时要执行的代码。例如：
<syntaxhighlight lang="smalltalk"> (| 槽1. 槽2 | 一些代码 )</syntaxhighlight>

槽（slot）是[[键-值对|名字-值对]]，槽包含到其他对象的[[参照|引用]]。槽列表由点号分隔的（可以为空的）一序列的槽描述符组成。在槽列表结束处的点号是可选的。槽描述符（descriptor）有两种：
*<code>槽 <- 表达式</code>，指示将指名的数据槽初始化为求值表达式的结果，它有相同名字附加冒号的包含赋值原语的赋值槽，这两个槽对应于其他语言中的一个读写变量。
*<code>槽 = 表达式</code>，指示将指名的数据槽初始化为求值表达式的结果，这个槽对应其他语言的一个只读变量。

在Self中没有单独的赋值运算。其他面向对象语言中的[[变异子与访问子|访问子方法]]对应数据槽，[[变异子与访问子|变异子方法]]对应赋值槽。假如<code>myPerson</code>对象中有个叫做<code>name</code>的数据槽，则通过{{code|myPerson name|"smalltalk"}}，可返回在这个槽中的值；如果它有对应的赋值槽<code>name:</code>，则通过{{code|myPerson name: 'foo'|"smalltalk"}}，可设置数据槽<code>name</code>的值为<code>'foo'</code>。

任何槽都可以通过增加星号后缀，来制成父槽。星号不是槽名字的一部份，在将名字与消息进行匹配时候忽略它。例如一个初始化了的可变的点可以定义为：
<syntaxhighlight lang="smalltalk">
(|  parent* = traits point.
    x <- 3 + 4.
    y <- 5.
|)
</syntaxhighlight>

一个对象的代码是以点号分隔的一序列的表达式。尾随的点号是可选的。每个表达式有一系列的消息发送和文字组成。在一个对象的代码中最后的表达式，可以前导着指示返回的<code>^</code>算符。

一个真正的空对象，指示为<code>(| |)</code>或简单的<code>()</code>，它根本不接收任何消息。

===方法===
[[方法_(计算机科学)|方法]]（method）是除了参数槽{{en-link|及或|And/or}}局部槽之外，还包含代码的对象。参数（argument）槽名字开始于一个冒号，它不是槽名字的一部分，在将名字与消息进行匹配时候忽略它。参数槽总是只读的，并且不能对它们指定初始化者。下面例子是计算平方的方法对象：
<syntaxhighlight lang="smalltalk">(| :arg | arg * arg )</syntaxhighlight>

一个普通方法（简称方法），是不嵌入到其他代码之中的方法，它只能存放在只读槽中。普通方法总是有一个叫做<code>self</code>的隐含的父参数槽。Self的普通方法等价于[[Smalltalk|Smalltalk]]的方法。

如果一个槽包含一个方法，在求值这个槽来响应发来的消息的时候，这个方法对象被{{en-link|对象复制|Object copying|浅层复制}}（clone），从而新建它的一个活动（activation）对象，它包含这个方法的参数槽和局部槽；复制体的<code>self</code>父槽，初始化为这个消息的接收者；复制体如果有参数槽，将它们初始化为实际参数；在这个新的活动对象的上下文中，执行这个方法的代码。

作为语法约定，参数名字可以直接写在槽名字之后（不带前缀冒号），从而隐含的声明参数槽。例如下面的方法定义：
<syntaxhighlight lang="smalltalk">
(| ifTrue: False: = (| :trueBlock. :falseBlock |
       trueBlock value ).
|) 
</syntaxhighlight>
可以等价的定义为：
<syntaxhighlight lang="smalltalk">
(| ifTrue: trueBlock False: falseBlock =
       ( trueBlock value ).
|)
</syntaxhighlight>

返回算符<code>^</code>的出现或缺席，不影响普通方法的行为，因为普通方法总是会返回它最终的表达式的值。

=== 消息 ===
通过[[消息传递|消息]]访问槽的语法，类似于Smalltalk，有三类消息可以获得：
;一元: <code>接收者 槽名字</code>
;二元: <code>接收者 算符 参数</code>
;关键字: <code>接收者 关键字1: 参数1 关键字2: 参数2</code>

所有消息都返回结果，所以显式指定的接收者和参数自身可以是其他消息的结果。下面是Self版本的[[hello_world|hello world]]程序例子：

<syntaxhighlight lang="smalltalk">'Hello, World!' print.</syntaxhighlight>

组合可以通过使用圆括号来进行强制。在缺乏明确组合的情况下，一元消息具有最高优先级，其次是二元消息，而关键字消息最低。一元消息从左至右复合。二元消息对于同一个算符从左至右结合，例如<code>3 + 4 + 7</code>被解释为<code>(3 + 4) + 7</code>，而对于不同的算符没有结合性，例如<code>3 + 4 * 7</code>是非法的，而必须显式的写为要么<code>(3 + 4) * 7</code>要么<code>3 + (4 * 7)</code>。

关键字消息的第一部份必须开始于小写字母，而后续部份都必须开始于大写字母。例如表达式：
<syntaxhighlight lang="smalltalk">
5 min: 4 Max: 7
</syntaxhighlight>
是一个单一的消息<code>min:Max:</code>，它被发送给<code>5</code>并具有参数<code>4</code>和<code>7</code>，而表达式：
<syntaxhighlight lang="smalltalk">
5 min: 4 max: 7
</syntaxhighlight>
涉及两个消息：第一个消息<code>max:</code>被发送给<code>4</code>并接受<code>7</code>作为它的参数，而接下来消息<code>min:</code>被发送给<code>5</code>，并接受<code>4 max: 7</code>的结果作为它的参数。关键字消息从右至左结合，例如：
<syntaxhighlight lang="smalltalk">
5 min: 6 min: 7 Max: 8 Max: 9 min: 10 Max: 11
</syntaxhighlight>
被解释为：
<syntaxhighlight lang="smalltalk">
5 min: (6 min: 7 Max: 8 Max: (9 min: 10 Max: 11))
</syntaxhighlight>

由于很多消息被发送给当前消息接收者<code>self</code>，故而可以将<code>self</code>作为隐含接收者而不需要显式的写出。例如计算点的加法的一个方法：
<syntaxhighlight lang="smalltalk">
(| + arg = ( (clone x: x + arg x) y: y + arg y ) 
|)
</syntaxhighlight>
可以被无歧义的分析，其含义同于：
<syntaxhighlight lang="smalltalk">
(| + = (| :arg | (clone x: ((x + (arg x)))) y: ((y + (arg y))) ). 
|)
</syntaxhighlight>
这里出现了三个隐含接收者一元消息<code>clone</code>、<code>x</code>和<code>y</code>。

===块===
[[块_(编程)|块]]是Self的[[闭包_(计算机科学)|闭包]]，Self就像[[Smalltalk|Smalltalk]]，使用“块”用于控制流程和其他职责。块文字的写法，除了方括号替代了圆括号之外，类似于其他对象文字。例如嵌入在下列表达式中的块：
<syntaxhighlight lang="smalltalk">
1 to: 5 * i By: 2 * j Do: [| :k | k print ]
</syntaxhighlight>

一个块文字定义两个对象：一个块数据对象，和它包围的一个块方法对象。
*块数据对象，它有包含块方法对象的一个槽，其选择子也就是槽名字，由参数数目决定，没有参数是<code>value</code>，一个参数是<code>value:</code>，两个参数是<code>value:With:</code>，随着参数增多<code>With:</code>个数也随之递增。此外，它还有一个叫<code>parent*</code>的父槽，指向含有块对象都共享的行为的那个对象（<code>traits block</code>）。
*块方法对象，它含有这个块的代码。不同于普通方法对象，它不包含<code>self</code>槽，转而有一个匿名父槽，它被初始化指向在词法上处于外围的块或方法的活动对象。匿名的含义，是这个槽的名字在Self层面是不可见的，而不能显式的访问。作为结果，在一个块方法内发送的隐含接收者消息，被限定在这个块所在表达式的词法作用域之内，而非这个块经过可能有的多次转送，最终向它发送适当的<code>value</code>消息变体之时的那个作用域。

相应的，块求值分为如下两个阶段：
*在这个块被求值的时候，即它被用作发送消息的参数，比如例子中<code>to:By:Do:</code>消息的参数之时，建立块对象（即块数据对象）；这个块被浅层复制（clone），并将指向这个块在词法上外围的活动记录，即当前的活动记录的一个指针交给它匿名保存。
*在向这个块发送适当的<code>value</code>消息变体的时候，求值这个块方法；这个块方法接着被浅层复制，并填充此复制体的方法槽，使用第一阶段确定的指针来初始化匿名父槽，最后执行这个块的代码。

在块中，返回算符<code>^</code>导致从包含这个块的普通方法中返回控制权，立即终止这个方法的活动，这个块的活动，和在其间的所有活动。这种返回叫做“非局部返回”，因为它可以穿越很多活动。普通方法求值的结果，是非局部返回所返回的值。

=== 委托 ===
{{main|委托 (面向对象编程)}}
在理论上，所有Self对象都是独立实体，Self既没有类也没有元类。对任何特定对象的变更，都不影响任何其他对象，但是在某些情况下，却需要它们有关联。正常的一个对象，只能理解对应于它的局部槽的消息，但拥有一个或更多的指示父（parent）对象的槽，对象可以将任何自身不理解的消息，[[委托_(面向对象编程)|委托]]（delegate）给父对象。

Self采用这种方式，处理在基于类的语言中使用[[继承_(计算机科学)|继承]]来担负的责任。委托还可以用来实现一些特征，比如[[命名空间|命名空间]]和[[词法作用域|词法作用域]]。通过下面的例子展示委托与传统的类的不同之处：
<syntaxhighlight lang="smalltalk">myObject parent: someOtherObject.</syntaxhighlight>
这个句子通过改变与叫做<code>parent</code>的父槽关联的值，在运行时间改变<code>myObject</code>的“类”。不同于继承或词法作用域，委托对象可以在运行时间修改。

===特质===
{{main|Trait (计算机科学)}}
例如，假定在一个简单的账簿应用中，定义了一个对象叫做“银行帐号”（bank account）。通常建立的这个对象，具有内部的方法，比如说“存款”（deposit）和“取款”（withdraw），和任何它所需要的数据槽，比如说“余额”（balance）。这只是一个原型，它只在使用方式上特殊，因为它恰好是一个全功能的银行帐号。

为“Bob的账户”制作银行帐号对象的复制品（clone），将建立一个新对象，它在起初时完全同于原型。在这种情况下，将复制（copy）包括方法和任何数据的槽。但更常用的解决方案，是首先建立叫做它的[[traits_(计算机科学)|特质]]（trait）对象的一个简单对象，它包含通常与一个类有关的项目。

在这个例子中，“银行账户”将没有存款和取款方法，而是委托给一个父对象来做这些。采用这种方式，可以制作银行帐号对象的很多复本，但是我们仍可以通过改变它所委托的特质对象中的槽，来改变它们全体的行为。

===Self世界===
当处在于提示符下键入表达式的场景时，由叫做“大厅”（lobby）的一个对象，引领用户进入Self世界。当建立一个新对象的脚本被读入系统的时候，脚本中的表达式都在大厅的上下文中求值。就是说大厅是这个脚本中所有发送给<code>self</code>的消息的接收者。

要引用在脚本中的某个现存的对象，必须通过发送一个消息到大厅才可以访问到它。大厅的<code>traits</code>、<code>globals</code>和<code>mixins</code>槽，是从大厅可以访问的对象[[命名空间|命名空间]]的[[根目录|根]]。大厅的<code>lobby</code>槽允许大厅自身通过名字来提及。[[路径_(计算机科学)|路径]]名字是一个一元选择子的序列，它描述从大厅到这个对象的路径。路径名字也是可以在大厅的上下文中求值的表达式，它产出这个对象。

例如，原型列表的完全路径名字是<code>globals list</code>。因为<code>globals</code>是父槽，它可以从路径名字表达式中省略，生成简短路径名字<code>list</code>。大厅的<code>traits</code>不是父槽，特质对象的名字必须开始于前缀<code>traits</code>，因此列表的特质对象必须称呼为<code>traits list</code>。

不是所有对象都有路径名字，只有那些从大厅可以到达的对象才有，这些对象称为“周知的”。大厅向用户提供三类对象：
*[[trait_(计算机科学)|特质]]（traits）对象，封装共享行为的对象，典型的每个原型对象，都有一个关联的同名特质对象，用来描述它的行为的共享部份。任何Self实现都需要为整数、浮点数、字符串和块提供特质对象。Sefl世界中多数具体对象派生自两种个顶层特质对象：不唯一性对象承袭自<code>traits clonable</code>，而唯一性对象承袭自<code>traits oddball</code>。唯一性的对象通过返回自身，来响应消息<code>copy</code>，并使用[[同一性|同一性]]来测试[[相等|相等]]。
*全局（globals）对象，即不唯一性的原型对象，和“每种只有一个”的独特（<code>oddball</code>）对象。一些对象比如<code>true</code>、<code>false</code>和<code>nil</code>是唯一性的，在系统中它们只需要有一个。因为一个<code>oddball</code>不需要在它的很多实例间共享它的行为，它不需要有分立的特质对象和原型对象。很多<code>oddball</code>对象从<code>traits oddball</code>继承<code>copy</code>方法，它返回对象自身而非一个新复本。
*[[mixin|混入]]（mixins）对象，即小而无父对象的行为束（bundle），是持有共享行为的一种对象，通常用来混入那些有其他父对象的对象之中。混入对象的一个例子是<code>mixins identity</code>。两个对象测试相等，通常基于在一个共同的域（[[domain|domain]]）内是否有相同的值。例如，在数的域内<code>3.0 = 3</code>，即使它们不是相同的对象甚至不是同种类的对象。但是在一些域中，两个对象相等当且仅当它们是相同的对象，例如两个[[进程|进程]]即使有相同的状态也不被当作是相等除非它们是同一个。在这种情况上，使用同一性比较来实现相等测试，并混入<code>mixins identity</code>来得到想要的行为。

在大厅的<code>defaultBehavior</code>槽中，定义了系统中大多数对象所继承的缺省行为。

=== 新建对象 ===
有两个消息与对象复制有关：
*{{code|clone|"smalltalk"}}，{{en-link|对象复制|Object copying|浅层复制}}，返回包含着与最初对象完全相同的槽和代码的一个新对象。它用在对象内部，客户应当使用<code>copy</code>。
*{{code|copy|"smalltalk"}}，复制接收者，可能具有嵌入的复制或初始化。

考虑一个图形用户界面有关的例子：
<syntaxhighlight lang="smalltalk">(desktop activeWindow) draw: (labelWidget copy label: 'Hello, World!').</syntaxhighlight>
首先进行的是{{code|desktop activeWindow|"smalltalk"}}，它从<code>desktop</code>（桌面）对象拥有的一个窗口列表中，返回<code>activeWindow</code>（活动窗口）。按从内向外从左至右的次序，接着是{{code|labelWidget copy label: 'Hello, World!'|"smalltalk"}}，通过<code>copy</code>消息制作<code>labelWidget</code>（标签组件）对象的一个复本，接着向它发送一个消息，将<code>Hello, World!</code>放入它的叫做<code>label</code>（标签）的槽中。最后将返回的这个组件，发送到这个活动窗口的<code>draw</code>（绘制）槽中。

=== 增加槽 ===
在Self中的对象，可以通过包括新加的槽来修改。这可以通过被推荐使用的图形编程环境来做，或者直接使用原语<code>_AddSlots:</code>。原语与正常关键字消息有相同的语法，但是它的名字开始于下划线字符。给<code>_AddSlots:</code>的参数是一个对象文字，它的槽将被复制进入接收者。例如，在大厅中新增叫做<code>newObject</code>的对象，并初始化这里举出的它的叫做<code>entries</code>的槽，采用如下这样的表达式：

<syntaxhighlight lang="smalltalk">_AddSlots: (| newObject = (| entries <- list copy ... |) |)</syntaxhighlight>

因为<code>_AddSlots:</code>原语未指定接收者，这里的消息隐含接收者<code>self</code>是大厅，由它来理解产生初始值的消息<code>list copy</code>，<code>list</code>是周知的原型对象。

== 例子 ==
在下面的例子中，将基于类语言中叫做<code>Vehicle</code>（车辆）的一个简单类，重新构造为Self中的<code>vehicle</code>对象，从而能够区分出在轿车和卡车之间共有的行为：
<syntaxhighlight lang="smalltalk">_AddSlots: (| vehicle <- (|parent* = traits clonable|) |).</syntaxhighlight>
在大厅中创建了一个叫做<code>vehicle</code>的槽，它的值是一个对象文字，同时还创建了一个叫做<code>vehicle:</code>的赋值槽。作为<code>vehicle</code>槽初始值的对象文字，也就是新建的叫做<code>vehicle</code>的对象，包括了一个单一的父槽<code>parent</code>，没有相应的<code>parent:</code>，它委托了<code>traits clonable</code>对象，这个顶层的特质对象可以理解与复制有关的消息。

然后向这个新建对象继续增加<code>name</code>槽和相应的<code>name:</code>槽：
<syntaxhighlight lang="smalltalk">vehicle _AddSlots: (| name <- 'automobile'|).</syntaxhighlight>

在大厅中从<code>vehicle</code>对象建立一个<code>sportsCar</code>（跑车）对象，并接着向<code>sportsCar</code>增加<code>vehicle</code>没有的一个新的方法槽<code>driveToWork</code>（开车上班）：
<syntaxhighlight lang="smalltalk">_AddSlots: (| sportsCar <- vehicle copy |).
sportsCar _AddSlots: (| driveToWork = ("这个方法的代码") |).</syntaxhighlight>

在大厅中从<code>sportsCar</code>对象建立一个<code>porsche911</code>（[[保时捷911|保时捷911]]）对象，接着向新建对象<code>porsche911</code>发送一个消息改变它的<code>name</code>槽的值：
<syntaxhighlight lang="smalltalk">_AddSlots: (| porsche911 <- sportsCar copy |).
porsche911 name: 'Bobs Porsche'.</syntaxhighlight>
对象<code>porsche911</code>与它的原型对象<code>sportsCar</code>，仍有着完全相同的槽，但是其中的一个槽有着不同的值。

== 环境 ==
Self的一个特征，是它基于了早期Smalltalk系统所用的某种[[虚拟机|虚拟机]]系统。就是说，程序不是像[[C语言|C]]语言中那样的独立实体，而是需要它们的整体内存环境来运行。这要求应用程序被装载入保存内存的{{en-link|大块 (信息)|Chunk (information)|大块}}（chunk）之中，这叫做“快照”或{{en-link|系统映像|System image|映像}}。这种方式的缺点，是映像有时很大并且笨重；但是调试一个映像，经常被调试一个传统程序要简单，因为运行时状态更容易检查和修改。在基于源代码和基于映像的开发之间的不同，是类似于在面向类的和面向原型的面向对象编程之间的区别。

此外，环境是为了让在系统之中的对象能快速和可持续的变更而定制的。重新构建一个“类”设计，就像从现存的祖先拖动出来方法放入新造的之中一样容易。简单任务像测试方法，可以通过制作复本来处理，拖动方法进入这个复本，接着变更它。不同于传统系统，只有变更了的对象有新代码，不需要重建任何东西来测试它。如果这个方法有效，可以简单的把它拖动回祖先之中。

===性能===
Self的VM实现的性能，在某些测试之中大约是优化的C程序速度的一半<ref>{{cite web |url=http://research.sun.com/jtech/pubs/97-pep.ps |title=Design and Implementation of Pep, a Java Just-In-Time Translator |last1=Agesen |first1=Ole |date=March 1997 |website=sun.com |publisher= |archiveurl=https://web.archive.org/web/20061124224739/http://research.sun.com/jtech/pubs/97-pep.ps |archivedate=2006-11-24 |accessdate=2020-05-13 |dead-url=yes }}</ref>。这是通过[[即时编译|即时编译]]技术达到的，它是在Self研究中首创并改进的，能够使高级语言表现得这么好。

===垃圾收集===
Self的[[垃圾回收_(计算机科学)|垃圾收集器]]使用[[追踪垃圾回收|分代垃圾回收]]，它按年龄分离对象。通过使用内存管理系统记录页面写，可以维护一个写屏障。这个技术给出了卓越的性能，尽管在运行一些时间之后，出现完全的垃圾收集，要花相当可观的时间。

===优化===
运行系统选择性的扁平化调用结构。这给出适当的自身提速，但允许了对不同调用者类型的类型信息和多版本的代码的大量缓存。这去除了对做很多方法查找的需要，并允许条件分支语句和硬编码调用被插入，这经常能给出类似C语言的性能，而又不失去语言层面的通用性，但要建立在完全的垃圾收集系统之上<ref>[https://www.researchgate.net/publication/2423092_Whole-Program_Optimization_of_Object-Oriented_Languages Whole-Program Optimization of Object-Oriented Languages] {{Wayback|url=https://www.researchgate.net/publication/2423092_Whole-Program_Optimization_of_Object-Oriented_Languages |date=20220510131103 }}.</ref>。

==引用==
{{reflist|2}}

==延伸阅读==
* [http://bibliography.selflanguage.org/ Published papers on Self]{{Wayback|url=http://bibliography.selflanguage.org/ |date=20140208005304 }}
*{{citation
 | first1= C. |last1= Chambers
 | year=1992
 | title = The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages
 | publisher=[[Stanford_University|Stanford University]]
}}
* [http://blog.rfox.eu/en/Series_about_Self.html Series of four articles "Environment and the programming language Self"]{{Wayback|url=http://blog.rfox.eu/en/Series_about_Self.html |date=20200311203922 }}

== 站外链接 ==
* {{Official website|www.selflanguage.org}}
* {{github|russellallen/self}}
* [http://kitakitsune.org/self/self_tutorial/ Prototype-Based Application Construction Using SELF 4.0]{{Wayback|url=http://kitakitsune.org/self/self_tutorial/ |date=20200202003808 }}
* [http://selfguru.sourceforge.net/ Automated Refactoring application on sourceforge.net, written for and in Self]{{Wayback|url=http://selfguru.sourceforge.net/ |date=20191030100659 }}
* [http://www.self-support.com/ Gordon's Page on Self]{{Wayback|url=http://www.self-support.com/ |date=20191018212910 }}
* [http://www.ag-nbi.de/research/dself/ dSelf: distributed extension to the delegation and language Self]{{Wayback|url=http://www.ag-nbi.de/research/dself/ |date=20180908092907 }}

{{Smalltalk programming language}}
{{程序设计语言}}

[[Category:动态编程语言|Category:动态编程语言]]
[[Category:动态类型编程语言|Category:动态类型编程语言]]
[[Category:面向对象的编程语言|Category:面向对象的编程语言]]
[[Category:基于原型的编程语言|Category:基于原型的编程语言]]
[[Category:Smalltalk编程语言家族|Category:Smalltalk编程语言家族]]
[[Category:1987年建立的程式語言|Category:1987年建立的程式語言]]