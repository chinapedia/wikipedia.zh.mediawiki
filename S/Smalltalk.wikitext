{{NoteTA|G1=IT}}
{{Infobox programming language
| name = Smalltalk
| logo = File:Smalltalk Balloon.svg
| logo_size = 200px
| caption = 
| paradigm = [[面向对象程序设计|面向对象]]，[[反射式编程|反射式]]
| year = {{Start date and age|1972}}（開發始於1969年）
| designer = [[艾伦·凯|Alan Kay]]、{{tsl|en|Dan Ingalls}}、{{tsl|en|Adele Goldberg (computer scientist)|Adele Goldberg}}
| developer = [[艾伦·凯|Alan Kay]]、{{tsl|en|Dan Ingalls}}、{{tsl|en|Adele Goldberg (computer scientist)|Adele Goldberg}}、{{en-link|Ted Kaehler}}、{{tsl|en|Diana Merry}}、Scott Wallace、[[彼得·多伊奇|Peter Deutsch]]、[[帕羅奧多研究中心|Xerox PARC]]其他人
| latest release version = Smalltalk-80版本2
| latest release date = {{Start date and age|1983}}
| typing = [[強弱型別|強]]、[[類型系統#靜態和動態檢查|動態]]
| scope = [[作用域|词法]]（静态）
| platform = [[Xerox_Alto|Xerox Alto]]<ref>{{cite web |title=Alto I Schematics |url=http://bitsavers.org/pdf/xerox/alto/schematics/AltoI_Schematics.pdf |website=Bitsavers |access-date=21 July 2016 |page=54 |archive-date=2021-02-24 |archive-url=https://web.archive.org/web/20210224014316/http://bitsavers.org/pdf/xerox/alto/schematics/AltoI_Schematics.pdf }}</ref><ref name=alto>{{cite web |title=History of Computers and Computing, Birth of the modern computer, Personal computer, Xerox Alto |access-date=2016-04-19 |url=http://history-computer.com/ModernComputer/Personal/Alto.html |archive-date=2020-12-05 |archive-url=https://web.archive.org/web/20201205082025/https://history-computer.com/ModernComputer/Personal/Alto.html }}</ref>
| implementations = {{tsl|en|Amber Smalltalk|Amber Smalltalk|Amber}}, {{tsl|en|Dolphin Smalltalk|Dolphin Smalltalk|Dolphin}}, {{tsl|en|Gemstone (database)|GemStone/S}}, [[GNU_Smalltalk|GNU Smalltalk]], [[Pharo|Pharo]], Smalltalk/X, [[Squeak|Squeak]], {{en-link|VisualAge}}, {{tsl|en|VisualWorks}}
| dialects = [[Self|Self]], [[GNU_Smalltalk|GNU Smalltalk]]
| influenced by = [[Lisp|Lisp]],<ref name="kay2003">{{cite web|url=http://www.purl.org/stefan_ram/pub/doc_kay_oop_en|title=E-Mail of 2003-07-23|last=Kay|first=Alan|author2=Stefan Ram|date=2003-07-23|work=Dr. Alan Kay on the Meaning of “Object-Oriented Programming”|accessdate=2009-01-03|archive-date=2020-09-16|archive-url=https://web.archive.org/web/20200916071847/http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en|dead-url=no}}</ref> [[Simula|Simula]],<ref name="kay2003"/> {{tsl|en|Euler (programming language)|Euler}},<ref name="kay2003"/> {{tsl|en|IMP (programming language)|IMP}},<ref name="kay2003"/> {{tsl|en|Planner (programming language)|Planner}},<ref name="kay2003"/> [[Logo语言|Logo]]<ref name="History"/>,[[Sketchpad|Sketchpad]],<ref name="kay2003"/> [[ARPAnet|ARPAnet]],<ref name="kay2003"/> {{tsl|en|Burroughs large systems||Burroughs B5000}}<ref name="kay2003"/>
| influenced = [[AppleScript|AppleScript]], [[Common_Lisp对象系统|CLOS]], [[Dart|Dart]], [[Dylan_(编程语言)|Dylan]], [[Erlang|Erlang]], {{tsl|en|Etoys (programming language)|Etoys}}, [[Falcon|Falcon]], [[Go|Go]], [[Groovy|Groovy]], [[Io_(编程语言)|Io]], Ioke, [[Java|Java]], {{tsl|en|Lasso (programming language)|Lasso}}, {{tsl|en|Logtalk}}, {{tsl|en|Newspeak (programming language)|Newspeak (编程语言)|Newspeak}}, [[NewtonScript|NewtonScript]], {{tsl|en|Object REXX}}, [[Objective-C|Objective-C]], [[PHP|PHP 5]], [[Perl_6|Perl 6]], [[Python|Python]], [[Ruby|Ruby]], [[Scala|Scala]], [[Scratch|Scratch]], [[Self|Self]]
| operating system = [[跨平台|跨平台]]
| wikibooks = Smalltalk
| website =
}}

'''Smalltalk'''是一种[[动态类型|动态类型]]、[[反射式编程|反射式]]的[[面向对象程序设计|面向对象]][[编程语言|编程语言]]。Smalltalk由[[艾伦·凯|艾伦·凯]]、Dan Ingalls、Ted Kaehler、Adele Goldberg等于1970年代初在[[施乐|施乐]][[帕羅奧多研究中心|帕羅奧多研究中心]]开始开发。

Smalltalk对其它众多的程序设计语言的产生起到了极大的推动作用，特別是[[Objective-C|Objective-C]]、[[Common_Lisp对象系统|CLOS]]、[[Python|Python]]和[[Ruby|Ruby]]等。1990年代涌现的许多软件开发思想都得益于Smalltalk，例如[[设计模式_(计算机)|设计模式]]、[[敏捷编程|敏捷编程]]和[[代码重构|代码重构]]<ref>{{cite web|title=Where Did Refactoring Come From?|url=http://sourcemaking.com/refactoring/where-did-refactoring-come-from|work=sourcemaking.com|access-date=17 December 2013|archive-date=2016-03-31|archive-url=https://web.archive.org/web/20160331194932/https://sourcemaking.com/refactoring/where-did-refactoring-come-from}}</ref>等。

== 概述 ==
Smalltalk和许多程序设计语言不同，它不仅仅是一门语言。下面从几个不同的角度来解释Smalltalk。
*一种面向对象的程序设计语言：它是一种面向对象的语言，包含语言的语法和语义。一些编译器可以透过Smalltalk源程序产生可执行文件。这些编译器通常产生一种能在[[虚拟机|虚拟机]]上运行的二进制代码。Smalltalk语言本身非常精炼。

*一种程序设计环境：这里指的是一种提供许多[[对象_(计算机科学)|-{zh-hans:对象; zh-hant:物件;}-]]的系统，而不是某种特殊的开发环境。和许多语言不同（包括[[C++|C++]]），Smalltalk附带有一个巨大的、相当标准的类库。这些[[类_(计算机科学)|类]]使得开发Smalltalk程序的效率非常高。在其它语言（例如[[Ada|Ada]]、[[C语言|C]]和[[Pascal_(程式語言)|Pascal]]）中，通常被作为语言的一部分的功能（例如条件判断，循环等），在Smalltalk由特定的类提供。

*一个应用开发环境（ADE）：由于Smalltalk的历史原因，它具有一个非常优秀的高度集成、开放的应用开发环境。由于开发环境中的浏览器、监视器以及调试器，都由同样的源程序衍生出来的，不同的版本之间也具有相当好的兼容性。此外，这些工具的源程序都可以在ADE直接存取。

== 历史 ==
[[File:Smalltalk-76.popup.png|thumb]]
[[File:VisualWorks.png|thumb]]
[[File:Pharo_v10.png|thumb]]分叉出的开源实现[[Pharo|Pharo]]]]
最早的Smalltalk原型由[[艾伦·凯|艾伦·凯]]于1970年代初提出。[[类_(计算机科学)|类]]（来自[[Simula|Simula 67]]）、{{en-link|海龟绘图|Turtle graphics}}（来自[[Logo语言|LOGO]]）以及[[图形用户界面|图形用户界面]]（来自[[Sketchpad|Sketchpad]]等先驱系统）等概念的有机组合，构成了Smalltalk的最初的蓝图<ref name="History">{{cite web|author=[[Alan_Kay|Alan Kay]]|url=http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html|title=The Early History of Smalltalk|quote=What [[Sketchpad|Sketchpad]] called masters and instances, [[Simula|Simula]] called activities and processes. Moreover, Simula was a procedural language for controlling Sketchpad-like objects, thus having considerably more flexibility than constraints (though at some cost in elegance) ……. ……<br />This Smalltalk language (today labeled -71) was very influenced by FLEX, PLANNER, [[LOGO|LOGO]], META II, and my own derivatives from them. ……<br />One of the styles retained from Smalltalk-71 was the comingling of function and class ideas. In other works, Smalltalk-72 classes looked like and could be used as functions, but it was easy to produce an instance (a kind of closure) by using the object ISNEW. ……<br />Overlapping windows were the first project tackled (With Diana Merry) after writing the code to read the keyboard and create a string of text. ……<br />One of the next classes to be implemented on the Interim [[Dynabook|Dynabook]] (after the basics of numbers, strings, etc.) was an object-oriented version of the [[LOGO|LOGO]] turtle implemented by Ted. ……<br />Our early “[[LISP|LISP]]-pair” definition is an example of an abstract data type because it preserves the “field access” and “field rebinding” that is the hallmark of a data structure. …… What I got from Simula was that you could now replace bindings and assignment with goals. ……<br />Where does the special efficiency of object-oriented design come from? …… Four techniques used together – persistent state, polymorphism, instantiation, and methods-as-goals for the object – account for much of the power. None of these require an “object-oriented language” to be employed – [[ALGOL_68|ALGOL 68]] can almost be turned to this style – and OOPL merely focuses the designer’s mind in a particular fruitful direction. ……<br />Simula-I had neither classes as objects nor inheritance. Simula-67 added the latter as a generalization to the [[ALGOL_60|ALGOL-60]] <block> structure. ……<br />On the other hand, since things can be done with a dynamic language that the difficult with a statically compiled one, I just decided to leave inhertance out as a feature in Smalltalk-72, knowing that we could simulate it back using Smalltalk’s LISPlike flexibility. ……<br />By the time Smalltalk-76 cam along, Dan Ingalis had come up with a scheme that was Simula-like in its semantics but could be incrementally changed on the fly to be in accord with our goals of close interaction.|access-date=2021-03-06|archive-date=2011-04-29|archive-url=https://web.archive.org/web/20110429192453/http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html}}</ref>。

在1971年到1975年之间，艾伦·凯在Xerox PARC的小组，在[[Xerox_Alto|Xerox Alto]]计算机上，设计并实现了第一个真正的Smalltalk语言系统，編譯器由Dan Ingalls負責主要實作。这个系统被称为Smalltalk-71與Smalltalk-72，具有以下几个技术创新：
*语言完全基于[[消息传递|消息]][[报文交换|交换]]和[[Simula_67|Simula 67]]的类的概念。
*语言没有固定的语法，语法分析由类本身完成。
开发环境的革新相当迅速。虽然当时的[[點陣式顯示器|位图显示器]]十分昂贵，但是艾伦·凯却说服了PARC，让他使用这些位图显示器，这使得艾伦·凯和他的小组，能够实现不同大小和字体的文字，使用多窗口环境，以及一些对图像处理的高端支持。Smalltalk-72影响了[[演员模型|演员模型]]的发展<ref name="hewitt1973">{{cite paper |url=https://www.ijcai.org/Proceedings/73/Papers/027B.pdf |author={{en-link|Carl Hewitt}} |coauthors=Peter Bishop, Richard Steiger |title=A Universal Modular Actor Formalism for Artificial Intelligence |publisher=IJCAI |date=1973 |quote=Alan Kay whose FLEX and SMALLTALK machines have influenced our work. Alan emphasized the crucial importance of using intentional definitions of data structures and of passing messages to them. This paper explores the consequences of generalizing the message mechanism of SMALLTALK and SIMULA-67; ……. |journal= |access-date=2022-04-11 |archive-date=2021-02-25 |archive-url=https://web.archive.org/web/20210225043811/https://www.ijcai.org/Proceedings/73/Papers/027B.pdf }}</ref>，它的语法和执行模型，与现代的Smalltalk变体有着显著的差异。

在1975到1976年间，艾伦·凯小组认识到应当对执行效率和规模进行优化。于是他们在许多重要方面重新设计了Smalltalk系统，被称为Smalltalk-76，它在语言上：
*引入了[[继承_(计算机科学)|继承]]和子类的概念<ref>{{cite report|url=https://xeroxalto.computerhistory.org/Filene/Smalltalk-76/.document.press!1.pdf|title=How To Use the Smalltalk-76 System|author=Learning Research Group|date=October 1979|publisher=[[Xerox|Xerox]] [[Palo_Alto_Research_Center|Palo Alto Research Center]]|quote=To define a new class, select a class category in the first pane of the browse window. This selection specifies the category to which the new class will be added, and causes a template to appear in the largest pane of the browse window, the code pane. ……<br />The template presented in the code pane looks as follows<code><br /><nowiki>    </nowiki>Class new title: ’NameofClass’<br /><nowiki>    </nowiki>subclassof: Object<br /><nowiki>    </nowiki>fields: ’names of fields’<br /><nowiki>    </nowiki>declare: ’names of class variables’</code>|access-date=2022-03-12|archive-date=2022-04-12|archive-url=https://web.archive.org/web/20220412034119/https://xeroxalto.computerhistory.org/Filene/Smalltalk-76/.document.press!1.pdf}}</ref>。
*确定了语言的语法，这使得编译器能够产生高效、可执行、精炼的二进制代码。
* [[拉里·泰斯勒|拉里·泰斯勒]]设计了类浏览器，这极大地提高了Smalltalk程序员的编程效率。

前述的所有Smalltalk系统，都是在特殊的硬件上实现的，直到1977年至1978年，Bruce Horn和Ted Kaehler把Smalltalk-76移植到{{en-link|Xerox NoteTaker}}上，它是由Intel 8086处理器和自定显示器所组成的硬件环境。虽然这种硬件环境只生产了10台，但是它证明了在通常的处理器上实现Smalltalk的可能性。

在1979至1980年，部分受NoteTaker项目的影响，Smalltalk小组的注意力转移到Smalltalk的销售可行性上。小组设计并实现了新一代的Smalltalk系统，这次修改的目标着重于在标准硬件上的移植性等方面，被称为Smalltalk-80，它包括：
*采取[[ASCII|ASCII]]码字符集，摒弃了原先在Smalltalk-72和Smalltalk-76中使用的特殊字符。
*取消了原始方法直接存取内存的能力。取而代之的是引入一系列的原始方法提供相应的功能。
*引入了[[元类|元类]]的概念<ref>{{cite web|author=[[Alan_Kay|Alan Kay]]|url=http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html|title=The Early History of Smalltalk|quote=The most puzzling strange idea – at least to me as a new outsider – was the introduction of metaclasses (really just to make instance initialization a little easier – a very minor improvement over what Smalltalk-76 did quite reasonably already). <br />Peter’s 1989 comment is typical and true: “metaclasses have proven confusing to many users, and perhaps in the balance more confusing than valuable.” In fact, in their PIE system, Goldstein and Bobrow had already implemented in Smalltalk on “observer language”, somewhat following the view-oriented approach Ihad been advocating and in some ways like the “perspectives” proposed in KRL [Goldstein *]. <br />Once one can view an instance via multiple perspectives even “sem-metaclasses” like Class Class and Class Object are not really necessary since the object-role and instance-of-a-class-role are just different views and it is easy to deal with life-history issues includeding instantiation. This was there for the taking (along with quite a few other good ideas), but it wsn’t adopted. My guess is that Smalltalk had moved into the final phase I memntioned at the beginning of this story, in which a way of doing things finally gets canonized into an inflexible belief structure.|access-date=2021-03-06|archive-date=2011-04-29|archive-url=https://web.archive.org/web/20110429192453/http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html}}</ref>。
*引入[[MVC|MVC]]（模型-视图-控制器）系统以方便交互式应用软件的开发。

Smalltalk-80是在PARC之外能获得到的第一个语言变体，最初作为Smalltalk-80版本1，给与了少数公司（[[惠普|惠普]]、[[苹果公司|苹果公司]]、[[泰克|泰克]]和[[DEC|DEC]]）和大学（[[UC_Berkeley|UC Berkeley]]），用于[[同行评审|同行评审]]和在它们自己的平台上实现。后来在1983年普遍可获得的实现，叫做Smalltalk-80版本2，发行为[[虚拟机|虚拟机]]规定和映像（具有对象定义的独立于平台的文件）<ref name="v2">{{cite web|url=http://www.wolczko.com/st80/image.tar.gz|title=Smalltalk-80 v2 image|access-date=2022-02-16|archive-date=2022-03-20|archive-url=https://web.archive.org/web/20220320184838/http://www.wolczko.com/st80/image.tar.gz}}</ref>。

1988年Xerox PARC为了将Smalltalk推向市场而成立了分拆公司ParcPlace Systems。ANSI Smalltalk自从1998年来是标准的语言参考<ref>{{cite web|url=http://wiki.squeak.org/squeak/uploads/172/standard_v1_9-indexed.pdf|title=Draft American National Standard for Information Systems - Programming Languages - Smalltalk|publisher=squeak.org|access-date=2022-02-09|archive-date=2021-10-20|archive-url=https://web.archive.org/web/20211020220456/https://wiki.squeak.org/squeak/uploads/172/standard_v1_9-indexed.pdf}}</ref>。

两个当前流行的Smalltalk实现变体，是这些最初Smalltalk-80映像的后代。[[Squeak|Squeak]]是[[开源软件|开源]]实现，它经由Apple Smalltalk<ref>{{cite web|url=https://www.macintoshrepository.org/2187-apple-smalltalk-80|title=Apple Smalltalk 80}}</ref>，派生自Smalltalk-80版本1.03<ref>{{cite web|url=http://files.squeak.org/sources_files/SqueakV1.sources.gz|title=Squeak V1 Sources|access-date=2022-02-24|archive-date=2017-06-27|archive-url=https://web.archive.org/web/20170627052105/http://files.squeak.org/sources_files/SqueakV1.sources.gz}}</ref>。{{en-link|VisualWorks}}经由Smalltalk-80 2.5和ObjectWorks（二者都是ParcPlace Systems的产品），派生自Smalltalk-80版本2<ref name="v2" />。

== 面向对象编程 ==
{{main|面向对象编程}}
[[File:Smalltalk-metaclass-sample.svg|thumb]]下的类层级和与之并行的[[元类|元类]]层级的示意图。其中的<code>r</code>是<code>ProtoObject</code>，<code>c</code>是<code>Class</code>，<code>mc</code>是<code>Metaclass</code>。蓝色连接表示实例联系，绿色连接表示继承联系。]]
如同其他面向对象语言，Smalltalk-80（而非Smalltalk-72）的中心概念是“[[对象_(计算机科学)|对象]]” 。一个对象总是一个“[[类_(计算机科学)|类]]”的一个“{{en-link|实例 (计算机科学)|Instance (computer science)|实例}}”。类是描述它们的实例的属性和行为的“蓝图”。例如，一个GUI窗口类，可以声明窗口拥有的属性，比如标签、位置和窗口是否可见。这个类还可以声明其实例支持的操作，比如打开、关闭、移动和隐藏。每个特定窗口对象，对这些属性都有自己的值，它们每个都能进行它的类定义的操作。

Smalltalk对象确切的可以做三件事：
# 持有状态（引用到其他对象）。
# 接收[[消息传递|消息]]自本身或其他对象。
# 在处理一个消息的过程中，发送消息至本身或其他对象。

一个对象持有的状态总是私有于这个对象。其他对象只能通过发动请求（消息）至这个对象，来让它做出查询或变更这个状态。任何消息可以发送给任何对象：当接收到一个消息的时候，接收者确定这个消息是否合适。Alan Kay评论说，尽管关注于对象，消息才是Smalltalk中最重要的概念：“最大的想法是消息传递，它是Smalltalk/[[Squeak|Squeak]]核心的全部意义所在（它是我们在Xerox PARC阶段从未真正完成的某种东西）。”<ref>{{cite web |last=Kay |first=Alan |title=Prototypes vs Classes (e-mail on Squeak list) |url=http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html |date=October 10, 1998 |access-date=2021-03-06 |archive-date=2021-02-16 |archive-url=https://web.archive.org/web/20210216140614/http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html }}</ref>

不同于多数其他语言，Smalltalk对象可以在系统运行的同时进行修改。现场编码和飞速应用补丁，是Smalltalk的主导编程方法论，并且是它高效的主要原因。

Smalltalk是“纯”面向对象编程语言，这意味着，不像[[C++|C++]]和[[Java|Java]]，在作为对象的值和作为原始类型的值之间没有区别。在Smalltalk中，原始值比如整数、布尔值和字符，也是对象，这么说的意义在于它们也是相应类的实例，而且要发送消息来调用在它们上的运算。编程者可以通过[[继承_(计算机科学)|子类]]，改变或扩展实现原始值的类，使得可以向它们的实例定义新行为，例如实现一个新的控制结构，甚至使得它们现有行为得以改变。这个事实被总结成常听到的一句短语：“在Smalltalk中，所有东西都是对象”，它可以更精确的表达为：“所有的值都是对象”，因为变量不是。

因为所有的值都是对象，[[类_(计算机科学)|类]]也是对象。每个类都是这个类的[[元类|元类]]的一个实例。元类都是<code>Metaclass</code>（元类类）的实例，它也是对象，并且是<code>Metaclass class</code>（元类元类）的实例。代码块是Smalltalk表达[[匿名函数|匿名函数]]的方式，它也是对象<ref>{{cite book|last1=Goldberg|first1=Adele|author-link1=Adele Goldberg (computer scientist)|last2=Robson|first2=David|title=Smalltalk-80 The Language|year=1989|publisher=Addison Wesley|isbn=0-201-13688-0|pages=31, 75–89}}</ref>。

==Hello, World!例子==
[[Hello_World|Hello, World!]]程序，实质上被所有计算机语言的课本用作要学习的第一个程序，它展示了这个语言的最基本语法和环境。对于Smalltalk，这个程序可极其简单的书写。下列代码中，消息<code>show:</code>被发送给对象<code>Transcript</code>，具有字符串文字<code>'Hello, World!'</code>作为它的实际参数。调用<code>show:</code>方法，导致它的实际参数，即字符串文字<code>'Hello, World!'</code>，显示在叫做“副本”（Transcript）的终端窗口：
<syntaxhighlight lang="smalltalk">
Transcript show: 'Hello, World!'.
</syntaxhighlight>
注意需要打开Transcript窗口，来看到这个例子的结果。

==语法==
Smalltalk-80语法是相当[[极简主义|极简主义]]的，只基于了一小把的声明和保留字。事实上，Smalltalk中只保留了六个“关键字”：<code>true</code>、<code>false</code>、<code>nil</code>、<code>self</code>、<code>super</code>和<code>thisContext</code>。它们的准确术语是“伪变量”，是服从变量标识符规则的标识符，但指示了编程者所不能变更的绑定。<code>true</code>、<code>false</code>和<code>nil</code>伪变量是[[单例模式|单例]]实例。<code>self</code>和<code>super</code>，在响应一个消息而激活的方法中，指称这个消息的接收者；但是发送给<code>super</code>的消息，在这个方法的定义类的超类中查找方法，而非这个接收者的类中，这允许子类中的方法调用在超类中的同名方法。<code>thisContext</code>指称当前的活动记录。

内建的语言构造只有消息发送、赋值、方法返回和某些对象的文字语法。从它最初作为给所有年龄儿童的语言开始，标准的Smalltalk语法以更像英语，而非主流编码语言的方式使用标点符号。语言余下部份，包括用于条件求值和迭代的控制结构，都由标准Smalltalk类库实现在内建构造之上。出于性能上的原因，实现可以识别并特殊处理某些这种消息，但这只是优化而并未硬性规定入语言语法。

谚语“Smalltalk语法适合一张[[明信片|明信片]]”，所提及的是{{en-link|Ralph Johnson|Ralph Johnson (computer scientist)|Ralph Johnson}}的一个代码片段，展示了一个方法的所有基本标准语法元素<ref>{{cite web|url=http://sdmeta.gforge.inria.fr/Programmez/OnTheWeb/Art2-Eng-AminimalistSyntax.pdf|title=Squeak: A minimalist syntax!|access-date=2021-03-06|archive-date=2018-06-13|archive-url=https://web.archive.org/web/20180613141451/http://sdmeta.gforge.inria.fr/Programmez/OnTheWeb/Art2-Eng-AminimalistSyntax.pdf}}<br />{{cite web |url=http://scg.unibe.ch/archive/lectures/DucasseLectures/Duca00y1SmalltalkLectures.pdf |title=Object-Oriented Design with Smalltalk — a Pure Object Language and its Environment |access-date=2021-03-06 |archive-date=2021-01-21 |archive-url=https://web.archive.org/web/20210121155228/http://scg.unibe.ch/archive/lectures/DucasseLectures/Duca00y1SmalltalkLectures.pdf }}</ref>：
<syntaxhighlight lang="smalltalk">
exampleWithNumber: x
  | y |
  true & false not & (nil isNil) ifFalse: [self halt].
  y := self size + super size.
  #($a #a 'a' 1 1.0)
    do: [ :each |
      Transcript show: (each class name);
                 show: ' '].
  ^x < y
</syntaxhighlight>

===文字===
下列例子诠释了最常用的对象，可以在Smalltalk-80方法中被写为{{en-link|文字 (计算机编程)|Literal (computer programming)|文字}}值。

====数和字符====
下列是数的某些可能例子：
<syntaxhighlight lang="console">
42
-42
123.45
1.2345e2
2r10010010
16rA000
</syntaxhighlight>

最后两个项目分别是二进制和十六进制数。在<code>r</code>前的数是[[底数_(进制)|底数]]或基数。基数不必须是二的幂；例如<code>36rSMALLTALK</code>是一个有效的数值，等价于十进制的<code>80738163270632</code>。

[[字符|字符]]书写时带有前导的美元符：
<syntaxhighlight lang="smalltalk">$A</syntaxhighlight>

====字符串====
[[字符串|字符串]]是包围在单引号内的字符序列：
<syntaxhighlight lang="smalltalk">'Hello, world!'</syntaxhighlight>

要在一个字符串中包括一个引号，使用另一个引号来[[转义字符|转义]]：
<syntaxhighlight lang="smalltalk">'I said, ''Hello, world!'' to them.'</syntaxhighlight>

双引号不需要转义，因为单引号界定字符串：
<syntaxhighlight lang="smalltalk">'I said, "Hello, world!" to them.'</syntaxhighlight>

两个相等的字符串（字符串相等，如果它们包含完全相同的字符）可以是驻留在内存不同位置中的不同对象。

====符号====
除了字符串，Smalltalk有一类叫做{{en-link|符号 (编程)|Symbol (programming)|符号}}（<code>Symbol</code>）的字符序列对象。符号保证是唯一的，没有作为不同对象的两个相等的符号。因此，符号非常易于比较，并经常用于语言构造中，比如用作消息选择子。

符号被写为<code>#</code>跟随着{{en-link|字符串文字|string literal}}。比如：
<syntaxhighlight lang="smalltalk">#'foo'</syntaxhighlight>

如果一个序列不包含空白或标点字符，还可以写为：
<syntaxhighlight lang="smalltalk">#foo</syntaxhighlight>

====数组====
例如定义了四个整数的一个数组：
<syntaxhighlight lang="smalltalk">#(1 2 3 4)</syntaxhighlight>

很多实现支持下列字节数组（<code>ByteArray</code>）的文字语法，例如定义了四个整数的字节数组：
<syntaxhighlight lang="Javascript">#[1 2 3 4]</syntaxhighlight>

====其他====
最后却重要的是块（[[匿名函数|匿名函数]]文字）:
<syntaxhighlight lang="smalltalk">[... 一些smalltalk代码 ...]</syntaxhighlight>

很多Smalltalk方言为其他对象实现了额外的语法，但是上述的是所有方言都本质上支持的。

===变量声明===
在各种Smalltalk中共同使用的有两种变量：实例变量和临时变量。其他变量和有关术语依赖于特定实现，例如{{en-link|VisualWorks}}有类共享变量和名字空间共享变量，而[[Squeak|Squeak]]和很多其他实现，有类变量、池变量和全局变量。

在Smalltalk中临时变量声明是在方法（见后）内声明的变量。它们声明在方法的顶部，作为由竖杠包围的空格分隔的名字。例如：

<syntaxhighlight lang="smalltalk">| index |</syntaxhighlight>

声明一个临时变量名叫<code>index</code>，可以包含初始值<code>nil</code>。

多个变量可以在一组竖杠内声明：

<syntaxhighlight lang="smalltalk">| index vowels |</syntaxhighlight>

声明了两个变量：<code>index</code>和<code>vowels</code>。所有变量都要初始化。字符串的索引变量，初始化为<code>null</code>字符或初始为<code>0</code>的<code>ByteArray</code>，此外的所有变量初始化为<code>nil</code>。

按命名约定，实例变量、临时变量、方法或块的参数，应当以小写字母开头，指示它们具有私有作用域，它们合称为局部变量。而全局变量、类变量、池字典、类名字，应当以大写字母开头，它们合称为共享变量。

===赋值===
变量通过<code>:=</code>语法来指定一个值。比如：

<syntaxhighlight lang="smalltalk">vowels := 'aeiou'</syntaxhighlight>

指定字符串<code>'aeiou'</code>至前面声明的<code>vowels</code>变量。这个字符串是个对象（在单引号之间的字符序列是文字字符串的语法），在编译时间由编译器创建。

在最初的Parc Place映像中，现在下划线（<code>_</code>）的字形，在那时是左向箭头（<code>←</code>）字形（就像1963年版本[[ASCII|ASCII]]代码中那样）。Smalltalk最初接受左向箭头，作为唯一的赋值算符。一些现代代码仍然包含充当赋值的下划线，会让人想起这种最初的用法。多数现代的Smalltalk实现接受要么下划线，要么冒号等号语法。

===消息===
消息是Smalltalk中最基础的语言构造。所有控制结构都实现为[[消息传递|消息发送]]。Smalltalk缺省的采用[[动态分派|动态分派]]和[[单一分派|单一分派]]策略，这是相对于其他一些面向对象语言使用的[[多分派|多分派]]而言的。

====一元消息====
下列例子是发送消息<code>factorial</code>至数值<code>42</code>：
<syntaxhighlight lang="smalltalk">42 factorial</syntaxhighlight>

在这种情况下，<code>42</code>叫做这个消息的“接收者”，而<code>factorial</code>是消息的选择子。接收者通过返回一个值来相应这个消息（这个情形中是<code>42</code>的阶乘）。同其他事物一样，消息的结果可以赋值给一个变量：
<syntaxhighlight lang="smalltalk">aRatherBigNumber := 42 factorial</syntaxhighlight>

上面的<code>factorial</code>是“一元”消息，因为只涉及了一个对象，即接收者。

====关键字消息====
消息可以承载额外的对象作为实际参数，比如：
<syntaxhighlight lang="smalltalk">2 raisedTo: 4</syntaxhighlight>

在这个表达式中，涉及了两个变量：<code>2</code>作为接收者而<code>4</code>作为消息的实际参数。消息结果，或用Smalltalk的说法，回答被认定为<code>16</code>。这种消息叫做“关键字”消息。消息可以有多个实际参数，使用如下语法:
<syntaxhighlight lang="smalltalk">'hello world' indexOf: $o startingAt: 6</syntaxhighlight>

它的回答是在接收者字符串中字符<code>o</code>的索引，从索引<code>6</code>开始查找。这个消息的选择子是<code>indexOf:startingAt:</code>，构成自两个部份或关键字。

这种关键字和实际参数的交织意图改进代码的可读性，因为实际参数由前导于它们的关键字来解释。例如，要建立一个矩形的表达式使用C++或Java类语法可以写为：
<syntaxhighlight lang="java">new Rectangle(100, 200);</syntaxhighlight>

不清楚这些实际参数分别是什么。与之相反，在Smalltalk中，这个代码可以写为：
<syntaxhighlight lang="smalltalk">Rectangle width: 100 height: 200</syntaxhighlight>

这个情况下接收者是<code>Rectangle</code>类，回答是这个类的具有指定宽度和高度的一个实例。

====二元消息====
最后，多数特殊（非字母）字符可以被用作所谓的“二元消息”。这些允许了数学和逻辑算符以传统形式书写：

<syntaxhighlight lang="smalltalk">3 + 4</syntaxhighlight>

它发送消息<code>+</code>给接收者<code>3</code>，具有<code>4</code>作为实际参数传递（回答将是<code>7</code>）。类似的：

<syntaxhighlight lang="smalltalk">3 > 4</syntaxhighlight>

将消息<code>></code>发送给<code>3</code>具有实际参数<code>4</code>（回答将是<code>false</code>）。

注意，Smalltalk-80语言自身，不包含着这些算符的含义。上述的结果，都只是这些消息的接收者（这里是数值实例），为了响应消息<code>+</code>和<code>></code>而定义并返回的。这个机制的副作用是[[运算符重载|运算符重载]]，消息<code>></code>可以被其他对象所理解，允许使用形如<code>a > b</code>的表达式来比较它们。

===表达式===
一元消息可以一个接一个的写成{{en-link|方法链|method chaining}}：
<syntaxhighlight lang="smalltalk">3 factorial factorial log</syntaxhighlight>
它发送<code>factorial</code>到<code>3</code>，接着发送<code>factorial</code>到前面的结果<code>6</code>，接着发送<code>log</code>到前面的结果<code>720</code>，产生最终的结果<code>2.85733</code>。

一个表达式可以包括多次消息发送。在这个情况下，表达式依据一个简单的优先级次序来分析。一元消息有最高的优先级，随后是二元消息，最后是关键字消息。例如：
<syntaxhighlight lang="smalltalk">3 factorial + 4 factorial between: 10 and: 100</syntaxhighlight>
被求值如下：
#<code>3</code>接收消息<code>factorial</code>并回答<code>6</code>
#<code>4</code>接收消息<code>factorial</code>并回答<code>24</code>
#<code>6</code>接收消息<code>+</code>具有<code>24</code>作为实际参数并回答<code>30</code>
#<code>30</code>接收消息<code>between:and:</code>具有<code>10</code>和<code>100</code>作为实际参数并回答<code>true</code>
最后的消息发送的回答，是整个表达式的结果。

====组合====
在需要的时候使用圆括号可以改变求值的次序。例如：
<syntaxhighlight lang="smalltalk">(3 factorial + 4) factorial between: 10 and: 100</syntaxhighlight>
将改变表达式含义，首先计算<code>3 factorial + 4</code>产生<code>10</code>。接着<code>10</code>接收第二个<code>factorial</code>消息，产生<code>3628800</code>。<code>3628800</code>接着接收<code>between:and:</code>，回答<code>false</code>。

注意由于二元消息的含义，不是硬性规定入Smalltalk-80语法的，它们全部都被认为有相等的优先级，并简单的从左至右来求值。因此，使用二元消息的Smalltalk表达式的含义，可能不同于传统释义：
<syntaxhighlight lang="smalltalk">3 + 4 * 5</syntaxhighlight>
被求值为<code>(3 + 4) * 5</code>，产生<code>35</code>。要得到预期回答<code>23</code>，必须使用圆括号来显式的定义运算次序：
<syntaxhighlight lang="smalltalk">3 + (4 * 5)</syntaxhighlight>

====复合====
以点号分隔的表示式按顺序执行。注意在变量定义和随后的表达式之间没有点号。一个表达式序列的值，是最后的表达式的值。除了最后的表达式之外，所有的表达式的值都被忽略。注意点号是分隔符而并非终结符，因此最终的点号是可选的。

下列（假想）例子中，书写了一序列的表达式，每个都用点号分隔。这个例子首先建立类<code>Window</code>的一个新实例，存储它在一个变量中，接着向它发送两个消息：
<syntaxhighlight lang="smalltalk">
| window |
window := Window new.
window label: 'Hello'.
window open
</syntaxhighlight>

====级联====
如果像上述例子这样，将一序列消息都发送给相同的接收者，它们也可以写为{{en-link|方法级联|method cascading}}，具有用分号分隔的单独消息：
<syntaxhighlight lang="smalltalk">
Window new
  label: 'Hello';
  open
</syntaxhighlight>
这种将前面例子的重新为一个单一表达式，避免了对将新窗口存储在临时变量的需要。依据平常的优先级规则，首先向<code>Window</code>类发送一元消息<code>new</code>，接着向<code>new</code>回答的那个对象，发送<code>label:</code>和<code>open</code>。

可以使用<code>yourself</code>消息来返回一个级联消息的接收者。

===代码块===
[[块_(编程)|块]]是[[头等对象|头等对象]]。代码块即[[匿名函数|匿名函数]]，可以被表达一个文字值（它是一个对象，因为所有值都是对象）。这是通过方括号达成的：

<syntaxhighlight lang="smalltalk">[ :params | <消息表达式> ]</syntaxhighlight>

这里的<code>:params</code>是代码可以接受的形式参数的列表。结果的块对象可以形成一个[[闭包_(计算机科学)|闭包]]：它可以在任何时间访问它外围的词法作用域内的变量。这意味着下列Smalltalk代码：
<syntaxhighlight lang="smalltalk">[:x | x + 1]</syntaxhighlight>
可以理解为：<math>f(x) = x + 1</math>，或用[[λ演算|λ演算]]表达为：<math>\lambda x</math> : <math>x + 1</math>。

块可以通过发送给它们<code>value</code>消息来执行。块有一个参数用<code>value:</code>，有2个参数使用<code>value:value:</code>，以此类推直到4个参数，对多于4个参数使用<code>valueWithArguments:</code>并将参数作为数组传递。例如下面的表达式：
<syntaxhighlight lang="smalltalk">[:x | x + 1] value: 3</syntaxhighlight>
可以被求值为：<math>f(3) = 3 + 1</math>，或用λ演算表达为：<math>(\lambda x. x + 1)\,3 \,\underset{\beta}\rightarrow \, 3+1</math>。

块返回（常称为回答）其主体的最后一个表达式的值，除非有一个由显式的<code>^</code>指示的返回，这时返回这个返回表达式的值。在块内部的返回，充当了一种逃出（escape）机制。在一个嵌套的块表达中的返回表达式，将终止在字面上包围的方法。

块的文字表示是一种创新，它一方面允许特定代码有更重大的可读性；它允许涉及迭代的算法一更清晰和简洁的方式编码。典型的在某些语言中使用循环写成的代码，可以在Smalltalk中使用块简洁的书写，有时在单一一行之内。更加重要的，块允许使用消息和[[多态_(计算机科学)|多态]]来表达控制结构，因为块推延了计算，而多态可以用来选择交替者（alternative）。所以在Smalltalk 80中，<code>if…then…else</code>被书写和实现为：
<syntaxhighlight lang="smalltalk">
expr ifTrue: [ expr为真时求值的语句 ] ifFalse: [ expr为假时求值的语句 ]
</syntaxhighlight>

再举一例，向一个搜集发送消息<code>select:</code>：
<syntaxhighlight lang="smalltalk">
positiveAmounts := allAmounts select: [:anAmount | anAmount isPositive]
</syntaxhighlight>

注意这与[[函数式编程|函数式编程]]有关，这里的计算模式被[[抽象化_(计算机科学)|抽象]]成了[[高阶函数|高阶函数]]。<code>select:</code>等价于在一个适当的[[函数对象|函子]]上的高阶函数[[Filter_(高阶函数)|filter]]<ref>{{cite book|last1=Goldberg|first1=Adele|author-link1=Adele Goldberg (computer scientist)|last2=Robson|first2=David|title=Smalltalk-80 The Language|year=1989|publisher=Addison Wesley|isbn=0-201-13688-0|pages=17–37}}</ref>。

==控制结构==
在Smalltalk中控制结构没有特殊的语法。它们转而实现为发送到对象上的消息。以条件执行为例，布尔类<code>Boolean</code>定义了<code>ifTrue:</code>、<code>ifFalse:</code>、<code>ifTrue:ifFalse:</code>和<code>ifFalse:ifTrue:</code>方法。比如向一个布尔对象，发送<code>ifTrue:</code>消息，并传递一个代码块作为实际参数，这个块被执行当且仅当布尔接收者为真。下面用一个例子来展示：
<syntaxhighlight lang="smalltalk">
result := a > b
  ifTrue: [ 'greater' ]
  ifFalse: [ 'less or equal' ]
</syntaxhighlight>

块也被用来实现，用户定义控制结构、[[迭代器|枚举器]]、[[访问者模式|访问者]]、[[异常处理|异常处理]]、可插拔的行为和很多其他模式。

===迭代===
下面例子，从一个字符串中[[filter_(高阶函数)|过滤]]出其中所含有的[[元音|元音]]字符：
<syntaxhighlight lang="smalltalk">
| aString vowels |
aString := 'This is a string'.
vowels := aString select: [:aCharacter | aCharacter isVowel].
</syntaxhighlight>
在最后一行，向字符串对象<code>aString</code>发送一个<code>select:</code>消息，它具有一个代码块<code>[:aCharacter | aCharacter isVowel]</code>作为实际参数。这个代码块，表示一个测试，代码块文字将被用作一个谓词函数，它回答<code>true</code>，当且仅当这个字符串的一个元素<code>aCharacter</code>，应当被包括在满足这个测试的字符搜集之中。

字符串类<code>String</code>响应<code>select:</code>消息，要调用的<code>select:</code>方法，定义并实现在搜集类<code>Collection</code>中<ref>
Collection Method Definitions: 
<syntaxhighlight lang="smalltalk">
select: aBlock 
  "Answer a new instance of a Collection containing all the elements
   in the receiver which, when passed to aBlock, answer true"
  | newCollection |
  newCollection := self copyEmpty.
  self do:
    [:element | (aBlock value: element) ifTrue: [newCollection add: element]].
  ^newCollection
</syntaxhighlight>
</ref>；它将给<code>select:</code>的实际参数选择块，传送给形式参数<code>aBlock</code>；然后将绑定了选择块的<code>aBlock</code>嵌入到迭代块的代码之中，再把这个迭代块作为向字符串自身发送的<code>do:</code>消息的实际参数，从而将这个字符串所包含的每个字符，都作为实际参数传送给这个迭代块，而各做一次求值。在求值迭代块的时候，通过<code>value:</code>消息，将迭代元素传送给<code>aBlock</code>所绑定的选择块，它回答一个布尔值；接着向它发送<code>ifTrue:</code>消息，如果这个布尔值是对象<code>true</code>，则将这个字符增加到要返回的字符串中。

字符串类<code>String</code>响应<code>do:</code>消息，要调用的<code>do:</code>方法，定义在可迭代类<code>Iterable</code>中<ref>
Iterable Method Definitions:
<syntaxhighlight lang="smalltalk">
do: aBlock
  "Enumerate each object of the receiver, passing them to aBlock"
  self subclassResponsibility
</syntaxhighlight>
</ref>，而实现在可序列化搜集类<code>SequenceableCollection</code>中<ref>
SequenceableCollection Method Definitions:
<syntaxhighlight lang="smalltalk">
do: aBlock
  "Evaluate aBlock for all the elements in the sequenceable collection"
  1 to: self size do: [:i | aBlock value: (self at: i)]
</syntaxhighlight>
Interval Method Definitions:
<syntaxhighlight lang="smalltalk">
do: aBlock
  "Evaluate the receiver for each element in aBlock"
  | i |
  i := start. step > 0 
    ifTrue: [[i_<=_stop]_whileTrue:_[aBlock_value:_i._i_:=_i_+_step|i <= stop] whileTrue: [aBlock value: i. i := i + step]]
    ifFalse: [[i_>=_stop]_whileTrue:_[aBlock_value:_i._i_:=_i_+_step|i >= stop] whileTrue: [aBlock value: i. i := i + step]]
</syntaxhighlight>
</ref>，这个类是<code>Iterable</code>类的子类和<code>String</code>类的超类。

===异常处理===
Smalltalk的异常处理机制，<code>Exception</code>类及其子类比如<code>Error</code>类，类似于[[Common_Lisp对象系统|CLOS]]的异常处理样式，使用块作为处理器：
<syntaxhighlight lang="smalltalk">
[ 一些运算. 
  Error signal: 'an error occurred'.
  另一些运算
] on: Error do: [ :ex | 
  处理器代码. 
  ex return ]
</syntaxhighlight>
异常处理器的<code>ex</code>实际参数，提供对挂起运算的状态的访问，比如它的栈帧、行号、接收者和实际参数等，并且通过发送<code>ex proceed</code>、<code>ex reject</code>、<code>ex restart</code>或<code>ex return</code>之一，还可用来控制计算怎样继续。

==类==
类通过实例变量定义它的实例的结构，通过方法定义它的实例的行为。每个方法都有叫做选择子的一个名字，它在这个类之内是唯一性的。

===定义===
下面是个平凡的类定义<ref>{{cite book|last1=Goldberg|first1=Adele|author-link1=Adele Goldberg (computer scientist)|last2=Robson|first2=David|title=Smalltalk-80 The Language|year=1989|publisher=Addison Wesley|isbn=0-201-13688-0|pages=39–53}}</ref>：
<syntaxhighlight lang="smalltalk">
Object subclass: #MessagePublisher
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Smalltalk Examples'
</syntaxhighlight>
多数这种定义经常由编程环境来填充。这里的类定义是给<code>Object</code>类的一个消息，用来建立它叫做<code>MessagePublisher</code>的一个子类。

在Smalltalk中类是[[头等对象|头等对象]]，它可以就像任何其他对象一样接收消息，并可以在执行时间动态的创建。<code>Object</code>类在收到这个<code>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:</code>消息之时，原则上首先在其[[元类|元类]]<code>Object class</code>中查找对应方法，未果而上溯继承链在其超类<code>Class</code>类中找到对应方法实现。

在Smalltalk中，{{en-link|实例变量|Instance variable}}是这个实例的私有变量，它可以在定义它们的类的任何实例方法中，还有在它的子类中定义的方法中，通过名字来访问。在需要于一个类的所有实例、这个类本身和它的子类之间，共享某个数据的时候，要使用{{en-link|类变量|Class variable}}，它是由这个类和它的所有实例共享的私有变量。池变量是在可以没有继承关联的多个类之间共享的变量。池变量最初存储在池字典中，现在它们应当被定义为专门的类（<code>SharedPool</code>的子类）的类变量。

<code>category</code>指示有关的类的“群组”，在现代Smalltalk版本如[[Pharo|Pharo]]中被替代为<code>package</code>，包系统是利用简单的命名约定，组织[[Squeak|Squeak]]和[[Pharo|Pharo]]源代码的简单而轻量级的方式。

在一个类所对应的[[元类|元类]]中定义的实例变量叫做类实例变量，每个类都有自己私有的类实例变量，子类将继承这些类实例变量，但是子类会拥有这些变量的它们自己的私有复本，类和它们的子类不分享类实例变量。例如，可以定义一个类实例变量叫做<code>count</code>来跟踪一个给定的类有多少实例。

类不能直接访问它的实例的实例变量，而实例不能访问它们的类的类实例变量。如果需要的话必须定义[[变异子与访问子|变异子与访问子]]。

===方法===
当一个对象接收到一个消息的时候，调用[[模式匹配|匹配]]这个消息名字的一个方法。所有方法都是公开的和[[虚函数|虚拟]]的（也就是[[动态分派|动态查找]]的）。方法被分组入指示它们意图的[[协议_(面向对象编程)|协议]]（protocol）之中。

为一个类增加方法涉及到<code>Behavior</code>类，其中的<code>compile:</code>方法，编译一个方法源代码并返回一个<code>CompiledMethod</code>类的实例；<code>addSelector:withMethod:</code>方法，将给定的一个编译过的方法增加到方法字典中。在<code>Behavior</code>类的子类<code>ClassDescription</code>类中，<code>compile:classified:</code>方法，编译一个方法的源代码，并为这个方法指派上给定的归类（对于方法称为协议）。

对象负责在运行时间动态的确定，执行哪个方法来响应一个消息，尽管在很多语言中，这可能是（有时或总是）在编译时间静态确定的。下列代码定义一个方法<code>publish</code>，并且这个定义将在这个对象收到<code>publish</code>消息的时候发生。
<syntaxhighlight lang="smalltalk">
publish
  Transcript show: 'Hello World!'
</syntaxhighlight>

下列名字为<code>#quadMultiply:and:</code>的方法，演示了接收多个实际参数并返回一个值：
<syntaxhighlight lang="smalltalk">
quadMultiply: i1 and: i2
  "这个方法将给定的两个数相乘并对结果乘以4."
  | mul |
  mul := i1 * i2.
  ^mul * 4
</syntaxhighlight>

执行任何前导了<code>^</code>（[[脱字符|脱字符]]或<code>↑</code>）的表达式，都导致这个方法于这一点退出，并返回这个表达式的值。终止而没有显式返回某个表达式的一个方法，将隐含的返回自身。

===实例化===
为一个类新建一个实例，要用到<code>new</code>方法，它定义在<code>Behavior</code>类中。下列例子代码：
<syntaxhighlight lang="smalltalk">
MessagePublisher new
</syntaxhighlight>
建立并返回<code>MessagePublisher</code>类的一个新实例。它典型的会被赋值到一个变量：
<syntaxhighlight lang="smalltalk">
publisher := MessagePublisher new
</syntaxhighlight>
但是也可以向一个临时的匿名对象发送一个消息：
<syntaxhighlight lang="smalltalk">
MessagePublisher new publish
</syntaxhighlight>

===类方法===
[[类方法|类方法]]就是在一个类的[[元类|元类]]中定义的方法。

比如搜集类<code>Collection</code>的类方法中，实例创建方法有<code>with:</code>、<code>with:with:</code><ref>
Collection Method Definitions: 
<syntaxhighlight lang="smalltalk">
Collection class >> with: firstObject with: secondObject 
  "Answer a collection whose only elements are the parameters
   in the order they were passed"
    ^(self new)
      add: firstObject;
      add: secondObject;
      yourself
</syntaxhighlight>
</ref>、一直到<code>with:with:with:with:with:with:</code>方法。在下面的例子中，将<code>with:with:</code>用于有序搜集类<code>OrderedCollection</code>，它是<code>SequenceableCollection</code>类的子类，故而能最终上溯至超类搜集类：
<syntaxhighlight lang="smalltalk">
| rectangles aPoint collisions |
rectangles := OrderedCollection
  with: (Rectangle left: 0 right: 10 top: 100 bottom: 200)
  with: (Rectangle left: 10 right: 10 top: 110 bottom: 210).
aPoint := Point x: 20 y: 20.
collisions := rectangles select: [:aRect | aRect containsPoint: aPoint].
</syntaxhighlight>

== 反射 ==
{{main|反射式编程}}

[[反射式编程|反射]]是一个计算机科学术语，适用于有能力检查它们自己的结构的软件程序，例如检查它们的[[分析树|分析树]]或输入和输出参数的[[数据类型|数据类型]]。反射是动态、交互式语言比如Smalltalk和Lisp的一个特征。具有反射的交互式程序（要么解释的要么编译的）维护所有内存内对象的状态，包括代码对象自身，这是在解析/编译期间生成的，并且是在编程上可访问和修改的。

反射也是Smalltalk这种有元模型的语言的一个特征。[[元建模|元模型]]是描述这个语言的模型，开发者可以使用元模型来做事，比如游历、检查和修改一个对象的分析树，或找到特定种类的结构的所有实例（例如在元模型中<code>Method</code>类的所有实例）。

Smalltalk-80是完全的反射式系统，用Smalltalk-80语言实现。Smalltalk-80提供了结构性和计算性反射二者。Smalltalk是结构性反射式系统，其结构是由Smalltalk-80对象定义的。定义这个系统的类和方法也是对象，并且完全是它们所有助力定义的系统的一部份。Smalltalk编译器将文本源代码编译成方法对象，典型是的<code>CompiledMethod</code>的实例。通过把它们存储入一个类的方法字典，而增加到这个类。类层级的定义类的那部份，可以向系统增加新类。这个系统是通过运行建立或定义类和方法的Smalltalk-80代码来扩展的。Smalltalk-80系统是个现场（living）系统，承载着在运行时间扩展自身的能力。

因为类是对象，可以向它们提问比如：“你实现了哪些方法？”或“你定义了什么字段/槽/实例变量？”。所以通过能应用于系统中的任何对象的普通的代码，对象可以轻易的检查、复制、（去）[[序列化|序列化]]，诸如此类<ref>{{cite journal|last=Clark|first=A.N.|title=Metaclasses and Reflection in Smalltalk|year=1997}}</ref>。

Smalltalk-80还提供计算性反射，有能力观察系统的计算状态。在派生自最初Smalltalk-80的语言中，一个方法的当前活动（activation），可以作为通过伪变量命名的一个对象来访问，这个伪变量是作为六个保留字之一的<code>thisContext</code>。通过发送消息至<code>thisContext</code>，一个方法活动可以提问比如：“谁给你发送了这个消息？”。这些设施使得有可能实现[[协程|协程]]，或类似[[Prolog|Prolog]]的[[回溯法|回溯]]，而不需要修改虚拟机。异常系统也是使用这个设施实现的。这个设施更有趣的用法之一，是在{{en-link|Seaside (软件)|Seaside (software)|Seaside}} web框架之中，它通过为每个编辑的页面存储[[计算续体|续体]]，并在它们之间切换来导航一个web站点，缓解了编程者处理Web浏览器的返回按钮的复杂性。使用Seaside编程web服务器，可以使用更常规的编程风格来完成<ref>{{cite web|last1=Ducasse|first1=Stéphane|last2=Lienhard|first2=Adrian|last3=Renggli|first3=Lukas|title=Seaside – A Multiple Control Flow Web Application Framework|url=http://scg.unibe.ch/archive/papers/Duca04eSeaside.pdf|work=scg.unibe.ch|publisher=Software Composition Group Institut fur Informatik und angewandte Mathematik Universitaat Bern, Switzerland|access-date=16 December 2013|archive-date=2020-01-31|archive-url=https://web.archive.org/web/20200131175329/http://scg.unibe.ch/archive/papers/Duca04eSeaside.pdf}}</ref>。

Smalltalk如何使用反射的一个例子，是处理错误的机制。当一个对象被发送了一个它没有实现的消息的时候，虚拟机发送给这个对象<code>doesNotUnderstand:</code>消息，具有这个消息的[[实化|实化]]作为实际参数。这个消息（它是另一个对象，是<code>Message</code>的实例），包含这个消息的选择子和它的实际参数的一个<code>Array</code>。在交互式Smalltalk系统中，<code>doesNotUnderstand:</code>的缺省实现，是打开一个错误窗口（一个<code>Notifier</code>）向用户报告错误。通过它和反射设施，用户可以检查错误在其中发生的上下文，重新定义犯错的代码，并继续，这一切都在这个系统之中，使用Smalltalk-80的反射设施<ref>{{cite journal|last1=Foote|first1=Brian|last2=Johnson|first2=Ralph|title=Reflective Facilities in Smalltalk-80|journal=Oopsla '89|pages=327–335|date=1–6 October 1989|url=http://www.laputan.org/ref89/ref89.html|access-date=16 December 2013|doi=10.1145/74877.74911|isbn=0897913337|archive-date=2021-03-24|archive-url=https://web.archive.org/web/20210324045422/http://www.laputan.org/ref89/ref89.html}}</ref><ref>{{cite journal|last=Smith|first=Brian C|title=Procedural Reflection in Programming Languages|journal=MIT Technical Report|date=1982-01-01|issue=MIT-LCS-TR-272|url=http://publications.csail.mit.edu/lcs/specpub.php?id=840|access-date=16 December 2013|archive-date=2015-12-13|archive-url=https://web.archive.org/web/20151213034343/http://publications.csail.mit.edu/lcs/specpub.php?id=840}}</ref>。

通过建立只理解（实现）<code>doesNotUnderstand:</code>的一个类，可以建立一个实例，经由它的<code>doesNotUnderstand:</code>方法能拦截发送给它的任何消息。这种实例可以叫做透明代理（proxy）<ref>{{cite journal|last1=Denker|first1=Marcus|last2=Peck|first2=Mariano Martinez|last3=Bouraqadi|first3=Noury|last4=Fabresse|first4=Luc|last5=Ducasse|first5=Stéphane|title=Efficient Proxies in Smalltalk|url=https://hal.inria.fr/inria-00614720/file/Mart11a-IWST11-Marea.pdf|journal=|access-date=2021-03-07|archive-date=2021-03-03|archive-url=https://web.archive.org/web/20210303185122/https://hal.inria.fr/inria-00614720/file/Mart11a-IWST11-Marea.pdf}}</ref>。可以使用这种代理来实现很多设施，比如分布式Smalltalk，这里的消息在多个Smalltalk系统之间交换，和数据库接口，这里的对象透明的从数据库中排除错误，还有[[Future与promise|promise]]等。分布式Smalltalk的设计影响了如[[CORBA|CORBA]]这样的系统。

==基于映像的持久存储==
多数流行的编程系统，将静态的程序代码（以类定义、函数或过程的形式），分离于动态的或[[执行期|运行时间]]的程序状态（比如对象或其他形式的程序数据）。它们在程序启动的时候装载程序代码，而任何先前的程序状态必须从配置文件或其他数据源显式的重新建立。程序（和编程者）未显式保存的设置，在每次重启时都必须再次设立。传统的程序在每次程序保存一个文件、退出和重载的时候，还失去很多有用的文档信息。这会失去细节比如回退历史或光标位置。基于映像的系统不会因为计算机关闭或OS更新，而强制失去所有这些东西。

但是很多Smalltalk系统，不区分程序数据（对象）和代码（类）。事实上，类也是对象。因此，多数Smalltalk系统，存储整个程序状态（包括类和非类对象二者）在一个{{en-link|系统映像|system image|映像}}文件之中。这个映像可以接着由Smalltalk[[虚拟机|虚拟机]]装载，将类Smalltalk系统恢复成先前的状态<ref>{{cite web|title=Image-Based Persistence|url=http://book.seaside.st/book/advanced/persistency/image-based-persistency|work=book.seaside.st|access-date=17 December 2013|archive-date=2013-12-17|archive-url=https://web.archive.org/web/20131217223957/http://book.seaside.st/book/advanced/persistency/image-based-persistency}}</ref>。这是受到了FLEX的启发，它是[[Alan_Kay|Alan Kay]]创建的语言并描述于他的科学硕士毕业论文中<ref>{{cite journal|last=Kay|first=Allen|title=FLEX – A flexible extendable language|journal=University of Utah MSC Thesis|year=1968|url=http://www.mprove.de/diplom/gui/kay68.html|access-date=2021-03-08|archive-date=2018-07-18|archive-url=https://web.archive.org/web/20180718055226/https://www.mprove.de/diplom/gui/kay68.html}}</ref>。

Smalltalk映像类似于（可重启的）[[核心转储|核心转储]]，并可以提供与核心转储相同的功能，比如延迟或远程调试，具有对出错时刻的程序状态的完全访问。将应用代码建模为某种形式的数据的其他语言比如[[Lisp|Lisp]]，也经常使用基于映像的持久存储。这种持久存储的方法，对于快速开发是强力的，因为所有开发信息（比如程序的解析树），都保存而利用于调试。但是它作为一个真实的持久存储机制，也有一个严重的缺点。首先，开发者可能经常想要隐藏实现细节，并使它们在运行时间不可获得。出于法律和维护的原因，允许任何人在运行时间修改程序，对于在运行时间环境不暴露源代码的编译后的系统，不可避免的介入复杂性和潜在的错误。其次，尽管持久存储机制易于使用，它缺乏多数多用户系统需要的真正持久存储能力。最明显的是进行同多个用户并行访问相同的数据库的事务<ref>{{cite web|last=Fowler|first=Martin|title=Memory Image|url=http://martinfowler.com/bliki/MemoryImage.html|work=martinfowler.com|access-date=17 December 2013|archive-date=2021-05-07|archive-url=https://web.archive.org/web/20210507100422/https://martinfowler.com/bliki/MemoryImage.html}}</ref>。

==实现列表==

=== OpenSmaltalk ===
OpenSmaltalk VM（OS VM）是Smalltalk运行时环境的著名实现，很多现代Smalltalk VM基于或派生自它<ref>{{Citation|title=OpenSmalltalk/opensmalltalk-vm|date=2020-11-03|url=https://github.com/OpenSmalltalk/opensmalltalk-vm|publisher=OpenSmalltalk|access-date=2020-11-08|archive-date=2021-03-10|archive-url=https://web.archive.org/web/20210310151319/https://github.com/OpenSmalltalk/opensmalltalk-vm}}</ref>。OS VM自身是从一组Smalltalk源代码文件（它们叫做VMMaker），转译成原生[[C语言|C]]语言源代码（通过使用叫做Slang的转译器<ref>{{Cite web|title=Slang|url=http://wiki.squeak.org/squeak/slang|access-date=2020-11-08|website=wiki.squeak.org|archive-date=2021-06-08|archive-url=https://web.archive.org/web/20210608165754/http://wiki.squeak.org/squeak/slang}}</ref><ref>{{Cite web|title=A Guide to the S-Lang Language (v2.3.0): Preface|url=http://jedsoft.org/slang/doc/html/slang-1.html#ss1.1|access-date=2020-11-08|website=jedsoft.org|archive-date=2019-08-27|archive-url=https://web.archive.org/web/20190827034226/http://jedsoft.org/slang/doc/html/slang-1.html#ss1.1}}</ref>），它依次再针对特定平台和硬件架构来编译，实际上确使Smalltalk映像的跨平台执行。源代码可以在GitHub上获得并在[[MIT许可证|MIT许可证]]下发布。OS VM的知名派生者有：
{{div col|colwidth=30em}}
*[[Squeak|Squeak]]，一个开源Smalltalk。
* [[Pharo|Pharo]] Smalltalk，一个开源[[跨平台|跨平台]]语言。
*[[Croquet_OS#虛擬機|Croquet VM]]，Croquet OS的一个与Squeak有关的Smalltalk VM。
*Cuis-Smalltalkf<ref>{{Cite web|url=http://www.cuis-smalltalk.org/|title=Cuis Smalltalk|access-date=2022-02-16|archive-date=2022-02-07|archive-url=https://web.archive.org/web/20220207130359/http://www.cuis-smalltalk.org/}}</ref>，一个开源的小型、简洁和适用的Smalltalk。
*Haver-Smalltalk<ref>{{Cite web |url=http://haver.klix.ch/index.html |title=Haver-Smalltalk |access-date=2022-02-12 |archive-date=2022-02-12 |archive-url=https://web.archive.org/web/20220212085956/http://haver.klix.ch/index.html }}</ref>，Cuis的具有完整模块系统的扩展。
{{div col end}}

=== JavaScript VM ===
{{div col|colwidth=30em}}
*PharoJS<ref>{{Cite web |url=https://pharojs.org/ |title=PharoJS |access-date=2022-05-17 |archive-date=2022-05-01 |archive-url=https://web.archive.org/web/20220501204029/https://pharojs.org/ }}</ref>，一个开源的从Smalltalk到Javascript的[[转译器|转译器]]，扩展了[[Pharo|Pharo]]环境。
*SqueakJS<ref>{{Cite web |url=https://squeak.js.org/ |title=SqueakJS |access-date=2022-05-17 |archive-date=2022-05-01 |archive-url=https://web.archive.org/web/20220501160550/https://squeak.js.org/ }}</ref>，用于web的一个OpenSmalltalk兼容的VM，还能运行老旧的Squeak应用如{{en-link|Etoys (编程语言)|Etoys (programming language)|Etoys}}或[[Scratch|Scratch]]。
{{div col end}}

=== 其他 ===
{{div col|colwidth=30em}}
*{{en-link|Amber Smalltalk}}，通过转译运行在[[JavaScript|JavaScript]]上。
*{{en-link|Cincom|Cincom Systems}} Smalltalk，包含下列产品：{{en-link|VisualWorks}}、ObjectStudio和WebVelocity。
*{{en-link|Visual Smalltalk Enterprise}}，一个家族，包括Smalltalk/V。
*Smalltalk/X<ref>{{Cite web |url=https://www.exept.de/en/smalltalk-x.html |title=Smalltalk/X |access-date=2022-02-12 |archive-date=2022-04-13 |archive-url=https://web.archive.org/web/20220413115401/https://www.exept.de/en/smalltalk-x.html }}</ref>，由Claus Gittinger开发。
*{{en-link|F-Script (编程语言)|F-Script (programming language)|F-Script}}，在2009年写的只用于macOS的实现。
*{{en-link|Gemstone (数据库)|Gemstone (database)|GemStone/S}}，GemTalk系统出品。
*[[GNU_Smalltalk|GNU Smalltalk]]，Smalltalk的无头（缺少GUI）实现。
*{{en-link|StepTalk}}，[[GNUstep|GNUstep]]脚本框架，它在[[Objective-C|Objective-C]]运行时上使用Smalltalk语言。
*{{en-link|VisualAge}} Smalltalk。
*VAST平台（VA Smalltalk）<ref>{{cite web|url=https://www.instantiations.com/vast-platform/|title=VA Smalltalk|access-date=2022-02-25|archive-date=2022-04-13|archive-url=https://web.archive.org/web/20220413185148/https://www.instantiations.com/vast-platform/}}</ref>，Instantiations公司开发。
*{{en-link|Little Smalltalk}}。
*{{en-link|Dolphin Smalltalk}}，Object Arts出品。
*{{en-link|Smalltalk MT}}，Object Connect出品的Windows平台Smalltalk。
*{{en-link|Pocket Smalltalk}}，运行于Palm Pilot。
*SmallJ<ref>{{Cite web |url=https://smallj.org/ |title=SmallJ |access-date=2022-05-17 |archive-date=2021-03-01 |archive-url=https://web.archive.org/web/20210301043426/https://smallj.org/ }}</ref>，一个开源的基于[[Java|Java]]的Smalltalk，派生自SmallWorld<ref>{{Cite web |url=http://web.engr.oregonstate.edu/~budd/SmallWorld/ |title=SmallWorld |access-date=2021-03-07 |archive-date=2009-02-26 |archive-url=https://web.archive.org/web/20090226204221/http://web.engr.oregonstate.edu/~budd/SmallWorld/ }}</ref>。
*{{en-link|Etoys (编程语言)|Etoys (programming language)|Etoys}}，用于学习的可视编程系统。
*{{en-link|Strongtalk}}，提供可选的强类型。
*TruffleSqueak<ref>{{Cite web |url=https://github.com/hpi-swa/trufflesqueak/ |title=TruffleSqueak |access-date=2022-02-12 |archive-date=2022-04-16 |archive-url=https://web.archive.org/web/20220416222541/https://github.com/hpi-swa/trufflesqueak/ }}</ref>，用于GraalVM的一个Squeak/Smalltalk VM和Polyglot编程环境（更多基于GraalVM的Smalltalk实现可见于官网<ref>{{Cite web |url=https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Languages/ |title=www.graalvm.org |access-date=2022-02-12 |archive-date=2022-03-17 |archive-url=https://web.archive.org/web/20220317064619/https://www.graalvm.org/graalvm-as-a-platform/language-implementation-framework/Languages/ }}</ref>)
{{div col end}}

==参见==
* {{en-link|Seaside (软件)|Seaside (software)|Seaside}}
* [[解决方案堆栈#GLASS|GLASS]]

==引用==
{{Reflist|2}}

==延伸阅读==
*{{cite book|author1={{tsl|en|Adele Goldberg (computer scientist)|Adele Goldberg}}|author2=David Robson|first2=|title=Smalltalk-80: The Language and its Implementation|url=http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf|date=May 1983|publisher=Addison-Wesley|isbn=0-201-11371-6|access-date=2022-02-16|archive-date=2017-08-07|archive-url=https://web.archive.org/web/20170807165331/http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf}}
*{{cite book|author1={{tsl|en|Adele Goldberg (computer scientist)|Adele Goldberg}}|url=https://epdf.pub/smalltalk-80-the-interactive-programming-environment-addison-wesley-series-in-co.html|title=Smalltalk-80: The Interactive Programming Environment|date=December 1983|publisher=Addison-Wesley|isbn=0-201-11372-4|access-date=2022-02-09|archive-date=2022-02-09|archive-url=https://web.archive.org/web/20220209203306/https://epdf.pub/smalltalk-80-the-interactive-programming-environment-addison-wesley-series-in-co.html}}
*{{cite book|editor=Glen Krasner|title=Smalltalk-80: Bits of History, Words of Advice|url=https://epdf.pub/smalltalk-80-bits-of-history-words-of-advice-addison-wesley-series-in-computer-s.html|date=August 1983|publisher=Addison-Wesley|isbn=0-201-11669-3|access-date=2022-02-09|archive-date=2022-02-09|archive-url=https://web.archive.org/web/20220209204611/https://epdf.pub/smalltalk-80-bits-of-history-words-of-advice-addison-wesley-series-in-computer-s.html}}
*{{cite book|title=Smalltalk 80: The Language|author1={{tsl|en|Adele Goldberg (computer scientist)|Adele Goldberg}}|author2=David Robson|date=11 January 1989|publisher=Addison-Wesley|isbn=0-201-13688-0}}
*{{cite journal|author={{tsl|en|Dan Ingalls}}|url=https://wiki.squeak.org/squeak/uploads/400/Smalltalk-76.pdf|title=The Smalltalk-76 programming system design and implementation|publisher=[[Xerox|Xerox]] [[Palo_Alto_Research_Center|Palo Alto Research Center]]|date=January 1978|journal=|access-date=2022-03-12|archive-date=2021-11-21|archive-url=https://web.archive.org/web/20211121141639/http://wiki.squeak.org/squeak/uploads/400/Smalltalk-76.pdf}}
*{{cite report|url=https://xeroxalto.computerhistory.org/Filene/Smalltalk-76/.document.press!1.pdf|title=How To Use the Smalltalk-76 System|author=Learning Research Group|date=October 1979|publisher=[[Xerox|Xerox]] [[Palo_Alto_Research_Center|Palo Alto Research Center]]|access-date=2022-03-12|archive-date=2022-04-12|archive-url=https://web.archive.org/web/20220412034119/https://xeroxalto.computerhistory.org/Filene/Smalltalk-76/.document.press!1.pdf}}
*{{cite book|editor1={{tsl|en|Adele Goldberg (computer scientist)|Adele Goldberg}}|editor2=[[艾伦·凯|Alan Kay]]|title=Smalltalk-72 Instruction Manual|url=http://www.bitsavers.org/pdf/xerox/parc/techReports/Smalltalk-72_Instruction_Manual_Mar76.pdf|date=March 1976|publisher=[[Xerox|Xerox]] [[Palo_Alto_Research_Center|Palo Alto Research Center]]|access-date=2021-03-06|archive-date=2020-11-12|archive-url=https://web.archive.org/web/20201112022343/http://www.bitsavers.org/pdf/xerox/parc/techReports/Smalltalk-72_Instruction_Manual_Mar76.pdf}}
*{{cite journal|author=[[艾伦·凯|Alan Kay]]|date=March 1993|title=The Early History of Smalltalk|journal=ACM SIGPLAN Notices|publisher=[[Association_for_Computing_Machinery|ACM]]|volume=28|issue=3|pages=69–95|url=http://www.metaobject.com/papers/Smallhistory.pdf|doi=10.1145/155360.155364|access-date=2021-03-06|archive-date=2021-03-23|archive-url=https://web.archive.org/web/20210323210524/http://www.metaobject.com/papers/Smallhistory.pdf}}
*{{cite book|last1=Nierstrasz|first1=Oscar|last2=Ducasse|first2=Stéphane|last3=Pollet|first3=Damien|last4=Black|first4=Andrew P.|title=Squeak by Example|date=2009-10-07|publisher=Square Bracket Associates|location=Kehrsatz, Switzerland|isbn=978-3-9523341-0-2|url=https://wiki.squeak.org/squeak/6546|access-date=2022-03-12|archive-date=2022-03-18|archive-url=https://web.archive.org/web/20220318202721/https://wiki.squeak.org/squeak/6546}}
*{{cite book|last1=Nierstrasz|first1=Oscar|last2=Ducasse|first2=Stéphane|last3=Pollet|first3=Damien|last4=Black|first4=Andrew P.|title=Pharo by Example|url=https://books.pharo.org/pharo-by-example/|date=February 23, 2010|publisher=Square Bracket Publishing|location=Kehrsatz, Switzerland|isbn=978-3-9523341-4-0|access-date=2022-03-12|archive-date=2022-02-10|archive-url=https://web.archive.org/web/20220210110333/http://books.pharo.org/pharo-by-example/}}
*{{cite journal|date=August 1981|title=Special Issue on Smalltalk|journal={{en-link|Byte (杂志)|Byte (magazine)|Byte}}|publisher=McGraw-Hill|volume=6|issue=8|url=https://archive.org/details/byte-magazine-1981-08|access-date=2013-10-18}}
**{{cite journal|date=August 1981|title=Introducing the Smalltalk-80 System|author={{tsl|en|Adele Goldberg (computer scientist)|Adele Goldberg}}|journal={{en-link|Byte (杂志)|Byte (magazine)|Byte}}|publisher=McGraw-Hill|volume=6|issue=8|url=https://archive.org/stream/byte-magazine-1981-08/1981_08_BYTE_06-08_Smalltalk#page/n15/mode/2up|access-date=2013-10-18}}
**{{cite journal|author={{tsl|en|Dan Ingalls}}|date=August 1981|title=Design Principles Behind Smalltalk|journal={{en-link|Byte (杂志)|Byte (magazine)|Byte}}|publisher=McGraw-Hill|volume=6|issue=8|url=https://archive.org/stream/byte-magazine-1981-08/1981_08_BYTE_06-08_Smalltalk#page/n299/mode/2up|access-date=2011-11-11}}
**{{cite journal|author=[[拉里·泰斯勒|Larry Tesler]]|date=August 1981|title=The Smalltalk Environment|journal={{en-link|Byte (杂志)|Byte (magazine)|Byte}}|publisher=McGraw-Hill|volume=6|issue=8|url=https://archive.org/stream/byte-magazine-1981-08/1981_08_BYTE_06-08_Smalltalk#page/n103/mode/2up|access-date=2016-05-02}}

==外部链接==
{{Wikibooks|en:Smalltalk Programming}}
*[http://stephane.ducasse.free.fr/FreeBooks.html Free Online Smalltalk Books] {{Wayback|url=http://stephane.ducasse.free.fr/FreeBooks.html |date=20210528200914 }}
*[https://smalltalkzoo.thechm.org/ Smalltalk Zoo] {{Wayback|url=https://smalltalkzoo.thechm.org/ |date=20220327202247 }}
*Smalltalk-80 Bluebook implementations in C++: by [https://github.com/dbanay/smalltalk dbanay] {{Wayback|url=https://github.com/dbanay/smalltalk |date=20201119140344 }} and [https://github.com/rochus-keller/Smalltalk/ rochus-keller] {{Wayback|url=https://github.com/rochus-keller/Smalltalk/ |date=20210127223616 }} on github
* {{cite web|url=http://som-st.github.io/|title=A minimal Smalltalk for teaching of and research on Virtual Machines|access-date=2022-02-09|archive-date=2022-03-28|archive-url=https://web.archive.org/web/20220328102929/https://som-st.github.io/}}

{{Smalltalk programming language}}
{{程序设计语言|Smalltalk}}

[[Category:面向对象的编程语言|Category:面向对象的编程语言]]
[[Category:基于类的编程语言|Category:基于类的编程语言]]
[[Category:Smalltalk编程语言家族|Category:Smalltalk编程语言家族]]
[[Category:1972年建立的程式語言|Category:1972年建立的程式語言]]