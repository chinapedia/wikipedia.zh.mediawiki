{{NoteTA
|G1 = IT
|G2 = 教育與研究
}}
{{Infobox programming language
|name = Scheme
|logo = Lambda lc.svg
|logo size = 100px
|paradigm = [[编程范式|多范型]]：[[函数式编程|函数式]], [[指令式编程|指令式]], [[元编程|元编程]]
| family = [[Lisp|Lisp]]
| year = {{Start date and age|1975}}
|designer = [[小蓋伊·史提爾|小蓋伊·史提爾]]和[[傑拉德·傑伊·薩斯曼|傑拉德·傑伊·薩斯曼]]
| latest release version = R7RS
| latest release date = {{Start date and age|2013}}
|typing = [[强类型|强类型]]，[[动态语言|动态类型]]
| scope = [[作用域|词法]]
| dialects = 
| file_ext = .scm   .ss
|implementations = {{en-link|Bigloo}}, [[Chez_Scheme|Chez Scheme]], [[Chicken_(Scheme)|Chicken]], [[Gambit_(Scheme实现)|Gambit]], [[GNU_Guile|GNU Guile]], {{en-link|Game Oriented Assembly Lisp}} (GOAL), {{en-link|Ikarus (Scheme实现)|Ikarus (Scheme implementation)|Ikarus}}, [[JScheme|JScheme]], {{en-link|Kawa (Scheme实现)|Kawa (Scheme implementation)|Kawa}}, {{en-link|Larceny (Scheme实现)|Larceny (Scheme implementation)|Larceny}}, [[MIT/GNU_Scheme|MIT/GNU Scheme]], {{en-link|MultiLisp}}, Pocket Scheme, [[Racket|Racket]], {{en-link|RScheme}}, [[Scheme_48|Scheme 48]], [[SCM_(Scheme实现)|SCM]], [[SIOD|SIOD]], {{en-link|T (编程语言)|T (programming language)|T}}, [[TinyScheme|TinyScheme]]
| influenced by = [[ALGOL|ALGOL]], [[Lisp|Lisp]], {{en-link|MDL (编程语言)|MDL (programming language)|MDL}}
| influenced = [[Clojure|Clojure]], [[Common_Lisp|Common Lisp]], [[Dylan_(编程语言)|Dylan]], {{en-link|EuLisp}}, [[Haskell|Haskell]], {{en-link|Hop (软件)|Hop (software)|Hop}}, [[JavaScript|JavaScript]], [[Julia_(编程语言)|Julia]], [[Lua|Lua]], [[R语言|R]], [[Racket|Racket]], [[Ruby|Ruby]], [[Rust|Rust]], [[S语言|S]], [[Scala|Scala]]
}}

'''Scheme'''是一种[[函数式编程语言|函数式编程语言]]，是[[Lisp|Lisp]]的两种主要方言之一，不同于与之并列的[[Common_Lisp|Common Lisp]]，Scheme遵循{{en-link|极简主义 (计算)|Minimalism (computing)|極簡主義}}哲学，以一个小型语言核心作为标准，加上各种强力语言工具（[[语法糖|语法糖]]）来扩展语言本身<ref name="csail">{{cite web|title=The Scheme Programming Language|url=https://groups.csail.mit.edu/mac/projects/scheme/|website=MIT|access-date=2022-05-04|archive-date=2022-04-12|archive-url=https://web.archive.org/web/20220412004120/http://groups.csail.mit.edu/mac/projects/scheme/}}</ref>。

Scheme最早由[[麻省理工學院|麻省理工學院]]的[[蓋伊·史提爾二世|蓋伊·史提爾二世]]與[[傑拉德·傑伊·薩斯曼|傑拉德·傑伊·薩斯曼]]自1975年開始發展出來，並由兩人發表的「λ論文集」推廣開來。Scheme語言與[[λ演算|λ演算]]關係十分密切。小寫字母「[[λ|λ]]」是Scheme語言的[[標誌|標誌]]。Scheme是第一個使用靜態[[作用域|作用域]]的Lisp方言，也是第一个引入“{{le|干净宏|Hygienic macro}}”和[[头等对象|头等]][[计算续体|续体]]的编程语言。

[[麻省理工學院|麻省理工學院]]與其他院校曾采用Scheme教授计算机科学入門課程。著名的入門教材《[[計算機程序的構造和解釋|-{zh-hans:计算机程序的构造和解释;zh-hant:電腦程式的構造和解釋}-]]》（SICP）利用Scheme來解釋程序設計<ref name="sicp">{{Cite book | author = Harold Abelson and Gerald Jay Sussman with Julie Sussman | title = Structure and Interpretation of Computer Programs | location = Cambridge, MA | publisher = MIT Press | date = 1996 | ISBN = 0-262-01153-0 | accessdate = 2011 | url = http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start | language = en | deadurl = yes | archiveurl = https://web.archive.org/web/20180309173822/https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start | archivedate = 2018-03-09 }}</ref>。Scheme的廣泛受眾被視為一個主要優勢，然而不同實現之間的差異成為了它的一個劣勢，Scheme掌控委员会声称它是“世上最不可移植的编程语言”并且是一个“编程语言家族”而非一个单一的语言<ref name="position_paper">{{cite web
| publisher = Scheme Steering Committee
| author = Will Clinger, Marc Feeley, Chris Hanson, Jonathan Rees and Olin Shivers
| url = http://scheme-reports.org/2009/position-statement.html
| title = Scheme Steering Committee Position Statement
| date = 2009-08-20
| quote = Scheme has the unhappy distinction of being the world's most unportable programming language. It is almost misleading to call Scheme a "programming language;" it would be more accurate to characterise Scheme as a family of dialects, all loosely related by the common features of lexical scope, dynamic typing, list structure, higher-order functions, proper tail-recursion, garbage collection, macros, and (some form of) s-expression based lexical syntax.
| access-date = 2011-12-19
| archive-date = 2009-08-26
| archive-url = https://web.archive.org/web/20090826190908/http://scheme-reports.org/2009/position-statement.html
}}</ref>。

==歷史==
{{Main|{{en-link|Scheme编程语言历史|History of the Scheme programming language}}}}
===起源===
[[File:Jerry_Sussman.jpg|thumb]]]]
{{CSS image crop |Image = Guy Steele.jpg |bSize = 400 |cWidth = 200 |cHeight = 300 |oTop = 30 |oLeft = 110 |Location= right |Description = [[小蓋伊·史提爾|Guy Lewis Steele Jr.]]}}
Scheme起源於[[約翰·麥卡錫|約翰·麥卡錫]]於1958年提出的[[Lisp|Lisp]]語言。通過Lisp，麥卡錫證明了[[圖靈完備|圖靈完備]]的系統，可以僅僅由幾個簡單的算子，與用於匿名函數的借鑒自[[阿隆佐·邱奇|阿隆佐·邱奇]]的λ表示法組成。這一設計對Scheme的影響非常深刻。麥卡錫提出的[[S-表达式|S-表达式]]具備[[同像性|同像性]]（即程序与数据由相同的结构存储）。Scheme的語法即來自S-表达式，這一特性使得在Scheme中實現[[自循環直譯器|自循環直譯器]]變得非常簡單。

Scheme的靈感，來自[[麻省理工學院|麻省理工學院]]的{{en-link|Carl Hewitt}}提出的一種叫做[[演員模型|演員模型]]的[[計算模型|計算模型]]。Hewitt當時為了實作演員模型，正在試圖創建新的{{en-link|Planner (编程语言)|Planner (programming language)|Planner-73}}語言（後改稱PLASMA，即建模在演員上的類PLAnner系統），而受其影響的史提爾與薩斯曼，決定在[[Maclisp|Maclisp]]中實現一個支援演員模型的[[Lisp|Lisp]]方言<ref>{{cite web|title=The First Report on Scheme Revisited|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://www.researchgate.net/publication/227202780_The_First_Report_on_Scheme_Revisited|year=1998|quote=We wanted to better understand Hewitt’s actors model but were having trouble relating the actors model and its unusual terminology to familiar programming notions. We decided to construct a toy implementation of an actor language so that we could play with it. Using MacLisp as a working environment, we wrote a tiny Lisp interpreter and then added mechanisms for creating actors and sending messages.|access-date=2021-11-07|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235711/https://www.researchgate.net/publication/227202780_The_First_Report_on_Scheme_Revisited}}</ref>。史提爾與薩斯曼兩人，很快發現演員模型與[[λ演算|λ演算]]非常類似，而所謂「演員」就是[[Peter_J._Landin|Peter J. Landin]]提出的[[闭包_(计算机科学)|閉包]]，它由{{en-link|Joel Moses}}於1970年介入LISP来解决{{en-link|函数参数问题|funarg problem}}<ref name="Moses">{{cite web
| author = {{en-link|Joel Moses}}
| title = The Function of FUNCTION in LISP, or Why the FUNARG Problem Should Be Called the Environment Problem
| url = http://dspace.mit.edu/handle/1721.1/5854
| id = AI Memo 199
| quote = A useful metaphor for the difference between FUNCTION and QUOTE in LISP is to think of QUOTE as a porous or an open covering of the function since free variables escape to the current environment. FUNCTION acts as a closed or nonporous covering (hence the term "closure" used by Landin). Thus we talk of "open" Lambda expressions (functions in LISP are usually Lambda expressions) and "closed" Lambda expressions. [...] My interest in the environment problem began while Landin, who had a deep understanding of the problem, visited MIT during 1966-67. I then realized the correspondence between the FUNARG lists which are the results of the evaluation of "closed" Lambda expressions in [[LISP|LISP]] and [[ISWIM|ISWIM]]'s Lambda Closures.
| format = pdf
| accessdate = 2009-10-27
| date = June 1970
| archive-date = 2010-05-23
| archive-url = https://web.archive.org/web/20100523000556/http://dspace.mit.edu/handle/1721.1/5854
| dead-url = no
}}</ref>。因此兩人很快意識到，將詞法[[變數範圍|變數範圍]]介入到Lisp中，是實現演員的關鍵<ref>{{cite web|title=The First Report on Scheme Revisited|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://www.researchgate.net/publication/227202780_The_First_Report_on_Scheme_Revisited|year=1998|quote=Sussman had just been studying Algol. He suggested starting with a lexically scoped dialect of Lisp, because that seemed necessary to model the way names could refer to acquaintances in PLASMA. Lexical scoping would allow actors and functions to be created by almost identical mechanisms. Evaluating a form beginning with the word <code>lambda</code> would capture the current variable-lookup environment and create a [[闭包_(计算机科学)|closure]]; evaluating a form beginning with the word <code>alpha</code> would also capture the current environment but create an actor. Message passing could be expressed syntactically in the same way as function invocation. The difference between an actor and a function would be detected in the part of the interpreter traditionally known as <code>apply</code>. A function would return a value, but an actor would never return; instead, it would typically invoke a [[计算续体|continuation]], another actor that it knew about. Our interpreter also provided the necessary primitives for implementing the internal behavior of primitive actors, such as an addition operator that could accept two numbers and a continuation actor. ……<br />…… This led us to three important ideas:<br />• First, we realized that all the patterns of control structure that Hewitt had described in terms of actors could equally well be described by the λ-calculus. ……<br />• Second, we realized that the λ-calculus — a small, simple formalism — could serve as the core of a powerful and expressive programming language. (Lisp had adopted the λ-notation for functions but had failed to support the appropriate behavior for free variables. The original theoretical core of Lisp was recursion equations, not the λ-calculus.) ……<br />• Third, we realized that in our quest for the “ultimate AI language” we had come full circle. As the MIT school had struggled to find more and more powerful ways to express and manipulate control structure to support heuristic search, we had progressed from Lisp to CONVERT to Planner to Conniver to PLASMA to a simple variation of Lisp!|access-date=2021-11-07|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235711/https://www.researchgate.net/publication/227202780_The_First_Report_on_Scheme_Revisited}}</ref>。基於這一見解，兩人很快開發出了一套精簡的程式語言，並命名為「Schemer」，後因作業系統字數限制改為Scheme。儘管Hewitt指出了Scheme有不能表达特定类型的演员的不足<ref>{{cite web|title=The First Report on Scheme Revisited|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://www.researchgate.net/publication/227202780_The_First_Report_on_Scheme_Revisited|year=1998|quote=We concluded that actors and closures were effectively the same concept. (Hewitt later agreed with this, but noted that two types of primitive actors in his theory, namely cells (which have modifiable state) and synchronizers (which enforce exclusive access), cannot be expressed as closures in a lexically scoped pure Lisp without adding equivalent primitive extensions.)|access-date=2021-11-07|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235711/https://www.researchgate.net/publication/227202780_The_First_Report_on_Scheme_Revisited}}</ref>，它簡約的語法很快贏得廣泛接受，並成為最具影響力的程式語言之一。

===λ論文集===
「λ論文集」是Scheme的發明人史提爾與薩斯曼所撰寫的關於程式語言設計的一系列論文，最早作為[[麻省理工學院|麻省理工學院]]的內部[[備忘錄|備忘錄]]發表。Scheme的功能很大一部分是由這些論文確立的<ref>{{cite web|url=https://research.scheme.org/lambda-papers/|title=The Original 'Lambda Papers' by Guy Steele and Gerald Sussman|access-date=2021-11-07|archive-date=2022-01-12|archive-url=https://web.archive.org/web/20220112102620/https://research.scheme.org/lambda-papers/}}</ref>。通常認為λ論文集包括：
{{Div col|small=yes|1}}
* 1975年: Scheme: An Interpreter for Extended Lambda Calculus.<ref name="lambda_paper_1">{{cite wikisource|title=Scheme: An Interpreter for Extended Lambda Calculus|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|year=1975}}</ref>
* 1976年: Lambda: The Ultimate Imperative.<ref name="lambda_paper_2">{{cite web|title=Lambda: The Ultimate Imperative|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/5790|year=1976|access-date=2021-11-11|archive-date=2022-04-10|archive-url=https://web.archive.org/web/20220410100640/https://dspace.mit.edu/handle/1721.1/5790}}</ref>
* 1976年: Lambda: The Ultimate Declarative.<ref>{{cite web|title=LAMBDA: The Ultimate Declarative|author=[[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6091|year=1976|access-date=2021-11-10|archive-date=2022-04-09|archive-url=https://web.archive.org/web/20220409165253/https://dspace.mit.edu/handle/1721.1/6091}}</ref>
* 1977年: Debunking the 'Expensive Procedure Call' Myth, or, Procedure Call Implementations Considered Harmful, or, Lambda: The Ultimate GOTO.<ref>{{cite web|title=Debunking the 'Expensive Procedure Call' Myth, or, Procedure Call Implementations Considered Harmful, or, Lambda: The Ultimate GOTO|author=[[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/5753|year=1977|access-date=2021-11-07|archive-date=2022-05-09|archive-url=https://web.archive.org/web/20220509211001/http://dspace.mit.edu/handle/1721.1/5753}}</ref>
* 1978年: The Art of the Interpreter or, the Modularity Complex (Parts Zero, One, and Two).<ref>{{cite web|title=The Art of the Interpreter of the Modularity Complex (Parts Zero, One, and Two)|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6094|year=1978|access-date=2021-11-07|archive-date=2021-11-07|archive-url=https://web.archive.org/web/20211107052826/https://dspace.mit.edu/handle/1721.1/6094}}</ref>
* 1978年: RABBIT: A Compiler for SCHEME.<ref>{{cite web|title=RABBIT: A Compiler for SCHEME|author=[[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6913|year=1978|access-date=2021-11-07|archive-date=2021-11-08|archive-url=https://web.archive.org/web/20211108142343/https://dspace.mit.edu/handle/1721.1/6913}}</ref>
* 1979年: Design of LISP-based Processors, or SCHEME: A Dialect of LISP, or Finite Memories Considered Harmful, or LAMBDA: The Ultimate Opcode.<ref>{{cite web|title=Design of LISP-based Processors, or SCHEME: A Dielectric LISP, or Finite Memories Considered Harmful, or LAMBDA: The Ultimate Opcode|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/5731|year=1979|access-date=2021-11-07|archive-date=2021-11-07|archive-url=https://web.archive.org/web/20211107052827/https://dspace.mit.edu/handle/1721.1/5731}}</ref>
* 1980年: Compiler Optimization Based on Viewing LAMBDA as RENAME + GOTO. AI: An MIT Perspective. 
* 1980年: Design of a Lisp-based Processor. CACM. 23. 11.<ref>{{cite web|title=Design of a LISP-based microprocessor|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://www.researchgate.net/publication/220421958_Design_of_a_LISP-based_microprocessor|year=1980|access-date=2021-11-07|archive-date=2021-11-08|archive-url=https://web.archive.org/web/20211108145542/https://www.researchgate.net/publication/220421958_Design_of_a_LISP-based_microprocessor}}</ref>
{{Div col end}}

===標準化===
在1978年，[[蓋伊·史提爾二世|蓋伊·史提爾二世]]和[[傑拉德·傑伊·薩斯曼|傑拉德·傑伊·薩斯曼]]发表了《修订的Scheme报告：一种LISP方言》<ref>{{cite web|title=The Revised Report on SCHEME: A Dialect of LISP|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6283|year=1978|access-date=2021-11-07|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235427/https://dspace.mit.edu/handle/1721.1/6283}}</ref>。Scheme曾經由[[IEEE|IEEE]]標準化為IEEE 1178–1990，它于2019年11月07日停用<ref name="ieee1178">{{cite web|url=https://standards.ieee.org/standard/1178-1990.html|title=IEEE 1178-1990 - IEEE Standard for the Scheme Programming Language|access-date=2022-01-14|archive-date=2021-03-04|archive-url=https://web.archive.org/web/20210304200431/https://standards.ieee.org/standard/1178-1990.html}}</ref>。現在由一個專門的掌控委員會發表的《第n次修訂的演算法語言Scheme報告》（Revised<sup>n</sup> Report on the Algorithmic Language Scheme）是[[業界標準|業界標準]]。这种标题形式参照了[[ALGOL|ALGOL 60]]标准文档的标题<!--
 --><ref name="algol_report">{{cite journal |url=http://www.masswerk.at/algol60/report.htm |title=Revised Report on the Algorithmic Language Algol 60 |author=J.W. Backus |journal=Numerische Mathematik, Communications of the ACM, and Journal of the British Computer Society |date=January–April 1960 |access-date=2012-08-09 |author2=F.L. Bauer |author3=J.Green |author4=C. Katz |author5=J. McCarthy P. Naur |display-authors=etal |archive-date=2007-06-25 |archive-url=https://web.archive.org/web/20070625171638/http://www.masswerk.at/algol60/report.htm }}</ref>。

1998年通过的R<sup>5</sup>RS是現在被普遍接受的標準<ref name="r5rs">{{cite journal
| author = Richard Kelsey
| title = Revised<sup>5</sup> Report on the Algorithmic Language Scheme
| url = http://www.schemers.org/Documents/Standards/R5RS/
| journal = Higher-Order and Symbolic Computation
| volume = 11
| issue = 1
| pages = 7–105
| doi = 10.1023/A:1010051815785
| author2 = William Clinger
| author3 = Jonathan Rees
| display-authors = 3
| last4 = Rozas
| first4 = G.J.
| last5 = Adams Iv
| first5 = N.I.
| last6 = Friedman
| first6 = D.P.
| last7 = Kohlbecker
| first7 = E.
| last8 = Steele Jr.
| first8 = G.L.
| last9 = Bartley
| first9 = D.H.
| language = en
| date = August 1998
| access-date = 2007-01-04
| archive-date = 2007-01-05
| archive-url = https://web.archive.org/web/20070105152327/http://www.schemers.org/Documents/Standards/R5RS/
| dead-url = no
}}</ref>。而2007年通過的R<sup>6</sup>RS<ref name="r6rs">{{cite web
| publisher = Scheme Steering Committee
| author = Michael Sperber, R. Kent Dybvig, Matthew Flatt, Anton Van Straaten  et al.
| title = Revised<sup>6</sup> Report on the Algorithmic Language Scheme (R6RS)
| url = http://www.r6rs.org/
| accessdate = 2009-10-20
| date = August 2007
| archive-date = 2013-06-25
| archive-url = https://www.webcitation.org/6HcvveNv7?url=http://www.r6rs.org/
| dead-url = no
}}</ref>，做出了很大的變動<ref name="r6rs_Language_changes">{{cite web
| publisher = Scheme Steering Committee
| title = Revised<sup>6</sup> Report on the Algorithmic Language Scheme, Appendix E: language changes
| url = http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-19.html#node_chap_E
| date = 2007-09-26
| access-date = 2011-12-19
| archive-date = 2010-04-09
| archive-url = https://web.archive.org/web/20100409231639/http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-19.html#node_chap_E
}}</ref>，Scheme社區中有使用者指責它在堆積華而不實的功能<ref name="r6rs_electorate">{{cite web
| publisher = Scheme Steering Committee
| url = http://www.r6rs.org/ratification/electorate.html
| title = R6RS Electorate
| year = 2007
| accessdate = 2009-10-20
| archive-date = 2008-12-04
| archive-url = https://web.archive.org/web/20081204105141/http://www.r6rs.org/ratification/electorate.html
| dead-url = no
}}</ref><ref name="r6rs_feeley">{{cite web
| author = Marc Feeley (compilation)
| publisher = Scheme Steering Committee, r6rs-discuss mailing list
| url = http://lists.r6rs.org/pipermail/r6rs-discuss/2007-October/003351.html
| title = Implementors' intentions concerning R6RS
| date = 2007-10-26
| accessdate = 2009-10-20
| archive-date = 2008-08-20
| archive-url = https://web.archive.org/web/20080820040409/http://lists.r6rs.org/pipermail/r6rs-discuss/2007-October/003351.html
| dead-url = no
}}</ref>。Scheme掌控委員會決定在R<sup>7</sup>RS中，將Scheme分化為兩個獨立而兼容的語言：一個是現已通過了的R<sup>7</sup>RS small<ref>{{cite web|title=R<sup>7</sup>RS-small language, final draft|url=https://small.r7rs.org/attachment/r7rs.pdf|year=2013|access-date=2021-11-10|archive-date=2019-04-17|archive-url=https://web.archive.org/web/20190417121242/https://small.r7rs.org/attachment/r7rs.pdf}}</ref>，它為教學場合提供对IEEE/R<sup>5</sup>RS標準的及时更新，而另一個是大型語言，它為實際編程場合提供对R<sup>6</sup>RS標準的继续完善<ref name="position_paper"/>。

==命名法==
在正式场合比如Scheme标准的{{en-link|命名法|Nomenclature}}中，提及一个λ表达式或原始过程时，偏好使用词语“过程”而非“函数”。在一般使用中，词语“过程”和“函数”是可互换使用的。过程应用有时被正式称呼为“组合”（combination）。

同其他Lisp一样，在Scheme中使用术语“{{en-link|thunk}}”，来提及没有实际参数的过程。术语“正当”（proper）尾递归，称谓所有Scheme实现的一个性质，它们都进行尾递归优化，从而支持无限数目的活跃[[尾递归|尾递归]]。

==基础特征==
Scheme大体上是一個[[函數式程式語言|函數式程式語言]]，並支援其他[[编程范型|编程范型]]。它同其他Lisp编程语言家族语言共享了很多特征。它的非常简单的語法基於[[Lisp|Lisp]]的[[S-表达式|S-表达式]]：即圆括号包围的列表，其中的前缀是算符，而随后那些的是实际参数。故而Scheme程序由嵌套的列表的序列构成。列表也是Scheme中的主要数据结构，这导致了在源代码和数据格式之间的紧密等价性，即[[同像性|同像性]]。Scheme程序可以轻易的动态建立和求值Scheme代码片段。

Scheme與其他Lisp方言的[[列表_(抽象数据类型)|列表]]，都是基於最基礎的數據結構[[有序對|有序對]]（pair）。Scheme从它的Lisp先辈继承了一组丰富的列表处理原始运算，比如cons、car和cdr<ref>cons，car，與cdr的名稱來自於Lisp。這三者的含義分別為「construct」（意為「建立」），「'''C'''ontent of '''A'''ddress '''R'''egister」（意為「記憶體地址暫存器內容」），與「'''C'''ontent of '''D'''ecrement '''R'''egister」（意為「記憶體減量暫存器內容」）。這些名稱反映了Lisp中有序對最早的實現方法。</ref>。Scheme的變數都使用動態強型別系統，Scheme中的过程都是[[頭等物件|頭等物件]]，即[[头等函数|头等函数]]，因此过程可以作为值赋值给变量，或作为实际参数传递给过程。

本章主要集中于语言的创新特征，它们使得Scheme区别于其他Lisp方言。除非专门指出，这里描述的特征都有关于R<sup>5</sup>RS标准。在本章例子中使用“===> 结果”表示法，来指示求值在紧前行上的表达式的结果。这同于R<sup>5</sup>RS中使用的约定。本章节描述的特征使得Scheme不同于在它之前的其他编程语言。Scheme的这些方面强烈的影响了Scheme语言的所有产品，并共通于自从1975年最初的λ论文，特别是1978年最初修订报告以来，所有版本的Scheme编程语言。

===極簡主義===
Scheme的簡約性使它成為具備同級別功能的程式語言中最易於實現的語言<ref name="easy_to_implement_scheme48">事實上，Richard Kelsey與Jonathan Rees曾在1986年8月6日僅用48小時寫作過一個Scheme直譯器，並命名為[[Scheme_48|Scheme 48]]。詳見{{cite web
| publisher = Jonathan Rees, s48.org
| author = Richard Kelsey, Jonathan Rees, Mike Sperber
| title = The Incomplete Scheme 48 Reference Manual for release 1.8
| url = http://s48.org/1.8/manual/manual.html
| date = 2008-01-10
| accessdate = 2009-10-20
| archive-date = 2009-02-01
| archive-url = https://web.archive.org/web/20090201084805/http://s48.org/1.8/manual/manual.html
| dead-url = no
}}</ref>。能这么容易是使用[[λ演算|λ演算]]来从更原始的形式导出多数的语言语法所贡献的<ref>{{cite web|title=The Revised Report on SCHEME: A Dialect of LISP|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6283|year=1978|quote=System-Provided Extensions － Some standard syntactic extension are provided by convenience in ordinary programming. They are distinguished from other magic words in that they are semantically defined in terms of others rather then being primitive {Note {{en-link|fexpr|fexpr|FEXPR}}s Are Okay by Us}. For expository purposes they are described here pattern-matching/production-rules kind of language. takes advantage of the definition of list notation: <code>(A B C) = (A . (B . (C . NIL)))</code>. Thus the pattern <code>(x . r)</code> matches <code>(A B C)</code>, with <code>x = A</code> and <code>r = (B C)</code>. the ordering of the "productions" is significant; the first one which matches is to be used.}}</ref>。例如在R<sup>5</sup>RS Scheme标准中，定义了23个基于[[S-表达式|S-表达式]]的语法构造，其中14个被归类为派生形式或库形式，它们可以被写为涉及原则上为lambdad的更基础形式的宏。正如R<sup>5</sup>RS（§3.1）所说：“最基础的变量绑定构造是lambda表达式，因为所有其他的变量绑定构造，都可以依据lambda表达式来做出解释”<ref name="r5rs"/>。
: '''基础形式'''：<code>define</code>、<code>lambda</code>、<code>quote</code>、<code>if</code>、<code>define-syntax</code>、<code>let-syntax</code>、<code>letrec-syntax</code>、<code>syntax-rules</code>、<code>set!</code>
: '''派生形式'''：<code>do</code>、<code>let</code>、<code>let*</code>、<code>letrec</code>、<code>cond</code>、<code>case</code>、<code>and</code>、<code>or</code>、<code>begin</code>、命名<code>let</code>、<code>delay</code>、<code>unquote</code>、<code>unquote-splicing</code>、<code>quasiquote</code>
下面是一个宏的例子，它将<code>let</code>实现为使用<code>lambda</code>来进行变量绑定的一个表达式：
<syntaxhighlight lang="Scheme">
(define-syntax let
  (syntax-rules ()
    ((let ((var expr) ...) body ...)
      ((lambda (var ...) body ...) expr ...))))
</syntaxhighlight>

使用上述定义的<code>let</code>，一个Scheme实现可以将<code>(let ((a 1)(b 2)) (+ b a))</code>，重写为<code>((lambda (a b) (+ b a)) 1 2)</code>，这将实现任务缩减为编码过程实例化的工作。

當Scheme被廣為接受後，在1998年，史提爾與薩斯曼曾承認，他們事實上沒有刻意實現Scheme的簡約性。兩人認為簡單而強大的[[λ演算|λ演算]]，最終使得Scheme得以實現極度的精簡化<ref>{{cite web|title=The First Report on Scheme Revisited|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://www.researchgate.net/publication/227202780_The_First_Report_on_Scheme_Revisited|year=1998|quote=We were actually trying to build something complicated and discovered, serendipitously, that we had accidentally designed something that met all our goals but was much simpler than we had intended. <br />We thought that Scheme would turn out to be the next in a long series of programming languages that had been designed at MIT over the course of 17 years. ……<br />In this process we learned some great lessons. The λ-calculus can be seen as a universal glue by which compound constructs can be built inductively from simpler ones and a set of primitives. …… The essence of the matter is that the λ-calculus provides a way of abstracting entities of any particular type and then combining such abstractions with other entities to make new entities of that same type, which are instances of the abstractions. …… Given the right primitives, the λ-calculus can serve as a foundation for the abstraction and instantiation of virtually any kind of complex conceptual structure.<br />We also were struck by the great importance of names as a means of reference. …… Naming seems to correspond to some important cognitive mechanism that is, if not innate, then at least extremely well-developed in our culture. The λ-calculus embodies a provably coherent theory of naming.|access-date=2021-11-07|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235711/https://www.researchgate.net/publication/227202780_The_First_Report_on_Scheme_Revisited}}</ref>。

===词法作用域===
{{See also|作用域}}
像多数现代语言而不像更早期的Lisp比如[[Maclisp|Maclisp]]，Scheme是词法作用域的<ref name="lexcial">{{cite wikisource|title=Scheme: An Interpreter for Extended Lambda Calculus|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|year=1975|quote=There are several important consequences of closing every lambda expression in the environment from which it is passed (i.e., in its "lexical" or "static" environment). <br />First, the axioms of [[λ演算|lambda calculus]] are automatically preserved. Thus, {{en-link|referential transparency}} is enforced. This in turn implies that there are no "fluid" variable bindings (as there are in standard stack implementations of LISP such as MacLISP). <br />Second, the upward {{en-link|函数参数问题|funarg problem|funarg problem}} [Moses] requires that the environment structure be potentially tree-like. <br />Finally, the environment at any point in a computation can never be deeper than the lexical depth of the expression being evaluated at that time; i.e., the environment contains bindings only for variables bound in lambdas lexically surrounding the expression being evaluated. This is true even if recursive functions are involved. ……Furthermore, it is not even necessary to scan the environment for the variable, since its value must be in a known position relative to the top of the environment structure; this position can be computed by a compiler at compile time on the basis of lexical scope. }}</ref>：在一个程序单元中所有可能的变量绑定，都可以通过阅读这个程序单元来分析出来，而不需要考虑到它可能在其中被调用的那些上下文。这对比于动态作用域，它是早期Lisp方言的特征，因为在当时的编译器和解释器中，用来实现词法作用域算法的原始的文字替换方法，关联着处理代价。在那些Lisp中，对一个过程内的[[自由变量|自由变量]]的引用，依赖于这个调用的上下文，完全有可能引用到这个过程外部的相当不同的绑定。

===λ演算===
{{see also|λ演算}}
[[邱奇|邱奇]]的[[λ演算|λ演算]]的数学表示法，启发了Lisp使用<code>lambda</code>作为介入一个过程的关键字，并影响了Lisp中涉及到使用[[高阶函数|高阶函数]]的[[函数式编程|函数式编程]]技术的发展。但是早期的Lisp，由于它们对[[自由变量|自由变量]]的处理方式<ref>{{Cite book | url = http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf | title = LISP 1.5 Programmer's Manual | publisher = [[MIT_Press|MIT Press]] | author = [[John_McCarthy|John McCarthy]], Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, Michael I. Levin | isbn = 0-262-13011-4 | orig-year = 1962 | edition = 2nd | year = 1985 | quote = The variables in a lambda expression are dummy or bound variables because systematically changing them does not alter the meaning of the expression. Thus <code>λ<nowiki>[[u;v]</nowiki>;v<sup>2</sup>+u<nowiki>]</nowiki></code> means the same thing as <code>λ<nowiki>[[x;y]</nowiki>;y<sup>2</sup>+x<nowiki>]</nowiki></code>.<br />We shall sometimes use expressions in which a variable is not bound by a lambda. For example, in the function of two variables <code>λ<nowiki>[[x;y]</nowiki>;x<sup>n</sup>+y<sup>n</sup><nowiki>]</nowiki></code> the variable <code>n</code> is not bound. This is called a free variable. It may be regarded as a parameter. Unless <code>n</code> has been given a value before trying to compute with this function, the value of the function must be undefined. ……<br />Free Variables － A variable is <code>bound</code> in a particular function when it occurs in a list of bound variables following the word LAMBDA or PROG. Any variable that is not bound is free. ……<br />When a variable is used free, it must have been bound by a higher level function. If a program is being run interpretively, and a free variable is used without having bee bound on a higher level, error diagnostic *A 8* will occur.<br />If the program is being run complied, the diagnostic may not occur, and the variable may have value NIL. | access-date = 2021-11-10 | archive-date = 2021-03-02 | archive-url = https://web.archive.org/web/20210302065612/http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf }}</ref>，不适合表达λ演算<ref>{{cite web|author={{en-link|David Turner|David Turner (computer scientist)|David Turner}}|title=Some History of Functional Programming Languages|url=https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf|quote=LISP was not based on the lambda calculus, despite using the word “LAMBDA” to denote functions. At the time he invented LISP, McCarthy was aware of (Church 1941) but had not studied it. The theoretical model behind LISP was Kleene’s theory of first order recursive functions. (McCarthy made these statements, or very similar ones, in a contribution from the floor at the 1982 ACM symposium on LISP and functional programming in Pittsburgh. No written version of this exists, as far as know.)|access-date=2021-11-10|archive-date=2020-04-15|archive-url=https://web.archive.org/web/20200415053847/https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf}}<br />{{cite web|url=http://www.cs.yale.edu/homes/fischer/pubs/lambda.pdf|author={{en-link|Michael J. Fischer}}|title=Lambda-Calculus Schemata|year=1993|publisher=LISP AND SYMBOLIC COMPUTATION: An International Journal, 6, 259–288|quote=Pure LISP allows the definition and evaluation of functions over S-expressions. The lambda notation for functional abstraction is borrowed from Church’s lambda calculus, but otherwise there is little similarity between the two systems. Pure LISP has no higher-order functions, and call-by-value evaluation order is implicitly assumed. Two special constructs, conditional expressions and the label operator, allow recursive functions to be defined. Limited as it is, pure LISP is nevertheless powerful enough to express all partial recursive functions and hence provides an adequate basis for a theory of computation.|access-date=2021-11-10|archive-date=2022-03-02|archive-url=https://web.archive.org/web/20220302172407/http://www.cs.yale.edu/homes/fischer/pubs/lambda.pdf}}</ref>。

一个正式的λ系统，拥有一些公理和一个完备的推理规则。这有助于使用数理逻辑和工具来进行分析。在这个系统中，演算可以被看作直接的演绎。λ演算的语法，来自用<code>x, y, z, ...</code>、圆括号、空格、点号和符号λ形成的递归表达式<ref>{{cite journal |last1=van Tonder |first1=André |title=A Lambda Calculus for Quantum Computation |journal=SIAM Journal on Computing |date=1 January 2004 |volume=33 |issue=5 |pages=1109–1135 |doi=10.1137/S0097539703432165 |arxiv=quant-ph/0307150 |s2cid=613571 }}</ref>。λ演算的功能包括：首先，充当强力的数理逻辑的起点。其次，它可以缩减编程者在考虑实现细节上的要求，因为它可以用于模拟机器求值。最后，λ演算建立了一个坚实的元理论<ref>{{cite journal |last1=Niehren |first1=J. |last2=Schwinghammer |first2=J. |last3=Smolka |first3=G. |title=A concurrent lambda calculus with futures |journal=Theoretical Computer Science |date=November 2006 |volume=364 |issue=3 |pages=338–356 |doi=10.1016/j.tcs.2006.08.016 |url=https://hal.inria.fr/inria-00090434/file/0.pdf |access-date=2021-11-07 |archive-date=2022-04-08 |archive-url=https://web.archive.org/web/20220408050021/https://hal.inria.fr/inria-00090434/file/0.pdf }}</ref>。

在Scheme中，<code>lambda</code>關鍵字被用於定義[[匿名函數|匿名过程]]，并且使用<code>define</code>基础形式来定义命名过程，即将一个<code>lambda</code>过程绑定到指名的全局变量<ref name="binding">{{cite wikisource|title=Scheme: An Interpreter for Extended Lambda Calculus|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|year=1975|quote=<code>DEFINE</code> － This is analogous to the MacLISP <code>DEFUN</code> primitive (but note that the <code>LAMBDA</code> must appear explicitly!). It is used for defining a function in the "global environment" permanently, as opposed to <code>LABELS</code> (see below), which is used for temporary definitions in a local environment. <code>DEFINE</code> takes a name and a lambda expression; it closes the lambda expression in the global environment and stores the closure in the LISP value cell of the name (which is a LISP atom).}}<br />{{cite web|title=The Revised Report on SCHEME: A Dialect of LISP|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6283|year=1978|quote=Atoms which are not atomic symbols (identifiers) evaluate to themselves. Typical examples of such atoms are numbers, arrays, and strings (character arrays). Symbols are treated as identifiers or variables. They may be lexically bound by lambda-expressions. There is a global environment containing values initially have as their values primitive operations such as, for example, <code>CAR</code>, <code>CONS</code>, and <code>PLUS</code>. SCHEME differs from most LISP systems in that the atom <code>CAR</code> is not itself an operation (in the sense of being an invocable object, e.g. a valid first argument to <code>APPLY</code>), but only has one as a value when considered as an identifier.|access-date=2021-11-07|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235427/https://dspace.mit.edu/handle/1721.1/6283}}</ref>。在Scheme中，<code>(define (foo x) (+ x 1))</code>與<code>(define foo (lambda (x) (+ x 1)))</code>，在語法上是等同的。例如[[有序對|有序對]]可以表示為<ref>{{cite web|title=Structure and Interpretation of Computer Programs － 2.1.3 What Is Meant by Data?|url=https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-14.html#%_idx_1452|access-date=2021-11-04|archive-date=2022-04-25|archive-url=https://web.archive.org/web/20220425040100/https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-14.html#%_idx_1452}}</ref>：
<syntaxhighlight lang="scheme">
(define (cons x y)
  (lambda (m) (m x y)))

(define (car z)
  (z (lambda (p q) p)))

(define (cdr z)
  (z (lambda (p q) q)))
</syntaxhighlight>
這樣定義出來的<code>cons</code>、<code>car</code>和<code>cdr</code>，滿足恆等式<code>(car (cons x y))</code>等於<code>x</code>，和<code>(cdr (cons x y))</code>等於<code>y</code>。甚至[[递归_(计算机科学)|递归]]也可以表示为利用λ演算的[[不动点组合子#Y组合子|Y组合子]]<ref>{{cite web|title=Y-Combinator, Based on work by Jim Marshall|url=https://cs.brynmawr.edu/~dblank/cs245/ycomb_jim.html|access-date=2021-12-24|archive-date=2021-12-24|archive-url=https://web.archive.org/web/20211224150130/https://cs.brynmawr.edu/~dblank/cs245/ycomb_jim.html}}</ref>。

词法作用域的介入<ref name="lexcial" />，通过在某些形式的λ表示法，和在工作编程语言中它们的实际表达之间做出等价，解决了早期Lisp的有关问题。Sussman和Steele展示了，通过将λ表达式用作“控制结构和环境修改器”，而非简单的过程实例化，可以用这个新语言优雅的导出其他编程语言包括[[ALGOL|ALGOL]]和[[Fortran|Fortran]]的，所有指令式和声明式语义，和其他Lisp的动态作用域<ref>{{cite wikisource|title=Lambda: The Ultimate Imperative|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|year=1976|quote=Lambda calculus (and related languages, such as "pure LISP") is often used for modelling the applicative constructs of programming languages. However, they are generally thought of as inappropriate for modelling imperative constructs. …… we show how imperative constructs may be modelled by applicative SCHEME constructs. ……<br />Up to now we have thought of SCHEME’s <code>LAMBDA</code> expressions as functions, and of a combination such as <code>(G (F X Y))</code> as meaning “apply the function <code>F</code> to the values of <code>X</code> and <code>Y</code>, and return a value so that the function <code>G</code> can be applied and return a value ...” But notice that we have seldom used <code>LAMBDA</code> expressions as functions. Rather, we have used them as control structures and environment modifiers. For example, consider the expression:<br /><code>(BLOCK (PRINT 3) (PRINT 4))</code><br />This is defined to be an abbreviation for:<br /><code>((LAMBDA (DUMMY) (PRINT 4)) (PRINT 3))</code><br />We do not care about the value of this <code>BLOCK</code> expression; it follows that we do not care about the value of the <code>(LAMBDA (DUMMY) ...)</code>. We are not using <code>LAMBDA</code> as a function at all.<br />It is possible to write useful programs in terms of <code>LAMBDA</code> expressions in which we never care about the value of any lambda expression. We have already demonstrated how one could represent any “FORTRAN” program in these terms: all one needs is <code>PROG</code> (with <code>GO</code> and <code>SETQ</code>), and <code>PRINT</code> to get the answers out. The ultimate generalization of this imperative programming style is continuation-passing. ……<br />…… we will consider the problem of dynamically scoped, or "fluid", variables. These do not exist in ALGOL, but are typical of many LISP implementations, ECL, and APL. We will see that fluid variables may be modelled in more than one way, and that one of these is closely related to continuation-passing.}}</ref>。他们在第一篇λ论文中，与对Scheme的首次描述一起，介入了{{en-link|续体传递风格|continuation-passing style}}<ref>{{cite wikisource|title=Scheme: An Interpreter for Extended Lambda Calculus|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|year=1975|quote=It is always possible, ……to perform any calculation in this way: rather than reducing to its value, it reduces to an application of a continuation to its value (cf. [Fischer]). That is, in this continuation-passing programming style, a function always "returns" its result by "sending" it to another function.}}</ref>，并在后续的论文中，他们推进演示了λ演算的这种实际使用的原生能力。

===过程应用中的求值次序===
Scheme采用了[[求值策略#传值调用|传值调用]]，但不同于多数Lisp规定了过程实际参数的求值次序，Scheme不规定求值次序。对比于其他Lisp，Scheme表达式在算符位置（第一个项目）上可以是一个表达式，只要在算符位置上的表达式的结果是一个过程，这种表示就是完全合法的<ref>{{cite web|title=The Revised Report on SCHEME: A Dialect of LISP|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6283|year=1978|quote=Non-atomic forms are divided by the evaluator into two classes: combinations and "magic (special) forms". …… Magic forms are recognized by then presence of a "magic (reserved) word" in the <code>car</code> position of the form. All non-atomic forms which are not magic forms are considered to be combinations. The system has a small initial set of magic words; there is also a mechanism for creating new ones {Note FUNCALL is a Pain}.<br />A combination is considered to be a list of subforms. These subforms are all evaluated. The first value mub be a procedure; it is applied to the other values to get the value of the combination. There are four important points here:<br />(1) the procedure Position is always evaluated just like any other position. (This is why the primitive operators are the values of global identifiers.)<br />(2) the procedure is never "re-evaluated"; if the first subform fails to evaluate to a applicable procedure, it is an error. Thus, unlike most LISP systems, SCHEME always evaluates the first subform of a combination exactly once.<br />(3) the arguments are all completely evaluated before the procedure is applied; that is, SCHEME, like most LISP systems, is an applicative-order language. Many SCHEME programs exploit this fact.<br />(4) the argument forms (and procedure form) may in principle be evaluated in any order. This is unlike the usual LISP left-to-right order. (All SCHEME interpreters implemented so far have in fact performed left-to-right evaluation, but we do not wish programs to depend on this fact. Indeed, there are some reasons why a clever interpreter might want to evaluate them right-to-left, e.g. to get things on a stack in the correct order.)}}</ref>。

在Scheme中，在算符和实际参数位置上的这些表达式的求值次序，可以在逐个调用的基础上由实现来选择，而唯一的约束是：“运算符和运算数表达式的任何并发求值的效果，被约束为一致于某种顺序次序的求值。”（R<sup>5</sup>RS sec. 4.1.3）<ref name="r5rs"/>
<syntaxhighlight lang="Scheme">
(let ((ev (lambda(n) (display "Evaluating ")
                     (display (if (procedure? n) "procedure" n))
                     (newline) n)))
  ((ev +) (ev 1) (ev 2)))
===> 3
</syntaxhighlight>
<code>ev</code>是一个过程，它描述传递给它的实际参数，接着返回这个实际参数的值。在调用过程<code>+</code>来加<code>1</code>和<code>2</code>之中，表达式<code>(ev +)</code>、<code>(ev 1)</code>和<code>(ev 2)</code>可以按任何次序求值，只要效果上它们不像是并行求值的。因此在上述例子被执行的时候，下列三行可以被标准Scheme按任何次序来显示，然而一行的文本不可以同另一行的文本产生交错，因为这会违反顺序求值约束。
: Evaluating 1
: Evaluating 2
: Evaluating procedure

===塊結構===
Scheme的[[代碼塊|代碼塊]]結構繼承自更早時候的語言<ref>{{cite wikisource|title=Scheme: An Interpreter for Extended Lambda Calculus|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|year=1975|quote=<code>LABELS</code> － We have decided not to use the traditional <code>LABEL</code> primitive in this interpreter because it is difficult to define several mutually recursive functions using only <code>LABEL</code>. The solution, which Hewitt [Smith and Hewitt] also uses, is to adopt an [[ALGOL|ALGOL]]-esque block syntax:<br /><code>(LABELS <function definition list> <expression>)</code><br />This has the effect of evaluating the expression in an environment where all the functions are defined as specified by the definitions list. Furthermore, the functions are themselves closed in that environment, and not in the outer environment; this allows the functions to call themselves and each other recursively. ……<br /><code>BLOCK</code> － This is like the MacLISP <code>PROGN</code>, but arranges to evaluate its last argument without an extra net control frame (explained later), so that the last argument may involved in an iteration. Note that in SCHEME, unlike MacLISP, the body of a <code>LAMBDA</code> expression is not an implicit <code>PROGN</code>.}}<br />
{{cite wikisource|title=Lambda: The Ultimate Imperative|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|year=1976|quote=At this point we are almost in a position to model the most general form of compound statement. In LISP, this is called the "<code>PROG</code> feature". In addition to statement sequencing and <code>GO TO</code> statements, one can return a value from a <code>PROG</code> by using the <code>RETURN</code> statement.<br />Let us first consider the simplest compound statement, which in SCHEME we call <code>BLOCK</code>. Recall that<br /><code><nowiki>    </nowiki>(BLOCK S1 S2)</code> is defined to be <code>((LAMBDA (DUMMY) S2) S1)</code><br />Notice that this not only performs <code>S1</code> before <code>S2</code>, but also returns the value of <code>S2</code>. Furthermore, we defined <code>(BLOCK S1 S2 ... Sn)</code> so that it returns the value of <code>Sn</code>. Thus <code>BLOCK</code> may be used as a compound expression, and models a LISP <code>PROGN</code>, which is a <code>PROG</code> with no <code>GO TO</code> statements and an implicit <code>RETURN</code> of the last "statement" (really an expression). }}<br />
{{cite web|title=The Revised Report on SCHEME: A Dialect of LISP|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6283|year=1978|quote=<br /><code>(BLOCK x<sub>1</sub> x<sub>2</sub> ... x<sub>n</sub>)<br /><nowiki>    </nowiki>(BLOCK x) → x<br /><nowiki>    </nowiki>(BLOCK x . r) → ((LAMBDA (A B) (B)) x (LAMBDA () (BLOCK . r)))</code><br /><code>BLOCK</code> sequentially evaluates the subforms <code>x<sub>i</sub></code> from left to right. For example:<br /><code><nowiki>    </nowiki>(BLOCK (ASET' X 43) (PRINT X) (+ X 1))</code><br />returns <code>44</code> after setting <code>x</code> to <code>43</code> and then printing it {Note <code>BLOCK</code> Exploits Applicative Order}.<br /><code>(LET ((v<sub>1</sub> x<sub>1</sub>) (v<sub>2</sub> x<sub>2</sub>) ... (v<sub>n</sub> x<sub>n</sub>)) . body)<br /><nowiki>    </nowiki>→ ((LAMBDA (v<sub>1</sub> v<sub>2</sub> ... v<sub>n</sub>) (BLOCK . body)) x<sub>1</sub> x<sub>2</sub> ... x<sub>n</sub>)</code><br /><code>LET</code> provides a convenient syntax for binding several variables to corresponding quantities. It allows the forms for the quantities to appear textually adjacent to their corresponding variables. Notice that the variables are all bound simultaneously, not sequentially, and that the initialization form <code>x<sub>i</sub></code> may be evaluated in any order. For convenience, <code>LET</code> also supplies a <code>BLOCK</code> around the forms constituting its body.}}</ref>。自从R<sup>2</sup>RS开始<ref name="r2rs" />，Scheme中的块，是通过三个“绑定构造”来实现的：{{en-link|Let 表达式|Let expression|<code>let</code>}}、<code>let*</code>和<code>letrec</code>。例如，下列构造建立一个[[块_(编程)|块]]，其中叫做<code>var</code>的符号被绑定到数<code>10</code>：
<syntaxhighlight lang="Scheme">
(define var "goose")
;; 这里任何到var的引用都会被绑定到"goose"
(let ((var 10))
  ;; 语句走到这里时，任何到var的引用都会绑定到10
  )
;; 这里任何到var的引用都会绑定到"goose"
</syntaxhighlight>

依据编程者的需要，块可以{{en-link|嵌套 (计算)|Nesting (computing)|嵌套}}来建立任意复杂的块结构。使用块结构来建立局部绑定，减轻了不然可能发生的{{en-link|命名冲突|Naming collision|命名空间冲突}}。

<code>let</code>的变体之一<code>let*</code>，允许绑定引用在前面相同构造中定义的变量，例如：

<syntaxhighlight lang="Scheme">
(let* ((var1 10)
       (var2 (+ var1 12)))
  ;; 但是var1的定义不可以引用var2
  )

</syntaxhighlight>

<code>let</code>的另一个变体<code>letrec</code>，被设计用来确使[[互递归|互递归]]过程可绑定彼此。

下面的例子是[[侯世达|侯世达]]{{en-link|侯世达序列|Hofstadter sequence#Hofstadter Female and Male sequences|雌雄序列}}：
<syntaxhighlight lang="Scheme">
;; 将侯世达雌雄序列计算为有序对的列表
(define (hofstadter-male-female n)
  (letrec ((female (lambda (n)
		     (if (= n 0)
			 1
			 (- n (male (female (- n 1)))))))
	   (male (lambda (n)
		   (if (= n 0)
		       0
		       (- n (female (male (- n 1))))))))
    (let loop ((i 0))
      (if (> i n)
	  '()
	  (cons (cons (female i)
		      (male i))
		(loop (+ i 1)))))))

(hofstadter-male-female 8)

===> ((1 . 0) (1 . 0) (2 . 1) (2 . 2) (3 . 2) (3 . 3) (4 . 4) (5 . 4) (5 . 5))
</syntaxhighlight>
在一个单一的<code>letrec</code>中的所有过程，可以通过名字引用其他的过程，还有在相同的<code>letrec</code>中此前定义的变量的值，但是它们不可以引用在相同的<code>letrec</code>中此后定义的变量的值。

<code>let</code>的变体“命名<code>let</code>”形式，在<code>let</code>关键字之后有一个标识符。它将这些<code>let</code>变量绑定到一个过程的实际参数，这个过程的名字由这个标识符给出，它的过程体是<code>let</code>形式的主体。这个过程体可以通过调用这个过程达成想要的重复。命名<code>let</code>被广泛用于实现迭代。

一个简单的计数器例子:
<syntaxhighlight lang="Scheme">
(let loop ((n 1))
  (if (> n 10)
      '()
      (cons n
	    (loop (+ n 1)))))

===> (1 2 3 4 5 6 7 8 9 10)
</syntaxhighlight>
就像Scheme中的任何过程一样，在命名<code>let</code>中建立的这个过程是[[头等对象|头等对象]]。

===正当尾递归===
{{Further|尾递归}}
Scheme拥有一个迭代构造<code>do</code><ref>{{cite wikisource|title=Scheme: An Interpreter for Extended Lambda Calculus|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|year=1975|quote=<code>DO</code> － This is like the MacLISP "new-style" <code>DO</code>; old-style <code>DO</code> is not supported.}}</ref>，但是在Scheme中更推崇的{{en-link|编程惯用法|Programming idiom|惯用法}}，是使用[[尾递归|尾递归]]来表达[[迭代|迭代]]<ref>{{cite web|title=The Revised Report on SCHEME: A Dialect of LISP|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6283|year=1978|quote=Another difference from LISP is that SCHEME is implemented in such a way that tail-recursions execute without net growth of the interpreter stack. The effect of this is that a procedure call behaves like a <code>GOTO</code> and thus procedure calls can be used to implement iterations, as in PLASMA.|access-date=2021-11-07|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235427/https://dspace.mit.edu/handle/1721.1/6283}}</ref>。遵循标准的Scheme实现被要求优化尾递归，从而支持无限数量的活跃尾递归（R<sup>5</sup>RS sec. 3.5<ref name="r5rs"/>），这个性质被Scheme报告描述为“正当”（proper）尾递归，它使得Scheme编程者可以安全的使用递归结构来书写迭代算法，这在很多时候是更符合直觉的。尾递归过程和命名<code>let</code>形式，提供对使用尾递归的迭代的支持。

<syntaxhighlight lang="Scheme">
;; 建造从0到9的平方的列表：
;; 注意：loop简单的就是用作标签的一个任意符号。任何符号都行。
(define (list-of-squares n)
  (let loop ((i n) (res '()))
    (if (< i 0)
        res
        (loop (- i 1) (cons (* i i) res)))))

(list-of-squares 9)
===> (0 1 4 9 16 25 36 49 64 81)
</syntaxhighlight>

===头等续体===
{{Main|计算续体}}
在Scheme中[[计算续体|续体]]是[[头等对象|头等对象]]<ref>{{cite wikisource|title=Scheme: An Interpreter for Extended Lambda Calculus|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|year=1975|quote=<code>CATCH</code> － This is the "escape operator" which gives the user a handle on the control structure of the interpreter. The expression:<br /><code>(CATCH <identifier> <expression>)</code><br />evaluates <code><expression></code> in an environment where <code><identifier></code> is bound to a [[计算续体|continuation]] which is "just about to return from the <code>CATCH</code>"; that is, if the continuation is called as a function of one argument, then control proceeds as if the <code>CATCH</code> expression had returned with the supplied (evaluated) argument as its value. ……<br />As another example, we can define a <code>THROW</code> function, which may then be used with <code>CATCH</code> much as they are in LISP:<br /><code>(DEFINE THROW (LAMBDA (TAG RESULT) (TAG RESULT)))</code>}}</ref>。自从R<sup>2</sup>RS开始<ref name="r2rs">{{cite web|title=The Revised Revised Report on Scheme or An Uncommon Lisp|author={{en-link|William Clinger|William Clinger (computer scientist)|William Clinger}}|url=https://dspace.mit.edu/handle/1721.1/5600|year=1985|access-date=2021-11-10|archive-date=2022-04-08|archive-url=https://web.archive.org/web/20220408164637/https://dspace.mit.edu/handle/1721.1/5600}}</ref>，Scheme提供了过程<code>{{en-link|以当前续体调用|call-with-current-continuation|call-with-current-continuation}}</code>（简写为<code>call/cc</code>），通过把当前[[计算续体|续体]]包装成脱离（escape）过程来捕获它，并把它绑定到编程者提供的一个过程的一个形式参数（R<sup>5</sup>RS sec. 6.4）<ref name="r5rs"/>。头等[[计算续体|续体]]使得编程者能够建立非局部[[控制流程|控制结构]]比如[[迭代|迭代]]、[[协程|协程]]和[[回溯|回溯]]。

续体可以被用来模拟指令式编程语言中[[return语句|return语句]]的行为。下列函数<code>find-first</code>接受函数<code>func</code>和列表<code>lst</code>，返回<code>lst</code>中的第一个元素<code>x</code>，它使得<code>(func x)</code>返回真。

<syntaxhighlight lang="scheme">
(define (find-first func lst)
  (call-with-current-continuation
   (lambda (return-immediately)
     (for-each (lambda (x)
		 (if (func x)
		     (return-immediately x)))
	  lst)
     #f)))

(find-first integer? '(1/2 3/4 5.6 7 8/9 10 11))
===> 7
(find-first zero? '(1 2 3 4))
===> #f
</syntaxhighlight>

David Madore在1999年提出的阴阳谜题<ref>David Madore, [https://groups.google.com/forum/#!msg/comp.lang.scheme/Fysq_Wplxsw/awxEZ_uxW20J "call/cc mind-boggler"] {{Webarchive|url=http://arquivo.pt/wayback/20110122130054/https://groups.google.com/forum/#!msg/comp.lang.scheme/Fysq_Wplxsw/awxEZ_uxW20J |date=2011-01-22 }}</ref>，展示了Scheme可以将续体当作[[头等对象|头等对象]]处理，绑定它们到变量，和把它们作为给过程的实际参数来传递<ref>Yin Wang, [https://web.archive.org/web/20140129194441/http://yinwang0.wordpress.com/2012/07/27/yin-yang-puzzle "Understanding the Yin-Yang Puzzle"]</ref>。

===统一的命名空间===
对比于Common Lisp，在Scheme中所有的数据和过程共享一个共同的命名空间，而Common Lisp中有[[Common_Lisp#数名字空间|函数和数据分离的命名空间]]，使得一个函数和一个变量可以有相同的名字，并且将一个函数作为值引用时要求特殊的表示法。这有时叫做“Lisp<sub>1</sub>与Lisp<sub>2</sub>”差异，二者分别称谓Scheme的统一的命名空间，和Common Lisp的分立的命名空间<ref>{{cite journal |title=Technical Issues of Separation in Function Cells and Value Cells |url=http://www.nhplace.com/kent/Papers/Technical-Issues.html |author={{en-link|Richard P. Gabriel}} |author2={{en-link|Kent M. Pitman}} |journal=Lisp and Symbolic Computation |date=June 1988 |volume=1 |issue=1 |pages=81–101 |doi=10.1007/bf01806178 |s2cid=26716515 |access-date=2021-11-08 |archive-date=2006-11-13 |archive-url=https://web.archive.org/web/20061113140912/http://www.nhplace.com/kent/Papers/Technical-Issues.html }}</ref>。

在Scheme中， 可以使用操纵和绑定数据的原始运算来绑定过程。没有等价于Common Lisp的<code>defun</code>和<code>#'</code>的原始运算。
<syntaxhighlight lang="Scheme">
;; 变量绑定到一个数：
(define f 10)
f
===> 10
;; 变化（改变绑定值）
(set! f (+ f f 6))
f
===> 26
;; 将一个过程赋值给相同的变量：
(set! f (lambda (n) (+ n 12)))
(f 6)
===> 18
;; 将一个表达式的结果赋值给相同的变量：
(set! f (f 1))
f
===> 13
;; 函数式编程：
(apply + '(1 2 3 4 5 6))
===> 21
(set! f (lambda (n) (+ n 100)))
(map f '(1 2 3))
===> (101 102 103)
</syntaxhighlight>

==实现标准==
本章归档多年来做出的给与Scheme特定特征的设计决定，它们不是最初设计的直接产物。

===注释===
{{See also|注释 (计算机语言)}}
直到R<sup>5</sup>RS标准，在Scheme中的标准注释是分号，它使得这行余下部份对Scheme不可见。许多实现支持可替代的约定，允许注释扩展为多于一行，而R<sup>6</sup>RS标准允许其中的两种：一个完整的[[S-表达式|S-表达式]]，可以通过前导<code><nowiki>#;</nowiki></code> 而变成一个注释（介入于SRFI 62<ref>{{cite web |publisher=The SRFI Editors, schemers.org |author=Taylor Campbell |date=2005-07-21 |title=SRFI 62: S-expression comments |url=http://srfi.schemers.org/srfi-62/srfi-62.html |access-date=2012-08-09 |archive-date=2022-04-11 |archive-url=https://web.archive.org/web/20220411184107/https://srfi.schemers.org/srfi-62/srfi-62.html }}</ref>），和通过用<code><nowiki>#</nowiki>|</code>和<code>|#</code>围绕文本，产生的“多行注释”或“块注释”。

===在布尔表达式中非布尔值的处理===
在多数Lisp方言包括Common Lisp中，布尔表达式中的值<code>NIL</code>按照惯例被求值为值假。在Scheme中，自从1991年的IEEE标准<ref name="ieee1178"/>，除了<code>#f</code>的所有的值，包括在Scheme中写为<code>'()</code>的<code>NIL</code>的等价者，在布尔表达式中求值为值真（R<sup>5</sup>RS sec. 6.3.1）<ref name="r5rs" />。

在多数Lisp中表示布尔值真的常量是<code>T</code>，而在Scheme中它是<code>#t</code>。

===干净宏===
{{Main|{{en-link|干净宏|Hygienic macro}}}}
Scheme的语法可以轻易的通过宏系统来扩展<ref>{{cite web|title=The Revised Report on SCHEME: A Dialect of LISP|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6283|year=1978|quote=Syntactic Extensions － SCHEME has a syntactic extension mechanism which provides a way to define an identifier to be a magic word, and to associate a function with that word. The function accepts the magic form as an argument, and produces a new form; this new form is then evaluated in place of the original (magic) form. This is precisely the same as the MacLISP macro facility.|access-date=2021-11-07|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235427/https://dspace.mit.edu/handle/1721.1/6283}}</ref>。R<sup>5</sup>RS标准介入了强力的干净宏系统<ref name="hygiene">{{cite conference|last1 = Kohlbecker|first1 = E.|last2 = Friedman|first2 = D. P.|last3 = Felleisen|first3 = M.|last4 = Duba|first4 = B.|year = 1986|title = Hygienic Macro Expansion|book-title = ACM conference on LISP and functional programming|url = http://www.cs.indiana.edu/pub/techreports/TR194.pdf|quote = In most current Lisp systems the expander's task is confined to the process of finding syntactic extensions and replacing them by their expansions. This implies, in particular, the each macro function is responsible for the integrity of the program. For Lisp systems (and other languages with similar macro facilities) this means specifically that variable binding  must not be corrupted. This, however, is not as simple a task as it sounds. ……<br />The real danger of these erroneous macros is that they are treacherous. They work in all cases but one: when the user － or some other macro writer － inadvertently picks the wrong identifier name.<br />Various techniques have been proposed to circumvent this capturing problem, but they rely on the individual macro writer. if even one of many macro writers is negligent, the macro system becomes unsafe. We claim that the task of safely renaming macro-generated identifier is mechanical. It is essentially an α-conversion, which is knowledgeable about the origin of the identifiers. For these reasons we propose a change to the navïe macro expansion algorithm which automatically maintains hygienic conditions during expansion time.|access-date = 2021-11-10|archive-date = 2017-08-29|archive-url = https://web.archive.org/web/20170829182901/https://www.cs.indiana.edu/pub/techreports/TR194.pdf}}<br />{{cite conference|last1 = Kohlbecker|first1 = E|last2 = Wand|first2 = M|title = Macro-by-example: Deriving syntactic transformations from their specifications|book-title = Symposium on Principles of Programming Languages|year = 1987|url = https://legacy.cs.indiana.edu/ftp/techreports/TR206.pdf|access-date = 2021-11-10|archive-date = 2022-04-12|archive-url = https://web.archive.org/web/20220412142630/https://legacy.cs.indiana.edu/ftp/techreports/TR206.pdf}}</ref>，它允许编程者使用一种简单的[[模式匹配|模式匹配]]子语言，向语言增加的新的语法构造（R<sup>5</sup>RS sec 4.3）<ref name="r5rs"/>。在此前的R<sup>4</sup>RS标准中，干净宏系统已经作为“高级”系统，和“低级”宏系统一起被编排入标准的附录中<ref name="r4rs">{{cite journal |title=Revised<sup>4</sup> Report on the Algorithmic Language Scheme |author=William Clinger and Jonathan Rees, editors |url=https://people.csail.mit.edu/jaffer/r4rs_toc.html |journal=ACM Lisp Pointers |volume=4 |issue=3 |pages=1–55 |year=1991 |access-date=2012-08-09 |archive-date=2022-01-22 |archive-url=https://web.archive.org/web/20220122145809/http://people.csail.mit.edu/jaffer/r4rs_toc.html }}</ref>，二者都被当作对Scheme的扩展而非语言的本质部份。

干净宏的实现，也叫做<code>syntax-rules</code>, 被要求遵守语言的其余部份的词法作用域。这是通过针对宏展开的特殊命名和作用域规则来确保的，从而避免在其他编程语言的宏系统中可能出现的常见编程错误。R<sup>6</sup>RS规定了更加复杂的变换系统<code>syntax-case</code>，它已经作为对R<sup>5</sup>RS Scheme的一个语言扩展而能够获得到有一段时间了。例如：
<syntaxhighlight lang="Scheme">
;; 定义一个宏来实现“if”的具有多个表达式的变体
;; 有真分支而无假分支
(define-syntax when
  (syntax-rules ()
    ((when pred exp exps ...)
      (if pred (begin exp exps ...)))))
</syntaxhighlight>

宏和过程的调用看起来非常相似，二者都是S-表达式，但是它们被不同的对待。在编译器遇到程序中的一个S-表达式的时候，它首先查看这个符号是否被定义为在当前词法范围内的语法关键字。如果是这样，它接着尝试展开这个宏，将在这个S-表达式尾部的项目当作实际参数，而不用编译代码来求值它们，递归的重复这个处理过程直到没有余留的宏调用。如果它不是一个语法关键字，编译器编译代码来求值在这个S-表达式尾部的实际参数，并接着求值在这个S-表达式头部的符号所表示的变量，把它作为过程来调用，并把最终的尾部表达式作为实际参数传递给它。

多数Scheme实现还提供额外的宏系统。其中最流行是{{en-link|干净宏#语法闭包|Hygienic macro#syntactic closures|语法闭包}}、{{en-link|干净宏#显式重命名|Hygienic macro#explicit renaming|显式重命名宏}}和<code>define-macro</code>，它是类似于[[Common_Lisp|Common Lisp]]中提供的<code>defmacro</code>系统的非干净宏。

不能指定一个宏是否为干净的，是宏系统的一个缺点。可作为替代的展开模型比如作用域集合，提供一种潜在的解决方案<ref>{{cite book |doi=10.1145/2837614.2837620 |chapter=Binding as sets of scopes |title=Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages |year=2016 |last1=Flatt |first1=Matthew |pages=705–717 |isbn=978-1-4503-3549-2 |s2cid=15401805 }}</ref>。

===延迟求值===
{{See also|惰性求值}}
自从R<sup>2</sup>RS开始<ref name="r2rs" />，Scheme通过<code>delay</code>形式和过程<code>force</code>支持延迟求值。

<syntaxhighlight lang="Scheme">(define a 10)
(define eval-aplus2 (delay (+ a 2)))
(set! a 20)
(force eval-aplus2)
===> 22
(define eval-aplus50 (delay (+ a 50)))
(let ((a 8))
  (force eval-aplus50))
===> 70
(set! a 100)
(force eval-aplus2)
===> 22
</syntaxhighlight>

这些原始运算，产生或处理叫做[[Future与promise|promise]]的值，promise的原本定义的文字内容被留存了，并且在第一次使用<code>force</code>之后它的值也被留存了。promise永远只求值一次。它们可以被用来实现高级的[[惰性求值|惰性求值]]构造比如[[字串流|串流]]<ref name="srfi-41">{{cite web |publisher=The SRFI Editors, schemers.org |author=Philip L. Bewig |url=http://srfi.schemers.org/srfi-41/srfi-41.html |title=SRFI 41: Streams |date=2008-01-24 |access-date=2012-08-09 |archive-date=2021-03-07 |archive-url=https://web.archive.org/web/20210307200437/https://srfi.schemers.org/srfi-41/srfi-41.html }}</ref>。

在R<sup>5</sup>RS中，给出了<code>delay</code>和<code>force</code>的推荐实现，将promise实现为没有实际参数的一个过程（{{en-link|thunk}}），并使用[[记忆化|记忆化]]来确保它永远只求值一次，与调用<code>force</code>的次数无关（R<sup>5</sup>RS sec. 6.4）<ref name="r5rs"/>。在R<sup>6</sup>RS标准中，它们不再是原始运算，转而作为R<sup>5</sup>RS兼容库的一部份提供（rnrs r5rs (6)）。

SRFI 41确使有限和无限序列能够具有非凡经济性的表达。例如，这是使用在SRFI 41中的函数定义的一个[[斐波那契数列|斐波那契数列]]<ref name="srfi-41"/>：

<syntaxhighlight lang="Scheme">
;; 定义斐波那契序列
(define fibs
  (stream-cons 0
    (stream-cons 1
      (stream-map +
        fibs
        (stream-cdr fibs)))))
;; 计算这个序列的第一百个数
(stream-ref fibs 99)
===>  218922995834555169026
</syntaxhighlight>

===eval及其运行环境===
R<sup>5</sup>RS标准之前，在其他Lisp中无处不在的<code>eval</code>过程，在Scheme中没有等价者。在第一篇λ论文中，曾经将<code>evaluate</code>描述为“类似于LISP函数EVAL”<ref>{{cite wikisource|title=Scheme: An Interpreter for Extended Lambda Calculus|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|year=1975|quote=<code>EVALUATE</code> － This is similar to the LISP function <code>EVAL</code>. It evaluates its argument, and then evaluates the resulting s-expression as SCHEME code.}}</ref>，但在具有词法作用域的Scheme中，对这个表达式在哪个环境中求值存在困惑。例如，不明确求值下列表达式的结果应当是<code>5</code>还是<code>6</code><ref name="rees_1992">{{cite web|url=https://www.cs.hmc.edu/~fleck/envision/scheme48/meeting/node4.html#SECTION00000400000000000000|title=The Scheme of Things: The June 1992 Meeting － Evaluating computed expressions|publisher=ACM SIGPLAN, Lisp Pointers, Volume V, Issue 4|year=1992|access-date=2021-11-12|archive-date=2022-04-04|archive-url=https://web.archive.org/web/20220404192719/https://www.cs.hmc.edu/~fleck/envision/scheme48/meeting/node4.html#SECTION00000400000000000000}}</ref>：
<syntaxhighlight lang="Scheme">
(let ((name '+))
  (let ((+ *))
    (evaluate (list name 2 3))))
</syntaxhighlight>
在求值实际参数<code>name</code>的时候，在外层环境中找到了它的定义；在求值结果表达式<code>(+ 2 3)</code>的时候，如果在外层环境中求值，结果是两个运算数的总和；如果在内层环境中求值，这里符号<code>+</code>已经被绑定到过程<code>*</code>的值，结果是两个运算数的乘积。为此在1978年的最初修订报告中，将<code>evaluate</code>替代为<code>enclose</code>，它接受分别为代码和运行环境的两个实际参数<ref>{{cite web|title=The Revised Report on SCHEME: A Dialect of LISP|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6283|year=1978|quote=<br /><code>(ENCLOSE fnrep envrep)</code><br /><code>ENCLOSE</code> takes two s-expressions, one representing the code for a procedure, and the other representing the (lexical) environment in which is to run. <code>ENCLOSE</code> returns a (closed) procedure which can be invoked.<br />The representation of the code is the standard s-expression description (a lambda-expression). the representation of the environment is an association list (a-list) of the traditional kind:<br /><code>((var1 . value1) (var2 . value2) ...)</code><br /><code>NIL</code> represents the global lexical environment. ……<br />The <code>EVALUATE</code> primitive described in [SCHEME] has been removed from the language. We discovered (the hard way) that the straightforward implementation of <code>EVALUATE</code> (evaluate the given expression in the current environment) destroys {{en-link|referential transparency}}. We then altered it to evaluate the expression in the top-level environment, but were still disturbed by the extent to which one is tied to a particular representation of a procedure to be executed.|access-date=2021-11-07|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235427/https://dspace.mit.edu/handle/1721.1/6283}}</ref>。由于各种技术和实际原因，第二次、第三次和第四次修订报告省略了任何<code>eval</code>的等价者<ref name="rees_1992" />。

R<sup>5</sup>RS通过规定三个返回环境的过程，并提供接受一个S-表达式和一个环境的过程<code>eval</code>，它在提供的这个环境内求值这个表达式（R<sup>5</sup>RS sec. 6.5）<ref name="r5rs" />，解决了这个困惑。R<sup>6</sup>RS通过提供叫做<code>environment</code>的一个过程进行了扩展，编程者通过它可以精确的指定将哪个对象导入到求值环境之内。

通过现代Scheme（通常兼容于R<sup>5</sup>RS）来求值表达式<code>expr</code>，你需要定义如下这样的一个函数<code>evaluate</code>：

<syntaxhighlight lang="Scheme">
(define (evaluate expr)
   (eval expr (interaction-environment)))
</syntaxhighlight>

<code>interaction-environment</code>是解释器的全局环境。

===数值塔===
{{Main|{{en-link|数值塔|Numerical tower}}}}
Scheme规定了数值数据类型的相较完全的集合，包括[[复数_(数学)|复数]]和[[有理数|有理数]]类型，这在Scheme中叫做“数值塔”（R<sup>5</sup>RS sec. 6.2<ref name="r5rs"/>）。标准对它们作抽象处理，而不委以任何特定的内部表示。

数可以有精确性品质。一个精确数只能从涉及其他精确数的精确运算产生，不精确是传染的。标准规定任何两个实现对产生精确数的所有运算都必须产生等价的结果。

R<sup>5</sup>RS标准规定了过程<code>exact->inexact</code>和<code>inexact->exact</code>，它们可以用于改变一个数的精确性。<code>inexact->exact</code>产生“在数值上最接近实际参数的精确数”。<code>exact->inexact</code>产生“在数值上最接近实际参数的不精确数”。R<sup>6</sup>RS标准在主报告中省略了这些过程，而是在标准库中将它们规定为R<sup>5</sup>RS兼容过程（rnrs r5rs (6)）。

在R<sup>5</sup>RS标准中，不要求Scheme实现去实现整个数值塔，而是它们必须实现“符合实现用途和Scheme语言精神二者的连贯子集”（R<sup>5</sup>RS sec. 6.2.3）<ref name="r5rs"/>。新的R<sup>6</sup>RS标准要求实现整个数值塔，并且“精确整数对象和精确有理数对象实际上有无限的大小和精度，并且对于实现特定过程...所以它们在得到精确实际参数时总是返回精确结果”（R<sup>6</sup>RS sec. 3.4, sec. 11.7.1）<ref name="r6rs"/>。

在支持精确有理复数的实现中的精确算术例子： 
<syntaxhighlight lang="Scheme">
;; 三个有理实数和两个有理复数的总和
(define x (+ 1/3 1/4 -1/5 -1/3i 405/50+2/3i))
x
===> 509/60+1/3i
;; 检查精确性
(exact? x)
===> #t
</syntaxhighlight>

在既不支持精确有理数也不支持复数却接受有理数表示法的实数的实现中相同算术的例子：
<syntaxhighlight lang="Scheme">
;; 四个有理实数的总和
(define xr (+ 1/3 1/4 -1/5 405/50))
;; 两个有理实数的总和
(define xi (+ -1/3 2/3))
xr
===> 8.48333333333333
xi
===> 0.333333333333333
;; 检查精确性
(exact? xr)
===> #f
(exact? xi)
===> #f
</syntaxhighlight>

二者实现都符合R<sup>5</sup>RS标准，但是第二个实现不符合R<sup>6</sup>RS，因为它没有实现完整的数值塔。

===原始数据类型不相交===
在Scheme中原始数据类型是不相交的。对于任何Scheme对象，下列谓词中只有一个可以为真：<code>boolean?</code>、<code>pair?</code>、<code>symbol?</code>、<code>number?</code>、<code>char?</code>、><code>string?</code>、<code>vector?</code>、<code>port?</code>和<code>procedure?</code>（R<sup>5</sup>RS sec 3.2）<ref name="r5rs"/>。

作为对比，在数值数据类型之内，对数值值是可以有交叠的。例如，一个整数值可以同时满足如下谓词：<code>integer?</code>、<code>rational?</code>、<code>real?</code>、<code>complex?</code>和<code>number?</code>（R<sup>5</sup>RS sec 6.2）<ref name="r5rs"/>。

===等价谓词===
{{See also|关系算子}}
Scheme在任意对象之间有三种不同类型的等价，它们通过三种不同的“等价谓词”来指示，即测试等式的关系算符<code>eq?</code>、<code>eqv?</code>和<code>equal?</code>：
*  <code>eq?</code>求值为<code>#f</code>，除非它的实际参数表示在内存中相同的对象；
* <code>eqv?</code>大体上同于<code>eq?</code>，但是特殊处理原始对象（比如字符和数），使得表示相同值的数<code>eqv?</code>为真，即使它们不引用相同的对象；
* <code>equal?</code>比较数据结构比如列表、向量和字符串，来确定它们是否有全等的结构并且其内容<code>eqv?</code>为真（R<sup>5</sup>RS sec. 6.1）<ref name="r5rs"/>。

在Scheme中还存在依赖于类型的等价运算：<code>string=?</code>和<code>string-ci=?</code>比较两个字符串（后者进行不依赖大小写比较）；<code>char=?</code>和<code>char-ci=?</code>比较字符；<code>=</code>比较数<ref name="r5rs"/>。

===输入/输出===
Scheme的输入和输出基于了“端口”数据类型（R<sup>5</sup>RS sec 6.6）<ref name="r5rs"/>。R<sup>5</sup>RS定义了两个缺省端口，可通过过程<code>current-input-port</code>和<code>current-output-port</code>来访问，它们对应于Unix概念的[[标准串流|标准输入和标准输出]]。多数实现还提供<code>current-error-port</code>。标准通过标准过程比如<code>with-input-from-file</code>和<code>with-output-to-file</code>，支持输入和标准输出的[[重定向_(计算机)|重定向]]。多数实现提供有重定向能力的字符串端口，使用在SRFI 6中描述的过程<ref name="srfi-6">{{cite web |publisher=The SRFI Editors, schemers.org |author=William D Clinger |date=1999-07-01 |title=SRFI 6: Basic String Ports |url=http://srfi.schemers.org/srfi-6/srfi-6.html |access-date=2012-08-09 |archive-date=2021-10-21 |archive-url=https://web.archive.org/web/20211021131859/https://srfi.schemers.org/srfi-6/srfi-6.html }}</ref>，确使很多常规的输入-输出运算能在字符串缓冲区上进行而非在文件上。R<sup>6</sup>RS标准规定了更多复杂和有能力的端口过程和很多新的端口类型。

下面的例子是使用严格的R<sup>5</sup>RS Scheme书写的。

例子1，缺省输出到<code>current-output-port</code>：
<syntaxhighlight lang="Scheme">
(let ((hello0 (lambda() (display "Hello world") (newline))))
  (hello0))
</syntaxhighlight>

例子2，类似例子1但对输出过程使用可选的端口参数的例子：
<syntaxhighlight lang="Scheme">
(let ((hello1 (lambda (p) (display "Hello world" p) (newline p))))
  (hello1 (current-output-port)))
</syntaxhighlight>

类似例子1，但是输出被重定向到一个新建文件：
<syntaxhighlight lang="Scheme">
;; NB: with-output-to-file is an optional procedure in R5RS
(let ((hello0 (lambda () (display "Hello world") (newline))))
  (with-output-to-file "helloworldoutputfile" hello0))
</syntaxhighlight>
类似例子2，但是具有显式的文件打开和端口关闭来发送输出到文件：
<syntaxhighlight lang="Scheme">
(let ((hello1 (lambda (p) (display "Hello world" p) (newline p)))
      (output-port (open-output-file "helloworldoutputfile")))
  (hello1 output-port)
  (close-output-port output-port))
</syntaxhighlight>

类似例子2，但是使用<code>call-with-output-file</code>来发送输出到一个文件：
<syntaxhighlight lang="Scheme">
(let ((hello1 (lambda (p) (display "Hello world" p) (newline p))))
  (call-with-output-file "helloworldoutputfile" hello1))
</syntaxhighlight>

对输入提供了类似的过程。R<sup>5</sup>RS Scheme提供了谓词<code>input-port?</code>和<code>output-port?</code>。对于字符输入和输出提供了<code>write-char</code>、<code>read-char</code>、<code>peek-char</code>和<code>char-ready?</code>。为了书写和阅读Scheme表达式，Scheme提供了<code>read</code>和<code>write</code>。在读运算时，如果输入端口到达了文件的结束处，则返回的结果是<code>end-of-file</code>对象，并且这可以使用谓词<code>eof-object?</code>来测试。

除了标准之外，SRFI 28定义了一个基本的格式化过程，类似Common Lisp的<code>format</code>并以此命名<ref name="srfi-28">{{cite web |publisher=The SRFI Editors, schemers.org |author=Scott G. Miller |date=2002-06-25 |title=SRFI 28: Basic Format Strings |url=http://srfi.schemers.org/srfi-28/srfi-28.html |access-date=2012-08-09 |archive-date=2022-05-08 |archive-url=https://web.archive.org/web/20220508131437/https://srfi.schemers.org/srfi-28/srfi-28.html }}</ref>。

===标准过程的重定义===
在Scheme中，过程被绑定到变量<ref name="binding" />。在R<sup>5</sup>RS中语言标准正式的授权编程者可以变更内建过程的变量绑定，在效果上重定义它们（R<sup>5</sup>RS "Language changes"）<ref name="r5rs"/>。例如，通过重定义<code>+</code>可以将它扩展为同接受数一样接受字符串：

<syntaxhighlight lang="Scheme">
(set! +
      (let ((original+ +))
        (lambda args
          (apply (if (or (null? args) (string? (car args)))
                     string-append
                     original+)
                 args))))
(+ 1 2 3)
===> 6
(+ "1" "2" "3")
===> "123"
</syntaxhighlight>

在R<sup>6</sup>RS中所有绑定，包括标准过程，都属于某个库，并且所有导出的绑定都是不可变的（R<sup>6</sup>RS sec 7.1）<ref name="r6rs"/>。因此，禁止通过变更进行标准过程的重定义。转而，可以在标准过程的名字下导入不同的过程，这在效果上类似于重定义。

==标准形式和过程概述==
Scheme语言正式的定义在标准R<sup>5</sup>RS（1998年）和R<sup>6</sup>RS（2007年）之中。它们描述了标准“形式”，即关键字和随同的语法，它们提供语言的控制结构，和执行通常任务的标准过程。

在标准Scheme中，从一个数据类型转换到另一个数据类型的过程，在它们的名字中包含字符串<code>-></code>，谓词结束于一个<code>?</code>，而改变已经分配了数据的值的过程结束于一个<code>!</code>。Scheme编程者通常跟从这些[[命名规则|命名约定]]。

===标准形式===
本表格描述Scheme中的标准形式。某些形式出现在不止一行之中，因为它们不能被轻易的归类入语言中的一个单一功能。

在表格中标记了“L”的形式被归类为标准中的派生的“库”形式，并且在实践中通常被实现为使用了更基础形式的宏，这使得实现任务比在其他语言中要容易许多。
{| class="wikitable"
|+ R5RS Scheme语言中的标准形式
! 用途                !!   形式
|-
| 定义             || {{mono|define}}
|-
| 绑定构造     || {{mono|lambda, do (L), let (L), let* (L), letrec (L)}}
|-
| 条件求值 || {{mono|if, cond (L), case (L), and (L), or (L)}}
|-
| 顺序求值  || {{mono|begin (*)}}
|-
| 迭代              || {{mono|lambda, do (L), named let (L)}}
|-
| 语法扩展    || {{mono|define-syntax, let-syntax, letrec-syntax, syntax-rules (R5RS), syntax-case (R6RS)}}
|-
| 引述                || {{mono|quote('), unquote(,), quasiquote(`), unquote-splicing(,@)}}
|-
| 赋值             || {{mono|set!}}
|-
| 延迟求值     || {{mono|delay (L)}}
|}

注意<code>begin</code>在R<sup>5</sup>RS中被定义为库语法，但是展开者需要知道它来完成分片功能。在R<sup>6</sup>RS中它不再是库语法。

===标准过程===

下面两个表格描述在R<sup>5</sup>RS Scheme中的标准过程。R<sup>6</sup>RS更加具有可扩展性而如此总结是不实际的。

某些过程出现在不止一行之中，因为它们不能轻易的分类入语言的一个单一功能。
{| class="wikitable"
|+ R<sup>5</sup>RS Scheme语言中的标准过程
! 用途 !! 过程
|-
| 构造    || {{mono|vector, make-vector, make-string, list}}
|-
| 等价谓词 || {{mono|1=eq?, eqv?, equal?, string=?, string-ci=?, char=?, char-ci=?}}
|-
| 类型转换 || {{mono|vector->list, list->vector, number->string, string->number, symbol->string, string->symbol, char->integer, integer->char, string->list, list->string}}
|-
| 数值         || {{mono|参见独立表格}}
|-
| 字符串         || {{mono|1=string?, make-string, string, string-length, string-ref, string-set!, string=?, string-ci=?, string<? string-ci<?, string<=? string-ci<=?, string>? string-ci>?, string>=? string-ci>=?, substring, string-append, string->list, list->string, string-copy, string-fill!}}
|-
| 字符      || {{mono|1=char?, char=?, char-ci=?, char<? char-ci<?, char<=? char-ci<=?, char>? char-ci>?, char>=? char-ci>=?, char-alphabetic?, char-numeric?, char-whitespace?, char-upper-case?, char-lower-case?, char->integer, integer->char, char-upcase, char-downcase}}
|-
| 向量         || {{mono|make-vector, vector, vector?, vector-length, vector-ref, vector-set!, vector->list, list->vector, vector-fill!}}
|-
| 符号         || {{mono|symbol->string, string->symbol, symbol?}}
|-
| 有序对和列表 || {{mono|pair?, cons, car, cdr, set-car!, set-cdr!, null?, list?, list, length, append, reverse, list-tail, list-ref, memq. memv. member, assq, assv, assoc, list->vector, vector->list, list->string, string->list}}
|-
| 识别谓词 || {{mono|boolean?, pair?, symbol?, number?, char?, string?, vector?, port?, procedure?}}
|-
| 续体   || {{mono|call-with-current-continuation (call/cc), values, call-with-values, dynamic-wind}}
|-
| 环境    || {{mono|eval, scheme-report-environment, null-environment, interaction-environment (可选)}}
|-
| 输入/输出    || {{mono|display, newline, read, write, read-char, write-char, peek-char, char-ready?, eof-object? open-input-file, open-output-file, close-input-port, close-output-port, input-port?, output-port?, current-input-port, current-output-port, call-with-input-file, call-with-output-file, with-input-from-file(可选), with-output-to-file(可选)}}
|-
| 系统接口 || {{mono|load (可选), transcript-on (可选), transcript-off (可选)}}
|-
| 延迟求值 || {{mono|force}}
|-
| 函数式编程 || {{mono|procedure?, apply, map, for-each}}
|-
| 布尔逻辑        || {{mono|boolean? not}}
|}

在其名字中包含<code>-ci</code>的字符串和字符过程，在它们的实际参数之间进行不依赖大小写的比较：相同字符的大写和小写版本被认为是相等的。

{| class="wikitable"
|+ R5RS Scheme语言中的标准数值过程
! 用途 !! 过程
|-
| 基本算术算符 || {{mono|+, -, *, /, abs, quotient, remainder, modulo, gcd, lcm, expt, sqrt}}
|-
| 有理数 || {{mono|numerator, denominator, rational?, rationalize}}
|-
| 近似    || {{mono|floor, ceiling, truncate, round}}
|-
| 精确性        || {{mono|inexact->exact, exact->inexact, exact?, inexact?}}
|-
| 不等式     || {{mono|1=<, <= , >, >=, =}}
|-
| 杂项谓词 || {{mono|zero?, negative?, positive? odd? even?}}
|-
| 极大和极小 || {{mono|max, min}}
|-
| 三角     || {{mono|sin, cos, tan, asin, acos, atan}}
|-
| 指数     || {{mono|exp, log}}
|-
| 复数  || {{mono|make-rectangular, make-polar, real-part, imag-part, magnitude, angle, complex?}}
|-
| 输入-输出     || {{mono|number->string, string->number}}
|-
| 类型谓词  || {{mono|integer?, rational?, real?, complex?, number?}}
|}

接受多于一个实际参数的<code>-</code>和<code>/</code>在R<sup>5</sup>RS中被定义了但留作为可选的。

== Scheme实现要求 ==
{{Main|{{en-link|Scheme实现要求|Scheme Requests for Implementation}}}}
由于Scheme的极简主义，很多常见过程和语法形式不是由标准定义的。 为了保持核心语言很小并促进扩展的标准化，Scheme社群拥有“Scheme实现要求”（SRFI）流程，通过对扩展提案的仔细研讨来定义扩展库。这提升了代码可移植性。很多SRFI被几乎所有Scheme实现支持。

在不同的实现中具有相当广泛支持的SRFI包括<ref name="srfi_support">{{cite web |publisher=The SRFI Editors, schemers.org |date=2009-08-30 |url=http://srfi.schemers.org/srfi-implementers.html |title=Scheme Systems Supporting SRFIs |access-date=2012-08-09 |archive-date=2021-06-20 |archive-url=https://web.archive.org/web/20210620154132/https://srfi.schemers.org/srfi-implementers.html }}</ref>：
{{div col|colwidth=20em}}
* 0: 基于特征的条件展开构造
* 1: 列表库
* 4: 同构数值向量数据类型
* 6: 基本字符串端口
* 8: 接收、绑定到多个值
* 9: 定义记录类型
* 13: 字符串库
* 14: 字符集库
* 16: 可变[[元数|元数]]过程的语法
* 17: 广义<code>set!</code>
* 18: 多线程支持
* 19: 时间数据类型和过程
* 25: 多维数组原语
* 26: 不用[[柯里化|柯里化]]的特殊化形式参数的表示法
* 27: 随机数位的来源
* 28: 基本格式化字符串
* 29: [[国际化与本地化|本地化]]
* 30: 嵌套的多行注释
* 31: 递归求值的特殊形式
* 37: <code>args-fold</code>：程序实际参数处理器
* 39: 形式参数对象
* 41: [[字串流|串流]]
* 42: [[列表推导式|及早推导式]]
* 43: 向量库
* 45: 表达迭代式惰性算法的原语
* 60: 作为位元的整数
* 61: 更一般性的<code>cond</code>子句
* 66: [[八位组|八位组]]向量
* 67: 比较过程
{{div col end}}

==實作==
Scheme的精簡設計，使得程式語言設計人士與愛好者，特別鍾愛研究它的實作，很多嵌入式系統語言與腳本語言，即是基於Scheme。Scheme的實作一般小而精簡，造成了很多不可互通的實作互相競爭。儘管Scheme的精簡性是它的一個主要長處<ref name="scheme_implementations">75 known implementations of Scheme are listed by {{cite web |publisher=Community Scheme Wiki |url=http://community.schemewiki.org/?scheme-faq-standards#implementations |title=scheme-faq-standards |date=2009-06-25 |access-date=2009-10-20 |archive-date=2010-02-18 |archive-url=https://web.archive.org/web/20100218031914/http://community.schemewiki.org/?scheme-faq-standards#implementations }}</ref>，但试图使用Scheme编写既复杂又便于移植的程序，往往比较困难<ref name="position_paper" />，主要原因之一，是因为Scheme没有库函数标准。而R<sup>6</sup>RS试图完成这样的工作，它定义了两套标准，核心语言以及标准库。这使得Scheme第一次有了库函数标准，也使得编译器开发者和贡献者可以实现Scheme的可移植库。

幾乎所有Scheme實作都是基於Lisp的「[[讀取﹣求值﹣輸出循環|讀取﹣求值﹣輸出循環]]」模式。一些Scheme實作亦可作為編譯器，並將Scheme程式譯為二進制碼。很多用類似[[C語言|C]]的基礎語言寫成的軟體，都利用Scheme作為腳本語言。還有一些Scheme解釋器，比如[[Gambit_(Scheme实现)|Gambit]]、[[Chicken_(Scheme)|Chicken]]和{{en-link|Bigloo}}，可將Scheme程式譯為[[C語言|C]]或[[Java虚拟机|JVM]][[字节码|字节码]]，甚至是[[.Net|.Net]]字节码。

一些实现支持额外的特征。比如{{en-link|Kawa (Scheme实现)|Kawa (Scheme implementation)|Kawa}}和[[JScheme|JScheme]]提供与Java类的集成，而Scheme到C编译器通常易于使用C写成的外部库，甚至允许将实际C代码嵌入到Scheme源代码中。另一个例子是{{en-link|Pvts}}，它提供了支持Scheme学习的一组可视工具。

最基本的Scheme實作是在《[[計算機程序的構造和解釋|-{zh-hans:计算机程序的构造和解释;zh-hant:電腦程式的構造和解釋}-]]》中實現的[[自循環直譯器|自循環直譯器]]。這一直譯器以Scheme寫成，並利用底層的Scheme功能，來實現被執行的Scheme語言程式。由於要想運行自循環直譯器，電腦中必須已經存在一個Scheme直譯器，在實際上這一直譯器的意義不大，然而它簡單的語法可以幫助使用者理解Scheme的執行過程。

==教科書==
* 《[[計算機程序的構造和解釋|-{zh-hans:计算机程序的构造和解释;zh-hant:電腦程式的構造和解釋}-]]》（SICP）是最著名的使用Scheme語言的電腦科學教科書，由Scheme創始人之一薩斯曼與Harold Abelson編寫。
* 《[[程序设计方法|-{zh-hans:程序设计方法;zh-hant:程式設計方法}-]]》對SICP中的一些被認為過於艱澀的概念進行了改進，由Felleison等人編寫。
* 《{{en-link|编程语言的本质|Essentials of Programming Languages}}》，以Scheme为基础的教科书，由[[丹尼尔·福瑞得曼|丹尼尔·福瑞得曼]]等人编写。
* 《简单的Scheme：介绍计算机科学》<ref>{{cite web|title=Simply Scheme: Introducing Computer Science|author=Brian Harvey, Matthew Wright|url=https://people.eecs.berkeley.edu/~bh/ss-toc2.html|year=1999|access-date=2021-11-07|archive-date=2022-05-04|archive-url=https://web.archive.org/web/20220504020303/https://people.eecs.berkeley.edu/~bh/ss-toc2.html}}</ref>，是一本專為中學級別，無電腦科學基礎的學生編寫的入門書，由[[柏克萊加州大學|柏克萊加州大學]]資深講師[[布萊恩·哈維|布萊恩·哈維]]編寫。

==實際用處==
很多著名的[[電腦科學|電腦科學]]院校都利用Scheme來教授入門級課程。以下為一些最為著名的教授Scheme的學校：
{{div col|2}}
* [[麻省理工學院|麻省理工學院]]是Scheme與[[SICP|SICP]]的誕生地。直到2008年為止，麻省理工學院的入門課程6.001即是用Scheme來教授的<ref name="6.001">{{cite web
| publisher = MIT Open Courseware
| author = Eric Grimson
| url = http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-001Spring-2005/CourseHome/index.htm
| title = 6.001 Structure and Interpretation of Computer Programs
| date = Spring 2005
| accessdate = 2009-10-20
| archive-date = 2009-10-01
| archive-url = https://web.archive.org/web/20091001054613/http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-001Spring-2005/CourseHome/index.htm
| dead-url = no
}}</ref>。儘管現在Scheme已經不再被用於入門課程，麻省理工學院到目前為止還在教授SICP<ref name="6.001_zombies">{{cite web
| publisher = MIT CSAIL
| author = Alex Vandiver, Nelson Elhage, et al
| title = 6.184 - Zombies drink caffeinated 6.001
| url = http://web.mit.edu/alexmv/6.001/
| date = January 2009
| accessdate = 2009-10-20
| archive-date = 2009-08-28
| archive-url = https://web.archive.org/web/20090828031234/http://web.mit.edu/alexmv/6.001/
| dead-url = no
}}</ref>。
* [[柏克萊加州大學|柏克萊加州大學]]的入門課程61A到2010年為止利用Scheme與SICP教授入門課程，並利用Scheme來實作[[Logo语言|Logo]]，另一個基於[[Lisp|Lisp]]的程式語言<ref>{{cite web
| publisher = UC Berkeley Webcasts
| author = Brian Harvey
| title = CS 61A Structure and Interpretation of Computer Programs
| date = Spring 2011
| url = http://webcast.berkeley.edu/playlist#c,d,Computer_Science,3E89002AA9B9879E
| accessdate = 2011-12-18
| deadurl = yes
| archiveurl = http://arquivo.pt/wayback/20160316073714/http://webcast.berkeley.edu/playlist#c,d,Computer_Science,3E89002AA9B9879E
| archivedate = 2016-03-16
}}</ref>。自2011年起，61A改用[[Python|Python]]來教授SICP<ref>{{cite web
| publisher = UC Berkeley
| author = John DeNero
| title = CS 61A Structure and Interpretation of Computer Programs
| date = Fall 2011
| url = http://inst.eecs.berkeley.edu/~cs61a/fa11/61a-python/content/www/about.html
| accessdate = 2011-12-18
| archive-date = 2011-12-29
| archive-url = https://web.archive.org/web/20111229054711/http://inst.eecs.berkeley.edu/~cs61a/fa11/61a-python/content/www/about.html
| dead-url = no
}}</ref>。
* [[西北大学_(伊利诺伊州)|西北大學]]的入門課程CS2500利用Scheme來教授另一本著名的教材《[[程序设计方法|-{zh-hans:程序设计方法;zh-hant:程式設計方法}-]]》。
* [[印第安那大學|印第安那大學]]的入門課程C211利用Scheme來教授。
* [[耶魯大學|耶魯大學]]
* [[萊斯大學|萊斯大學]]
* [[香港科技大學|香港科技大學]]
* [[北京大學|北京大學]]
* {{link-en|ProgramByDesign|ProgramByDesign}}項目在美國超過600所高中教授Scheme語言。
* [[滑铁卢大学|滑铁卢大学]]数学系（包括计算机科学系）的入門課程CS115、CS116、CS135利用Scheme來教授。
* [[雲林科技大學|雲林科技大學]]
{{div col end}}

[[自由軟體|自由軟體]]影像處理程式[[GIMP|GIMP]]利用Scheme為嵌入式脚本語言<ref>{{cite web
|author=Dov Grobgeld
|publisher=The GIMP Team
|title=The GIMP Basic Scheme Tutorial
|url=http://www.gimp.org/tutorials/Basic_Scheme/
|year=2002
|accessdate=2009-10-20
|archive-date=2010-01-24
|archive-url=https://web.archive.org/web/20100124165216/http://www.gimp.org/tutorials/Basic_Scheme/
|dead-url=no
}}</ref>。[[GNU|GNU]]的扩展語言[[GNU_Guile|Guile]]是一个Scheme的实现，[[GNOME|GNOME]]中有到核心库的一个Guile包装器<ref name="live_gnome">{{cite web
|publisher=Free Software Foundation
|url=http://www.gnu.org/software/guile-gnome/
|title=guile-gnome
|date=
|accessdate=2009-10-20
|archive-date=2016-03-04
|archive-url=https://web.archive.org/web/20160304041955/http://www.gnu.org/software/guile-gnome/
|dead-url=no
}}</ref> 。

== 参见 ==
*[[LISP|LISP]]
*[[Racket|Racket]]

==註釋==
{{reflist|2}}

== 延伸阅读 ==
* {{cite web |author=[[Guy_L._Steele_Jr.|Guy L. Steele Jr.]], {{en-link|Richard P. Gabriel}} |title=The Evolution of Lisp |url=http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=025DEBBA2F21953AA2D2FB245EA0F25D?doi=10.1.1.49.7238&rep=rep1&type=pdf }}

== 外部链接 ==
*{{Wikibooks-inline|Scheme Programming}}
*{{Wikibooks-inline|Write Yourself a Scheme in 48 Hours}}
*{{Commons category-inline|Scheme (programming language)}}
*[https://github.com/schemedoc/awesome-scheme Awesome Scheme] {{Wayback|url=https://github.com/schemedoc/awesome-scheme |date=20220418023718 }}
*[https://lips.js.org/#bookmark Bookmarklet that add Interactive Scheme REPL to any website] {{Wayback|url=https://lips.js.org/#bookmark |date=20220423041834 }}
*[https://www.scheme.com/tspl4/ The Scheme programming language 4rd edition] {{Wayback|url=https://www.scheme.com/tspl4/ |date=20220324083744 }}

{{Lisp programming language}}
{{程序设计语言|Logo}}

[[Category:动态类型编程语言|Category:动态类型编程语言]]
[[Category:学术的编程语言|Category:学术的编程语言]]
[[Category:LISP程式語言家族|Category:LISP程式語言家族]]
[[Category:Scheme語言|]]
[[Category:1975年建立的程式語言|Category:1975年建立的程式語言]]