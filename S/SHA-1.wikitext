{{noteTA
|G1=IT
}}
{{Infobox encryption method
| name           = SHA-1
| image          = 
| caption        = 
<!-- General -->
| designers      = [[美国国家安全局|美国国家安全局]]
| publish date   = 1993年（SHA-0）<br />1995年（SHA-1）
| series         = [[安全散列算法|安全散列算法]]家族
| derived from   = 
| derived to     = 
| related to     = 
| certification  = [[聯邦資料處理標準|FIPS]] PUB 180-4，{{link-en|CRYPTREC|CRYPTREC}}（监测）
<!-- Detail -->
| digest size    = 160位元
| block size     = 512位元
| structure      = {{link-en|Merkle–Damgård结构|Merkle–Damgård construction}}
| rounds         = 80
| cryptanalysis  = 2011年，Marc Stevens的攻击，可以通过复杂度2<sup>60.3</sup>至2<sup>65.3</sup>的操作产生散列碰撞。<ref name="stevens-attacks">{{Cite thesis|last1=Stevens|first1=Marc|author-link1=Marc Stevens (cryptology)|title=Attacks on Hash Functions and Applications|url=https://marc-stevens.nl/research/papers/PhD%20Thesis%20Marc%20Stevens%20-%20Attacks%20on%20Hash%20Functions%20and%20Applications.pdf|date=2012-06-19|publisher=[[Leiden_University|Leiden University]]|isbn=9789461913173|oclc=795702954|hdl=1887/19093|access-date=2016-12-15|archive-date=2017-03-18|archive-url=https://web.archive.org/web/20170318045625/http://marc-stevens.nl/research/papers/PhD%20Thesis%20Marc%20Stevens%20-%20Attacks%20on%20Hash%20Functions%20and%20Applications.pdf|dead-url=no}}</ref>2017年2月23日，首次公开碰撞。<ref name="sha1-shattered">{{Cite conference|date=2017|last1=Stevens|first1=Marc|author-link1=Marc Stevens (cryptology)|last2=Bursztein|first2=Elie|author-link2=Elie Bursztein|last3=Karpman|first3=Pierre|last4=Albertini|first4=Ange|last5=Markov|first5=Yarik|editor-last=Katz|editor-first=Jonathan|editor-link1=Jonathan Katz (computer_scientist)|editor2-last=Shacham|editor2-first=Hovav|title=The First Collision for Full SHA-1|url=https://shattered.io/static/shattered.pdf|conference=Advances in Cryptology – [[International_Cryptology_Conference|CRYPTO]] 2017. [[Lecture_Notes_in_Computer_Science|Lecture Notes in Computer Science]]|publisher=[[Springer_Publishing|Springer]]|volume=10401|pages=570–596|doi=10.1007/978-3-319-63688-7_19|isbn=9783319636870|lay-url=https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html|lay-source=Google Security Blog|lay-date=2017-02-23|access-date=2017-02-23|archive-url=https://web.archive.org/web/20180515222208/http://shattered.io/static/shattered.pdf|archive-date=2018-05-15|url-status=dead}}</ref>SHA-1容易受到[[长度扩展攻击|长度扩展攻击]]。
}}
'''SHA-1'''（{{lang-en|Secure Hash Algorithm 1}}，中文名：安全散列算法1）是一种[[密码散列函数|密码散列函数]]，[[美国国家安全局|美国国家安全局]]设计，并由美国[[國家標準技術研究所|國家標準技術研究所]]（NIST）发布为[[聯邦資料處理標準|聯邦資料處理標準]]（FIPS）<ref name=":0">{{Cite web |url=http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf |title=存档副本 |accessdate=2016-12-15 |archive-date=2013-02-17 |archive-url=https://web.archive.org/web/20130217190337/http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf |dead-url=no }}</ref>。SHA-1可以生成一个被称为消息摘要的160[[位|位]]（20[[字节|字节]]）散列值，散列值通常的呈现形式为40个[[十六进制|十六进制]]数。

2005年，密码分析人员发现了对SHA-1的有效攻击方法，这表明该算法可能不够安全，不能继续使用<ref>{{cite web |url=https://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html |title=Schneier on Security: Cryptanalysis of SHA-1 |date=2005-02-18 |author=Schneier, Bruce |accessdate=2016-12-15 |archive-date=2017-04-14 |archive-url=https://web.archive.org/web/20170414014546/https://www.schneier.com/blog/archives/2005/02/cryptanalysis_o.html |dead-url=yes }}</ref>，自2010年以来，许多组织建议用[[SHA-2|SHA-2]]或[[SHA-3|SHA-3]]来替换SHA-1<ref>{{cite web|url=http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html|title=NIST.gov - Computer Security Division - Computer Security Resource Center|publisher=|access-date=2016-12-15|archive-url=https://web.archive.org/web/20170429171739/http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html|archive-date=2017-04-29|dead-url=yes}}</ref><ref name="shappening">{{cite web |url=https://sites.google.com/site/itstheshappening/ |title=The SHAppening: freestart collisions for SHA-1 |accessdate=2015-10-09 |first1=Marc |last1=Stevens1 |first2=Pierre |last2=Karpman |first3=Thomas |last3=Peyrin |archive-date=2017-04-19 |archive-url=https://web.archive.org/web/20170419214146/https://sites.google.com/site/itstheshappening/ |dead-url=no }}</ref><ref>{{cite web |url=https://www.schneier.com/blog/archives/2015/10/sha-1_freestart.html |author=Bruce Schneier |date=2015-10-08 |title=SHA-1 Freestart Collision |work=Schneier on Security |accessdate=2016-12-15 |archive-date=2017-01-28 |archive-url=https://web.archive.org/web/20170128161324/https://www.schneier.com/blog/archives/2015/10/sha-1_freestart.html |dead-url=no }}</ref>。[[Microsoft|Microsoft]]<ref>{{cite web | url=http://social.technet.microsoft.com/wiki/contents/articles/32288.windows-enforcement-of-authenticode-code-signing-and-timestamping.aspx | title=Windows Enforcement of Authenticode Code Signing and Timestamping | publisher=Microsoft | date=2015-09-24 | accessdate=2016-08-07 | archive-date=2016-10-05 | archive-url=https://web.archive.org/web/20161005030712/http://social.technet.microsoft.com/wiki/contents/articles/32288.windows-enforcement-of-authenticode-code-signing-and-timestamping.aspx | dead-url=no }}</ref>、[[Google|Google]]<ref>{{cite web | url=https://groups.google.com/a/chromium.org/d/msg/blink-dev/2-R4XziFc7A/i_JipRRJoDQJ | title=Intent to Deprecate: SHA-1 certificates | publisher=Google | date=2014-09-03 | accessdate=2014-09-04 }}{{Dead link}}</ref>以及[[Mozilla|Mozilla]]<ref>{{cite web | url=https://bugzilla.mozilla.org/show_bug.cgi?id=942515 | title=Bug 942515 - stop accepting SHA-1-based SSL certificates with notBefore >= 2014-03-01 and notAfter >= 2017-01-01, or any SHA-1-based SSL certificates after 2017-01-01 | publisher=Mozilla | accessdate=2014-09-04 | archive-date=2014-09-07 | archive-url=https://web.archive.org/web/20140907232215/https://bugzilla.mozilla.org/show_bug.cgi?id=942515 | dead-url=yes }}</ref><ref>{{cite web | url=https://wiki.mozilla.org/CA:Problematic_Practices#SHA-1_Certificates | title=CA:Problematic Practices - MozillaWiki | publisher=Mozilla | accessdate=2014-09-09 | archive-date=2017-05-06 | archive-url=https://web.archive.org/web/20170506120546/https://wiki.mozilla.org/CA:Problematic_Practices#SHA-1_Certificates | dead-url=no }}</ref><ref>{{cite web | url=https://blog.mozilla.org/security/2014/09/23/phasing-out-certificates-with-sha-1-based-signature-algorithms/ | title=Phasing Out Certificates with SHA-1 based Signature Algorithms | Mozilla Security Blog | publisher=Mozilla | date=2014-09-23 | accessdate=2014-09-24 | archive-date=2017-04-25 | archive-url=https://web.archive.org/web/20170425124953/https://blog.mozilla.org/security/2014/09/23/phasing-out-certificates-with-sha-1-based-signature-algorithms/ | dead-url=yes }}</ref>都宣布，它们旗下的浏览器将在2017年停止接受使用SHA-1算法签名的[[電子證書|SSL证书]]。

2017年2月23日，{{tsl|en|CWI Amsterdam}}与[[Google|Google]]宣布了一个成功的SHA-1{{tsl|en|Collision_attack|碰撞攻击}}<ref>{{Cite news|url=https://phys.org/news/2017-02-cwi-google-collision-industry-standard.html|title=CWI, Google announce first collision for Industry Security Standard SHA-1|access-date=2017-02-23|archive-date=2017-02-23|archive-url=https://web.archive.org/web/20170223190138/https://phys.org/news/2017-02-cwi-google-collision-industry-standard.html|dead-url=no}}</ref><ref name=googleblog>{{Cite blog|url=https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html|title=Announcing the first SHA1 collision|date=2017-02-23|access-date=|website=Google Online Security Blog|archive-date=2017-04-24|archive-url=https://web.archive.org/web/20170424012912/https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html|dead-url=no}}</ref>，发布了两份内容不同但SHA-1散列值相同的[[PDF|PDF]]文件作为概念证明。<ref>{{cite web | url=https://shattered.io/ | title=SHAttered | accessdate=2017-02-23 | archive-date=2017-04-12 | archive-url=https://web.archive.org/web/20170412182136/http://shattered.io/ | dead-url=yes }}</ref>

2020年，針對SHA-1的选择前缀冲突攻击已經實際可行。建議盡可能用[[SHA-2|SHA-2]]或[[SHA-3|SHA-3]]取代[[SHA-1|SHA-1]]。<ref name="#1">{{Cite web |url=https://eprint.iacr.org/2020/014.pdf |title=存档副本 |accessdate=2020-09-09 |archive-date=2020-09-10 |archive-url=https://web.archive.org/web/20200910135053/https://eprint.iacr.org/2020/014.pdf |dead-url=no }}</ref><ref name="#2">{{Cite web|title=Critical flaw demonstrated in common digital security algorithm|url=https://media.ntu.edu.sg:443/NewsReleases/Pages/newsdetail.aspx?news=ffbd7ab8-233f-42e2-9107-da8dbe784aae|accessdate=2020-09-08|work=media.ntu.edu.sg|language=en-US|archive-date=2020-04-19|archive-url=https://web.archive.org/web/20200419222030/https://media.ntu.edu.sg/NewsReleases/Pages/newsdetail.aspx?news=ffbd7ab8-233f-42e2-9107-da8dbe784aae|dead-url=no}}</ref>

== SHA-0和SHA-1 ==
[[File:SHA-1.svg|thumbnail]]

最初載明的演算法於1993年發佈，稱做安全雜湊標準（Secure Hash Standard），[[联邦资料处理标准|FIPS]] PUB 180。這個版本現在常被稱為SHA-0。它在發佈之後很快就被NSA撤回，並且由1995年發佈的修訂版本FIPS PUB 180-1（通常稱為SHA-1）取代。SHA-1和SHA-0的演算法只在壓縮函數的訊息轉換部份差了一個位元的循環位移。根據NSA的說法，它修正了一個在原始演算法中會降低雜湊安全性的弱點。然而NSA並沒有提供任何進一步的解釋或證明該弱點已被修正。而後SHA-0和SHA-1的弱點相繼被攻破，SHA-1似乎是顯得比SHA-0有抵抗性，這多少證實了NSA當初修正演算法以增進安全性的聲明。

SHA-0和SHA-1可將一個最大2<sup>64</sup>位元的訊息，轉換成一串160位元的訊息摘要；其設計原理相似於MIT教授[[Ron_Rivest|Ronald L. Rivest]]所設計的密碼學雜湊演算法[[MD4|MD4]]和[[MD5|MD5]]。
=== SHA-0的破解 ===
在[[CRYPTO|CRYPTO]] 98上，兩位法國研究者提出一種對SHA-0的攻擊方式<ref>Chabaud and Joux, 1998</ref>：在2<sup>61</sup>的計算複雜度之內，就可以發現一次碰撞（即兩個不同的訊息對應到相同的訊息摘要）；這個數字小於[[生日攻擊|生日攻擊法]]所需的2<sup>80</sup>，也就是說，存在一種演算法，使其安全性不到一個理想的雜湊函數抵抗攻擊所應具備的計算複雜度。

2004年時，[[Eli_Biham|Biham]]和Chen也發現了SHA-0的近似碰撞，也就是兩個訊息可以雜湊出幾乎相同的數值；其中162位元中有142位元相同。他們也發現了SHA-0的完整碰撞（相對於近似碰撞），將本來需要80次方的複雜度降低到62次方。

2004年8月12日，Joux, Carribault, Lemuet和Jalby宣佈找到SHA-0演算法的完整碰撞的方法，這是歸納Chabaud和Joux的攻擊所完成的結果。發現一個完整碰撞只需要2<sup>51</sup>的計算複雜度。他們使用的是一台有256顆[[Itanium#Itanium2|Itanium2]]處理器的[[超級電腦|超級電腦]]，約耗80,000 CPU工時。

2004年8月17日，在[[CRYPTO|CRYPTO]] 2004的Rump會議上，[[王小雲|王小雲]]，[[馮登國|馮登國]]（Feng）、[[來學嘉|來學嘉]]（Lai），和[[于紅波|于紅波]]（Yu）宣佈了攻擊[[MD5|MD5]]、SHA-0和其他[[雜湊函數|雜湊函數]]的初步結果。他們攻擊SHA-0的計算複雜度是2<sup>40</sup>，這意味的他們的攻擊成果比Joux還有其他人所做的更好。請參見[[MD5#Security|MD5安全性]]。

2005年二月，[[王小雲|王小雲]]和[[殷益群|殷益群]]、[[于紅波|于紅波]]再度發表了對SHA-0破密的演算法，可在2<sup>39</sup>的計算複雜度內就找到碰撞。

=== SHA-1的破解 ===
鑒於SHA-0的破密成果，專家們建議那些計劃利用SHA-1實作密碼系統的人們也應重新考慮。在2004年[[CRYPTO|CRYPTO]]會議結果公佈之後，NIST即宣布他們將逐漸減少使用SHA-1，改以SHA-2取而代之。

2005年，[[Rijmen|Rijmen]]和[[Oswald|Oswald]]發表了對SHA-1較弱版本（53次的加密迴圈而非80次）的攻擊：在2<sup>80</sup>的計算複雜度之內找到碰撞。

2005年二月，[[王小雲|王小雲]]、[[殷益群|殷益群]]及[[于紅波|于紅波]]發表了對完整版SHA-1的攻擊，只需少於2<sup>69</sup>的計算複雜度，就能找到一組碰撞。（利用[[生日攻擊|生日攻擊法]]找到碰撞需要2<sup>80</sup>的計算複雜度。）

這篇論文的作者們寫道；「我們的破密分析是以對付SHA-0的[[差分攻擊|差分攻擊]]、近似碰撞、多區塊碰撞技術、以及從[[MD5|MD5]]演算法中尋找碰撞的訊息更改技術為基礎。沒有這些強力的分析工具，SHA-1就無法破解。」此外，作者還展示了一次對58次加密迴圈SHA-1的破密，在2<sup>33</sup>個單位操作內就找到一組碰撞。完整攻擊方法的論文發表在2005年八月的[[CRYPTO|CRYPTO]]會議中。

殷益群在一次面談中如此陳述：「大致上來說，我們找到了兩個弱點：其一是前置處理不夠複雜；其二是前20個迴圈中的某些數學運算會造成不可預期的安全性問題。」

2005年8月17日的[[CRYPTO|CRYPTO]]會議尾聲中[[王小雲|王小雲]]、[[姚期智|姚期智]]、[[姚儲楓|姚儲楓]]再度發表更有效率的SHA-1攻擊法，能在2<sup>63</sup>個計算複雜度內找到碰撞。

2006年的[[CRYPTO|CRYPTO]]會議上，[[Christian_Rechberger|Christian Rechberger]]和[[Christophe_De_Cannière|Christophe De Cannière]]宣布他們能在容許攻擊者決定部分原訊息的條件之下，找到SHA-1的一個碰撞。

在密碼學的學術理論中，任何攻擊方式，其計算複雜度若少於暴力搜尋法所需要的計算複雜度，就能被視為針對該密碼系統的一種破密法；但這並不表示該破密法已經可以進入實際應用的階段。

就應用層面的考量而言，一種新的破密法出現，暗示着將來可能會出現更有效率、足以實用的改良版本。雖然這些實用的破密法版本根本還沒誕生，但確有必要發展更強的雜湊演算法來取代舊的演算法。在「碰撞」攻擊法之外，另有一種反譯攻擊法（Pre-image attack），就是由雜湊出的字串反推原本的訊息；反譯攻擊的嚴重性更在碰撞攻擊之上，但也更困難。在許多會應用到密碼雜湊的情境（如用戶密碼的存放、文件的[[數位簽章|數位簽章]]等）中，碰撞攻擊的影響並不是很大。舉例來說，一個攻擊者可能不會只想要偽造一份一模一樣的文件，而會想改造原來的文件，再附上合法的簽章，來愚弄持有公钥的驗證者。另一方面，如果可以從密文中反推未加密前的使用者密碼，攻擊者就能利用得到的密碼登入其他使用者的帳戶，而這種事在密碼系統中是不能被允許的。但若存在反譯攻擊，只要能得到指定使用者密碼雜湊過後的字串（通常存在影檔中，而且可能不會透露原密碼資訊），就有可能得到該使用者的密碼。

2017年2月23日，Google公司宣布，他们与CWI Amsterdam合作创建了两个有着相同SHA-1值但内容不同的PDF文件，这代表SHA-1演算法已被正式攻破。<ref>{{Cite blog|url=https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html|title=Announcing the first SHA1 collision|date=2017-02-23|website=Google Online Security Blog|accessdate=2017-02-24|archive-date=2017-04-24|archive-url=https://web.archive.org/web/20170424012912/https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html|dead-url=no}}</ref>

2020年，針對SHA-1的选择前缀冲突攻击已經實際可行。建議盡可能用[[SHA-2|SHA-2]]或[[SHA-3|SHA-3]]取代[[SHA-1|SHA-1]]。在[[數位簽章|數位簽章]]領域，用更安全的[[SHA-2|SHA-2]]或[[SHA-3|SHA-3]]替換[[SHA-1|SHA-1]]已經變得急迫。<ref name="#1"/><ref name="#2"/>

== SHA-1演算法 ==
以下是SHA-1演算法的[[伪代码|伪代码]]：
 <span style="color: green;">''Note: All variables are unsigned 32 bits and wrap modulo 2<sup>32</sup> when calculating''</span>

 <span style="color: green;">''Initial variables:''</span>
 h0 := 0x67452301
 h1 := 0xEFCDAB89
 h2 := 0x98BADCFE
 h3 := 0x10325476
 h4 := 0xC3D2E1F0

 <span style="color: green;">''Pre-processing:''</span>
 append the bit '1' to the message
 append k bits '0', where k is the minimum number >= 0 such that the resulting message
     length (in ''bits'') is congruent to 448(mod 512)
 append length of message (before pre-processing), in ''bits'', as 64-bit big-endian integer

 <span style="color: green;">''Process the message in successive 512-bit chunks:''</span>
 break message into 512-bit chunks
 '''for''' each chunk
     break chunk into sixteen 32-bit big-endian words w[i], 0 ≤ i ≤ 15

     <span style="color: green;">''Extend the sixteen 32-bit words into eighty 32-bit words:''</span>
     '''for''' i '''from''' 16 to 79
         w[i] := (w[i-3] '''xor''' w[i-8] '''xor''' w[i-14] '''xor''' w[i-16]) '''leftrotate''' 1

     <span style="color: green;">''Initialize hash value for this chunk:''</span>
     a := h0
     b := h1
     c := h2
     d := h3
     e := h4

     <span style="color: green;">''Main loop:''</span>
     '''for''' i '''from''' 0 to 79
         '''if''' 0 ≤ i ≤ 19 '''then'''
             f := (b '''and''' c) '''or''' (('''not''' b) '''and''' d)
             k := 0x5A827999
         '''else if''' 20 ≤ i ≤ 39
             f := b '''xor''' c '''xor''' d
             k := 0x6ED9EBA1
         '''else if''' 40 ≤ i ≤ 59
             f := (b '''and''' c) '''or''' (b '''and''' d) '''or'''(c '''and''' d)
             k := 0x8F1BBCDC
         '''else if''' 60 ≤ i ≤ 79
             f := b '''xor''' c '''xor''' d
             k := 0xCA62C1D6

         temp := (a '''leftrotate''' 5) + f + e + k + w[i]
         e := d
         d := c
         c := b '''leftrotate''' 30
         b := a
         a := temp

     <span style="color: green;">''Add this chunk's hash to result so far:''</span>
     h0 := h0 + a
     h1 := h1 + b
     h2 := h2 + c
     h3 := h3 + d
     h4 := h4 + e

 <span style="color:green;">''Produce the final hash value (big-endian):''</span>
 digest = hash = h0 '''append''' h1 '''append''' h2 '''append''' h3 '''append''' h4

上述關於<code>f</code>運算式列於FIPS PUB 180-1中，以下替代運算式也許也能在主要迴圈裡計算<code>f</code>：
 (0  ≤ i ≤ 19): f := d '''xor''' (b '''and''' (c '''xor''' d))         <span style="color: green;">''(alternative)''</span>
  
 (40 ≤ i ≤ 59): f := (b '''and''' c) '''or''' (d '''and''' (b '''or''' c))   <span style="color: green;">''(alternative 1)''</span>
 (40 ≤ i ≤ 59): f := (b '''and''' c) '''or''' (d '''and''' (b '''xor''' c))  <span style="color: green;">''(alternative 2)''</span>
 (40 ≤ i ≤ 59): f := (b '''and''' c) + (d '''and''' (b '''xor''' c))   <span style="color: green;">''(alternative 3)''</span>

== SHA-1示例 ==

空文的散列为：

 SHA-1("") 
 = da39a3ee5e6b4b0d3255bfef95601890afd80709

==参考文献==
{{reflist|30em}}

{{密碼學|hash}}

[[Category:密码散列函数|Category:密码散列函数]]
[[Category:密码学|Category:密码学]]
[[Category:已攻破的散列函数|Category:已攻破的散列函数]]
[[Category:带有伪代码示例的条目|Category:带有伪代码示例的条目]]