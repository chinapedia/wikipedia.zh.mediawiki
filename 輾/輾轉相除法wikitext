{{NoteTA
|G1=Math
|1= zh-hans:余; zh-tw:餘;}}
[[File:Euclidean_algorithm_252_105_animation_flipped.gif|thumb]]長分别可表示252和105，則其中每一小分段長代表最大公因數21。如动画所示，只要輾轉地从大数中减去小数，直到其中一段的长度为0，此时剩下的一条线段的长度就是252和105的最大公因数。]]

在[[数学|数学]]中，'''辗转相除法'''，又称'''欧几里得算法'''（{{lang-en|Euclidean algorithm}}），是求[[最大公约数|最大公约数]]的[[算法|算法]]。辗转相除法首次出现于[[欧几里得|欧几里得]]的《[[几何原本|几何原本]]》（第VII卷，命题i和ii）中，而在[[中国|中国]]则可以追溯至[[东汉|东汉]]出现的《[[九章算术|九章算术]]》。

两个[[整数|整数]]的最大[[公约数|公约数]]是能够同时[[整除|整除]]它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。例如，252和105的最大公约数是21（<math>252=21\times12;105=21\times5</math>）；因为{{math|1={{nowrap begin}}252 − 105 = 21 × (12 − 5) = 147{{nowrap end}}}}，所以147和105的最大公约数也是21。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至余数为零。这时，所剩下的还没有变成零的数就是两数的最大公约数。由辗转相除法也可以推出，两数的最大公约数可以用两数的整数倍相加来表示，如{{math|1={{nowrap begin}}21 = 5 × 105 + (−2) × 252{{nowrap end}}}}。这个重要的結論叫做[[貝祖等式|貝祖定理]]。 

辗转相除法最早出现在欧几里得的《几何原本》中（大约[[公元前|公元前]]300年），所以它是现行的算法中歷史最悠久的。这个算法原先只用来处理[[自然数|自然数]]和几何长度（相當於正[[實數|實數]]），但在19世纪，辗转相除法被推广至其他类型的數學對象，如[[高斯整数|高斯整数]]和一元[[多项式|多项式]]。由此，引申出[[欧几里得整环|欧几里得整环]]等等的一些现代[[抽象代数|抽象代数]]概念。后来，辗转相除法又扩展至其他数学领域，如[[纽结理论|纽结理论]]和[[多項式#定義|多元多项式]]。

辗转相除法有很多应用，它甚至可以用来生成全世界不同文化中的传统音乐节奏。<ref>[[Godfried_Toussaint|Godfried Toussaint]], "The Euclidean algorithm generates traditional musical rhythms," ''Proceedings of BRIDGES: Mathematical Connections in Art, Music, and Science'', Banff, Alberta, Canada, July 31 to August 3, 2005, pp. 47–56.</ref>在现代[[密码学|密码学]]方面，它是[[RSA算法|RSA算法]]（一种在[[电子商务|电子商务]]中广泛使用的[[公钥加密|公钥加密]]算法）的重要部分。它还被用来解[[丢番图方程|丢番图方程]]，比如寻找满足[[中国剩余定理|中国剩余定理]]的数，或者求[[有限域|有限域]]中[[元素_(數學)|元素]]的[[逆元素|逆]]。辗转相除法还可以用来构造[[连分数|连分数]]，在[[施图姆定理|施图姆定理]]和一些[[整数分解|整数分解]]算法中也有应用。辗转相除法是现代[[数论|数论]]中的基本工具。

辗转相除法处理大数时非常高效，如果用除法而不是减法实现，它需要的步骤不会超过较小数的位数（[[十进制|十进制]]下）的五倍。[[拉梅|拉梅]]于1844年证明了这点，同時這也標誌著[[计算复杂性理论|计算复杂性理论]]的開端。

== 背景 ==
=== 最大公约数 ===
欧几里得的辗转相除法计算的是两个[[自然数|自然数]]''a''和''b''的最大公约数''g''，意思是能够同时整除''a''和''b''的自然数中最大的一个。两个数的最大公约数通常写成GCD(''a'', ''b'')，或者简写成(''a'', ''b'')<ref>Stark, p. 16.</ref>，但是第二种写法也被使用在其他数学概念，如[[二维|二维]][[向量|向量]]的坐标。

如果GCD(''a'', ''b'') = 1，則稱''a''和''b''[[互素|互素]]。<ref>Stark, p. 21.</ref>''a''和''b''是否互素和它们是否[[素数|素数]]无关。<ref>LeVeque, p. 32.</ref>如，6和35都不是素数，因为它们都可以分解为多于一个素因数的乘积：6 = 2 × 3，35 = 5 × 7。但是，6和35互素，因为除了1以外没有自然数同时整除6和35。

[[File:Square_tiling_24x60.svg|thumb]]

令''g'' = GCD(''a'', ''b'')。由于''a''和''b''都是''g''的整数倍，所以可以写成''a'' = ''mg''、''b'' = ''ng''，并且不存在更大的整数''G'' > ''g''使等式成立。为了使''g''尽可能大，就要使''a''和''b''中所有公约数都提取出来归入''g''中，所以自然数''m''和''n''一定互素，并且''a''和''b''的最大公约数''g''可以被''a''和''b''的所有其他公因数''c''整除。<ref>Leveque, p. 31.</ref>

我们可以用右图来解释最大公约数的概念：<ref>{{cite book | author = Grossman JW | year = 1990 | title = Discrete Mathematics | publisher = Macmillan | location = New York | isbn = 0-02-348331-8 | page = 213}}</ref>設一个长方形的边长为''a''和''b''。因为''a''和''b''的任何公约数''c''都可以整除''a''和''b''，所以长方形的边都可以等分为长度为''c''的线段，也就是长方形可以被边长为''c''的正方形正好填满。而最大公约数''g''是所有可能的''c''中最大的一个。例如，一个24 × 60的长方形区域可以分成1 × 1、2 × 2、3 × 3、6 × 6或12 × 12的正方形网格。也就是说，12是24和60的最大公约数。

''a''和''b''的最大公约数是两数共有的素因数的乘积。<ref name="Schroeder_21" >Schroeder, pp. 21–22.</ref>例如，462可以分解成2 × 3 × 7 × 11；1071可以分解成3 × 3 × 7 × 17。462和1071的最大公约数等于它们共有的素因数的乘积3 × 7 = 21。如果两数没有公共的素因数，那么它们的最大公约数是1，也即这两个数互素。辗转相除法的优点就在於它能以有系統的方式求出兩數的最大公约数，而無需分別對它們作因式分解。<ref>Schroeder, p. 19.</ref><ref>{{cite book | author = Ogilvy CS, Anderson JT | year = 1966 | title = Excursions in number theory | publisher = [[牛津大學出版社|Oxford University Press]] | location = New York | id = {{LCCN|66|0|14484}} | pages = 27–29}}</ref>大数的[[素因数分解|素因数分解]]被認為是一個困難的問題，即使是现代的计算机也非常难於處理，所以许多加密系统的原理都是建基於此。<ref name="Schroeder_216" >Schroeder, pp. 216–219.</ref>

在数学中，尤其是[[抽象代数|抽象代数]]的[[环论|环论]]中，最大公约数有一个更加巧妙的定义：<ref name="Leveque_p33" />''a''和''b''的最大公约数''g''是''a''和''b''的线性和中的最小正整數，即所有形如''ua'' + ''vb''（其中''u''和''v''是整数）的数中的最小正整数。可以證明，所有''ua'' + ''vb''都是''g''的整数倍（''ua'' + ''vb'' = ''mg''，其中''m''是整数）。用现代数学语言來說，''a''和''b''生成的[[理想_(环论)|理想]]即是由''g''生成的[[主理想|主理想]]。最大公约数的这个定义和其他定义的等价性将在下面描述。

三个数的最大公约数的定义和两个数的相同，即是它们共有的素因数的积<ref>Stark, p. 25.</ref>，它们或者也可以按下式计算<ref>Ore, pp. 47–48.</ref>：

: {{math|1=GCD(''a'', ''b'', ''c'') = GCD(''a'', GCD(''b'', ''c'')) = GCD(GCD(''a'', ''b''), ''c'') = GCD(GCD(''a'', ''c''), ''b'').}}

所以，欧几里得的辗转相除法实际可以计算任意多整数的最大公约数。

=== 归纳、递归和无穷递降 ===
下文的論證會用到三種相關的数学方法，分別是[[数学归纳法|数学归纳法]]、[[递归|递归]]和[[无穷递降|无穷递降]]。数学归纳法<ref>{{cite book|author=高德纳|year=1997|title=The Art of Computer Programming（[[计算机程序设计艺术|计算机程序设计艺术]]）, Volume 1: Fundamental Algorithms|edition=3rd|publisher=Addison-Wesley|isbn=0-201-89683-4}} (Section 1.2.1: Mathematical Induction, pp. 11–21.)</ref>经常用来证明某個定理對所有[[自然数|自然数]]成立：<ref>Rosen, pp. 18–21.</ref>首先证明定理对一个特定的数''n''<sub>0</sub>成立（通常是1）；然后證明如果定理对自然数''n''成立的話，那麼它对自然数''n'' + 1成立。這樣，便可證明定理对所有大于''n''<sub>0</sub>的自然数也成立。递归<ref>Rosen, pp. 21–24.</ref>是将相关的数组成一个[[数列|数列]](''a''<sub>1</sub>, ''a''<sub>2</sub>, ''a''<sub>3</sub>...)，<ref>{{cite book | author = Anderson JA | year = 2001 | title = Discrete Mathematics with Combinatorics | publisher = Prentice Hall | location = Upper Saddle River, NJ | isbn = 0-13-086998-8 | pages = 165–223}}</ref>當中除初始項外，其中每一项都用前一项或前几项表示。如[[斐波那契数列|斐波那契数列]]就是递归的，每一项''F''<sub>''n''</sub>都等于''F''<sub>''n''−1</sub> + ''F''<sub>''n''−2</sub>（n≧2）。辗转相除法中的一些等式也是递归的。最后，无穷递降<ref>Rosen, p. 492.</ref>是用方程的一个自然数解导出比它小的自然数解。<ref>{{cite book | author = Anderson JA | year = 2001 | title = Discrete Mathematics with Combinatorics | publisher = Prentice Hall | location = Upper Saddle River, NJ | isbn = 0-13-086998-8 | pages = 109–119}}</ref>但是，这种转化不能永远进行下去，因为只有有限個小於原來的自然数解的自然数。所以，要麼方程無解，不然在有限步内必然能得出最小的自然數解。在下文會用到此法來证明辗转相除法一定会在有限步内结束。

== 算法描述 ==
=== 计算过程 ===
辗转相除法是一种[[递归|递归]]算法，每一步计算的输出值就是下一步计算时的输入值。<ref name=autogenerated3>Stark, pp. 16–20.</ref>设''k''表示步骤数（从0开始计数），算法的计算过程如下。

每一步的输入是都是前两次计算的非負余数''r''<sub>''k''−1</sub>和''r''<sub>''k''−2</sub>。因为每一步计算出的余数都在不断减小，所以，''r''<sub>''k''−1</sub>小于''r''<sub>''k''−2</sub>。在第''k''步中，算法计算出满足以下等式的[[商數|商]]''q''<sub>''k''</sub>和[[余数|余数]] ''r''<sub>''k''</sub>：

:{{math|1= ''r''<sub>''k''−2</sub> = ''q''<sub>''k''</sub> ''r''<sub>''k''−1</sub> + ''r''<sub>''k''</sub>}}

其中0 ≤ ''r''<sub>''k''</sub> < ''r''<sub>''k''−1</sub>。也就是''r''<sub>''k''−2</sub>要不断减去''r''<sub>''k''−1</sub>直到比''r''<sub>''k''−1</sub>小。

為求簡明，以下只說明如何求兩個非負整數''a''和''b''的最大公約數（負數的情況是簡單的）。在第一步计算时（''k'' = 0），设''r''<sub>−2</sub>和''r''<sub>−1</sub>分别等于''a''和''b''，第2步（此时''k'' = 1）时计算''r''<sub>−1</sub>（即''b''）和''r''<sub>0</sub>（第一步计算产生的余数）相除产生的商和余数，以此类推。整个算法可以用如下等式表示：
{{math|1=
: ''a'' = ''q''<sub>0</sub> ''b'' + ''r''<sub>0</sub>
: ''b'' = ''q''<sub>1</sub> ''r''<sub>0</sub> + ''r''<sub>1</sub>
: ''r''<sub>0</sub> = ''q''<sub>2</sub> ''r''<sub>1</sub> + ''r''<sub>2</sub>
: ''r''<sub>1</sub> = ''q''<sub>3</sub> ''r''<sub>2</sub> + ''r''<sub>3</sub>
: …
}}

如果有''a'' < ''b''，算法的第一步實際上會把兩個數字交換，因為這時''a''除以''b''所得的商''q''<sub>0</sub>會等于0，余数''r''<sub>0</sub>則等于''a''。然後，算法的第二步便是把''b''除以''a''，再計算所得之商和餘數。所以，對於''k'' ≥ 0總有''r''<sub>''k''</sub><''r''<sub>''k''−1</sub>，即运算的每一步中得出的余数一定小于上一步计算的余数。

由于每一步的余数都在减小并且不为负数，必然存在第''N''步时''r''<sub>''N''</sub>等于0，使算法终止<ref name="Stark_p18" >Stark, p. 18.</ref>，''r''<sub>''N''−1</sub>就是''a''和''b''的最大公约数。其中''N''不可能无穷大，因为在''r''<sub>0</sub>和0之间只有有限个自然数。

=== 正确性的证明 ===
辗转相除法的正确性可以分成两步来证明。<ref name=autogenerated3 />在第一步，我們會證明算法的最终结果''r''<sub>''N''−1</sub>同时整除''a''和''b''。因为它是一个公约数，所以必然小于或者等于最大公约数''g''。在第二步，我們證明''g''能整除''r''<sub>''N''−1</sub>。所以''g''一定小于或等于''r''<sub>''N''−1</sub>。两个不等式只在''r''<sub>''N''−1</sub> = ''g''时同时成立。具体证明如下：
#{{math|1=
证明''r''<sub>''N''−1</sub>同时整除''a''和''b''：
#:因为余数''r''<sub>''N''</sub>是0，''r''<sub>''N''−1</sub>能够整除''r''<sub>''N''−2</sub>：
#:: ''r''<sub>''N''−2</sub> = ''q''<sub>''N''</sub> ''r''<sub>''N''−1</sub>
#:因为''r''<sub>''N''−1</sub>能够整除''r''<sub>''N''−2</sub>，所以也能够整除''r''<sub>''N''−3</sub>：
#:: ''r''<sub>''N''−3</sub> = ''q''<sub>''N''−1</sub> ''r''<sub>''N''−2</sub> + ''r''<sub>''N''−1</sub>
#:同理可证''r''<sub>''N''−1</sub>可以整除所有之前步骤的余数，包括''a''和''b''，即''r''<sub>''N''−1</sub>是''a''和''b''的公约数，''r''<sub>''N''−1</sub> ≤ ''g''。
#证明最大公约数''g''能整除''r''<sub>''N''-1</sub>：
#:根据定义，''a''和''b''可以写成''g''的倍数：''a'' = ''mg''、''b'' = ''ng''，其中''m''和''n''是自然数。因为''r''<sub>0</sub> = ''a'' − ''q''<sub>0</sub>''b'' = ''mg'' − ''q''<sub>0</sub>''ng'' = (''m'' − ''q''<sub>0</sub>''n'')''g''，所以''g''整除''r''<sub>0</sub>。同理可证''g''整除每个余数''r''<sub>1</sub>, ''r''<sub>2</sub>, ..., ''r''<sub>''N''-1</sub>。因為最大公约数''g''整除''r''<sub>''N''−1</sub>，因而''g'' ≤ ''r''<sub>''N''−1</sub>。
}}
因为第一步的证明告诉我们''r''<sub>''N''−1</sub> ≤ ''g''，所以''g'' = ''r''<sub>''N''−1</sub>。即：<ref>高德纳, p. 320.</ref><ref name="Lovasz_2003">{{cite book | author = Lovász L, Pelikán J, Vesztergombi K | year = 2003 | title = Discrete Mathematics: Elementary and Beyond | publisher = Springer-Verlag | location = New York | isbn = 0-387-95584-4 | pages = 100–101}}</ref>

:{{math|1=''g'' = GCD(''a'', ''b'') = GCD(''b'', ''r''<sub>0</sub>) = GCD(''r''<sub>0</sub>, ''r''<sub>1</sub>) = … = GCD(''r''<sub>''N''−2</sub>, ''r''<sub>''N''−1</sub>) = ''r''<sub>''N''−1</sub>}}

=== 举例 ===
[[File:Euclidean_algorithm_1071_462.gif|right]]

例如，计算''a'' = 1071和''b'' = 462的最大公约数的过程如下：从1071中不断减去462直到小于462（可以减2次，即商''q''<sub>0</sub> = 2），余数是147：

: {{math|1=1071 = 2 × 462 + 147.}}

然后从462中不断减去147直到小于147（可以减3次，即''q''<sub>1</sub> = 3），余数是21：

: {{math|1=462 = 3 × 147 + 21.}}

再从147中不断减去21直到小于21（可以减7次，即''q''<sub>2</sub> = 7），没有余数：

: {{math|1=147 = 7 × 21 + 0.}}

此时，余数是0，所以1071和462的最大公约数是21，这和用素因数分解得出的结果相同（见[[#最大公约数|上文]]）用表格表示如下：

{| class="wikitable"
|-
! 步骤数 !! 算式 !!商和余数
|-
| 0 || 1071 = 462 ''q''<sub>0</sub> + ''r''<sub>0</sub> || ''q''<sub>0</sub> = 2、''r''<sub>0</sub> = 147
|-
| 1 || 462 = 147 ''q''<sub>1</sub> + ''r''<sub>1</sub> || ''q''<sub>1</sub> = 3、''r''<sub>1</sub> = 21
|-
| 2 || 147 = 21 ''q''<sub>2</sub> + ''r''<sub>2</sub> || ''q''<sub>2</sub> = 7、''r''<sub>2</sub> = 0（算法终止）
|}

=== 图形演示 ===
辗转相除法的计算过程可以用图形演示。<ref name="Kimberling_1983">{{cite journal | author = Kimberling C | year = 1983 | title = A Visual Euclidean Algorithm | url = https://archive.org/details/sim_mathematics-teacher_1983-02_76_2/page/108 | journal = Mathematics Teacher | volume = 76 | pages = 108–109}}</ref>假设我们要在''a''×''b''的[[矩形|矩形]]地面上铺[[正方形|正方形]]瓷砖，并且正好铺满，其中''a''大于''b''。我们先尝试用''b''×''b''的瓷砖，但是留下了''r''<sub>0</sub>×''b''的部分，其中''r''<sub>0</sub><''b''。我们接着尝试用''r''<sub>0</sub>×''r''<sub>0</sub>的正方形瓷砖铺，又留下了''r''<sub>1</sub>×''r''<sub>0</sub>的部分，然后再使用''r''<sub>1</sub>×''r''<sub>1</sub>的正方形铺……直到全部铺满为止，即到某步时正方形刚好覆盖剩余的面积为止。此时用到的最小的正方形的边长就是原来矩形的两条边长的最大公约数。在图中，最小的正方形面积是21×21（{{color|red|红色}}），而原先的矩形（{{color|green|绿色}}）边长是1071×462，所以21是1071和462的最大公约数。

=== 计算商和余数 ===
{{See also|模除|带余除法}}

在每个步骤''k''中，辗转相除法都需要计算两个数''r''<sub>''k''−1</sub>和''r''<sub>''k''−2</sub>的商''q''<sub>''k''</sub>和余数''r''<sub>''k''</sub>：

: {{math|1=''r''<sub>''k''−2</sub> = ''q''<sub>''k''</sub> ''r''<sub>''k''−1</sub> + ''r''<sub>''k''</sub>}}

其中0 ≤ ''r''<sub>''k''</sub> < ''r''<sub>''k''−1</sub>。除法的算法保证这样的商和余数总是存在。自然数的除法算法还指出这样的商和余数是惟一的，但这对辗转相除法而言并非必要。<ref name="Cohn_1962">Cohn, pp. 104–110.</ref>

在欧几里得最初的描述中，商和余数是通过连续的减法来计算的，即从''r''<sub>''k''−2</sub>中不断减去''r''<sub>''k''−1</sub>直到小于''r''<sub>''k''−1</sub>。一個更高效的做法是使用整數除法和模除来计算商和余数：

:{{math|1=''r''<sub>''k''</sub> [[同余|≡]] ''r''<sub>''k''−2</sub> mod ''r''<sub>''k''−1</sub>}}

=== 计算机实现 ===
辗转相除法可用[[伪代码|伪代码]]表示，比如除法版本可以寫成<ref>高德纳, pp. 319–320.</ref>

 '''function''' gcd(a, b)
     '''while''' b ≠ 0
         t ← b
         b ← a '''mod''' b
         a ← t
     '''return''' a
c++版本：<syntaxhighlight lang="c++" line="1">
int gcd(int m,int n)
{
        int t = 1;
        while(t != 0)
        {
                t=m%n;
                m=n;
                n=t;
        }
        return m;
}
</syntaxhighlight>
Rust版本：<syntaxhighlight lang="rust" line="1">
fn gcd(x: isize, y: isize) -> Option<isize> {
    match (x,y) {
        (0, 0)         => None,
        (a, 0)         => Some(a.abs()),
        (mut a, mut b) => { 
            while b != 0 {
                let t = b;
                b = a % b;
                a = t;
            }

            Some(a.abs()) 
        },
    }
}
</syntaxhighlight>
Python3版本：<syntaxhighlight lang="python3" line="1">
def gcd(a, b):
    while b != 0:
        t = a % b
        a = b
        b = t
    return a
</syntaxhighlight>
在第''k''次循环开始时，变量''b''的值是前一次运算的余数''r''<sub>''k''−1</sub>，变量''a''的值是再前一次运算的余数''r''<sub>''k''−2</sub>。步骤{{nowrap begin}}''b'' := ''a'' mod ''b''{{nowrap end}}的作用等同于递归式{{nowrap begin}}''r''<sub>''k''</sub> ≡ ''r''<sub>''k''−2</sub> mod ''r''<sub>''k''−1</sub>{{nowrap end}}。变量''t''的功能是在下一个余数''r''<sub>''k''</sub>计算过程中临时性地保存''r''<sub>''k''−1</sub>的值。在一次循环结束时，变量''b''的值是前一次运算的余数''r''<sub>''k''</sub>，变量''a''的值是再前一次运算的余数''r''<sub>''k''−1</sub>。

在欧几里得定义的减法版本，取餘运算被减法替换。<ref>高德纳, pp. 318–319.</ref>

 '''function''' gcd(a, b)
     '''if''' a = 0
        '''return''' b
     '''while''' b ≠ 0
         '''if''' a > b
            a ← a − b
         '''else'''
            b ← b − a
     '''return''' a

变量''a''和''b''的值分别是前两次的余数''r''<sub>''k''−1</sub>和''r''<sub>''k''−2</sub>。假定第''k''次循环开始时''a''大于''b''，那么''a''等于''r''<sub>''k''−2</sub>，因为''r''<sub>''k''−2</sub> > ''r''<sub>''k''−1</sub>。在循环过程中，''a''重复减去''b''直到比''b''小，此时''a''就是下一个余数''r''<sub>''k''</sub>；然后''b''重复减去''a''直到比''a''小，此时''b''就是下一个余数''r''<sub>''k''+1</sub>；重复执行直到''b'' = 0。

以下是[[递归|递归]]版本<ref>Stillwell, p. 14.</ref>：

 '''function''' gcd(a, b)
     '''if''' b = 0
        '''return''' a
     '''else'''
        '''return''' gcd(b, a '''mod''' b)
c++[[递归|递归]]版本如下：<syntaxhighlight lang="c++" line="1">
int gcd(int n,int m)
{
    return  m == 0 ? n : gcd(m, n % m);
}
</syntaxhighlight>

Rust递归版本：<syntaxhighlight lang="rust" line="1">
fn gcd(x: isize, y: isize) -> Option<isize> {
    match (x,y) {
        (0, 0)  => None,
        (a, 0)  => Some(a.abs()),
        _       => gcd(y, x % y),
    }
}
</syntaxhighlight>

Java版本：<syntaxhighlight lang="java" line="1">
public class MethodOfSuccessiveDivision {
    public static void main(String[] args) {
        System.out.println(gcd(1071,462));
    }
    public static int gcd(int a,int b){
        if(b == 0){
            return a;
        }else{
            return gcd(b,a%b);
        }
    }
}
</syntaxhighlight>
Python3版本：<syntaxhighlight lang="python3" line="1">
def gcd(a, b):
    return a if b == 0 else gcd(b, a %b)
</syntaxhighlight>例如GCD(1071, 462)的计算过程是：函数的第一次调用计算GCD(462, 1071 mod 462) = GCD(462, 147)；下一次调用计算GCD(147, 462 mod 147) = GCD(147, 21)，在接下来是GCD(21, 147 mod 21) = GCD(21, 0) = 21。

=== 使用绝对值最小的余数 ===
在另一个版本的算法中，每一步还要把取余运算时计算出的商增加一后再重新计算余数（此时计算出的余数应该是负的），然后取两个余数的绝对值较小的数作为下一步运算时使用的余数。<ref name="Ore_least_abs_remainders" >Ore, p. 43.</ref><ref name="Stewart_1964">{{cite book | author = Stewart BM | year = 1964 | title = Theory of Numbers | edition = 2nd | publisher = Macmillan | location = New York | id = {{LCCN|64|0|10964}} | pages = 43–44}}</ref>取余运算后，设''r''<sub>''k''</sub>是计算出的余数（此時為正），''q''是计算出的商：

: {{math|1=''r''<sub>''k''−2</sub> = ''q''<sub>''k''</sub> ''r''<sub>''k''−1</sub> + ''r''<sub>''k''</sub>}}

即假設{{math|1=''r''<sub>''k''−1</sub> > ''r''<sub>''k''</sub> > 0}}。然後使用以下式子计算出一个负的余数''e''<sub>''k''</sub>：

: {{math|1=''r''<sub>''k''−2</sub> = (''q''<sub>''k''</sub> + 1) ''r''<sub>''k''−1</sub> + ''e''<sub>''k''</sub>}}

如果|''e''<sub>''k''</sub>| < |''r''<sub>''k''</sub>|，那么用''e''<sub>''k''</sub>替换''r''<sub>''k''</sub>进行下一次运算。如[[利奥波德·克罗内克|利奥波德·克罗内克]]所指出的，这个版本需要的运算步骤是欧几里得算法的所有版本中最少的。<ref name="Ore_least_abs_remainders" /><ref name="Stewart_1964" />

== 历史发展 ==
[[File:Euklid.jpg|thumb]]之前几个世纪就已经有了。图为使用两脚规进行测量。]]

辗转相除法是目前仍然在使用的历史最悠久的算法之一。<ref name=autogenerated2>高德纳, p. 318.</ref>它首次出现于《[[几何原本|几何原本]]》（卷7命题1–2、卷10命题2–3）（大约公元前300年）。在卷7中用于整数，在卷10中用于线段的长度（以現代的觀點看，线段的长度可視為正实数，也就是說辗转相除法實際可用於實數上，但是当时未有实数的概念）。卷10中出现的算法是几何的，两段线段''a''和''b''的最大公约数是''a''和''b''的[[通約性|公度]]中的最大值。

这个算法可能并非[[欧几里得|欧几里得]]发明，因為他也有将先前其他數學家的一些成果编进他的《几何原本》。<ref name="Weil_1983">{{cite book | author = [[André_Weil|Weil A]] | year = 1983 | title = Number Theory | publisher = Birkhäuser | location = Boston | isbn = 0-8176-3141-0 | pages = 4–6}}</ref><ref name="Jones_1994">{{cite book | author = Jones A | year = 1994 | chapter = Greek mathematics to AD 300 | title = Companion encyclopedia of the history and philosophy of the mathematical sciences | publisher = Routledge | location = New York | isbn = 0-415-09238-8 | pages = 46–48}}</ref>数学家、历史学家{{link-en|范德瓦尔登|Bartel Leendert van der Waerden}}认为卷7的内容可能来自[[毕达哥拉斯|毕达哥拉斯]]学院出身的数学家写的关于[[数论|数论]]的教科书。<ref name="van_der_Waerden_1954">{{cite book | author = [[Bartel_Leendert_van_der_Waerden|van der Waerden BL]] | year = 1954 | title = Science Awakening | url = https://archive.org/details/scienceawakening00waer| series = translated by Arnold Dresden | publisher = P. Noordhoff Ltd | location = Groningen | pages = [https://archive.org/details/scienceawakening00waer/page/114 114]–115}}</ref>辗转相除法在當時很可能已為[[尤得塞斯|尤得塞斯]]（大約公元前375年）所知
<ref name=autogenerated2 /><ref>{{cite journal | author = von Fritz K | date = 1945 | title = The Discovery of Incommensurability by Hippasus of Metapontum | url = https://archive.org/details/sim_annals-of-mathematics_1945-04_46_2/page/242 | journal = Ann. Math. | volume = 46 | pages = 242–264 | doi = 10.2307/1969021}}</ref>，甚至可能更早之前就已经存在<ref>{{cite book | author = [[T._L._Heath|Heath TL]] | year = 1949 | title = Mathematics in Aristotle | url = https://archive.org/details/mathematicsarist00heat| publisher = Oxford Press | pages = [https://archive.org/details/mathematicsarist00heat/page/n92 80]–83}}</ref><ref>{{cite book | author = [[David_Fowler_(mathematician)|Fowler DH]] | year = 1987 | title = The Mathematics of Plato's Academy: A New Reconstruction | publisher = Oxford University Press | location = Oxford | isbn = 0-19-853912-6 | pages = 31–66}}</ref>，因为欧几里得和[[亚里士多德|亚里士多德]]的著作中都出现了{{lang|el|ἀνθυφαίρεσις}}一词（意为“辗转相减”）。<ref>{{cite journal | author = Becker O | year = 1933 | title = Eudoxus-Studien I. Eine voreuklidische Proportionslehre und ihre Spuren bei Aristoteles und Euklid | journal = Quellen und Studien zur Geschichte der Mathematik B | volume = 2 | pages = 311–333}}</ref>

几个世纪之后，辗转相除法又分别被[[中国|中国]]人和[[印度|印度]]人独立发现，<ref name=autogenerated4>Stillwell, p. 31.</ref>主要用来解天文学中用到的[[丢番图方程|丢番图方程]]以及制定准确的历法。5世纪末，印度[[数学家|数学家]]、[[天文学家|天文学家]][[阿里亚哈塔|阿里亚哈塔]]曾稱辗转相除法为“粉碎机”，這可能是因为它在解[[丢番图方程|丢番图方程]]时很有效<ref>Rosen, pp. 86–87.</ref>。<ref name="#1">Tattersall, p. 70.</ref>在中国，《[[九章算术|九章算术]]》中提到了一种类似辗转相减法的“更相减损术”<ref>{{cite wikisource |title=九章算术 |plainchapter=卷第一　方田以御田疇界域| wslink=九章算術#-.7BA.7Czh-hans:.E5.8D.B7.3Bzh-hant:.E5.8D.B7.7D-.E7.AC.AC.E4.B8.80.E3.80.80.E6.96.B9.E7.94.B0.E4.BB.A5.E5.BE.A1.E7.94.B0.E7.96.87.E7.95.8C.E5.9F.9F| quote=可半者半之；不可半者，副置分母、子之數，以少減多，更相減損，求其等也。以等數約之。|wslanguage=zh}}</ref>。《[[孙子算经|孙子算经]]》中則出现了[[中国剩余定理|中国剩余定理]]的一个特例<ref>Ore, pp. 247–248.</ref>，但是直到1247年[[秦九韶|秦九韶]]才於其《[[数学九章|数学九章]]》中解答了該定理的一般情況，當中用到了他發明的[[大衍求一术|大衍求一术]]。此法的其中一部分實際上便是輾轉相除的原理，秦九韶在書中對此有明確表述。<ref>{{cite web|author1=洪萬生|title=中國π的一頁滄桑|url=http://episte.math.ntu.edu.tw/articles/sm/sm_08_05_3/page5.html|accessdate=2015-04-28}}</ref>在欧洲，辗转相除法首次出现于{{link-en|克劳德·巴希特|Claude Gaspard Bachet de Méziriac}}的著作《愉悦讨喜的问题》（''{{lang|fr|Problèmes plaisants et délectables}}''）的第二版<ref name="#1"/>在欧洲，辗转相除法被用于丢番图方程和構建[[连分数|连分数]]。后来，英国数学家{{link-en|桑德森|Nicholas Saunderson}}在其著作中收編了[[扩展欧几里得算法|扩展欧几里得算法]]，作为一個有效计算连分数的方法。他將此法的來源歸名於{{link-en|罗杰·科茨|Roger Cotes}}。<ref>Tattersall, pp. 72–76.</ref>

19世纪，辗转相除法促成了新[[数系|数系]]的建立，如[[高斯整数|高斯整数]]和[[艾森斯坦整数|艾森斯坦整数]]。1815年，[[高斯|高斯]]用辗转相除法证明高斯整数的分解是惟一的，儘管他的研究到了1832年才首度发表。<ref name="Gauss_1832" />高斯在他的《[[算数研究|算数研究]]》（出版于1801年）中實際上也有援引这个算法，但僅是以[[连分数|连分数]]方法的形式敘述。<ref name=autogenerated4 />[[约翰·彼得·古斯塔夫·勒热纳·狄利克雷|约翰·狄利克雷]]是第一个将辗转相除法作为数论的基础的数学家。{{fact}}狄利克雷提出，数论中的很多结论，如分解的惟一性，在任何使辗转相除法適用的数系中均有效。<ref>狄利克雷, pp. 29–31.</ref>狄利克雷的數論講義後來經[[理查德·戴德金|理查德·戴德金]]編輯和推广，戴德金也有以辗转相除法來研究[[代数整数|代数整数]]。比如，他是第一个用高斯整数的分解惟一性证明[[费马平方和定理|费马平方和定理]]的数学家。<ref>{{cite book | author = [[理查德·戴德金|Dedekind R]] | year = 1894 | chapter = Supplement XI | title = Vorlesungen über Zahlentheorie | editor = PGL 狄利克雷 }}</ref>戴德金还率先定义了[[欧几里得整环|欧几里得整环]]的概念。19世纪末，戴德金所定義的[[理想_(环论)|理想]]概念使得數論的重心不必建基於輾轉相除法，從而促進了理論的發展。<ref>{{cite book | author = [[John_Stillwell|Stillwell J]] | year = 2003 | title = Elements of Number Theory | publisher = Springer-Verlag | location = New York | isbn = 0-387-95587-9 | pages = 41–42}}</ref>
{| class="toccolours" style="float: left; margin-left: 1em; margin-right: 1em; font-size: 85%; background:#c6dbf7; color:black; width:23em; max-width: 25%;" cellspacing="5"
| style="text-align: left;" |
“欧几里得算法是所有算法的鼻祖，因为它是现存最古老的非凡算法。”
|-
| style="text-align: left;" | ——[[高德纳|高德纳]]，《[[计算机程序设计艺术|计算机程序设计艺术]]，第二卷：半数值算法》，第二版 (1981), p. 318.
|}
辗转相除法的其他应用发展于19世纪。1829年，[[雅克·夏尔·弗朗索瓦·施图姆|施图姆]]将辗转相除法用于[[施图姆定理|施图姆序列]]（用于确定多项式的不同实根的个数的方法）。<ref>{{cite journal | author = Sturm C | year = 1829 | title = Mémoire sur la résolution des équations numériques | journal = Bull. des sciences de Férussac | volume = 11 | pages = 419–422}}</ref>

辗转相除法是历史上第一个{{link-en|整数关系算法|integer relation algorithm}}，即寻找两個[[通約性|可通約]]實數的整数关系的算法。近年来，出现了一些新颖的整数关系算法，如{{link-en|埃拉曼·弗格森|Helaman Ferguson}}和福尔卡德于1979年发表的[[弗格森-福尔卡德算法|弗格森-福尔卡德算法]]（Ferguson–Forcade algorithm）
<ref>{{MathWorld|urlname=IntegerRelation|title=Integer Relation|Ferguson–Forcade algorithm}}</ref>、以及与它相关的{{link-en|LLL算法|Lenstra–Lenstra–Lovász lattice basis reduction algorithm}}、[[HJLS算法|HJLS算法]]以及[[PSLQ算法|PSLQ算法]]。<ref>{{cite journal | author = Peterson I | date = 12 August 2002 | title = [http://www.sciencenews.org/view/generic/id/172/title/Math_Trek__Jazzing_Up_Euclids_Algorithm Jazzing Up Euclid's Algorithm] | journal = ScienceNews }}</ref><ref>{{cite journal | author = Cipra BA | title = [http://amath.colorado.edu/resources/archive/topten.pdf The Best of the 20th Century: Editors Name Top 10 Algorithms] | journal = SIAM News | volume = 33 | number = 4 | date = 16 May 2000 | publisher = [[Society_for_Industrial_and_Applied_Mathematics|Society for Industrial and Applied Mathematics]]}}</ref>

1969年，科尔（Cole）和戴维（Davie）基于辗转相除法创造了一种二人游戏，叫做「欧几里得游戏」。<ref>{{cite journal | author = Cole AJ, Davie AJT | year = 1969 | title = A game based on the Euclidean algorithm and a winning strategy for it | url = https://archive.org/details/sim_mathematical-gazette_1969-12_53_386/page/354 | journal = Math. Gaz. | volume = 53 | pages = 354–357 | doi = 10.2307/3612461}}</ref>这个游戏有最优策略。<ref>{{cite journal | author = Spitznagel EL | year = 1973 | title = Properties of a game based on Euclid's algorithm | journal = Math. Mag. | volume = 46 | pages = 87–92}}</ref>游戏开始于两列分别为''a''和''b''个棋子组成的序列，玩家轮流从较长一列中取走较短一列棋子数量的''m''倍的棋子。如果两列棋子''p''和''q''分别由''x''和''y''个棋子组成，其中''x''大于''y''，那么玩家可以將序列''p''的棋子数量减少为自然数''x'' − ''my''。最后率先将一列棋子清空的玩家胜出。<ref>Rosen, p. 95.</ref><ref>{{cite book | author = Roberts J | year = 1977 | title = Elementary Number Theory: A Problem Oriented Approach | publisher = [[MIT_Press|MIT Press]] | location = Cambridge, MA | isbn = 0-262-68028-9 | pages = 1–8}}</ref>

== 数学上的应用 ==
=== 贝祖等式 ===
[[贝祖等式|贝祖等式]]说明，两个数''a''和''b''的最大公约数''g''可以表示为''a''和''b''的线性和。<ref>{{cite book | author = Jones GA, Jones JM | year = 1998 | chapter = Bezout's Identity | title = Elementary Number Theory | publisher = Springer-Verlag | location = New York | pages = 7–11}}</ref>也就是说，存在整数''s''和''t''使''g'' = ''sa'' + ''tb''。<ref>Rosen, p. 81.</ref><ref>Cohn, p. 104.</ref>

整数''s''和''t''可以从辗转相除法算出的商''q''<sub>0</sub>、''q''<sub>1</sub>……计算出。<ref>Rosen, p. 91.</ref> 从辗转相除法的最后一步开始，''g''可以表示成前一步的商''q''<sub>''N''−1</sub>和前两步的余数''r''<sub>''N''−2</sub>和''r''<sub>''N''−3</sub>：

: {{math|1=''g'' = ''r''<sub>''N''−1</sub> = ''r''<sub>''N''−3</sub> − ''q''<sub>''N''−1</sub> ''r''<sub>''N''−2</sub>}}

而前两步的余数又分别可以表示成它们前两步的余数和商：
{{math|1=
: ''r''<sub>''N''−2</sub> = ''r''<sub>''N''−4</sub> − ''q''<sub>''N''−2</sub> ''r''<sub>''N''−3</sub>
: ''r''<sub>''N''−3</sub> = ''r''<sub>''N''−5</sub> − ''q''<sub>''N''−3</sub> ''r''<sub>''N''−4</sub>
}}
将这两行式子先後代入第一个式子，可以将''g''表示成''r''<sub>''N''−4</sub>和''r''<sub>''N''−5</sub>的线性和。重复进行迭代直到出现''a''和''b''：
{{math|1=
: ''r''<sub>2</sub> = ''r''<sub>0</sub> − ''q''<sub>2</sub> ''r''<sub>1</sub>
: ''r''<sub>1</sub> = ''b'' − ''q''<sub>1</sub> ''r''<sub>0</sub>
: ''r''<sub>0</sub> = ''a'' − ''q''<sub>0</sub> ''b''
}}
最终，''g''可以表示成''a''和''b''的线性和：''g'' = ''sa'' + ''tb''。[[贝祖等式|贝祖等式]]以及以上证明都可以扩展至[[欧几里得整环|欧几里得整环]]。

=== 主理想和相关问题 ===
贝祖等式提供了另一种定义''a''和''b''的最大公约数''g''的方法。<ref name="Leveque_p33" >Leveque, p. 33.</ref>考虑形如''ua'' + ''vb''（其中''u''和''v''是整数）的数的[[集合_(数学)|集合]]。因为''a''和''b''都可以被''g''整除，所以这个集合中的所有元素都可以被''g''整除。也就是说这个集合中的数都可以表示成''g''的倍数，或者''a''和''b''的其他公约数的倍数。但是，只有最大公约数才是这个集合的元素。根据贝祖等式，有''g'' = ''sa'' + ''tb''。換言之，当''u'' = ''s''、''v'' = ''t''时得出''g''。任何其他的公约数都不是这个集合的元素，因为它们都不能被比它们大的''g''整除。相反地，''g''的任何倍数都属于这个集合，只要令''u'' = ''ms''、''v'' = ''mt''，便有：

: {{math|1=''mg'' = ''msa'' + ''mtb''}}

所以，形如''ua'' + ''vb''的数的集合等于''g''的整数倍的集合。也就是说，任意两个数的线性和的集合等同于它们最大公约数的整数倍的集合。''a''和''b''的最大公约数叫做''a''和''b''的[[理想_(环论)|理想]]的生成元素。这个最大公约数的定义导出了兩個现代[[抽象代数|抽象代数]]的概念：[[主理想|主理想]]（由单个元素生成的理想）以及[[主理想整环|主理想整环]]（其每一理想都是主理想的[[整环|整环]]）。

这个结果可以解决某些實際问题。<ref>Schroeder, p. 23.</ref>例如，考虑两个容积分别为''a''和''b''的量杯，其中''a''和''b''為正整數。通过加入或倒去''u''倍第一个量杯的体积以及''v''倍第二个量杯的体积的液体，任何体积为''ua'' + ''vb''的液体都可以被量出（只要''ua'' + ''vb''為正數）。根據贝祖等式，凡是可以被量出的液体，其体积一定是''a''和''b''的最大公约数''g''的倍數。

=== 扩展欧几里得算法 ===
{{main|扩展欧几里得算法}}
[[贝祖等式|贝祖等式]]的整数''s''和''t''可以通过[[扩展欧几里得算法|扩展欧几里得算法]]算出。这个扩展算法在原有辗转相除法的基础上增加了两个递归等式：<ref>Rosen, pp. 90–93.</ref>
{{math|1=
: ''s''<sub>''k''</sub> = ''s''<sub>''k''−2</sub> − ''q''<sub>''k''</sub>''s''<sub>''k''−1</sub>
: ''t''<sub>''k''</sub> = ''t''<sub>''k''−2</sub> − ''q''<sub>''k''</sub>''t''<sub>''k''−1</sub>
}}
算法开始时：
{{math|1=
: ''s''<sub>−2</sub> = 1, ''t''<sub>−2</sub> = 0
: ''s''<sub>−1</sub> = 0, ''t''<sub>−1</sub> = 1
}}
加上这兩个递归式后，当算法终止于''r''<sub>''N''</sub> = 0，贝祖等式的整数''s''和''t''分别由''s''<sub>''N''</sub>和''t''<sub>''N''</sub>给出。

这个算法的正确性可以用数学归纳法来证明。假设递归至第''k''−1步是正确的，也就是假设：

: {{math|1=''r''<sub>''j''</sub> = ''s''<sub>''j''</sub> ''a'' + ''t''<sub>''j''</sub> ''b''}}

在''j''小于''k''時皆成立。则第''k''步运算得出以下等式：

: {{math|1=''r''<sub>''k''</sub> = ''r''<sub>''k''−2</sub> − ''q''<sub>''k''</sub>''r''<sub>''k''−1</sub>}}

因为''r''<sub>''k''−2</sub>和''r''<sub>''k''−1</sub>被假定是正确的，所以可以用''s''和''t''表示：

: {{math|1=''r''<sub>''k''</sub> = (''s''<sub>''k''−2</sub> ''a'' + ''t''<sub>''k''−2</sub> ''b'') − ''q''<sub>''k''</sub>(''s''<sub>''k''−1</sub> ''a'' + ''t''<sub>''k''−1</sub> ''b'')}}

整理后得到第''k''步的结果，和我们期望得到的结果一致：

: {{math|1=''r''<sub>''k''</sub> = ''s''<sub>''k''</sub> ''a'' + ''t''<sub>''k''</sub> ''b'' = (''s''<sub>''k''−2</sub> − ''q''<sub>''k''</sub>''s''<sub>''k''−1</sub>) ''a'' + (''t''<sub>''k''−2</sub> − ''q''<sub>''k''</sub>''t''<sub>''k''−1</sub>) ''b''}}

=== 矩阵法 ===

整数''s''和''t''也可以用[[矩阵|矩阵]]运算得出。<ref name="Koshy_2002">{{cite book | author = Koshy T | year = 2002 | title = Elementary Number Theory with Applications | publisher = Harcourt/Academic Press | location = Burlington, MA | isbn = 0-12-421171-2 | pages = 167–169}}</ref>辗转相除法的计算过程：
{{math|1=
: ''a'' = ''q''<sub>0</sub> ''b'' + ''r''<sub>0</sub>
: ''b'' = ''q''<sub>1</sub> ''r''<sub>0</sub> + ''r''<sub>1</sub>
: …
: ''r''<sub>''N''−2</sub> = ''q''<sub>''N''</sub> ''r''<sub>''N''−1</sub> + 0
}}
可以写作2×2的商矩阵乘以一个2维余数向量：

:<math>
\begin{pmatrix} a \\ b \end{pmatrix} =
\begin{pmatrix} q_{0} & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} b \\ r_{0} \end{pmatrix} =
\begin{pmatrix} q_{0} & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} q_{1} & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} r_{0} \\ r_{1} \end{pmatrix} =
\cdots =
\prod_{i=0}^{N} \begin{pmatrix} q_{i} & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} r_{N-1} \\ 0 \end{pmatrix}
</math>

令'''M'''表示所有商矩阵的乘积：

:<math>
\mathbf{M} = \begin{pmatrix} m_{11} & m_{12} \\ m_{21} & m_{22} \end{pmatrix} =
\prod_{i=0}^{N} \begin{pmatrix} q_{i} & 1 \\ 1 & 0 \end{pmatrix} =
\begin{pmatrix} q_{0} & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} q_{1} & 1 \\ 1 & 0 \end{pmatrix} \cdots \begin{pmatrix} q_{N} & 1 \\ 1 & 0 \end{pmatrix}
</math>

这使辗转相除法化简为：

:<math>
\begin{pmatrix} a \\ b \end{pmatrix} =
\mathbf{M} \begin{pmatrix} r_{N-1} \\ 0 \end{pmatrix} =
\mathbf{M} \begin{pmatrix} g \\ 0 \end{pmatrix}
</math>

如要用''a''和''b''的线性和表示''g''，可將等式两边同时乘以矩阵'''M'''的[[逆矩阵|逆矩阵]]。<ref name="Koshy_2002" /><ref name="Bach_1996">{{cite book | author = Bach E, Shallit J | year = 1996 | title = Algorithmic number theory | publisher = MIT Press | location = Cambridge, MA | isbn = 0-262-02405-5 | pages = 70–73}}</ref>'''M'''的[[行列式|行列式]]等于(−1)<sup>''N''+1</sup>，因为它等于商矩阵的行列式的乘积，而每一个的行列式都是−1。因为'''M'''的行列式不为零，最终的余数向量可以利用'''M'''的逆矩阵解出：

:<math>
\begin{pmatrix} g \\ 0 \end{pmatrix} =
\mathbf{M}^{-1} \begin{pmatrix} a \\ b \end{pmatrix} =
(-1)^{N+1} \begin{pmatrix} m_{22} & -m_{12} \\ -m_{21} & m_{11} \end{pmatrix} \begin{pmatrix} a \\ b \end{pmatrix}
</math>

由上式可以得出''g'' = (−1)<sup>''N''+1</sup> ( ''m''<sub>22</sub> ''a'' − ''m''<sub>12</sub> ''b'')。

贝祖等式中的两个整数分别是''s'' = (−1)<sup>''N''+1</sup>''m''<sub>22</sub>、''t'' = (−1)<sup>''N''</sup>''m''<sub>12</sub>。矩阵法的效率可前文描述的辗转相除法的递归算法是相同的，每一步都有两次乘法和两次加法。

=== 欧几里得引理和唯一分解 ===
贝祖等式对辗转相除法的很多应用都很重要，如证明自然数的[[唯一分解|唯一分解]]性质<ref>Stark, pp. 26–36.</ref>假设数字''L''可以写成两个因数''u''和''v''的乘积，即''L'' = ''uv''。如果另一个数''w''与''u''互素的数也能整除''L''，那么''w''必须整除''v''，证明如下：如果''u''和''w''的最大公约数是1，则根据贝祖等式存在''s''和''t''使

: {{math|1=1 = ''su'' + ''tw''}}。

两边都乘以''v''：

: {{math|1=''v'' = ''suv'' + ''twv'' = ''sL'' + ''twv''}}

因为''w''整除等式右边，所以也应整除等式左边的''v''。这个结果叫做[[欧几里得引理|欧几里得引理]]。<ref name=autogenerated1>Ore, p. 44.</ref>如果一个素数整除''L''那么它至少整除''L''的一个因数。如果一个数''w''互素于数列''a''<sub>1</sub>、''a''<sub>2</sub>、…、''a''<sub>''n''</sub> 中的每一个数，则''w''也一定互素于它们的乘积''a''<sub>1</sub> × ''a''<sub>2</sub> × … × ''a''<sub>''n''</sub>。<ref name=autogenerated1 />

欧几里得引理足以证明每一个自然数的素数分解是惟一的。<ref>Stark, pp. 281–292.</ref>我们用反证法来证明，假设''L''可以分别分解成''m''个素数和''n''个素数，即：

: {{math|1=''L'' = ''p''<sub>1</sub>''p''<sub>2</sub>…''p''<sub>''m''</sub> = ''q''<sub>1</sub>''q''<sub>2</sub>…''q''<sub>''n''</sub>}}

根据假设，每个素数''p''都能整除''L''，因此它必须能够整除某個''q''；因为''q''也是一个素数，所以''p'' = ''q''。同理，对于每一个''p''都存在一个''q''与它相等。所以两种分解除了顺序不同以外是完全相同的。整数分解的惟一性在数学证明中有很多应用，下文将会提到。

=== 线性丢番图方程 ===
[[File:Diophante_Bezout.svg|thumb]]：9''x'' + 12''y'' = 483的图像，它的解用蓝点表示。]]

[[丢番图方程|丢番图方程]]是以[[亞歷山卓|亚历山大]]数学家[[丢番图|丢番图]]的名字命名的一类方程，它的解被限制在整数范围。<ref>Rosen, pp. 119–125.</ref>关于整数''x''和''y''的线性丢番图方程形如：<ref>Schroeder, pp. 106–107.</ref>

: <math>ax + by = c</math>

其中''a''、''b''、''c''是已知整数。这个方程可以写成关于''x''的[[同余|同余]]式：

: <math>ax \equiv c \pmod{b}</math>

令''g''为''a''和''b''的最大公约数，a、b都能被g整除，故''ax'' + ''by''能够被''g''整除。所以，''c''一定能够被''g''整除，不然方程就无解。方程两边若同时除以 <math>\tfrac {c}{g}</math>，方程就变成了贝祖等式：

: <math>sa + tb = g</math>

其中''s''和''t''可以用扩展欧几里得算法求解。<ref>Schroeder, pp. 108–109.</ref>所以这个丢番图方程的一个解即是：

: <math>
\begin{align}
x_1 = s ( \tfrac {c}{g} ) \\
y_1 = t ( \tfrac {c}{g} )
\end{align}
</math>

总体而言，丢番图方程如果有解，就一定有无数个解。<ref>Rosen, pp. 120–121.</ref>只需要考虑两个解 (x<sub>1</sub>, y<sub>1</sub>) 和 (x<sub>2</sub>, y<sub>2</sub>)：

: <math>ax_1 + by_1 = c = ax_2 + by_2</math>

或者可以写成：

: <math>a(x_1 - x_2) = b(y_2 - y_1)</math>

所以相邻两个解的''x''之间的差是<math>\tfrac {b}{g}</math>，''y''之间的差是<math>\tfrac {a}{g}</math>。这样，所有的解都可以表示成：

: <math>
\begin{align}
x = x_1 - \tfrac{bt}{g} \\
y = y_1 + \tfrac{at}{g}
\end{align}
</math>

当''t''取遍所有整数时，方程所有的解都可以从 (''x''<sub>1</sub>, ''y''<sub>1</sub>) 计算出来。如果限制為正整数解 (''x'' > 0, ''y'' > 0) 的话，那么解的数量就可能是有限的。有時候，这种对解的限制使丢番图方程在未知数個數比方程數更多的情况下仍然能有唯一解<ref>Stark, p. 47.</ref>，而在允許實數解的[[线性方程组|线性方程组]]中，这種情況是不可能的。

=== 乘法逆和RSA算法 ===
[[有限域|有限域]]是一个支持四种运算的数集。这四种运算也通稱為加法、减法、乘法、除法，跟一般的四則運算有相同的性质，如[[交换律|交换律]]、[[结合律|结合律]]和[[分配律|分配律]]。举例来说，使用[[同余|同余]]可以让13个数字的集合 {0, 1, 2, …, 12} 构成一个有限域。在这个域中，任何数学运算（加减乘除）都归约成13的[[模|模]]，例如 5 × 7 = 35 mod 13 = 9。对于任意素数''p''，都可以定义这种有限域；使用更复杂的方法，也可以对素数''p''的''m''次方定义这样的有限域。有限域也叫做[[埃瓦里斯特·伽罗瓦|伽罗瓦]]域，其缩写為 GF(''p'') 或 GF(''p''<sup> ''m''</sup>)。

在这样一个有''m''个数的域中，任何非零元素''a''都存在惟一[[乘法逆|乘法逆]] ''a''<sup>−1</sup> 使''aa''<sup>−1</sup> = ''a''<sup>−1</sup>''a'' ≡ 1 mod ''m''。这可以通过解同余式''ax'' ≡ 1 mod ''m'' 得出，<ref>Schroeder, pp. 107–109.</ref>或者也可以解与之等价的丢番图方程<ref>Stillwell, pp. 186–187.</ref>

: {{math|1=''ax'' + ''my'' = 1}}

这个方程可用扩展欧几里得算法解出（参见[[#线性丢番图方程|上文]]）。在[[RSA算法|RSA算法]]中，寻找乘法逆是非常重要的一步，它决定了使用哪个数来解密信息。<ref>Schroeder, p. 134.</ref>虽然RSA算法不使用域而是使用环，扩展欧几里得算法仍然可以用来求乘法逆。欧几里得算法也被应用于[[纠错码|纠错码]]，例如，它可以代替[[伯利坎普－梅西算法|伯利坎普－梅西算法]]解基于有限域的[[BCH码|BCH码]]和[[里德-所罗门码|里德-所罗门码]]。<ref>"Error correction coding: mathematical methods and algorithms", page 266, Todd K. Moon, John Wiley and Sons, 2005, ISBN 978-0-471-64800-0</ref>

=== 中国剩余定理 ===
辗转相除法也可以用來解线性丢番图方程组。<ref>Rosen, pp. 143–170.</ref>如在[[中国剩余定理|中国剩余定理]]中，整数可以表示成被''N''个互素的数''m''<sub>''i''</sub>除留下的余数：<ref>Schroeder, pp. 194–195.</ref>

: <math>
\begin{align}
x_1 &\equiv x \pmod{m_1}\\
x_2 &\equiv x \pmod{m_2}\\
\vdots & \\
x_N &\equiv x \pmod{m_N}
\end{align}
</math>

为了从''x''的''N''个余数''x''<sub>''i''</sub>中确定''x''的值，我们将这些式子组合成单个线性丢番图方程，其中模数''M''是所有模数''m''<sub>''i''</sub>的乘积，然后定义''M''<sub>''i''</sub>如下：

: <math> M_i = M / m_i </math>

也就是，''M''<sub>''i''</sub>是除了''m''<sub>''i''</sub>以外所有模数的乘积。接着是关键的一步，寻找''N''个数''h''<sub>''i''</sub>使：

: <math> M_i h_i \equiv 1 \pmod{m_i}</math>

有了这些数''h''<sub>''i''</sub>之后，整数''x''可以用下式从余数''x''<sub>''i''</sub>中解出：

: <math> x \equiv (x_1 M_1 h_1 + x_2 M_2 h_2 + \cdots + x_N M_N h_N ) \mod M </math>

因为''h''<sub>''i''</sub>是''M''<sub>''i''</sub>的乘法逆，所以可以使用扩展欧几里得算法求出（见[[#乘法逆和RSA算法|上一节]]）。

=== 连分数 ===
辗转相除法和[[连分数|连分数]]有着紧密的关系。<ref name="Vinogradov_1954">{{cite book | author = [[伊萬·維諾格拉多夫|Vinogradov IM]] | year = 1954 | title = Elements of Number Theory | publisher = Dover | location = New York | pages = 3–13}}</ref>计算连分数的过程如下：

:<math>
\begin{align}
\frac{a}{b} &= q_0 + \frac{r_0}{b} \\
\frac{b}{r_0} &= q_1 + \frac{r_1}{r_0} \\
\frac{r_0}{r_1} &= q_2 + \frac{r_2}{r_1} \\
\vdots& \\
\frac{r_{k-2}}{r_{k-1}} &= q_k + \frac{r_k}{r_{k-1}} \\
\vdots& \\
\frac{r_{N-2}}{r_{N-1}} &= q_N \\
\end{align}
</math>

其中每个式子的右边最后一项都等于下一个式子的左边项的[[倒数|倒数]]。所以前两个式子可以组合成：

:<math>\frac{a}{b} = q_0 + \frac{1}{q_1 + \frac{r_1}{r_0}} </math>

第三个式子可以代入分母中的''r''<sub>1</sub>/''r''<sub>0</sub>：

:<math>\frac{a}{b} = q_0 + \frac{1}{q_1 + \frac{1}{q_2 + \frac{r_2}{r_1}}} </math>

每一步中，最后一项''r''<sub>''k''</sub>/''r''<sub>''k''−1</sub>都可以用下一个式子代换，直至最后一个式子，结果是：

:<math>\frac{a}{b} = q_0 + \dfrac{1}{q_1 + \dfrac{1}{q_2 + \dfrac{1}{\ddots + \dfrac{1}{q_N}}}} = [ q_0; q_1, q_2, \cdots , q_N ] </math>

在[[#举例|上文的例子]]中计算了GCD(1071, 462)，其中商''q''<sub>''k''</sub>分别是2、3、7，所以分数 1071/462 可以写成如下连分数形式：

:<math>\frac{1071}{462} = 2 + \frac{1}{3 + \frac{1}{7}} = [2; 3, 7]</math>

=== 整数分解算法 ===
计算最大公约数是很多[[整数分解|整数分解]]算法的重要步骤<ref>{{cite book | author = Crandall R, Pomerance C | year = 2001 | title = Prime Numbers: A Computational Perspective | url = https://archive.org/details/primenumberscomp0000cran | edition = 1st | publisher = Springer-Verlag | location = New York | isbn = 0-387-94777-9 | pages = [https://archive.org/details/primenumberscomp0000cran/page/225 225]–349}}</ref>，如{{le|Pollard's rho算法|Pollard's rho algorithm}}<ref>高德纳, pp. 369–371.</ref>、[[Shor算法|Shor算法]]<ref>{{cite journal | author = [[彼得·秀爾|Shor PW]] | year = 1997 | title = Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer | journal = SIAM J. Sci. Statist. Comput. | volume = 26 | pages = 1484}}</ref>、{{le|Dixon分解法|Dixon's factorization method}}<ref>{{cite journal | author = Dixon JD | year = 1981 | title = Asymptotically fast factorization of integers | url = https://archive.org/details/sim_mathematics-of-computation_1981-01_36_153/page/255 | journal = Math. Comput. | volume = 36 | pages = 255–260 | doi = 10.2307/2007743}}</ref>以及{{le|Lenstra椭圆曲线分解|Lenstra elliptic curve factorization}}<ref>{{cite journal | author = [[亨德里克·倫斯特拉|Lenstra Jr. HW]] | year = 1987 | title = Factoring integers with elliptic curves | url = https://archive.org/details/sim_annals-of-mathematics_1987-11_126_3/page/649 | journal = Annals of Mathematics | volume = 126 | pages = 649–673 | doi = 10.2307/1971363}}</ref>。用辗转相除法算最大公约数效率非常高。而[[连分数分解法|连分数分解法]]由于用到了连分数，所以也需要使用辗转相除法<ref>高德纳, pp. 380–384.</ref>。

== 算法效率 ==
[[File:Euclidean_algorithm_running_time_X_Y.png|thumb]]

辗转相除法的计算效率已经被彻底研究过了。<ref>高德纳, pp. 339–364.</ref>一个算法的效率可以用计算所需步数乘以每步计算的开销表示。[[加百利·拉梅|加百利·拉梅]]于1884年指出<ref>{{cite journal | author = [[加百利·拉梅|加百利·拉梅]] | year = 1844 | title = Note sur la limite du nombre des divisions dans la recherche du plus grand commun diviseur entre deux nombres entiers | journal = Comptes Rendus Acad. Sci. | volume = 19 | pages = 867–870}}</ref>，用辗转相除法计算两个数的最大公约数所需的步数不会超过其中较小数十進制下的位数''h''的5倍。<ref>{{cite journal | author = Grossman H | year = 1924 | title = On the Number of Divisions in Finding a G.C.D. | url = https://archive.org/details/sim_american-mathematical-monthly_1924-11_31_9/page/443 | journal = The American Mathematical Monthly | volume = 31 | page = 443 | doi = 10.2307/2298146}}</ref><ref>{{cite book | author = Honsberger R | year = 1976 | title = Mathematical Gems II | publisher = The [[Mathematical_Association_of_America|Mathematical Association of America]] | isbn = 0-88385-302-7 | pages = 54–57}}</ref>因为每一步的计算开销通常也是''h''数量级的，所以辗转相除法的[[算法复杂度|复杂度]]是''h''<sup>2</sup>。

=== 计算步数 ===
计算两个自然数''a''和''b''的最大公约数所需的步数可以表示为''T''(''a'', ''b'')。<ref name=autogenerated5>高德纳, p. 344.</ref>如果''a''和''b''的最大公约数是''g''，''a'' = ''mg''，''b'' = ''ng''，而''m''和''n''是两个互素整数，那么：

: {{math|1=''T''(''a'', ''b'') = ''T''(''m'', ''n'')}}

这可以通过在辗转相除法的计算过程中的每一步都除以''g''来证明。<ref>Ore, p. 45.</ref>同样，当''a''和''b''同时乘以''w''时，计算步数不变：''T''(''a'', ''b'') = ''T''(''wa'', ''wb'')。所以，对于数值上相近的数，如T(''a'', ''b'')和T(''a'', ''b'' + 1)，计算步数可能相差很大。

根据辗转相除法的递归性质可以得出另一个公式：

: {{math|1=''T''(''a'', ''b'') = 1 + ''T''(''b'', ''r''<sub>0</sub>) = 2 + ''T''(''r''<sub>0</sub>, ''r''<sub>1</sub>) = … = ''N'' + ''T''(''r''<sub>''N''−2</sub>, ''r''<sub>''N''−1</sub>) = ''N'' + 1}}

其中，根據定义有''T''(''x'', 0) = 0。<ref name=autogenerated5 />

==== 最差情况 ====

假设用辗转相除法求自然数''a''和''b''（''a'' > ''b'' > 0）的最大公约数需要''N''步，那么满足这一条件的''a''和''b''的最小值分别是斐波那契数''F''<sub>''N''+2</sub>和''F''<sub>''N''+1</sub>。<ref name=autogenerated6>高德纳, p. 343.</ref>这可以用[[数学归纳法|数学归纳法]]证明。<ref>Mollin, p. 21.</ref>假设''N'' = 1，''b''整除''a''，满足这一条件的''a''和''b''最小是''b'' = 1、''a'' = 2，正是''F''<sub>2</sub>和''F''<sub>3</sub>。现在假设这一规律对''M'' − 1有效。一个需要''M''步的算法的第一步是''a'' = ''q''<sub>0</sub>''b'' + ''r''<sub>0</sub>，第二步是''b'' = ''q''<sub>1</sub>''r''<sub>0</sub> + ''r''<sub>1</sub>。因为算法是递归的，它需要''M'' − 1 步才能算出 GCD(''b'', ''r''<sub>0</sub>)，其中''b''和''r''<sub>0</sub>的最小值是 ''F''<sub>''M''+1</sub> 和 ''F''<sub>''M''</sub>。所以''a''的最小值是当 ''q''<sub>0</sub> = 1 的时候，此时 ''a'' = ''b'' + ''r''<sub>0</sub> = ''F''<sub>''M''+1</sub> + ''F''<sub>''M''</sub> = ''F''<sub>''M''+2</sub>。1844年，加百利·拉梅发现这个证明标志着[[计算复杂性理论|计算复杂性理论]]的诞生。<ref>LeVeque, p. 35.</ref>这也是[[斐波那契数列|斐波那契数列]]的第一个实际应用。<ref name=autogenerated6 />

这个结果也证明了辗转相除法的运算步骤不会超过较小数十进制下的位数的五倍。<ref>Mollin, pp. 21–22.</ref>因为如果算法需要''N''步，那么''b''一定大于或等于''F''<sub>''N''+1</sub>，也就是一定大于或等于''φ''<sup>''N''−1</sup>，其中''φ''是[[黄金分割比|黄金分割比]]。因为''b'' ≥ ''φ''<sup>''N''−1</sup>，所以''N'' − 1 ≤ log<sub>''φ''</sub>''b''。因为log<sub>10</sub>''φ'' > 1/5，(''N'' − 1)/5 < log<sub>10</sub>''φ'' log<sub>''φ''</sub>''b'' = log<sub>10</sub>''b''，所以''N'' ≤ 5 log<sub>10</sub>''b''。所以，辗转相除法不会进行超过[[大O符号|''O''(''h'')]]次除法，其中''h''是较小数''b''在十进制下的位数。

==== 平均情况 ====
辗转相除法的平均步骤数有三种不同的定义。第一种定义是计算已知自然数''a''和从0到''a'' − 1范围内随机选取的自然数''b''的最大公约数所需的时间''T''(''a'')：<ref name=autogenerated5 />

:<math>T(a) = \frac{1}{a} \sum_{0 \leq b<a} T(a, b)</math>

但是因为''T''(''a'', ''b'')在连续整数间变化非常剧烈，所以''T''(''a'')的值也会显得很杂乱。<ref>高德纳, p. 353.</ref>

为了解决这个问题，第二种定义规定τ(''a'')只要取遍其中所有和''a''互素的数即可：

:<math>\tau(a) = \frac{1}{\varphi(a)} \sum_{0 \leq b<a, \mathrm{GCD}(a, b) = 1} T(a, b)</math>

在小于''a''的数中，有''φ''(''a'')个数与''a''互素，其中''φ''是[[欧拉函数|欧拉函数]]。在这个定义中，τ(''a'')的函数值增长得平稳很多。<ref>高德纳, p. 357.</ref><ref>{{cite journal | author = Tonkov T | year = 1974 | title = On the average length of finite continued fractions | journal = Acta arithmetica | volume = 26 | pages = 47–57}}</ref>

:<math>\tau(a) = \frac{12}{\pi^2} \ln 2 \ln a + C + O(a^{-\frac{1}{6} + \varepsilon})</math>

誤差項的增長率為O(''a''<sup>−(1/6) + ε</sup>)，其中ε是[[无穷小量|无穷小量]]。公式中的常数''C''等于：

:<math>C = \frac{1}{2} + 6 (\frac{\ln 2}{\pi^2})( 4\gamma - 24\pi^2\zeta'(2) + 3 \ln 2 - 2) \approx 1.467</math>

其中γ是[[欧拉-马歇罗尼常数|欧拉-马歇罗尼常数]]，ζ′是[[黎曼ζ函数|黎曼ζ函数]]的导数。<ref>{{cite journal | author = Porter JW | year = 1975 | title = On a Theorem of Heilbronn | journal = Mathematika | volume = 22 | pages = 20–28}}</ref><ref>{{cite journal | author = 高德纳 DE | year = 1976 | title = Evaluation of Porter's Constant | url = https://archive.org/details/sim_computers-mathematics-with-applications_1976_2/page/137 | journal = Computers and Mathematics with Applications | volume = 2 | pages = 137–139 | doi = 10.1016/0898-1221(76)90025-0}}</ref>公式最左边的<math>\frac{12}{\pi^2}\ln 2</math>由两个独立的方法确定。<ref>{{cite journal | author = Dixon JD | year = 1970 | title = The Number of Steps in the Euclidean Algorithm | journal = J. Number Theory | volume = 2 | pages = 414–422 | doi = 10.1016/0022-314X(70)90044-2}}</ref><ref>{{cite book | author = Heilbronn HA | year = 1969 | chapter = On the Average Length of a Class of Finite Continued Fractions | title = Number Theory and Analysis | editor = Paul Turán | publisher = Plenum | location = New York | id = {{LCCN|68|00|8991}} | pages = 87–96}}</ref>

因为第一种定义可以通过用第二种定义的求和来完成：<ref>高德纳, p. 354.</ref>

:<math>T(a) = \frac{1}{a} \sum_{d | a} \varphi(d) \tau(d)</math>

所以也可以由以下公式近似：<ref name="Norton_1990">{{cite journal | author = Norton GH | year = 1990 | title = On the Asymptotic Analysis of the Euclidean Algorithm | journal = Journal of Symbolic Computation | volume = 10 | pages = 53–58 | doi = 10.1016/S0747-7171(08)80036-3}}</ref>

:<math>T(a) \approx C + \frac{12}{\pi^2} \ln 2 ( \ln a - \sum_{d|a} \frac{\Lambda(d)}{d} )</math>

其中Λ(''d'')是[[冯·曼戈尔特函数|冯·曼戈尔特函数]]。<ref>高德纳, p. 355.</ref>

第三种定义''Y''(''n'')定义为从1到''n''间随机选取''a''和''b''（[[離散型均勻分佈|均勻分佈]]）时计算它们的最大公约数所需的平均步骤数：<ref name="Norton_1990" />

:<math>Y(n) = \frac{1}{n^2} \sum_{a=1}^{n} \sum_{b=1}^{n} T(a, b) = \frac{1}{n} \sum_{a=1}^{n} T(a)</math>

将''T''(''a'')的近似公式代入，得到''Y''(''n'')的近似：<ref>高德纳, p. 356.</ref>

:<math>Y(n) \approx \frac{12}{\pi^2} \ln 2 \ln n + 0.06</math>

=== 每一步的计算开销 ===
在辗转相除法的每一步中，商''q''<sub>''k''</sub>和余数''r''<sub>''k''</sub>都通过''r''<sub>''k''−2</sub>和''r''<sub>''k''−1</sub>求出：

: {{math|1=''r''<sub>''k''−2</sub> = ''q''<sub>''k''</sub> ''r''<sub>''k''−1</sub> + ''r''<sub>''k''</sub>}}

所以每一步的计算开销主要与计算商''q''<sub>''k''</sub>的算法有关，因为余数''r''<sub>''k''</sub>可以很迅速地从''r''<sub>''k''−2</sub>、''r''<sub>''k''−1</sub>和''q''<sub>''k''</sub>计算出来：

: {{math|1=''r''<sub>''k''</sub> = ''r''<sub>''k''−2</sub> − ''q''<sub>''k''</sub> ''r''<sub>''k''−1</sub>}}

而计算一个''h''位整数的除法的算法复杂度是[[大O符号|''O''(''h''(''ℓ''+1))]]，其中''ℓ''是商的位数。<ref>高德纳, pp. 257–261.</ref>

作为对比，辗转相除法原先的版本使用的是减法，因此效率要慢很多。进行一次除法等同于进行''q''次减法（其中''q''是商）。如果''a''和''b''的比很大，计算出的商也很大，也就需要进行很多次减法。但在另一方面，计算出来的商在大多数情况下都是非常小的，除法中得出一个确定的商''q''的概率大约是<math>\log_2 \left(\tfrac{u}{u-1}\right)</math>。其中''u'' = (''q'' + 1)<sup>2</sup>。<ref>高德纳, p. 352.</ref>比如，商是1、2、3、4的可能性分别是大约41.5%、17.0%、9.3%、5.9%。因为计算机计算减法要快于除法，特別是对于很大的数字<ref>{{cite book | author = Wagon S | year = 1999 | title = Mathematica in Action | publisher = Springer-Verlag | location = New York | isbn = 0-387-98252-3 | pages = 335–336}}</ref>，所以减法版本的辗转相除法的性能可以比得上除法版本。<ref>Cohen, p. 14.</ref>这也被运用于[[二进制|二进制]]最大公约数算法。<ref>Cohen, pp. 14–15, 17–18.</ref>

综合考虑算法需要的步数和每一步的计算开销，辗转相除法随两个数字''a''和''b''的平均位数成平方级的速度增长(''h''<sup>2</sup>)。设''h''<sub>0</sub>、''h''<sub>1</sub>、…、''h''<sub>''N''−1</sub>表示计算过程中的余数''r''<sub>0</sub>、''r''<sub>1</sub>、…、''r''<sub>''N''−1</sub>的位数，因为算法的步数''N''随''h''线性增长，所以算法的运算时间为：

:<math>O\Big(\sum_{i<N}h_i(h_i-h_{i+1}+2)\Big)\subseteq O\Big(h\sum_{i<N}(h_i-h_{i+1}+2)\Big)\subseteq O(h(h_0+2N))\subseteq O(h^2)</math>

=== 其他算法的效率 ===
因为辗转相除法的高效率，它在实践中被广泛使用。作为对比，本段中介绍以下辗转相除法以外的其他最大公约数算法的效率。

计算两数''a''和''b''的最大公约数有一个效率很慢的算法：将''a''除以从2到''b''之间的每一个整数以计算出它们所有的公约数，其中最大的一个即是最大公约数。在这个算法中，步骤数随''b''线性增长，也就是随输入数字的位数呈指数级增长。另一个很低效的算法是计算出两个数的所有素因数（见[[#最大公约数|上文]]），最大公约数等于所有公共素因数的乘积。<ref name="Schroeder_21" />但是[[整数分解|整数分解]]算法效率极低，很多现代的加密系统甚至依靠这种低效率来防止资料被破解。<ref name="Schroeder_216" />

除了辗转相除法之外，也有一些高效的算法存在，如[[二进制最大公约数算法|二进制最大公约数算法]]将除法操作替换成了[[二进制|二进制]]的移位，以进一步提高用计算机运算时的效率。<ref>高德纳, pp. 321–323.</ref><ref>{{cite journal | author = Stein J | year = 1967 | title = Computational problems associated with Racah algebra | journal = Journal of Computational Physics | volume = 1 | pages = 397–405 | doi = 10.1016/0021-9991(67)90047-2}}</ref>但是，这种改变并没有降低算法的复杂度（仍然是[[大O符号|''O''(''h''²)]]），虽然它在计算机上确实比辗转相除法快些。<ref name="Crandall_2001">{{cite book | author = Crandall R, Pomerance C | year = 2001 | title = Prime Numbers: A Computational Perspective | url = https://archive.org/details/primenumberscomp0000cran | edition = 1st | publisher = Springer-Verlag | location = New York | isbn = 0-387-94777-9 | pages = [https://archive.org/details/primenumberscomp0000cran/page/77 77]–79, 81–85, 425–431}}</ref>也可以通过只检視''a''和''b''的前几位数来进一步提高效率，不过效果并不明显。<ref>高德纳, p. 328.</ref><ref>{{cite journal | author = Lehmer DH | year = 1938 | title = Euclid's Algorithm for Large Numbers | url = https://archive.org/details/sim_american-mathematical-monthly_1938_45/page/227 | journal = The American Mathematical Monthly | volume = 45 | pages = 227–233 | doi = 10.2307/2302607}}</ref>二进制版的算法还可以扩展到其它进制<ref>{{cite journal | author = Sorenson J | year = 1994 | title = Two fast GCD algorithms | journal = J. Algorithms | volume = 16 | pages = 110–144 | doi = 10.1006/jagm.1994.1006}}</ref>，效率最多可以提升五倍。<ref>{{cite journal | author = Weber K | year = 1995 | title = The accelerated GCD algorithm | journal = ACM Trans. Math. Soft. | volume = 21 | pages = 111–122 | doi = 10.1145/200979.201042}}</ref>

对于超过25,000位数的大数，有一种改进使算法复杂度降低至平方级以下<ref>{{cite book | author = Aho A, Hopcroft J, Ullman J | year = 1974 | title = The Design and Analysis of Computer Algorithms | publisher = Addison–Wesley | location = New York | pages = 300–310}}</ref>，如Schönhage<ref>{{cite journal | author = Schönhage A | title = Schnelle Berechnung von Kettenbruchentwicklungen | journal = Acta Informatica | volume = 1 | pages = 139–144 | doi = 10.1007/BF00289520 | year = 1971}}</ref><ref>{{cite book | author = Cesari G | year = 1998 | chapter = Parallel implementation of Schönhage's integer GCD algorithm | title = Algorithmic Number Theory: Proc. ANTS-III, Portland, OR | url = https://archive.org/details/algorithmicnumbe00buhl | editor = G. Buhler | publisher = Springer-Verlag | location = New York | pages = [https://archive.org/details/algorithmicnumbe00buhl/page/n71 64]–76}} Volume 1423 in ''Lecture notes in Computer Science''.</ref>、Stehlé、Zimmermann等人提出的算法。<ref>{{cite book | author = Stehlé D, Zimmermann P | year = 2005 | chapter = Gal’s accurate tables method revisited | title = Proceedings of the 17th IEEE Symposium on Computer Arithmetic (ARITH-17) | publisher = [[IEEE_Computer_Society_Press|IEEE Computer Society Press]] | location = Los Alamitos, CA}}</ref>这些算法利用2×2的矩阵（见[[#矩阵法|上文]]）。这些亚平方级的算法复杂度通常是{{nowrap|''O''(''h'' (log ''h'')<sup>2</sup> (log log ''h''))}}。<ref name="Crandall_2001" /><ref>{{cite journal | author = Möller N | title = [http://www.lysator.liu.se/~nisse/archive/sgcd.pdf On Schönhage's algorithm and subquadratic integer gcd computation] | journal = Mathematics of Computation | volume = 77 | pages = 589–607 | doi = 10.1090/S0025-5718-07-02017-0 | year = 2008}}</ref>

== 其他数系 ==
如上文所述，辗转相除法最早用来寻找两自然数的最大公约数，但其实它也可以被推广至实数，甚至是[[多项式|多项式]]、[[二次整数|二次整数]]和[[赫尔维茨四元数|赫尔维茨四元数]]。在这些数系中，辗转相除法甚至被用来證明一个重要特性：惟一分解，即这些数系中的数能够被惟一地分解成[[不可約元素|不可約元素]]（素数在这些数系的对应物）。惟一分解是数论中很多证明的基础。

=== 有理数和实数 ===
辗转相除法可以被应用至[[实数|实数]]，如欧几里得在[[几何原本|几何原本]]第10卷中所说的那样。算法的目的是计算出实数''g''，使已知实数''a''和''b''是它的整数倍：''a'' = ''mg''、''b'' = ''ng''，其中''m''和''n''是[[整数|整数]]。<ref name="Weil_1983" />这也就找到了''a''和''b''的整数关系，即找到整数''s''和''t''使{{nowrap begin}}''sa'' + ''tb'' = 0{{nowrap end}}。欧几里得使用辗转相除法来处理[[通约性|不可通约的长度]]。<ref>{{cite book | author = Boyer CB, Merzbach UC | year = 1991 | title = A History of Mathematics | edition = 2nd | publisher = Wiley | location = New York | isbn = 0-471-54397-7 | pages = 116–117}}</ref><ref>{{cite book | author = [[Florian_Cajori|Cajori F]] | year = 1894 | title = A History of Mathematics | url = https://archive.org/details/historyofmathema001062mbp| publisher = Macmillan | location = New York | page = [https://archive.org/details/historyofmathema001062mbp/page/n79 70]}}</ref>

实数的辗转相除法和整数的算法有两个区别。第一，余数''r''<sub>''k''</sub>是实数，虽然商''q''<sub>''k''</sub>仍然是整数。第二，算法不能保证在有限步内结束。如果能在有限步内结束，那么[[分数|分数]]{{math|1={{sfrac|''a''|''b''}}}}是一个[[有理数|有理数]]，即：

: {{math|1={{sfrac|''a''|''b''}} ={{sfrac| ''mg''|''ng''}} = {{sfrac|''m''|''n''}}}}

于是我们可以写出它的有限[[连分数|连分数]]形式：{{math|1={{nowrap|[''q''<sub>0</sub>; ''q''<sub>1</sub>, ''q''<sub>2</sub>, …, ''q''<sub>''N''</sub>]}}}}。如果算法无法结束，那么{{math|1={{sfrac|''a''|''b''}}}}是[[无理数|无理数]]，可以写成无限的连分数形式：{{math|1={{nowrap begin}}[''q''<sub>0</sub>; ''q''<sub>1</sub>, ''q''<sub>2</sub>, …]{{nowrap end}}}}。无限连分数的一个例子是：[[黄金分割比|黄金分割比]]{{math|1={{nowrap begin}}''φ'' = [1; 1, 1, …]{{nowrap end}}}}和[[2的算術平方根|2的算術平方根]]：{{#tag:math|{{根号|2|use math=yes|in math=yes}} = [1; 2, 2, \ldots]}}。通常，算法能够结束的可能性是很低的，因为对于实数{{math|''a''和''b''}}，几乎所有{{math|1={{sfrac|''a''|''b''}}}}都是无理数。

如果算法不结束，也可以在第''k''步时终止计算，得到近似连分数{{nowrap|[''q''<sub>0</sub>; ''q''<sub>1</sub>, ''q''<sub>2</sub>, …, ''q''<sub>''k''</sub>]}}。终止时的''k''越大，则近似越准确。连分数''m''/''n''的分子和分母互素并满足下式：
{{math|1=
:''m''<sub>''k''</sub> = ''q''<sub>''k''</sub> ''m''<sub>''k''−1</sub> + ''m''<sub>''k''−2</sub>
:''n''<sub>''k''</sub> = ''q''<sub>''k''</sub> ''n''<sub>''k''−1</sub> + ''n''<sub>''k''−2</sub>
}}
其中递归的初始值是{{math|1=''m''<sub>−1</sub> = ''n''<sub>−2</sub> = 1，''m''<sub>−2</sub> = ''n''<sub>−1</sub> = 0}}。{{math|1={{sfrac|''m''<sub>''k''</sub>|''n''<sub>''k''</sub>}}}}是{{math|1={{sfrac|''a''|''b''}}}}在分母是''n''<sub>''k''</sub>的数中最精确的[[有理数|有理数]]近似值：

:<math> 
\left|\frac{a}{b} - \frac{m_k}{n_k}\right| < \frac{1}{n_k^2}
</math>

=== 多项式 ===
只含有一个变量''x''的多项式可以和整数一样进行加法、乘法和分解為[[不可約多项式|不可約多项式]]（也就是多项式中的“素数”）。两个多项式''a''(''x'')和''b''(''x'')的最大公约数''g''(''x'')定义为它们[[因式分解|分解]]之后共有的不可約因式的乘积，这可以用辗转相除法进行计算。<ref name="Lang_1984" >{{cite book | author = [[塞尔日·兰|塞尔日·兰]] | year = 1984 | title = Algebra | url = https://archive.org/details/algebra0000lang | edition = 2nd | publisher = Addison–Wesley | location = Menlo Park, CA | isbn = 0-201-05487-6 | pages = [https://archive.org/details/algebra0000lang/page/190 190]–194}}</ref>对于多项式的算法和整数的算法很相似，在每个步骤''k''，计算出满足以下递归式的商多项式''q''<sub>''k''</sub>(''x'')和余数多项式''r''<sub>''k''</sub>(''x'')：

:{{math|1= ''r''<sub>''k''−2</sub>(''x'') = ''q''<sub>''k''</sub>(''x'') ''r''<sub>''k''−1</sub>(''x'') + ''r''<sub>''k''</sub>(''x'')}}

其中''r''<sub>−2</sub>(''x'') = ''a''(''x'')，''r''<sub>−1</sub>(''x'') = ''b''(''x'')。所选择的商式必须能使''q''<sub>''k''</sub>(''x'') ''r''<sub>''k''−1</sub>(''x'')的首项系數和''r''<sub>''k''−2</sub>(''x'')的相等，这样才能保证每个余数的次数小于前一个余数（deg[''r''<sub>''k''</sub>(''x'')] < deg[''r''<sub>''k''−1</sub>(''x'')]）。因为非零多项式的次数是非负整数，并且在每一步都减小，所以辗转相除法的计算一定能在有限步内结束。最后一个非零余数即是两个多项式''a''(''x'')和''b''(''x'')的最大公约数。<ref>Cox, pp. 37–46.</ref>

例如，有如下两个四次多项式，都可以分解成两个二次多项式的乘积：

: {{math|1=''a''(''x'') = ''x''<sup>4</sup> − 4''x''<sup>3</sup> + 4 ''x''<sup>2</sup> − 3''x'' + 14 = (''x''<sup>2</sup> − 5''x'' + 7)(''x''<sup>2</sup> + ''x'' + 2)}}

和

: {{math|1=''b''(''x'') = ''x''<sup>4</sup> + 8''x''<sup>3</sup> + 12''x''<sup>2</sup> + 17''x'' + 6 = (''x''<sup>2</sup> + 7''x'' + 3)(''x''<sup>2</sup> + ''x'' + 2)}}.

{{math|1=''a''(''x'')除以''b''(''x'')}}得到余数：

:<math>r_0(x) = x^3 + \frac{2}{3} x^2 + \frac{5}{3} x - \frac{2}{3}</math>

在下一步中，''b''(''x'')除以''r''<sub>0</sub>(''x'')得到''r''<sub>1</sub>(''x'') = ''x''<sup>2</sup> + ''x'' + 2。最终，''r''<sub>0</sub>(''x'')除以''r''<sub>1</sub>(''x'')得到的余数为0，所以''r''<sub>1</sub>(''x'')是''a''(''x'')和''b''(''x'')的最大公约数，这和它们因式分解的结果相符合。

上文所述的很多应用也适用于多项式。<ref>Schroeder, pp. 254–259.</ref>辗转相除法可以解多项式的线性丢番图方程和中国剩余定理，也可以用来定义多项式的连分数展开式。

多项式的辗转相除法也有其他应用，如[[施图姆定理|施图姆定理]]，一个用于计算多项式在给定区间内的实根个数的方法。这被应用于其他领域，如[[控制论|控制论]]的[[劳斯-赫尔维茨稳定性判据|劳斯-赫尔维茨稳定性判据]]。

最后，多项式的系数不必局限于整数、实数、甚至复数。这些系数可以是其他[[域_(数学)|域]]中的元素，如[[#乘法逆和RSA算法|上文]]所述的有限域GF(''p'')。从辗转相除法得出的结论也可以直接推广至这类多项式。<ref name="Lang_1984" />

=== 高斯整数 ===
[[File:Gaussian_primes.png|thumb]]的分布，其中''u''<sup>2</sup> + ''v''<sup>2</sup>小于500。]]

高斯整数是满足α = ''u'' + ''vi''的复数，其中''u''和''v''是普通[[整数|整数]]，''i''是[[虚数单位|虚数单位]]（-1的平方根）。<ref name="Stillwell_2003" />通过在高斯整数中定义辗转相除法，根据上文[[#贝祖等式|贝祖等式]]可以证明高斯整数的惟一分解。<ref name="Gauss_1832">{{cite journal | author = [[卡爾·弗里德里希·高斯|Gauss CF]] | date = 1832 | title = Theoria residuorum biquadraticorum | journal = Comm. Soc. Reg. Sci. Gött. Rec. | volume = 4}} See also ''Werke'', '''2''':67–148.</ref>高斯整数的惟一分解性质在很多应用中都很重要，如计算[[勾股数|勾股数]]或者证明[[费马平方和定理|费马平方和定理]]。<ref name="Stillwell_2003">{{cite book | author = [[John_Stillwell|Stillwell J]] | year = 2003 | title = Elements of Number Theory | publisher = Springer-Verlag | location = New York | isbn = 0-387-95587-9 | pages = 101–116}}</ref>辗转相除法用于这些应用很方便，但并非必不可少，一些定理也可以由其他方式证明。

对于两个高斯整数α和β的辗转相除法和普通整数只有两个区别。像整数一样，算法的第''k''步计算出商''q''<sub>''k''</sub>和余数''r''<sub>''k''</sub>：

: {{math|1=''r''<sub>''k''</sub> = ''r''<sub>''k''−2</sub> − ''q''<sub>''k''</sub> ''r''<sub>''k''−1</sub>}}

其中''r''<sub>''k''−2</sub> = α，''r''<sub>''k''−1</sub> = β，每个余数都严格地小于前一个余数，|''r''<sub>''k''</sub>| < |''r''<sub>''k''−1</sub>|。第一个区别即是：商和余数都是高斯整数，也就是[[复数_(数学)|复数]]，所以商''q''<sub>''k''</sub>是透過對實際比例（如複數α/β）的实部和虚部取最近似整數來找出的。第二个区别就是需要定义复数比较大小的方法。所以我们定义一个[[范数|范数]]函数{{nowrap begin}}''f''(''u'' + ''v''i) = ''u''<sup>2</sup> + ''v''<sup>2</sup>{{nowrap end}}，以将高斯整数''u'' + ''vi''转换成普通整数来比较大小。在每个步骤''k''中，余数的范数''f''(''r''<sub>''k''</sub>)必须小于前一个余数的范数''f''(''r''<sub>''k''−1</sub>)。因为范数是非负整数并且在每一步都减小，所以辗转相除法在有限步内一定能结束。最后一个非零余数即是α和β的最大公约数，即能同时整除α和β的整数中范数最大的一个。若把乘以±1或±i的所得結果考慮在內，那麼可以說α和β的最大公约数是唯一的。

很多其他应用如线性丢番图方程、中国剩余定理都適用于高斯整数，高斯整数的连分数也可以用辗转相除法定义。

=== 欧几里得整环 ===
如果一个支持两种[[二元运算|二元运算]]（+ 和 ·）的元素的集合形成一个[[交换环|交换环]]''R''并且可以使用辗转相除法求最大公约数，那么这个集合叫做[[欧几里得整环|欧几里得整环]]。<ref>Stark, p. 290.</ref><ref>Cohn, pp. 104–105.</ref>这两个二元运算不必是平常算数中的加法和乘法，它们可以是更广泛的概念，如[[群|群]]或[[幺半群|幺半群]]中的运算。但是这些运算仍然需要遵守[[交换律|交换律]]、[[结合律|结合律]]、[[分配律|分配律]]。

推广之后的辗转相除法需要一个欧几里得函数，即一個将''R''映射到非负整数集合的函數''f''，使得对于''R''中非零元素''a''和''b''，''R''中存在''q''和''r''满足{{nowrap begin}}''a'' = ''qb'' + ''r''{{nowrap end}}，{{nowrap begin}}''f''(''r'') < ''f''(''b''){{nowrap end}}。例如[[#高斯整数|上文]]中用于高斯整数的范数函数。这个函数''f''可以是数的绝对值或模，也可以是多项式的次数，只要辗转相除法计算过程中它的值不断减小就行，这样算法便能在有限步内结束。这非常依赖于非负整数的[[良序|良序]]性，即每个非空的非负整数集合都有一个最小数。

任何欧几里得整环都满足[[算数基本定理|算数基本定理]]：欧几里得整环中的数可以[[惟一分解|惟一分解]]。所以任何欧几里得整环都是[[惟一分解整环|惟一分解整环]]，但反之不然。欧几里得整环是[[GCD整环|GCD整环]]（任意两元素都存在最大公约数的整环）的子类。也就是说，在某些整环中，两元素存在最大公约数但却不能用辗转相除法计算。欧几里得整环都是[[主理想环|主理想环]]，即其中每一个[[理想_(环论)|理想]]都是[[主理想|主理想]]，但并不是每个主理想环都是欧几里得整环。

欧几里得整环的惟一分解性质在很多场合都非常有用。例如，高斯整数的惟一分解性质可以方便地导出[[勾股数|勾股数]]的公式，或者证明[[费马平方和定理|费马平方和定理]]。<ref name="Stillwell_2003" />惟一分解性质也是加百利·拉梅于1847年基于[[约瑟夫·刘维尔|约瑟夫·刘维尔]]的建议发表的证明[[费马最后定理|费马最后定理]]的尝试中的关键部分。<ref>{{cite journal | author = Lamé G | year = 1847 | title = Mémoire sur la résolution, en nombres complexes, de l'équation A<sup>n</sup> + B<sup>n</sup> + C<sup>n</sup> = 0 | journal = J. Math. Pures Appl. | volume = 12 | pages = 172–184}}</ref>拉梅的尝试需要形如''x'' + ω''y''的数的惟一分解性质，其中''x''和''y''是整数，ω = ''e''<sup>2''i''π/''n''</sup>是1的''n''次方根，即ω<sup>''n''</sup> = 1。虽然这对于某些''n''成立（如''n''=3时的[[艾森斯坦整数|艾森斯坦整数]]），但在其他情况下并非总是正确的。惟一分解性质在[[分圆域|分圆域]]的失效使[[恩斯特·库默尔|恩斯特·库默尔]]发明了[[理想数|理想数]]的概念，随后[[理查德·戴德金|理查德·戴德金]]创造了[[理想_(环论)|理想]]的概念。{{fact|date=March 2010}}

==== 二次整数的惟一分解 ====

[[File:Eisenstein_primes.svg|thumb]]）。]]

[[二次整数环|二次整数环]]对于解释欧几里得整环很有帮助。二次整数是高斯整数的推广，高斯整数中的虚数单位''i''被替换成一个复数ω。二次整数的形式是''u'' + ''v''ω，其中''u''和''v''是整数，ω有两种形式，取决于参数''D''。如果''D''不等于四的倍数加一，那么：

: <math>\omega = \sqrt{D}</math>

如果''D''等于四的倍数加一，那么：

: <math>\omega = \frac{1 + \sqrt{D}}{2}</math>

如果二次整数环有像[[#高斯整数|上文]]用来比较高斯整数的那样的[[范数_(域论)|范数]]函数，那么它就是规范欧几里德整环。只有当''D'' = −11, −7, −3, −2, −1, 2, 3, 5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41, 57或73时，二次整数环才是规范欧几里德整环<ref name="Cohn_1962" />。''D'' = −1和−3时的二次整数分别叫作[[高斯整数|高斯整数]]和[[艾森斯坦整数|艾森斯坦整数]]。

但如果[[范数_(域论)|范数]]函数''f''可以是任何欧几里得函数，那么使二次整数环是欧几里得整环的''D''的可能值到目前为止还不确定。<ref name="Clark_1994">{{cite journal | author = Clark DA | year = 1994 | title = [http://www.springerlink.com/content/6t9u2440402n1346/ A quadratic field which is Euclidean but not norm-Euclidean] | journal = Manuscripta mathematica | volume = 83 | pages = 327–330 | doi = 10.1007/BF02567617}}</ref>是欧几里得整环但不是规范欧几里德整环的第一个例子（''D''=69）发表于1994年<ref name="Clark_1994" />。温伯格於1973年证明，在[[广义黎曼猜想|广义黎曼猜想]]成立的前提下，''D''>0时的二次整数环是欧几里得整环，當且僅當它是一个[[主理想环|主理想环]]。<ref>{{cite journal | author = Weinberger P | chapter = On Euclidean rings of algebraic integers | journal = Proc. Sympos. Pure Math. | volume = 24 | pages = 321–332}}</ref>

=== 非交换环 ===
辗转相除法也可以应用至非交换环，如[[赫尔维茨四元数|赫尔维茨四元数]]。<ref>{{cite book | author = [[John_Stillwell|Stillwell J]] | year = 2003 | title = Elements of Number Theory | publisher = Springer-Verlag | location = New York | isbn = 0-387-95587-9 | pages = 151–152}}</ref>令{{math|''α''和''β''}}表示这样一个环中的两个元素。他们有右公约数''δ''如果{{math|1=''α'' = ''ξδ''，''β'' = ''ηδ''（''ξ''和''η''是环中的元素）}}。同样，他们有左公约数''δ''如果{{math|1=''α'' = ''δξ''，''β'' = ''δη''（''ξ''和''η''是环中的元素）}}。因为乘法不符合交换律，也就有两个版本的辗转相除法，一个计算右公约数，一个计算左公约数。例如对于右公约数，辗转相除法求最大公约数的第一步可以写成：

: {{math|1=''ρ''<sub>0</sub> = ''α'' − ''ψ''<sub>0</sub>''β'' = (''ξ'' − ''ψ''<sub>0</sub>''η'')''δ''}}

其中ψ<sub>0</sub>是商，ρ<sub>0</sub>是余数。对于左公约数，第一步过程是：

:{{math|1= ''ρ''<sub>0</sub> = ''α'' {{minus}} ''βψ''<sub>0</sub> = ''δ''(''ξ'' {{minus}} ''ηψ''<sub>0</sub>)}}

不管是哪一种，这个过程都会重复到最大左公约数或者最大右公约数计算出，像在欧几里得整环中一样，{{math|1=''ρ''<sub>0</sub>}}的“大小”一定小于{{math|β}}，并且對於{{math|1=ρ<sub>0</sub>}}只有有限种的可能大小，这样才能保证算法能够结束。

由辗转相除法得出的大多数结果都适用于非交换环。例如，[[贝祖等式|贝祖等式]]表明最大右公约数可以表示成{{math|1=α}}的倍数和{{math|1=β}}的倍数的和，即，存在{{math|1=σ和τ}}使：

:{{math|1= Γ<sub>右</sub> = ''σα'' + ''τβ''}}

对于最大左公约数，等式如下：

:{{math|1= Γ<sub>左</sub> = ''ασ'' + ''βτ''}}

贝祖等式可以用来解非交换环的丢番图方程。

== 推广至其他数学结构 ==
[[File:TorusKnot3D.png|thumb]]。<ref>{{cite journal | author = Yamada Y | year = 2007 | title = [http://arxiv.org/abs/0708.2316 Generalized rational blow-down, torus knots, and Euclidean algorithm] | publisher = arXiv:0708.2316v1}}</ref>]]

辗转相除法有三个性质保证它不会永远进行下去。第一，它可以写成一系列递归式：

: {{math|1=''r''<sub>''k''</sub> = ''r''<sub>''k''−2</sub> − ''q''<sub>''k''</sub> ''r''<sub>''k''−1</sub>}}

其中每一个余数都比前一个余数小，|''r''<sub>''k''</sub>| < |''r''<sub>''k''−1</sub>|。第二，余数的大小有嚴格下限，如|''r''<sub>''k''</sub>| ≥ 0。第三，小于|''r''<sub>''k''</sub>|的数的数量是有限的。辗转相除法推广至其他数学结构，如{{link-en|纏結|tangle (mathematics)}}<ref>{{cite book| author = [[約翰·何頓·康威|John Horton Conway]]|contribution=An enumeration of knots and links, and some of their algebraic properties|publisher=Pergamon|year=1970|pages=329–358|title=Computational Problems in Abstract Algebra (Proc. Conf., Oxford, 1967)}}</ref>和[[超限数|超限]][[序数|序数]]<ref>{{cite journal | author = Jategaonkar AV | year = 1969 | title = [http://projecteuclid.org/euclid.bams/1183530557 Rings with transfinite left division algorithm] | journal = Bull. Amer. Math. Soc. | volume = 75 | pages = 559–561 | doi = 10.1090/S0002-9904-1969-12242-1}}</ref>时仍保持这种性质。

辗转相除法的一个重要推广是[[代数几何|代数几何]]中[[格罗布纳基|格罗布纳基]]的概念。像前文所述，''a''和''b''的最大公约数''g'' 是它们的[[理想_(环论)|理想]]的生成元素。也就是说，对任何整数''s''和''t''，存在另一个整数''m''使：

: {{math|1=''sa'' + ''tb'' = ''mg''.}}

虽然这对一元多项式也成立，但是对多元多项式就不成立了。<ref>Cox, p. 65.</ref>在多元多项式的情况下，生成元素的有限集合''g''<sub>1</sub>、''g''<sub>2</sub>……可以定义如下：

: {{math|1=''sa'' + ''tb'' = Σ<sub>''k''</sub> ''m''<sub>''k''</sub>''g''<sub>''k''</sub>}}

其中''s''、''t''和''m''<sub>''k''</sub>是多元多项式。<ref>Cox, pp. 73–79.</ref>任何这样的多元多项式''f''可以表示成生成多项式的和加上惟一的余数多项式''r'', 通常叫做多项式''f''的一般形式。

: {{math|1= ''f'' = ''r'' + Σ<sub>''k''</sub> ''q''<sub>''k''</sub>''g''<sub>''k''</sub>}}

虽然商多项式''q''<sub>''k''</sub>可能不惟一。<ref>Cox, pp. 79–86.</ref>这些生成多项式的集合就叫做格罗布纳基。<ref>Cox, p. 74.</ref>

== 参考文献 ==
=== 引用 ===
{{Reflist|30em}}

=== 来源 ===
{{refbegin}}
; 书籍
* {{en}}{{cite book | author = [[Henri_Cohen|Cohen H]] | year = 1993 | title = A Course in Computational Algebraic Number Theory | url = //books.google.com/books?id=hXGr-9l1DXcC | publisher = Springer-Verlag | location = New York | isbn = 0-387-55640-0 }}
* {{en}}{{cite book | author = Cohn H | year = 1962 | title = Advanced Number Theory |url = //books.google.com/books?id=yMGeElJ8M0wC | publisher = Dover | location = New York | isbn = 0-486-64023-X }}
* {{en}}{{cite book | author = [[Thomas_H._Cormen|Cormen TH]], [[Charles_E._Leiserson|Leiserson CE]], [[Ronald_L._Rivest|Rivest RL]], and [[Clifford_Stein|Stein C]] | year = 2001 |title = Introduction to Algorithms |url = //books.google.com/books?id=NLngYyWFl_YC |edition = 2nd |publisher = MIT Press and McGraw–Hill |isbn = 0262032937 }}
* {{en}}{{cite book | author = Cox D, Little J, and O'Shea D | year = 1997 | title = Ideals, Varieties, and Algorithms: An Introduction to Computational Algebraic Geometry and Commutative Algebra |url = //books.google.com/books?id=7eLkq0wQytAC | edition = 2nd | publisher = Springer-Verlag | isbn = 0-387-94680-2 }}
* {{en}}{{cite book | author = [[约翰·彼得·古斯塔夫·勒热纳·狄利克雷|狄利克雷]] |year=1894 | title = Vorlesungen über Zahlentheorie | url = https://archive.org/details/vorlesungenber00lejeuoft |editor=[[理查德·戴德金|Richard Dedekind]] |publisher=Vieweg |location=Braunschweig }}
* {{en}}{{cite book | author = [[戈弗雷·哈罗德·哈代|戈弗雷·哈罗德·哈代]], [[愛德華·梅特蘭·賴特|Wright EM]] [revised by D.R. Heath-Brown and J.H. Silverman]. | date = 2008|url = //books.google.com/books?id=rey9wfSaJ9EC | title =An Introduction to the Theory of Numbers|edition = 6th|publisher=Clarendon Press |location = Oxford | isbn = 0199219869 }}
* {{en}}{{cite book |author=[[高德纳|高德纳]] |year=1997 |title=The Art of Computer Programming（[[计算机程序设计艺术|计算机程序设计艺术]]）, Volume 2: Seminumerical Algorithms|edition=3rd|publisher=Addison–Wesley |isbn = 0201896842 }}
* {{en}}{{cite book | author = [[William_J._LeVeque|LeVeque WJ]] | year = 1977 | title = Fundamentals of Number Theory | publisher = Dover | location = New York | isbn = 0-486-68906-9}}
* {{en}}{{cite book | author = Mollin RA | year = 2008 | title = Fundamental Number Theory with Applications | edition = 2nd|publisher=Chapman & Hall/CRC|location=Boca Raton|isbn = 9781420066593}}
* {{en}}{{cite book | author = [[Øystein_Ore|Ore Ø]] | date = 1948 | title = Number Theory and Its History | url = https://archive.org/details/numbertheoryitsh00ore| publisher = McGraw–Hill | location = New York | isbn = 0486656209 }}
* {{en}}{{cite book | author = Rosen KH | year = 2000 | title = Elementary Number Theory and its Applications | edition = 4th | publisher = Addison–Wesley | location = Reading, MA |isbn = 0201870738 }}
* {{en}}{{cite book | author = [[Manfred_R._Schroeder|Schroeder MR]] | year = 2005 | title = Number Theory in Science and Communication | edition = 4th | publisher = Springer-Verlag |isbn= 0387158006 }}
* {{en}}{{cite book | author = [[Harold_Stark|Stark H]] | year = 1978 | title = An Introduction to Number Theory | url = https://archive.org/details/introductiontonu00star_0| publisher = MIT Press | isbn = 0-262-69060-8 }}
* {{en}}{{cite book | author = [[John_Stillwell|Stillwell J]] | year = 1997 | title = Numbers and Geometry | publisher = Springer-Verlag | location = New York | isbn = 0-387-98289-2 }}
* {{en}}{{cite book | author = Tattersall JJ | year = 2005 | title = Elementary number theory in nine chapters | publisher = [[劍橋大學出版社|Cambridge University Press]] | location = Cambridge | isbn = 9780521850148}}
* {{en}}{{cite book | author1 = Uspensky JV |author2 = Heaslet MA | year = 1939 | title = Elementary Number Theory | publisher = McGraw–Hill | location = New York | isbn = 0070667500 }}
{{refend}}

== 外部链接 ==
{{Commonscat|Euclidean algorithm}}
{{Portal|数学}}
* [http://www.math.sc.edu/~sumner/numbertheory/euclidean/euclidean.html Demonstrations of Euclid's algorithm] {{Wayback|url=http://www.math.sc.edu/~sumner/numbertheory/euclidean/euclidean.html |date=19980113040536 }}
* {{MathWorld | urlname=EuclideanAlgorithm | title=Euclidean Algorithm}}
* [http://www.cut-the-knot.org/blue/Euclid.shtml Euclid's Algorithm] {{Wayback|url=http://www.cut-the-knot.org/blue/Euclid.shtml |date=20060404100134 }} at [[cut-the-knot|cut-the-knot]]
* {{PlanetMath | urlname=EuclidsAlgorithm | title=Euclid's algorithm}}
* [http://www.mathpages.com/home/kmath384.htm The Euclidean Algorithm] {{Webarchive|url=http://arquivo.pt/wayback/20160515140122/http%3A//www.mathpages.com/home/kmath384.htm |date=2016-05-15 }} at MathPages
* [http://www.cut-the-knot.org/blue/EuclidAlg.shtml Euclid's Game] {{Wayback|url=http://www.cut-the-knot.org/blue/EuclidAlg.shtml |date=20060420142707 }} at [[cut-the-knot|cut-the-knot]]
* [http://plus.maths.org/issue40/features/wardhaugh/index.html Music and Euclid's algorithm] {{Wayback|url=http://plus.maths.org/issue40/features/wardhaugh/index.html |date=20070809225041 }}

{{数论算法}}

[[Category:数论算法|Category:数论算法]]
[[Category:数论|Category:数论]]
[[Category:带有伪代码示例的条目|Category:带有伪代码示例的条目]]
[[Category:带有代码示例的条目|Category:带有代码示例的条目]]