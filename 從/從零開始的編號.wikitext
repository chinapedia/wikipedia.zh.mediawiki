{{Multiple issues|
{{Copyedit|time=2020-05-23T10:26:42+00:00}}
{{Unreferenced|time=2020-05-23T10:26:42+00:00}}
}}
'''從0開始編號'''或'''索引開頭為0'''是一種編號方式，在序列其中初始元素的索引被分配到的數字是零，而非一般日常環境中典型的索引開頭為一。從零開始的編號方式，序列中初始的元素有時被稱為第零元素（一般稱為第一元素）；「第零」索引是對應於數字零的[[序數|序數]]。

某些情況下，原來並不屬於該序列的物件或值，但可以自然地放置在其初始元素之前的，或稱其為第零元素。使用零作為序數並未被廣泛接受，因為在缺乏上下文時，對序列的所有後續元素會造成混淆。

從0開始編號的序列在數學符號中是相當常見的，特別是在[[組合數學|組合數學]]中，儘管數學領域的編程語言通常從一開始編號。計算機科學中，現代編程語言中（例如[[C語言|C語言]]）陣列的索引通常從0開始，因此編程人員會用「第零」開始索引，而其他人是使用「第一」開始索引的情況。在數學中對於出現在「第一個」之前的元素，其序數形式有明確的定義時，則使用從零開始的編號不會造成混淆；例如[[函數|函數]]的第零階[[導數|導數]]是進行零次微分獲得的，亦即函數本身。對應於不屬於該序列，但以這樣子命名法在其之前面的元素，或不妥當：所謂「第零階」的導數實際並非導數。然而，正如一階導數在二階導數之前，因此第零階導數（或原始函數本身）也在一階導數之前。

== 計算機編程 ==
=== 起源 ===
計算機編程中列舉數據從零開始編號，主要起因於提供的機器指令，根據條件判斷，程式要能在指令序列之間“跳轉”，這是實作分支結構的關鍵。可用條件以判斷暫存器內容的“零”和“負”為主。最常用於實作迭代的指令譬如“遞減，如果到零就跳轉”。也就是說，任何可列舉的數據結構都在迭代中循環處理，而是否為零的條件判斷，用於控制這些循環的執行（不為零就一直在循環中）。高階編程語言的循環結構（如do-while，repeat-until，for-step-to...）是奠基於這些根本的機器指令。

[[BCPL|BCPL編程語言]]（C編程語言的前身）的創建者，[[马丁·理察德|马丁·理察德]]設計了陣列從0開始的索引方式，作為存取陣列開頭內容的自然位置，因為表示位址的[[指標_(電腦科學)|指針]]p值，用於存取記憶體中的p+0位址；系統分析師Mike Hoye詢問Richards選用該慣例的原因。BCPL最初是用[[IBM_7090|IBM 7094]]機器編譯的；它在編譯時會優化這些陣列索引提供的指針反參考運算（indirection）。

在1982年[[艾兹赫尔·戴克斯特拉|艾兹赫尔·戴克斯特拉]]寫了個相關的說明《為什麼編號應該從零開始》，將陣列索引的上下界以不等式連接，來分析各種設計方案，列舉出嚴格和標準不等式的四種可能組合，展示了他的確信，從零開始編號的陣列不會造成索引範圍重疊，是最好的表示方法，從零開始暗示與實數同樣的[[區間|開，半開和閉區間]]。Dijkstra偏好這慣例的細節以空序列說明，它可以用更自然的（a≤i<a？）不等式來表示，相較於用閉合“區間”的（a≤i≤(a-1)？）不等式。而且以自然的半開“區間”不等式來看，子序列的長度等於上界減去下界（a≤i<b給出(b-a)的i可能值，其中的a，b，i都是自然數）。

=== 編程語言用法 ===
這種設計方案嵌入在許多具影響力的編程語言中，包括C，Java和Lisp。在這三種語言中，序列類型（C陣列，Java陣列和串列，Lisp串列和向量）以數字零為下標開始索引。特別是在C語言中，陣列與指針運算緊密相關，這使得一個更簡單的實現：下標的參考是從陣列起始位置的偏移，因此第一個元素的偏移量就是零。

幾乎所有計算機結構，都藉由位址和偏移量來表示直接引用內存，因此C語法的設計細節使編譯更容易，但代價是一些人工成本。這樣的情況下，使用“第零”作為序數並不是嚴明正確的，而是計算機業界的普遍慣例。其他編程語言如Fortran或COBOL，則有從一開始的陣列索引下標，因為它們意味著高階編程語言，因此它們必須與通常的序數相對應。一些最近的編程語言如Lua，由於同樣原因採用了相同的約定。

零是最低位的無符號整數值，是編程和硬件設計中最基本的類型之一。因此在計算機科學，零經常被當作許多種類的數值遞歸的基本情況。計算機科學中的證明和其他類型的數學推理通常從零開始。由於這些原因，在計算機科學中，從零而非從一開始計數的方式並不少見，時有用例。

黑客和計算機科學家經常喜歡將出版品的第一章，如果其內容特重於介紹的概念，則稱為“第0章”。其中一個經典的例子是在[[C程序设计语言_(书)|K＆R]]的第一版。近年來在許多純數學家中也出現這種特徵，許多構造被定義為從0開始編號。

如果用陣列表示循環，則[[模除|模除]](modulo)函式即可便利地獲得索引，而這會導致零。

=== 數值屬性 ===
使用從零開始的編號範圍表示為半開區間<math>[0, n)</math>，不同於閉合區間<math>[1, n]</math>。在演算法中經常發生的「空」範圍，很難以閉合區間[1,0]來表達。由於這個屬性，從零開始的索引潛在地減少了差一和柵欄錯誤。但另一方面，預先扣除掉重複的計數<math>n</math>，使得從<math>0</math>到<math>n-1</math>（包含）的表達較不直覺。有些作者更偏好從<math>1</math>開始的索引，因為它直接對應了該項目在其它段落中的索引。

零索引慣例的另一個特性是在現代計算機中實作的模運算。通常，模函數將任何模<math>N</math>映射到<math>0, 1, 2,\dots,N-1</math>中的一個數字，其中<math>N\geq1</math>。因此在算法（例如計算雜湊表索引）中的許多公式，當序列從零開始索引時，使用模運算可優雅地以代碼表示。如上文所提及位址/偏移量的底層邏輯，指針操作也能以零索引更優雅地表示。

為了說明，假設<math>a</math>是陣列中第一個元素的內存地址，<math>i</math>是需求元素的索引。要求所需元素的位址，如果從<math>1</math>開始計算索引號，則通過以下表式計算：

<math>a+s \times (i-1)</math>，其中<math>s</math>是每個元素的大小。若從0開始計數，則表達式變為：

<math>a+s \times i</math>，這個簡單的算式可在執行時期更有效率地計算。

然而注意，從1開始索引陣列的語法也能從簡採用約定：每個“陣列位址”以

<math>a'=a-s</math>來表示；

也就是說，不採用陣列中第一個元素的位址，這種語法使用某個“虛擬”元素的位址，緊接在實際的第一個元素之前。從1開始索引的表式如下：

<math>a'+s\times i</math>

因此零索引的執行期效率來自以0暫代第一元素的實際位址，不使用陣列之前的“虛擬”元素位址，此設計策略的優勢。可是，直接位於陣列之前的“虛擬”元素位址，或許是與陣列無關的其他項目，能有作用的位址。這種情況可能導致術語上的混亂。

在零索引方案中第1個元素是“下標零”；同理第12個元素是“下標11”。所以從序數到物件數量的轉換浮現；n個元素的最高索引會是n−1並且被稱為第n元素(表示數量為n，上界索引與計數差一)。反之第一個元素就被稱為第零物件(直接以序號指稱)，以避免混淆。

== 科學 ==
在數學中，許多數字序列或多項式是以非負整數來索引，例如[[白努利數|白努利數]]和[[貝爾數|貝爾數]]。

[[熱力學第零定律|熱力學第零定律]]是在第一和第二定律之後才提出的，但因為比其它定律更為基本，
所以稱為熱力學第零定律。

在生物或醫學實驗開始前的初始測量，被稱為此實驗的第0天。

第零個病患（或指標病例）是流行病學調查群體樣本中的初始病患。

== 參見 ==
* [[差一錯誤|差一錯誤]]{{Translation/Ref|lang=en|article=Zero-based_numbering|oldid=}}

[[Category:序数|*]]