{{noteTA|G1=IT}}
在[[计算机科学|计算机科学]]以及[[数据挖掘|数据挖掘]]领域中， '''先验算法'''（Apriori Algorithm）<ref name=apriori>Rakesh Agrawal and Ramakrishnan Srikant. [http://rakesh.agrawal-family.com/papers/vldb94apriori.pdf Fast algorithms for mining association rules in large databases] {{Wayback|url=http://rakesh.agrawal-family.com/papers/vldb94apriori.pdf |date=20150225213708 }}. Proceedings of the 20th International Conference on Very Large Data Bases, VLDB, pages 487-499, Santiago, Chile, September 1994.</ref>是[[关联规则学习|关联规则学习]]的经典[[算法|算法]]之一。先验算法的设计目的是为了处理包含交易信息内容的[[数据库|数据库]]（例如,顾客购买的商品清单，或者网页常访清单。）而其他的算法则是设计用来寻找无交易信息（如Winepi算法和Minepi算法）或无时间标记（如DNA测序）的数据之间的联系规则。

在[[关联式规则|关联式规则]]中,一般对于给定的项目集合（例如，零售交易集合，每个集合都列出的单个商品的购买信息），算法通常尝试在项目集合中找出至少有C个相同的子集。先验算法采用自底向上的处理方法，即频繁子集每次只扩展一个对象（该步骤被称为候选集产生），并且候选集由数据进行检验。当不再产生符合条件的扩展对象时，算法终止。

先验算法采用[[广度优先搜索|广度优先搜索]]算法进行搜索并采用[[树_(数据结构)|树]]结构来对候选项目集进行高效计数。它通过长度为<math>k-1</math>的候选项目集来产生长度为<math>k</math>的候选项目集，然后从中删除包含不常见子模式的候选项。根据[[向下封闭性引理|向下封闭性引理]],该候选项目集包含所有长度为<math>k</math>的频繁项目集。之后，就可以通过扫描交易数据库来决定候选项目集中的频繁项目集。

虽然先验算法具有显著的历史地位，但是其中的一些低效与权衡弊端也进而引致了许多其他的算法的产生。候选集产生过程生成了大量的子集（先验算法在每次对数据库进行扫描之前总是尝试加载尽可能多的候选集）。并且自底而上的子集浏览过程（本质上为宽度优先的子集格遍历）也直到遍历完所有 <math>2^{|S|}-1</math> 个可能的子集之后才寻找任意最大子集S。

== 例子 ==

一个大型超级市场根据[[最小存货单位|最小存货单位]]（SKU）来追踪每件物品的销售数据。从而也可以得知哪些物品通常被同时购买。通过采用先验算法来从这些销售数据中建立频繁购买商品组合的清单是一个效率适中的方法。假设交易数据库包含以下子集{1,2,3,4}，{1,2}，{2,3,4}，{2,3}，{1,2,4}，{3,4}，{2,4}。每个标号表示一种商品，如“黄油”或“面包”。先验算法首先要分别计算单个商品的购买频率。下表解释了先验算法得出的单个商品购买频率。
{| class="wikitable"
|-
! 商品编号 !! 购买次数
|-
| 1 || 3
|-
| 2 || 6
|-
| 3 || 4
|-
| 4 || 5
|}

然后我们可以定义一个最少购买次数来定义所谓的“频繁”。在这个例子中，我们定义最少的购买次数为3。因此，所有的购买都为频繁购买。接下来，就要生成频繁购买商品的组合及购买频率。先验算法通过修改[[树_(数据结构)|树]]结构中的所有可能子集来进行这一步骤。然后我们仅重新选择频繁购买的商品组合：
{| class="wikitable"
|-
! 商品编号 !! 购买次数
|-
| {1,2} || 3
|-
| {2,3} || 3
|-
| {2,4} || 4
|-
| {3,4} || 3
|}

并且生成一个包含3件商品的频繁组合列表（通过将频繁购买商品组合与频繁购买的单件商品联系起来得出）。在上述例子中，不存在包含3件商品组合的频繁组合。最常见的3件商品组合为{1,2,4}和{2,3,4}，但是他们的购买次数为2，低于我们设定的最低购买次数。

== 算法的局限 ==
因此Apriori算法中的一些低效与权衡弊端也进而引致了许多其他的算法的产生，例如FP-growth算法。候选集产生过程生成了大量的子集（先验算法在每次对数据库进行扫描之前总是尝试加载尽可能多的候选集）。并且自底而上的子集浏览过程（本质上为宽度优先的子集格遍历）也直到遍历完所有 <math>2^{|S|}-1</math> 个可能的子集之后才寻找任意最大子集S。

== 参考资料 ==
{{Reflist}}

[[Category:算法|Category:算法]]
[[Category:数据挖掘|Category:数据挖掘]]