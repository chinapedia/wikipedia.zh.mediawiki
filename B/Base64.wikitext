{{NoteTA
| G1 = IT
| 1 = zh-hans:字符; zh-hant:字元
}}
'''Base64'''（基底64）是一种基于64个可打印字符来表示[[二进制|二进制数据]]的表示方法。由于{{計算結果|log(2,64)}}，所以每6个[[位元|位元]]为一个单元，对应某个可打印字符。3个[[字节|字节]]相當於24个位元，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。在Base64中的可打印字符包括[[拉丁字母|字母]]<code>A-Z</code>、<code>a-z</code>、[[数字|数字]]<code>0-9</code>，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。一些如[[uuencode|uuencode]]的其他编码方法，和之后{{Link-en|BinHex}}的版本使用不同的64字符集来代表6个二进制数字，但是不被稱為Base64。

Base64常用于在通常处理文本[[数据|数据]]的场合，表示、传输、存储一些二进制数据，包括[[MIME|MIME]]的[[电子邮件|电子邮件]]及[[XML|XML]]的一些复杂数据。

== 示例 ==
舉例來說，一段引用自[[托马斯·霍布斯|托马斯·霍布斯]]《[[利维坦_(霍布斯)|利维坦]]》的文句：
<syntaxhighlight>
Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.
</syntaxhighlight>

經過Base64編碼之後變成：
<syntaxhighlight>
TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=
</syntaxhighlight>

编码「Man」的結果為<code>{{base64|Man}}</code>，詳細原理如下：
{| class="wikitable"
|-
! scope="row" | 文本
| colspan="8" align="center" | '''M'''
| colspan="8" align="center" | '''a'''
| colspan="8" align="center" | '''n'''
|-
! scope="row" | ASCII编码
| colspan="8" align="center" | 77
| colspan="8" align="center" | 97
| colspan="8" align="center" | 110
|-
! scope="row" | 二进制位
|0||1||0||0||1||1||0||1||0||1||1||0||0||0||0||1||0||1||1||0||1||1||1||0
|-
! scope="row" | 索引
| colspan="6" align="center" | 19
| colspan="6" align="center" | 22
| colspan="6" align="center" | 5
| colspan="6" align="center" | 46
|-
! scope="row" | Base64编码
| colspan="6" align="center" | '''T'''
| colspan="6" align="center" | '''W'''
| colspan="6" align="center" | '''F'''
| colspan="6" align="center" | '''u'''
|}

在此例中，Base64算法将3个字节编码为4个字符。

===Base64索引表===
{| class="wikitable" style="text-align:center"
|-
! scope="col" | 十进制 !! scope="col" | 二进制 !! scope="col" | 字符
| rowspan="17" |  
! scope="col" | 十进制 !! scope="col" | 二进制 !! scope="col" | 字符
| rowspan="17" |  
! scope="col" | 十进制 !! scope="col" | 二进制 !! scope="col" | 字符
| rowspan="17" |  
! scope="col" | 十进制 !! scope="col" | 二进制 !! scope="col" | 字符
|-
|  0 || 000000 || A || 16 || 010000 || Q || 32 || 100000 || g || 48 || 110000 || w
|-
|  1 || 000001 || B || 17 || 010001 || R || 33 || 100001 || h || 49 || 110001 || x
|-
|  2 || 000010 || C || 18 || 010010 || S || 34 || 100010 || i || 50 || 110010 || y
|-
|  3 || 000011 || D || 19 || 010011 || T || 35 || 100011 || j || 51 || 110011 || z
|-
|  4 || 000100 || E || 20 || 010100 || U || 36 || 100100 || k || 52 || 110100 || 0
|-
|  5 || 000101 || F || 21 || 010101 || V || 37 || 100101 || l || 53 || 110101 || 1
|-
|  6 || 000110 || G || 22 || 010110 || W || 38 || 100110 || m || 54 || 110110 || 2
|-
|  7 || 000111 || H || 23 || 010111 || X || 39 || 100111 || n || 55 || 110111 || 3
|-
|  8 || 001000 || I || 24 || 011000 || Y || 40 || 101000 || o || 56 || 111000 || 4
|-
|  9 || 001001 || J || 25 || 011001 || Z || 41 || 101001 || p || 57 || 111001 || 5
|-
| 10 || 001010 || K || 26 || 011010 || a || 42 || 101010 || q || 58 || 111010 || 6
|-
| 11 || 001011 || L || 27 || 011011 || b || 43 || 101011 || r || 59 || 111011 || 7
|-
| 12 || 001100 || M || 28 || 011100 || c || 44 || 101100 || s || 60 || 111100 || 8
|-
| 13 || 001101 || N || 29 || 011101 || d || 45 || 101101 || t || 61 || 111101 || 9
|-
| 14 || 001110 || O || 30 || 011110 || e || 46 || 101110 || u || 62 || 111110 || +
|-
| 15 || 001111 || P || 31 || 011111 || f || 47 || 101111 || v || 63 || 111111 || /
|}
如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后加上一个或两个<code>=</code>号，代表补足的字节数。也就是说，当最后剩余两个八位(待补足)字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；如果最后剩余一个八位(待补足)字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。
参考下表：<br />

{| class="wikitable"
|-
! scope="row" | 文本（1 Byte）
| colspan="8" align="center" | '''A'''
| colspan="8" align="center" |
| colspan="8" align="center" |
|-
! scope="row" | 二进制位
|0||1||0||0||0||0||0||1||0||0||0||0||0||0||0||0||0||0||0||0||0||0||0||0
|-
! scope="row" | 二进制位（補0）
|0||1||0||0||0||0||0||1||'''0'''||'''0'''||'''0'''||'''0'''||0||0||0||0||0||0||0||0||0||0||0||0
|-
! scope="row" | Base64编码
| colspan="6" align="center" | '''Q'''
| colspan="6" align="center" | '''Q'''
| colspan="6" align="center" |=
| colspan="6" align="center" |=
|-
! scope="row" | 文本（2 Byte）
| colspan="8" align="center" | '''B'''
| colspan="8" align="center" | '''C'''
| colspan="8" align="center" |
|-
! scope="row" | 二进制位
|0||1||0||0||0||0||1||0||0||1||0||0||0||0||1||1||0||0||0||0||0||0||0||0
|-
! scope="row" | 二进制位（補0）
|0||1||0||0||0||0||1||0||0||1||0||0||0||0||1||1||'''0'''||'''0'''||0||0||0||0||0||0
|-
! scope="row" | Base64编码
| colspan="6" align="center" | '''Q'''
| colspan="6" align="center" | '''k'''
| colspan="6" align="center" | '''M'''
| colspan="6" align="center" |=
|}

== 应用 ==

=== MIME ===
在[[MIME|MIME]]格式的[[电子邮件|电子邮件]]中，Base64可以用来将binary的字节序列数据[[字符编码|编码]]成[[ASCII|ASCII]]字符序列构成的文本。使用时，在传输编码方式中指定Base64。使用的字符包括大小写[[拉丁字母|拉丁字母]]各26个、数字10个、加号<code>+</code>和斜杠<code>/</code>，共64个字符，等号<code>=</code>用来作为后缀用途。

完整的Base64定义可见RFC 1421和RFC 2045。编码后的数据比原始数据略长，为原来的<math>\frac{4}{3}</math>。在电子邮件中，根据RFC 822规定，每76个字符，还需要加上一个回车换行。可以估算编码后数据长度大约为原长的135.1%。

转换的时候，将3[[字节|字节]]的数据，先后放入一个24位元的[[缓冲区|缓冲区]]中，先来的[[字节|字节]]占高位。数据不足3字节的话，於緩衝區中剩下的位元用0补足。每次取出6位元（因为<math>2 ^ 6 = 64</math>），按照其值选择<code style="word-break: break-all">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>中的字符作为编码后的输出，直到全部输入数据转换完成。

若原数据长度不是3的[[倍數|倍數]]时且剩下1個輸入數據，則在編碼結果後加2個<code>=</code>；若剩下2個輸入數據，則在編碼結果後加1個<code>=</code>。

=== IRCu ===
在{{Link-en|IRCu}}等软件所使用的P10 [[IRC|IRC]]服务器间协议中，对客户与服务器的消息类型号（client/server numerics）和二进制IP地址采用了Base64编码。消息类型号的长度固定为3字节，故可直接编码为4个字节而不需要加填充。对IP地址进行编码时，则需要在地址前添加一些0比特，使之可以编码为整数个字节。这里所用的符号集与前述MIME的也有所不同，将<code>+/</code>改成了<code>[]</code>。

=== UTF-7 ===
[[UTF-7|UTF-7]]是一个修改版Base64（'''Modified Base64'''）。主要是将[[UTF-16|UTF-16]]的数据，用Base64的方法编码为可打印的[[ASCII|ASCII]]字符序列。目的是传输Unicode数据。主要的区别在于不用等号<code>=</code>补餘，因为该字符通常需要大量的转译。

标准可见 RFC 2152，《A Mail-Safe Transformation Format of Unicode》。

=== URL ===
Base64编码可用于在[[HTTP|HTTP]]环境下传递较长的标识信息。例如，在[[Java|Java]][[持久化|持久化]]系统[[Hibernate|Hibernate]]中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的[[UUID|UUID]]）编码为一个字符串，用作HTTP表单和HTTP GET [[URL|URL]]中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到。

然而，标准的Base64并不适合直接放在URL裡传输，因为URL编码器会把标准Base64中的<code>/</code>和<code>+</code>字符变为形如<code>%XX</code>的形式，而这些<code>%</code>号在存入数据库时还需要再进行转换，因为[[ANSI|ANSI]] [[SQL|SQL]]中已将<code>%</code>号用作通配符。

为解决此问题，可采用一种'''用于URL的改进Base64'''编码，它不在末尾填充<code>=</code>号，并将标准Base64中的<code>+</code>和<code>/</code>分别改成了<code>-</code>和<code>_</code>，这样就免去了在URL编解码和数据库存储时所要做的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。

另有一种'''用于正则表达式的改进Base64'''变种，它将<code>+</code>和<code>/</code>改成了<code>!</code>和<code>-</code>，因为<code>+</code>，<code>*</code>以及前面在IRCu中用到的<code>[</code>和<code>]</code>在[[正则表达式|正则表达式]]中都可能具有特殊含义。

此外还有一些变种，它们将<code>+/</code>改为<code>_-</code>或<code>._</code>（用作编程语言中的标识符名称）或<code>.-</code>（用于[[XML|XML]]中的''Nmtoken''）甚至<code>_:</code>（用于XML中的''Name''）。

=== 其他 ===
* 垃圾訊息傳播者用Base64來避過反[[垃圾郵件|垃圾郵件]]工具，因為那些工具通常都不會翻譯Base64的訊息。
* 在{{Link-en|LDIF}}檔案，Base64用作编码字串。

== 相关事件 ==
*2018年2月电子邮件程序 {{tsl|en|Exim|}} 发现重大漏洞，编号为 [https://exim.org/static/doc/security/CVE-2018-6789.txt CVE-2018-6789] 的[[緩衝區溢位|緩衝區溢位]]漏洞允许攻击者在服务器上远程执行恶意代码。漏洞位于 base64 解码函数中，影响 Exim v4.90.1 之前的所有版本，多达 40 万服务器受到影响。<ref>{{Cite web |url=https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/ |title=存档副本 |accessdate=2018-03-07 |archive-date=2018-07-23 |archive-url=https://web.archive.org/web/20180723183720/https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/ |dead-url=no }}</ref><ref>{{Cite web |url=https://www.solidot.org/story?sid=55710 |title=存档副本 |accessdate=2018-03-07 |archive-date=2018-03-08 |archive-url=https://web.archive.org/web/20180308041715/https://www.solidot.org/story?sid=55710 |dead-url=no }}</ref>

== 参见 ==
*  [[Base58|Base58]]
* {{Link-en|Radix-64}}
* {{Link-en|Ascii85}}
* [[Quoted-printable|Quoted-printable]]
* [[uuencode|uuencode]]
* {{Link-en|yEnc}}
* {{Link-en|8BITMIME}}
* [[URL|URL]]

== 参考资料 ==
{{reflist}}
== 外部链接 ==
*RFC 1421（Privacy Enhancement for Electronic Internet Mail）
*RFC 2045（MIME）
*RFC 3548（The Base16, Base32, and Base64 Data Encodings）在 RFC 4648 中被替代
*[http://josefsson.org/base-encoding/ Home of the Base64 specification, with an online decoder and C99 implementation]{{Wayback|url=http://josefsson.org/base-encoding/ |date=20060619174744 }}

{{pns}}
{{Data Exchange}}

[[Category:标准|Category:标准]]
[[Category:文件格式|Category:文件格式]]
[[Category:进位制|Category:进位制]]
[[Category:数据序列化格式|Category:数据序列化格式]]