
{{NoteTA
|G1=IT

}}
若一個[[程式|程式]]或[[副程式|副程式]]可以「在任意時刻被[[中斷|中斷]]然後作業系統調度執行另一段程式碼，這段程式碼又使用了該副程式不會出錯」，則稱其為'''可重入'''（reentrant 或 re-entrant）的。即當該副程式正在[[執行期|運作時]]，執行线程可以再次進入並執行它，仍然可得到符合設計時所預期的結果。與多執行緒併發執行的[[執行緒安全|執行緒安全]]不同，可重入強調對單一執行緒執行時重新進入同一個子程序仍然是安全的。

可重入概念是在單執行緒作業系統的時代提出的。一個[[副程式|副程式]]的重入，可能由於自身原因，如執行了jmp或者call，類似于子程序的遞迴调用；或者由於作業系统的中斷回應。UNIX系统的[[訊號_(计算机科学)|signal]]的处理，即子程序被中断处理程序或者signal处理程序调用。所以，可重入也可称作“异步信号安全”。这里的异步是指信号中断可发生在任意时刻。 重入的子程序，按照后进先出线性序依次执行。

若一个[[函数|函数]]是可重入的，則该函数應當满足下述条件：
* 不能含有静态（全域）非常量数据。
* 不能返回静态（全域）非常量数据的地址。
* 只能处理由调用者提供的数据。
* 不能依赖于[[单实例模式|单实例模式]]资源的锁。
* 调用({{lang|en|call}})的函数也必需是可重入的。
上述条件就是要求可重入函数使用的所有变量都保存在[[呼叫堆疊|呼叫堆疊]]的目前[[函数栈|函数栈]]（frame）上，因此同一执行线程重入执行该函数时加载了新的函数帧，与前一次执行该函数时使用的函数帧不冲突、不互相覆盖，从而保证了可重入执行安全。

多「用户/对象/进程[[调度_(计算机)|优先级]]」以及[[多进程|多进程]]（Multiple processes），一般会使得对可重入代码的控制变得复杂。同时，IO代码通常不是可重入的，因为他们依赖于像磁盘这样共享的、单独的（類似[[編程|編程]]中的[[靜態|靜態]]、[[全域變數|全域]]）资源。

可重入性是[[函数程式語言|函数程式語言]]的關鍵特性之一。

== 例子 ==
在以下的[[C语言|C语言]]代码中，函数<code>f</code>和函数<code>g</code>都不是可重入的。

<syntaxhighlight lang="c">
 int g_var = 1;
 
 int f()
 {
   g_var = g_var + 2;
   return g_var;
 }
 
 int g()
 {
   return f() + 2;
 }
</syntaxhighlight>

以上代码中，<code>f</code>使用了[[全局变量|全局变量]] ''g_var''，所以，如果两个线程同时执行它并访问<code>g_var</code>，则返回的结果取决于执行的时间。因此，<code>f</code>不可重入。而<code>g</code>调用了<code>f</code>，所以它也不可重入。

稍作修改后，两个函数都是可重入的：

<syntaxhighlight lang="c">
 int f(int i)
 {
   return i + 2;
 }
 
 int g(int i)
 {
   return f(i) + 2;
 }
</syntaxhighlight>

== 与线程安全的关系 ==

可重入与[[线程安全|线程安全]]两个概念都关系到函数处理资源的方式。但是，他们有重大区别
*可重入概念会影响函数的外部接口，而线程安全只关心函数的实现。
** 大多数情况下，要将不可重入函数改为可重入的，需要修改函数接口，使得所有的数据都通过函数的调用者提供。
** 要将非线程安全的函数改为线程安全的，则只需要修改函数的实现部分。一般通过加入[[同步机制|同步机制]]以保护共享的资源，使之不会被几个线程同时访问。
*操作系统背景与CPU调度策略：
**可重入是在单线程操作系统背景下，重入的函数或者子程序，按照后进先出的线性序依次执行完毕。
**多线程执行的函数或子程序，各个线程的执行时机是由操作系统调度，不可预期的，但是该函数的每个执行线程都会不时的获得CPU的时间片，不断向前推进执行进度。
*可重入函数未必是线程安全的；线程安全函数未必是可重入的。
**例如，一个函数打开某个文件并读入数据。这个函数是可重入的，因为它的多个实例同时执行不会造成冲突；但它不是线程安全的，因为在它读入文件时可能有别的线程正在修改该文件，为了线程安全必须对文件加“同步锁”。
**另一个例子，函数在它的函数体内部访问共享资源使用了加锁、解锁操作，所以它是线程安全的，但是却不可重入。因为若该函数一个实例运行到已经执行加锁但未执行解锁时被停下来，系统又启动该函数的另外一个实例，则新的实例在加锁处将转入等待。如果该函数是一个中断处理服务，在中断处理时又发生新的中断将导致资源死锁。<code>fprintf</code>函数就是线程安全但不可重入。

下述例子，是线程安全的，但不是可重入的。
<syntaxhighlight lang="c">
int function()
{
 mutex_lock();
 ...
 function body
 ...
 mutex_unlock();
}
</syntaxhighlight>
多线程执行时，获得了[[互斥锁|互斥锁]]的线程总能获得CPU时间片，向前推进执行进度，最终解开互斥锁，使得别的线程也能获得互斥锁进入[[临界区|临界区]]。但是，如果在单线程背景下第一次执行该函数时已经获得互斥锁进入临界区，这时该函数被重入执行，这将在重新申请互斥锁时被饿死(starvation)，因为获得了互斥锁的该函数的第一次执行将永远没有机会再获得CPU时间片。

== 参见 ==
* {{link-en|引用透明|Referential transparency}}
* [[冪等|冪等]]

== 外部链接 ==
* Article "[http://www-106.ibm.com/developerworks/linux/library/l-reent.html Use reentrant functions for safer signal handling]" by [[Dipak_K_Jha|Dipak K Jha]]
* "[http://publib.boulder.ibm.com/infocenter/systems/topic/com.ibm.aix.genprogc/doc/genprogc/writing_reentrant_thread_safe_code.htm Writing Reentrant and Thread-Safe Code]," from ''AIX Version 4.3 General Programming Concepts: Writing and Debugging Programs'', 2nd edition, 1999.

[[Category:计算机编程|Kechongru]]
[[Category:递归|Category:递归]]