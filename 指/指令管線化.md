{{noteTA
|T=zh-hans:指令流水线;zh-hant:指令管線化;
|G1=IT
|1=zh-hans:指令流水线;zh-hant:指令管線化;
|2=zh-hans:流水线;zh-hant:管線化;
|3=zh-hans:流水线;zh-hant:管線;
|4=zh-hans:触发器;zh-hant:正反器;
|5=zh-hans:逻辑门;zh-hant:邏輯閘;
}}
{{article issues
|expand=2010-07-31
|expert=2010-07-31
}}
[[File:5_Stage_Pipeline.svg|thumb]]機器的五層管線示意圖（IF：讀取指令，ID：指令解碼，EX：執行，MEM：記憶體存取，WB：寫回暫存器）]]

'''指令管線化'''（{{lang-en|Instruction pipeline}}）是為了讓[[計算機|計算機]]和其它[[數位|數位]][[電子裝置|電子裝置]]能夠加速[[指令|指令]]的通過速度（單位時間內被執行的指令數量）而設計的技術。

管線在處理器的內部被組織成層級，各個層級的管線能半獨立地單獨運作。每一個層級都被管理並且鏈接到一條“鏈”，因而每個層級的輸出被送到其它層級直至任務完成。 [[處理器|處理器]]的這種組織方式能使總體的處理時間顯著縮短。

未管線化的架構產生的效率低，因為有些CPU的模組在其他模組執行時是閒置的。管線化雖並不會完全消除CPU的閒置時間，但是能夠讓這些模組並行運作而大幅提升程式執行的效率。

但並不是所有的指令都是獨立的。在一條簡單的管線中，完成一個指令可能需要5層。如右圖所示，要在最佳性能下運算，當第一個指令被執行時，這個管線需要運行隨後4條獨立的指令。如果隨後4條指令依賴於第一條指令的輸出，管線控制邏輯必須插入延遲時脈周期到管線內，直到依賴被解除。而轉發技術能顯著減少延時。憑藉多個層，雖然管線化在理論上能提高效能，優勝於無管線的內核（假設時脈也因應層的數量按比例增加），但事實上，許多指令碼設計中並不會考慮到理想的執行。

==簡介==
[[File:Fivestagespipeline.png|thumb]]
管線化是假設程式執行時有一連串的指令要被執行（垂直座標i是指令集，水平座標表時間t）。絕大多數當代的CPU都是利用[[時脈|時脈]]驅動。

而CPU是由內部的[[邏輯閘|邏輯閘]]與[[正反器|正反器]]組成。當受到時脈觸發時，[[正反器|正反器]]得到新的數值，並且[[邏輯閘|邏輯閘]]需要一段時間來解析出新的數值，而當受到下一個時脈觸發時[[正反器|正反器]]又得到新的數值，以此類推。而藉由邏輯閘分散成很多小區塊，再讓正反器鏈接這些小區塊組，使邏輯閘輸出正確數值的時間延遲得以減少，這樣一來就可以減少指令執行所需要的周期。

舉例來說，典型的[[RISC|RISC]]管線被分解成五個階段，每個階段之間使用正反器鏈接。
#讀取指令
#指令解碼與讀取[[暫存器|暫存器]]
#執行
#記憶體存取
#寫回暫存器

==優缺點==
並非在所有情況下管線技術都起作用。可能有一些缺點。如果一條指令管線能夠在每一個[[時脈週期|時脈週期]]接納一條新的指令，被稱為'''完整管線化'''（fully pipelined）。因管線中的指令需要延遲處理而要等待數個時脈週期，被稱為非完整管線化。

當一名[[程序員|程序員]]（或者組合者/[[編譯器|編譯者]]）編寫[[組合語言|組合代碼]]（或者[[汇编语言|彙編碼]]）時，他們會假定每個指令是循序執行的。而這個假設會使管線化無效。當此現象發生後程式會表現的不正常，而此現象就是'''危害'''。不過目前有提供幾種技術來解決這些危害像是[[轉發|轉發]]與[[延遲|延遲]]等。

===優點===
#减少了处理器执行指令所需要的時脈週期，在通常情況下增加了指令的輸入頻率（issue-rate）。
#一些[[集成電路|集成電路]]（combinational circuits），例如[[加法器|加法器]]（adders）或者[[乘法器|乘法器]]（multipliers），通過添加更多的環路（circuitry）使其工作得更快。如果以管線化替代，能相對地減少環路。

===缺點===
#非管線化的處理器每次（at a time）只執行一個指令。防止[[分支|分支]][[延時|延時]]（事實上，每個分支都會產生延時）和[[串行|串行]]指令被[[并行|并行]]執行產生的問題。設計比較簡單和較低生產成本。
#在執行相同的指令時，非管線化處理器的[[指令傳輸延遲時間|指令傳輸延遲時間]]（The instruction latency）比管線化處理器明顯較短。這是因為管線化的處理器必須在數據路徑（data path）中添加額外[[正反器|正反器]]（flip-flops）。
#非管線化處理器有固定指令[[位寬|位寬]]（a stable instruction bandwidth）。管線化處理器的性能更難以預測，並且不同的程序之間的變化（vary）可能更大。

==示例==
===一般的管線===
[[File:Pipeline,_4_stage.svg|thumb]]
右圖是一般有4層管線的示意圖：

# 讀取指令（Fetch）
# 指令解碼（Decode）
# 執行指令（Execute）
# 寫回執行结果（Write-back）

上方的大灰色格是一連串未執行的指令；下方的大灰色格則是已執行完成的指令；中間的大白色格則是管線。

執行順序如以下列表所示：
{| class="wikitable"
|-
! 時序 !! 執行情況
|-
| 0
| 四條指令等待執行
|-
| 1
|
* 從[[記憶體|記憶體]]（memory）中讀取綠色指令
|-
| 2
| 
* 綠色指令被解碼
* 從主存儲器中讀取紫色指令
|-
| 3
| 
* 綠色指令被執行（事實上運算已經開始（performed））
* 紫色指令被解碼
* 從主存儲器中讀取藍色指令
|-
| 4
|
* 綠色指令的運算結果被寫回到[[寄存器|寄存器]]（register）或者主存儲器
* 紫色指令被執行
* 藍色指令被解碼
* 從主存儲器中讀取紅色指令
|-
| 5
|
* 綠色指令被執行完畢
* 紫色指令的運算結果被寫回到寄存器或者主存儲器
* 藍色指令被執行
* 紅色指令被解碼
|-
| 6
|
* 紫色指令被執行完畢
* 藍色指令的運算結果被寫回到寄存器或者主存儲器
* 紅色指令被執行
|-
| 7
|
* 藍色指令被執行完畢
* 紅色指令的運算結果被寫回到寄存器或者主存儲器
|-
| 8
|
* 紅色指令被執行完畢
|-
| 9
| 所有指令皆執行完畢
|}

====汽泡====
[[File:Pipeline,_4_stage_with_bubble.svg|thumb]]
{{main|氣泡 (電腦運算)}}
指令執行中產生一個“打嗝”（hiccup），在管線中生成一個沒有實效的氣泡。

如右圖，在編號為2的時脈週期中，紫色指令的讀取被延遲，並且在編號為3的時脈週期中解碼層也產生了一個氣泡。所有在紫色指令之後的指令都被延遲執行，而在其之前已經執行了的指令則不受影響。

由於氣泡使指令執行延遲了一個時脈週期，完成全部4條指令的執行共需要8個時脈週期。

而氣泡處對指令的讀取、解碼、執行與寫回都沒有實質影響。這可以使用nop代碼來完成。

==複雜化==

很多處理器的管線深度到5層、7層、10層，甚至31層（像是[[Intel|Intel]] [[Pentium_4#Prescott|Pentium 4 Prescott]]）。[[Xelerator|Xelerator]] [[X10q|X10q]]甚至有多于1000層的管線深度[http://www.mdronline.com/watch/watch_Issue.asp?Volname=Issue+%23171&on=1#item13]。

{| class="wikitable"
|-
! 微架構
（Microarchitecture）
! 管線層數
（Pipeline stages）
|-
| Sony Cell
| 23
|-
| IBM PowerPC 7
| 17
|-
| IBM Xenon
| 19
|-
| AMD Athlon
| 10
|-
| AMD [[Athlon_XP|Athlon XP]]
| 11
|-
| AMD [[Athlon_64|Athlon 64]]
| 12
|-
| AMD [[Phenom|Phenom]]
| 12
|-
| AMD [[Opteron|Opteron]]
| 15
|-
| ARM7TDMI (-S)
| 3
|-
| ARM7EJ-S
| 5
|-
| ARM810
| 5
|-
| ARM9TDMI
| 5
|-
| ARM1020E
| 6
|-
| XScale PXA210/PXA250
| 7
|-
| ARM1136J (F)-S
| 8
|-
| ARM1156T2 (F)-S
| 9
|-
| ARM Cortex-A5
| 8
|-
| ARM Cortex-A8
| 13
|-
| AVR32 AP7
| 7
|-
| AVR32 UC3
| 3
|-
| [[DLX|DLX]]
| 5
|-
| [[Intel_P5|Intel P5]]（[[Pentium|Pentium]]）
| 5
|-
| [[Intel_P6|Intel P6]]（[[Pentium_Pro|Pentium Pro]]）
| 14
|-
| Intel P6（[[Pentium_III|Pentium III]]）
| 10
|-
| [[Intel_NetBurst|Intel NetBurst]]（Willamette）
| 20
|-
| Intel NetBurst（Northwood）
| 20
|-
| Intel NetBurst（Prescott）
| 31
|-
| Intel NetBurst（Cedar Mill）
| 31
|-
| [[Intel_Core微處理器架構|Intel Core]]
| 14
|-
| [[Intel_Atom|Intel Atom]]
| 16
|-
| LatticeMico32
| 6
|-
| R4000
| 8
|-
| StrongARM SA-110
| 5
|-
| SuperH SH2
| 5
|-
| SuperH SH2A
| 5
|-
| SuperH SH4
| 5
|-
| SuperH SH4A
| 7
|-
| [[UltraSPARC|UltraSPARC]]
| 9
|-
| [[UltraSPARC_T1|UltraSPARC T1]]
| 6
|-
| [[UltraSPARC_T2|UltraSPARC T2]]
| 8
|-
| [[WinChip|WinChip]]
| 4
|-
| [[LC2200_32_bit|LC2200 32 bit]]
| 5
|}

當程式出現分支將不利於過深管線，整條管線將會無效化。為了減輕此狀況，[[分支預測|分支預測]]就變的重要。如果分支預測錯誤，也能夠藉由自行結束預測來避免加速惡化效率。在某些運用上，像是[[超級電腦|超級電腦]]運算，為了能夠將超長管線的運算優勢凸顯出來，會特地將程式寫的極少分支化來避免預測失敗，而且深度的管線化主要是為了能降低每個時脈執行的指令量而設計。當程式經常出現分支，把分支重新排序（像是將更為需要的指令提早放入管線中）而將明顯的降低損失的速度以避免將分支“沖垮”。像是[[gcov|gcov]]程式能夠使用一種[[代碼覆蓋率|覆蓋率檢查]]的技術檢查特定分支的執行頻率，但是這種檢查法經常是最佳化的最後手段。處理能力高的管線會因為很多分支的程式而降低效率，這是因為處理器不知道下一個要讀取的指令是甚麼，而需要等待完成分支指令而讓管線清空。處理完分支之後，下一個指令就要經過所有管線，直到整個指令集的結果出現，而處理器才會再繼續執行。而在極端的狀況下，管線化處理器的效能理論上可能會與未管線化處理器一致，甚至是每層管線都在待命狀態，而且指令經常在管線之中跑來跑去時的效能比較差一些。

由於指令管線化，處理器讀取機器碼時並不會立即執行。因為如此，在很接近的地方執行更新機器碼的動作就可能無法作用，因為這些機器碼已經進入[[預讀輸入隊列|預讀輸入隊列]]內。[[指令快取|指令快取]]又會讓此現象更加惡化。不過這只會在能夠[[自我修改程式碼|自我變更的程式]]出現此現象。

==範例==
===範例一===
一個典型的加法指令可能會寫成像<code>ADD A, B, C</code>，而[[中央處理器|中央處理器]]（CPU）會將[[記憶體|記憶體]]（Memory）內A位置與B位置的數值相加後放到C位置。在管線化處理器內，[[管線|管線]]控制器會將這個指令分拆成一連串微指令：

<pre>
LOAD A, R1
LOAD B, R2
ADD R1, R2, R3
STORE R3, C
LOAD next instruction
</pre>

''R1'', ''R2''和''R3''是CPU內的[[暫存器|暫存器]]（register是CPU裡面能夠快速存取的暫存記憶體）。主存儲器內標註為A位置和B位置之存儲單元中的數值被載入（或稱複製）到暫存器R1和R2中，然後送到加法器中相加，結果輸出到暫存器R3中，R3中的數值再被存儲到主存儲器內標註為C位置的存儲單元。

而且在非管線化的例子，開始驅動加法動作到完成的時間是不變的。

在這個範例中的管線分為3層：載入，執行，存儲。每一步被稱為管線層（或稱管線階段，pipeline stages）。

在非管線化處理器中，同一時間只允許一個層運作，所以必須等待指令執行完畢才能開始執行下一條指令。在管線化處理器中，所有的層能在同一時間處理不同的指令。當一條指令在執行層，另外一條指令在解碼層，第三條指令在讀取層。

管線沒有減少執行指令所花費的時間；它增加了在同一時間被處理的指令數量，並且減少了完成指令之間的延遲。隨着處理器中管線層的數量增加，能在同一時間被處理的指令數量也相應增加，也減少了指令等待處理所產生的延遲。現在生產的微處理器至少有2層管線。<sup>[來源請求]</sup>（[[Atmel_AVR|Atmel AVR]]與[[PIC微控制器|PIC微控制器]]都有2層管線）Intel Pentium 4處理器有20層管線。

===範例二===
以下表格具體列出3層管線理論：

{| class="wikitable"
|-----
! 管線層（Stage）
! 說明（Description）
|-----
| 讀取（Load） || 從主存儲器中讀取指令
|-----
| 執行（Execute） || 執行指令
|-----
| 存儲（Store） || 將執行結果存儲到主存儲器和/或者暫存器
|}

以[[組合語言|組合語言]]表示將會被執行的指令列表：
<pre>
	LOAD  #40, A      ;讀取40載入A內
	MOVE  A, B        ;將A內的數據複製到B內
	ADD   #20, B      ;將B內的數據與20相加
	STORE B, 0x300    ;將B內的數據儲存到地址為0x300的存儲器單元
</pre>

代碼的執行循序如下：

{| class="wikitable"
|+第1週期
|-----
! 讀取
! 執行
! 儲存
|-----
| LOAD ||   ||  
|}

從主存儲器中讀取LOAD指令。

{| class="wikitable"
|+第2週期
|-----
! 讀取
! 執行
! 儲存
|-----
| MOVE || LOAD ||  
|}

LOAD指令被執行，同時從主存儲器中讀取MOVE指令。

{| class="wikitable"
|+第3週期
|-----
! 讀取
! 執行
! 儲存
|-----
| ADD || MOVE || LOAD
|}

LOAD指令在存儲層（Store stage），LOAD指令的執行結果#40（the number 40）將被存儲到暫存器A。同時，MOVE指令被執行。MOVE指令必須等待LOAD指令執行完畢才能將暫存器A中的內容移動到暫存器B中。

{| class="wikitable"
|+第4週期
|-----
! 讀取
! 執行
! 儲存
|-----
| STORE || ADD || MOVE
|}

STORE指令被載入，同時MOVE指令執行完畢，並且ADD指令被執行。

注意! 有時候，一個指令會依賴於其他指令的執行結構（例如以上的MOVE指令）。當一個指令因為操作數而需引用一個特定的位置，讀取（作為輸入）或者寫入（作為輸入），執行那些指令的循序不同於程序原本的執行循序能導致[[冒險_(計算機體系結構)|冒險]]（hazards）。現時有機種技術用於預防危害，或者繞過（working around）它們。

==參見==
* [[等待狀態|等待狀態]]
* [[傳統的RISC管線|傳統的RISC管線]]
* [[管線|管線]]
* [[並行運算|並行運算]]
* [https://web.archive.org/web/20070927195431/http://x86.org/articles/branch/branchprediction.htm Pentium家族的分支預測]

==外部連結==
* [http://arstechnica.com/articles/paedia/cpu/pipelining-1.ars/1 來自ArsTechnica的管線化相關文章]

[[Category:Instruction_processing|Pipeline]]

{{CPU_technologies}}