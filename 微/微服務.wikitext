{{NoteTA|G1=IT}}
'''微服務'''（{{lang-en|Microservices}}）是一種[[软件架构|軟體架構風格]]，它是以專注於單一責任與功能的小型功能區塊 (Small Building Blocks) 為基礎，利用模組化的方式組合出複雜的大型應用程式，各功能區塊使用與語言無關 (Language-Independent/Language agnostic）的[[应用程序接口|API]]集相互通訊。

微服務的起源是由 Peter Rodgers 博士於 2005 年度雲端運算博覽會提出的微 Web 服務（Micro-Web-Service）開始，Juval Löwy 則是與他有類似的前導想法，將類別變成細粒服務（granular services），以作為[[微软|微软]]下一階段的軟體架構，其核心想法是讓服務是由類似 Unix 管道的存取方式使用，而且複雜的服務背後是使用簡單 [[URI|URI]] 來開放介面，任何服務，任何細粒都能被開放（exposed）。這個設計在 HP 的實驗室被實現，具有改變複雜軟體系統的強大力量。

2014年，[[Martin_Fowler|Martin Fowler]] 與 [[James_Lewis|James Lewis]] 共同提出了微服務的概念，定義了微服務是由以單一應用程式構成的小服務，自己擁有自己的进程與輕量化處理，服務依業務功能設計，以全自動的方式部署，與其他服務使用[[超文本传输协议|HTTP API]]通訊。同時服務會使用最小的規模的集中管理 (例如 [[Docker|Docker]]) 能力，服務可以用不同的程式語言與資料庫等元件實作<ref>{{Cite web |url=http://martinfowler.com/articles/microservices.html |title=Microservices: A definition of this new architectural term |access-date=2016-03-18 |archive-date=2018-02-14 |archive-url=https://web.archive.org/web/20180214171522/https://martinfowler.com/articles/microservices.html |dead-url=no }}</ref>。

== 概念 ==

微服務是一種以業務功能為主的服務設計概念，每一個服務都具有自主運行的業務功能，對外開放不受語言限制的 API (最常用的是 HTTP)，應用程式則是由一個或多個微服務組成。

微服務的另一個對比是'''[[單體式應用程式|單體式應用程式]]'''。單體式應用表示一個應用程式內包含了所有需要的業務功能，並且使用像[[主從式架構|主從式架構]]（Client/Server）或是{{tsl|en|Multitier architecture|多層次架構}}（N-tier）實作，雖然它也是能以分散式應用程式來實作，但是在單體式應用內，每一個業務功能是不可分割的。若要對單體式應用進行擴展則必須將'''整個'''應用程式都放到新的運算資源（如：虛擬機器） 內，但事實上應用程式中最吃耗費資源、需要運算資源的僅有某個業務部份（例如跑分析報表或是數學演算法分析），但因為單體式應用無法分割該部份，因此無形中會有大量的資源浪費的現象。

微服務運用了以業務功能的設計概念，應用程式在設計時就能先以業務功能或流程設計先行分割，將各個業務功能都獨立實作成一個能自主執行的個體服務，然後再利用相同的協定將所有應用程式需要的服務都組合起來，形成一個應用程式。若需要針對特定業務功能進行擴充時，只要對該業務功能的服務進行擴展就好，不需要整個應用程式都擴展，同時，由於微服務是以業務功能導向的實作，因此不會受到應用程式的干擾，微服務的管理員可以視運算資源的需要來配置微服務到不同的運算資源內，或是佈建新的運算資源並將它配置進去。

雖然使用一般的[[伺服器虛擬化|伺服器虛擬化]]技術就能應用於微服務的管理，但容器技術 (Container Technology) 如 [[Docker|Docker]] 會更加地適合發展微服務的運算資源管理技術。

== 規劃 ==
[[File:Microservice_Databases.png|缩略图]]
微服務的規劃與'''[[單體式應用程式|單體式應用程式]]'''十分不同，微服務中每個服務都需要避免與其他服務有所牽連，且都要能夠自主，並在其他服務發生錯誤時不受干擾。[[File:Microservice Databases with a new service.png|缩略图|361x361像素|如果資料庫都是分開的，那麼新服務上線時就會遇到資料庫為空的窘境。我們並不能從另一個服務複製資料過來，因為我們無法確定該服務擁有最新的資料。

此時應該從事件存儲中心重播所有事件，如此一來就可以找回先前的所有、最新的資料。
]]
=== 資料庫 ===
微服務理念中有數個資料庫的規劃方式。
* 每個服務都各有一個資料庫，同屬性的服務可共享同個資料庫。
* 所有服務都共享同個資料庫，但是不同表格，並且不會跨域存取。
* 每個服務都有自己的資料庫，就算是同屬性的服務也是，資料庫並不會共享。
資料庫並不會只存放該服務的資料，而是「'''該服務所會用到的所有資料'''」。更深層一點的舉例：假設有個文章服務，而這個服務可能會需要判斷使用者的帳號⋯⋯等。那麼文章服務的資料庫就可以放入使用者的部分資料。此舉是為了避免服務之間的相依性，避免文章服務呼叫使用者服務。

==== 資料庫的可棄性 ====
實踐微服務有許多的做法，但其中一種做法是將資料庫作為'''短期'''的儲存空間而不是儲存長期的資料。這意味著資料庫可以在離線時被清空。因為它們可以在上線時從事件存儲中心恢复，因此也能以記憶體快取（如：[[Redis|Redis]]） 作為資料庫伺服器。但這種做法需要將每個請求當作事件來進行廣播。如此一來就可以從事件存儲中心重播所有的事件來找回所有的資料。

=== 溝通與事件廣播 ===
[[File:NSQ.png|缩略图|306x306像素|NSQ 是一個訊息佇列系統、平台。在微服務中所扮演的角色是將訊息、資料傳遞到其他服務。

此舉是異步執行，所以不需要等到其他服務接收到訊息就能夠執行下一步。這種方式能夠避免服務之間有所牽連、呼叫。
]]
微服務中最重要的就是每個服務的獨立與自主，因此服務與服務之間也'''不應該'''有所溝通。倘若真有溝通，也應採用異步溝通的方式來避免緊密的相依性問題。要達到此目的，則可用下列兩種方式：

==== 事件存儲中心（Event Store） ====
這可以讓你在服務叢集中廣播事件，並且在每個服務中監聽這些事件並作處理，這令服務之間沒有緊密的相依性，而這些發生的事件都會被保存在事件存儲中心裡。這意味著當微服務重新上線、部署時可以重播（Replay）所有的事件。這也造就了微服務的資料庫隨時都可以被刪除、摧毀，且不需要從其他服務中取得資料。

==== 訊息佇列（Message Queue） ====
這令你能夠在服務叢集中廣播消息，並傳遞到每個服務中。具有這個功能的像是 NSQ 或是 [[RabbitMQ|RabbitMQ]]。你能夠在 A 服務上廣播一個「建立新使用者」的事件，這個事件可以順便'''帶有'''新使用者的資料。而 B 服務可以'''監聽'''這個事件並在接收到之後有所處理。這些過程都是異步處理的，這意味著 A 服務並不需要等到 B 服務處理完該事件後才能繼續，而這也代表 A 服務無法取得 B 服務的處理結果。與事件存儲中心近乎相似，但有所不同的是：訊息佇列並'''不會'''保存事件。一旦事件被消化（接收）後就會從佇列中消失，這很適合用在像發送歡迎信件的時機。

=== 服務探索 ===
單個微服務在上線的時候，會向服務探索中心（如：Consul）註冊自己的 IP 位置、服務內容，如此一來就不需要向每個微服務表明自己的 IP 位置，也就不用替每個微服務單獨設定。當服務需要呼叫另一個服務的時候，會去詢問服務探索中心該服務的 IP 位置為何，得到位置後即可直接向目標服務呼叫。

這麼做的用意是可以統一集中所有服務的位置，就不會分散於每個微服務中，且服務探索中心可以每隔一段時間就向微服務進行健康檢查（如透過：TCP 呼叫、HTTP 呼叫、Ping），倘若該服務在時間內沒有回應，則將其從服務中心移除，避免其他微服務對一個無回應的服務進行呼叫。

== 內容 ==

一個微服務架構的應用程式有下列特性：
* 每個服務都容易被取代。
* 服務是以能力來組織的，例如使用者介面、前端、推薦系統、帳單或是物流等。
* 由於功能被拆成多個服務，因此可以由不同的程式語言、資料庫實作。
* 架構是對稱而非分層（即生產者與消費者的關係）。

一個微服務架構：

* 適用於具[[持續交付|持續交付]]（Continuous Delivery）的軟體開發流程。
* 與[[服務導向架構|服務導向架構]]（Service-Oriented Architecture）不同，後者是整合各種業務的應用程式，但微服務只屬於一個應用程式。

== 技术 ==

微服务可以用不同的编程语言实现，也可以使用不同的基础设施。<ref>{{Cite web | publisher = Simform | url = https://www.simform.com/microservice-testing-strategies/ | title = Microservices Testing Strategies, Types & Tools: A Complete Guide | access-date = 2021-06-29 | archive-date = 2021-06-29 | archive-url = https://web.archive.org/web/20210629124203/https://www.simform.com/microservice-testing-strategies/ | dead-url = no }}</ref>因此，最重要的技术选择是微服务之间的通信方式（同步、异步、UI集成）以及用于通信的协议（[[RESTful|RESTful]] HTTP、消息、[[GraphQL|GraphQL]]……）。在传统系统中，大多数技术选择，如编程语言，都会影响整个系统。因此，选择技术的方法是完全不同的。<ref>{{cite book|url=http://practical-microservices.com|title=Microservices - A Practical Guide|isbn=978-1717075901|last1=Wolff|first1=Eberhard|date=2018-04-15|access-date=2021-10-01|archive-date=2021-05-01|archive-url=https://web.archive.org/web/20210501230120/https://practical-microservices.com/|dead-url=no}}</ref>

[[Eclipse基金会|Eclipse基金会]]已经发布了开发微服务的规范——Eclipse MicroProfile。<ref>{{cite web|url=https://projects.eclipse.org/projects/technology.microprofile|title=Eclipse MicroProfile|first=Stephanie|last=Swart|date=14 December 2016|website=projects.eclipse.org|access-date=2020-07-20|archive-date=2022-01-19|archive-url=https://web.archive.org/web/20220119172154/https://projects.eclipse.org/projects/technology.microprofile}}</ref>

=== Service mesh ===

在服务网格中，每个服务实例都与一个反向代理服务器实例（称为服务代理、 sidecar代理或sidecar）配对。服务实例和 sidecar 代理共享一个容器，容器由一个容器编排工具（如[[Kubernetes|Kubernetes]]、[[Nomad_(software)|Nomad]]、[[Docker|Docker Swarm]]、[[Mesosphere,_Inc.|DC/OS]]）管理。
服务代理负责与其他服务实例的通信，并支持服务（实例）发现、负载平衡、身份验证和授权、安全通信等功能。

在服务网格中，服务实例及其sidecar代理被称为构成数据平面，其中不仅包括数据管理，还包括请求处理和响应。服务网格还包括一个用于管理服务之间交互的控制平面，这些交互由它们的sidecar代理协调。服务网格架构有几个选项: [[Istio|Istio]]、[[Cloud_Native_Computing_Foundation|Linkerd]]、[[Consul_(software)|Consul]]和其他许多服务网格景观。服务网格管理平面[https://meshery.io Meshery] {{Wayback|url=https://meshery.io/ |date=20220606163613 }}提供跨服务网格部署的生命周期、配置和性能管理。

=== 平台比较 ===
实现[[微服務|微服務]]体系结构非常困难。任何微服务体系结构都需要解决许多问题（见下表）。[[Netflix|Netflix]]开发了一个微服务框架来支持他们的内部应用程序，然后开放了<ref>{{Citation | publisher = Git Hub | url = https://netflix.github.io/ | title = Netflix OSS | accessdate = 2020-07-20 | archive-date = 2021-05-01 | archive-url = https://web.archive.org/web/20210501230145/https://netflix.github.io/ | dead-url = no }}</ref>该框架的许多部分。其中许多工具已经通过[[Spring_Framework|Spring框架]]得到推广——它们已经在Spring Cloud项目的保护伞下重新实现为基于Spring的工具。<ref>{{Citation | url = http://spring.io/projects/spring-cloud | publisher = Spring | title = Cloud | accessdate = 2020-07-20 | archive-date = 2022-06-22 | archive-url = https://web.archive.org/web/20220622003655/https://spring.io/projects/spring-cloud/ }}</ref> 下表显示了Kubernetes生态系统中的实现功能与Spring Cloud世界中的等效功能的比较。<ref>{{Citation | work = Developers | publisher = Red hat | date = 2016-12-09 | url = https://developers.redhat.com/blog/2016/12/09/spring-cloud-for-microservices-compared-to-kubernetes/ | title = Spring Cloud for Microservices Compared to Kubernetes | accessdate = 2020-07-20 | archive-date = 2021-05-01 | archive-url = https://web.archive.org/web/20210501230146/https://developers.redhat.com/blog/2016/12/09/spring-cloud-for-microservices-compared-to-kubernetes/ | dead-url = no }}</ref> Spring Cloud生态系统值得注意的一点是，它们都是基于Java的技术，而Kubernetes是一个多语言运行时平台。

{| class="wikitable" style="font-size: 85%; text-align: left; width: auto;"
|-
! 微服务
! Spring Cloud与Netflix OSS
! Kubernetes
|-
| 配置管理：微服务应用程序的配置需要从代码中进行外部化，并可以通过简单的服务调用进行检索。
| Spring Config Server、Netflix Archaius都支持基于Git存储库的配置位置。Archaius支持配置数据类型。
| Kubernetes ConfigMaps通过服务公开存储在etcd中的配置。 Kubernetes Secrets支持基于服务的安全部署和敏感配置信息（例如密码，证书等）的使用。
|-
| [[服务发现|服务发现]]：维护微服务域中可用于工作的服务实例列表。
| Spring Cloud Eureka允许客户端向其注册，与注册的客户端保持心跳，并将服务名称映射到按服务名称查找服务的客户端的主机名。
| Kubernetes Services提供集群内部可用的服务实例的部署时注册。Ingress是一种机制，通过这种机制，服务可以向集群之外的客户端公开。
|-
| 负载平衡：扩展分布式系统的关键是能够运行一个组件的多个实例。然后要通过负载均衡器将负载分配到这些实例上。
| Spring Cloud Ribbon为服务客户端提供跨服务实例负载平衡的能力。
| Kubernetes Service提供了跨服务实例对服务进行负载平衡的能力。这与Ribbon提供的功能不同。
|-
| API网关：微服务提供的API的粒度通常与服务客户端需要的粒度不同。API网关实现表层，并提供其他服务，如代理、协议转换和其他管理功能。
| Spring Cloud Zuul提供基于配置的API表层
| Kubernetes Service和Ingress resources、Istio、Ambassador是提供南北（进出数据中心）和东西（跨数据中心或云或地区的通信）API网关功能的解决方案。
|-
| 安全问题：许多安全问题推给API网关来实现。对于分布式微服务应用程序，不重新造安全方面的轮子，允许在所有服务共享的组件中进行策略定义和实现是有意义的。
| Spring Cloud Security通过Spring Cloud Zuul解决了许多安全问题
| Kubernetes生态系统提供了像Istio这样的服务网格，该网格能够通过其API网关机制提供安全性。
|-
| 集中化日志记录：拥有一个集中化的日志收集和分析基础设施来管理大量的服务非常重要——其中许多服务是以分布式方式运行的。
| ELK技术栈（[[Elasticsearch|Elasticsearch]]、LogStash、[[Kibana|Kibana]]）
| EFK技术栈（[[Elasticsearch|Elasticsearch]]、[[Fluentd|Fluentd]]、[[Kibana|Kibana]]）
|-
| 集中的度量：一个可以监控单个服务和整个系统的健康和性能的集中区域对于正确的操作是必不可少的。
| Spring Spectator & Atlas
| Heapster, Prometheus, & [[Grafana|Grafana]]
|-
| 分布式跟踪：每个进程的日志记录和度量监视都有其存在的地方，但它们都不能重构事务在跨分布式系统传播时所采用的复杂路径。分布式跟踪是微服务平台必不可少的工具。
| Spring Cloud Sleuth
| Hawkular, [[Linux基金會|Jaeger]]
|-
| 弹性和容错性：分布式系统必须能够围绕故障进行自动路由，并且能够将请求路由到提供最佳响应的服务实例。
| Spring Hystrix, Turbine, & Ribbon
| Health check, [[service_meshes|service meshes]] (example: Istio)<ref>{{Citation | publisher = Kubernetes | date = May 2017 | url = https://kubernetes.io/blog/2017/05/managing-microservices-with-istio-service-mesh/ | title = Managing microservices with the Istio service mesh | accessdate = 2020-07-20 | archive-date = 2021-05-01 | archive-url = https://web.archive.org/web/20210501230125/https://kubernetes.io/blog/2017/05/managing-microservices-with-istio-service-mesh/ | dead-url = no }}</ref>
|-
| 自动伸缩和自我修复：分布式系统通过水平伸缩响应更高的负载: 平台必须检测并自动响应这些条件。此外，系统需要检测故障，并尝试自动重启，无需操作员输入。
| -
| 健康检查、自我修复和自动缩放
|-
| 打包、部署和调度: 大规模系统需要健壮的包管理和部署系统来管理滚动部署或蓝绿色部署，并在必要时进行回滚。调度程序帮助确定可以根据当前条件将一组新服务部署到哪个特定的执行节点。
| Spring Boot, Apache Maven. Spring Cloud系统没有真正的调度程序。
| Docker, Rkt, Kubernetes Scheduler & Deployment, Helm<ref>{{Citation | url = https://helm.sh/ | publisher = Helm | title = The Kubernetes Package Manager | accessdate = 2020-07-20 | archive-date = 2021-05-01 | archive-url = https://web.archive.org/web/20210501230126/https://helm.sh/ | dead-url = no }}</ref>
|-
| 作业管理：控制无人值守的后台程序执行。
| Spring Batch
| Kubernetes Jobs与Scheduled Jobs
|-
| 单例应用程序：限制特定服务作为该服务在整个系统中的唯一实例运行。
| Spring Cloud Cluster
| Kubernetes Pods
|}

== 相關程式語言 ==
* {{tsl|en|Jolie (programming language)||Jolie}}<ref>{{cite web|title=Jolie|url=http://www.jolie-lang.org|access-date=2022-06-26|archive-date=2022-06-09|archive-url=https://web.archive.org/web/20220609213852/https://www.jolie-lang.org/}}</ref>

== 微服務採用者 ==

* [[SOA_Software|Akana]]
* [[Amazon.com|Amazon]]
* [[AnyPresence_JustAPIs|AnyPresence JustAPIs]]<ref name="infoq">{{cite web|url=http://www.infoq.com/news/2015/04/anypresence-justapis-launch?|title=AnyPresence Launches a New API Platform for Mobile and IoT Developers|access-date=2016-03-18|archive-date=2021-05-11|archive-url=https://web.archive.org/web/20210511204905/https://www.infoq.com/news/2015/04/anypresence-justapis-launch/}}</ref>
* [[Apprenda|Apprenda]]<ref name="apprenda">{{cite web|url=http://apprenda.com/blog/enterprise-paas-microservices|title=How Enterprise PaaS can add Critical Value to Microservices|access-date=2016-03-18|archive-date=2015-05-08|archive-url=https://web.archive.org/web/20150508070946/http://apprenda.com/blog/enterprise-paas-microservices/|dead-url=no}}</ref>
* [[Axway|Axway]]
* [http://1060research.com 1060 Research Ltd.] {{Wayback|url=http://1060research.com/ |date=20210120030409 }}
* [[Bluemix|Bluemix]]
* [[Cloud_Foundry|Cloud Foundry]]<ref name="infoqbook">{{cite web|url=http://www.infoq.com/presentations/microservices-pass-spring-cloud-foundry|title=Developing Microservices for PaaS with Spring and Cloud Foundry|access-date=2016-03-18|archive-date=2021-05-01|archive-url=https://web.archive.org/web/20210501230128/https://www.infoq.com/presentations/microservices-pass-spring-cloud-foundry/|dead-url=no}}</ref>
* [[Google|Google]]
* ''[[The_Guardian|The Guardian]]''
* [[Hailo_Taxi|Hailo Taxi]]
* [[HP_Helion|HP Helion]] Development Platform
* [[Jelastic|Jelastic]]
* [[Microsoft_Azure|Microsoft Azure]]
* [[Netflix|Netflix]]<ref name="infoqbook2">{{cite web|url=http://www.infoq.com/resource/minibooks/emag-microservices/en/pdf/Microservices-emag.pdf|title=Microservices}}{{Dead link|date=2018年6月 |bot=InternetArchiveBot |fix-attempted=no }}</ref> 
* [http://nirmata.com Nirmata] {{Wayback|url=http://nirmata.com/ |date=20220616064908 }}<ref name="nirmata">{{cite web|url=http://nirmata.com/tag/microservices/|title=Microservices|access-date=2016-03-18|archive-date=2021-04-13|archive-url=https://web.archive.org/web/20210413103300/https://nirmata.com/tag/microservices/}}</ref>
* [http://www.nearform.com nearForm] {{Wayback|url=http://www.nearform.com/ |date=20220624100650 }}<ref name="nearform">{{cite web|url=http://www.nearform.com/nodecrunch/tag/microservices/|title=Microservices|access-date=2016-03-18|archive-url=https://web.archive.org/web/20160326204339/http://www.nearform.com/nodecrunch/tag/microservices/|archive-date=2016-03-26|dead-url=yes}}</ref>
* [[Riot_Games|Riot Games]]
* [[SoundCloud|SoundCloud]]
* [[優步|Uber]]
* [http://joinednode.com Joined Node] {{Wayback|url=http://joinednode.com/ |date=20210623153204 }}

== 平台實作 ==
* [http://servicecomb.incubator.apache.org/ Apache ServiceComb] {{Wayback|url=http://servicecomb.incubator.apache.org/ |date=20220314211420 }}
* [http://docker.com Docker] {{Wayback|url=http://docker.com/ |date=20220624102536 }}
* [http://azure.microsoft.com/en-us/campaigns/service-fabric/ Microsoft Service Fabric] {{Wayback|url=http://azure.microsoft.com/en-us/campaigns/service-fabric/ |date=20150916070104 }} ([https://azure.microsoft.com/en-us/documentation/articles/service-fabric-overview/ overview] {{Wayback|url=https://azure.microsoft.com/en-us/documentation/articles/service-fabric-overview/ |date=20161018155853 }}, [http://azure.microsoft.com/blog/2015/04/20/announcing-azure-service-fabric-reducing-complexity-in-a-hyper-scale-world/ blog announcement] {{Wayback|url=http://azure.microsoft.com/blog/2015/04/20/announcing-azure-service-fabric-reducing-complexity-in-a-hyper-scale-world/ |date=20150806073841 }})
* [http://www.codeproject.com/Tips/894355/MicroService-Net-Create-Micro-Services-Easily-with MicroService4Net] {{Wayback|url=http://www.codeproject.com/Tips/894355/MicroService-Net-Create-Micro-Services-Easily-with |date=20191130080529 }}
* [[NetKernel|NetKernel]]<ref>{{cite web|title=Products > Platform|url=http://1060research.com/products/|publisher=1060 Research Ltd|accessdate=12 October 2015|archive-date=2015-08-12|archive-url=https://web.archive.org/web/20150812042808/http://www.1060research.com/products/|dead-url=no}}</ref>
* [http://www.nirmata.com Nirmata] {{Wayback|url=http://www.nirmata.com/ |date=20220616064908 }}
* [http://senecajs.org Seneca Microservices Framework and Protocol] {{Wayback|url=http://senecajs.org/ |date=20220321173155 }}
* [http://projects.spring.io/spring-cloud Spring Cloud] {{Wayback|url=http://projects.spring.io/spring-cloud |date=20220129144746 }}
* 微服務測試工具：[[Wilma_(software)|Wilma]]<ref>{{Cite web |url=http://epam.github.io/Wilma/ |title=Wilma documentation |access-date=2016-03-18 |archive-date=2020-09-20 |archive-url=https://web.archive.org/web/20200920191312/http://epam.github.io/Wilma/ }}</ref><ref>{{Cite web |url=https://github.com/epam/Wilma |title=Wilma source code |access-date=2016-03-18 |archive-date=2022-03-27 |archive-url=https://web.archive.org/web/20220327042604/https://github.com/epam/Wilma }}</ref>
* [[Vert.x|Vert.x]]<ref>{{cite web|title=Vertx|url=http://vertx.io|access-date=2022-06-26|archive-date=2021-12-24|archive-url=https://web.archive.org/web/20211224065301/https://vertx.io/}}</ref>
* [http://baratine.io Baratine] {{Wayback|url=http://baratine.io/ |date=20151109161556 }} <ref>{{cite web|title=Baratine|url=http://baratine.io|access-date=2021-10-01|archive-date=2015-11-09|archive-url=https://web.archive.org/web/20151109161556/http://baratine.io/|dead-url=no}}</ref>
* KumuluzEE<ref>{{cite web|title=KumuluzEE|url=http://ee.kumuluz.com|access-date=2022-06-26|archive-date=2022-03-31|archive-url=https://web.archive.org/web/20220331051044/https://ee.kumuluz.com/}}</ref> 
* [[Enduro/X|Enduro/X]]

== 參考 ==

<references />

{{雲端運算}}
{{软件设计模式}}

[[Category:雲端運算|Category:雲端運算]]