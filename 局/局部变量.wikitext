在[[计算机科学|计算机科学]]中，'''局部变量（{{Lang-en|local variables}}）'''是拥有局部[[作用域|作用域]]的[[变量|变量]]。这样的变量只能由声明它的[[子程序|函数]]或[[块|块]]中访问。在仅有两层可见性的[[程序设计语言|程序设计语言]]中，局部变量对应[[全局变量|全局变量]]；另一方面，许多类[[ALGOL|ALGOL]]语言允许任意多层的[[嵌套函数|嵌套函数]]，各自拥有私有变量、函数、常量和类型。

大多数程序设计语言中，局部变量是直接存储在[[调用堆栈|调用堆栈]]上的[[自动变量|自动变量]]。即[[递归函数|递归函数]]调用自己时，局部变量的每一份实例都在不同的[[地址空间|地址空间]]中。于是在当前作用域对变量的声明、写入、读取都不会在其被声明的函数外产生[[副作用|副作用]]。

== 静态局部变量 ==
静态局部变量（{{Lang-en|static local variables}}）是一类特殊的局部变量，许多主流语言（[[C语言|C]]/[[C++|C++]]、[[Visual_Basic|Visual Basic]]、 [[VB.NET|VB.NET]]等）中都有该变量。静态局部变量的值将一直保留，即便一个函数结束，另一个函数开始使用该变量。换言之，它是局部范围（local scope）的[[静态变量|静态变量]]。

静态局部变量 和 静态全局变量（{{Lang-en|static global variables}}）的生命周期一样，它们会存活到程序结束为之。<ref>{{PDFlink|[http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf Current C standard]|3.61 MB<!-- application/pdf, 3788603 bytes -->}} ({{As of|2009|lc=on}}). 注意第32页章节 6.2.4《Storage durations of objects》。</ref> 它们的区别：静态局部变量只可被一个函数访问（function scope）， 静态全局变量 可被所有函数访问（global scope）。<syntaxhighlight lang="c++">
#include <iostream>
using namespace std;

void test()
{
    // var是一个静态局部变量
    static int var = 0;
    ++var;

    cout << var << endl;
}

int main()
{
    
    test(); // 输出1
    test(); // 输出2

    return 0;
}
</syntaxhighlight>[[闭包_(计算机科学)|闭包]]（{{Lang-en|Closure}}）同样可以做到静态局部变量的效果。

== 另见 ==
* [[全局变量|全局变量]]
* {{Tsl|en|Non-local variable|非局部变量}}

== 参考资料 ==
<references />

[[Category:程序架构|Category:程序架构]]
[[Category:变量|Category:变量]]