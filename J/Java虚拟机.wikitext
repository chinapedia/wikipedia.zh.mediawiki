{{noteTA
|T = zh-cn:Java虚拟机; zh-tw:Java虛擬機器;
|G1 = IT
}}
{{Infobox CPU architecture
| name       = Java虚拟机
| designer   = [[昇陽電腦|昇陽電腦]]
| bits       = [[32位元|32位]]
| introduced = 1994
| version    = 
| design     = 
| type       = [[堆疊結構機器|堆疊結構]]及[[加载/存储体系架构|加载/存储体系架构]]
| encoding   = 
| branching  = 
| endianness = [[字节序|大]]
| page size  = 
| extensions = 
| open       = 
| registers  = 
| gpr        = 每个方法的操作数栈（至多65535个）及方法中的局部变量（至多65535个）
| fpr        = 
}}
[[File:Java虚拟机架构.svg|thumb]]

'''Java虛擬機'''（{{lang-en|Java Virtual Machine}}，縮寫為JVM），一種能夠執行[[Java_bytecode|Java bytecode]]的[[虛擬機器|虛擬機器]]，以[[堆疊結構機器|堆疊結構機器]]來進行實做。最早由[[昇陽電腦|昇陽電腦]]所研發并实现第一个实现版本，是[[Java平臺|Java平臺]]的一部份，能夠執行以[[Java|Java]]語言寫作的[[軟體|軟體]][[程式|程式]]。

Java虚拟机有自己完善的[[硬体|硬体]]架构，如[[处理器|处理器]]、[[堆栈|堆栈]]、[[寄存器|寄存器]]等，还具有相应的[[指令|指令]]系统。JVM屏蔽了与具体[[操作系统|操作系统]]平台相关的信息，使得Java[[程序|程序]]只需生成在Java虚拟机上运行的目标代码（[[字节码|字节码]]），就可以在多种平台上不加修改地运行。通过对中央处理器（[[CPU|CPU]]）所执行的软件實作，实现能执行[[编译|编译]]过的Java程序码（[[Applet|Applet]]与应用程式）。

作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件符合JVM对载入编译文件格式要求，任何语言都可以由JVM编译运行。此外，除了[[甲骨文公司|甲骨文]]，也有其他开源或闭源的实现。
==技术规范==
据技术规范所述，Java虚拟机是一部抽象（虚拟）的计算机。但技术规范未定义使用的垃圾回收算法及优化Java虚拟机指令的内部算法，这主要是为了不给实现者带来过多困扰与限制。所有的Java程序仅可在对Java虚拟机的抽象技术规范的具体实现环境中才可运行。<ref>Bill Venners, ''[http://www.artima.com/insidejvm/ed2/index.html Inside the Java Virtual Machine] {{Wayback|url=http://www.artima.com/insidejvm/ed2/index.html |date=20210125092727 }}'' Chapter 5</ref>

自[[Java_SE|Java平台标准版]]（J2SE）5.0起，Java虚拟机的技术规范改为由[[JCP|Java社区流程]]开发制定（JSR 924）。<ref>{{cite web |url=http://www.jcp.org/en/jsr/detail?id=924 |title=The Java Community Process(SM) Program - JSRs: Java Specification Requests - detail JSR# 924 |publisher=Jcp.org |date= |accessdate=2015-06-26 |archive-date=2020-12-24 |archive-url=https://web.archive.org/web/20201224125612/https://jcp.org/en/jsr/detail?id=924 |dead-url=no }}</ref>2006年，JSR 924对技术规范进行了变更，支持更改{{tsl|en|class (file format)|class (文件格式)|类文件格式}}的提议（JSR 202）<ref>{{cite web |url=http://www.jcp.org/en/jsr/detail?id=202 |title=The Java Community Process(SM) Program - JSRs: Java Specification Requests - detail JSR# 202 |publisher=Jcp.org |date= |access-date=2015-06-26 |archive-url=https://web.archive.org/web/20120226185155/http://www.jcp.org/en/jsr/detail?id=202 |archive-date=2012-02-26 |dead-url=yes }}</ref>。Java虚拟机的技术细节以蓝皮书<ref>''[http://java.sun.com/docs/books/vmspec/ The Java Virtual Machine Specification] {{Wayback|url=http://java.sun.com/docs/books/vmspec/ |date=20080709010412 }}'' (the [http://java.sun.com/docs/books/vmspec/html/VMSpecTOC.doc.html first] {{Wayback|url=http://java.sun.com/docs/books/vmspec/html/VMSpecTOC.doc.html |date=20081012060813 }} and [http://java.sun.com/docs/books/vmspec/2nd-edition/html/VMSpecTOC.doc.html second] {{Wayback|url=http://java.sun.com/docs/books/vmspec/2nd-edition/html/VMSpecTOC.doc.html |date=20110925050249 }} editions are also available online).</ref>的形式发布，其前言称：
{{quote|我们希望这份文档中的技术规范足以打造出相兼容的净室版Java虚拟机实现。甲骨文公司提供用于验证Java虚拟机实现是否正常运作的测试项目。{{notetag|1=原文：We intend that this specification should sufficiently document the Java Virtual Machine to make possible compatible clean-room implementations. Oracle provides tests that verify the proper operation of implementations of the Java Virtual Machine.}}}}

甲骨文公司的一款Java虚拟机名为[[HotSpot|HotSpot]]；另一款自[[BEA_Systems|BEA Systems]]继承而来的名为[[JRockit|JRockit]]。[[净室设计|净室设计]]版Java实现有{{tsl|en|Kaffe|Kaffe|Kaffe}}、{{tsl|en|IBM J9|IBM J9|IBM J9}}及Skelmir's CEE-J 。甲骨文公司拥有Java商标权，且可能将其用于认证其他实现是否能完全匹配甲骨文的技术规范。

===类加载器===
{{Main article|Java类加载器}}
Java字节码的组织单位之一是类。类加载器实现必须识别并加载任何为Java类格式的文件。任何实现也可识别其他二进制文件，但必须识别类文件。

类加载器以下列严格顺序执行三个基础任务：

#加载：寻找并导入特定类型的二进制数据；
#链接：执行验证、准备及（可选）解析操作；
#*验证：确保导入类型的正确性。
#*准备：为类变量分配内存并初始化内存为默认值。
#*解析：将类型的符号引用转化为直接引用。
#初始化：调用初始化类变量至正确起始值的Java代码。

通常而言，共有两种类加载器类型：引导类加载器（Bootstrap Class Loader）及用户定义类加载器（User Defined Class Loader）。

每款Java虚拟机实现均必须有加载受信类的引导类加载器。Java虚拟机技术规范不对类加载器寻找类的方式作出指定。

===虚拟机架构===
Java虚拟机以原始值（整数及浮点数）及[[參照|引用]]的方式运行，其本质上是一个32位的机器。64位的<code>long</code>和<code>double</code>类型数据被原生支持，但需要在帧的局部变量或操作数栈中占用两个存储单元（单个单元为32位）。<code>boolean</code>、<code>byte</code>、<code>short</code>及<code>char</code>均为[[符号扩充|符号扩充]]类型（<code>char</code>使用[[符号扩充#零扩展|零扩展]]），且以32位整数的形式（与<code>int</code>类型相同）运作。较小的数据类型仅有少量用于载入、存储于类型转换的特定指令。<code>boolean</code>类型被视为8位<code>byte</code>值，0代表<code>false</code>，1代表<code>true</code>。（虽然《Java虚拟机规范第二版》阐明<code>boolean</code>被认为是一种数据类型，但除[[类型特征|类型特征]]的[[名字修饰|名字修饰]]及boolean数组类型外<code>boolean</code>和<code>byte</code>无太大区别。<code>boolean</code>类型的方法签名为<code>Z</code> 而<code>byte</code>的类型签名为<code>B</code>。布尔型数组搭载数据类型<code>boolean[]</code>，但每个元素使用8个字节，同时Java虚拟机不内置将布尔数据包装成[[位数组|位数组]]的功能，除此之外其与<code>byte</code>数组大同小异。在其他用途中，Java虚拟机实际上不知道<code>boolean</code>类型，因为用于操作布尔型数据的指令与操作<code>byte</code>的指令完全相同。）

Java虚拟机拥有用于存储对象及数组的[[垃圾回收_(計算機科學)|垃圾回收]]堆。代码、常量及其他类数据均存储于“方法区”中。方法区逻辑上是堆的一部分，但虚拟机的实现可能会区分两者，从而可能不对方法区进行垃圾回收。每个Java虚拟机线程均有其自己的[[调用栈|调用栈]]（Java虚拟机栈），用于存储[[呼叫堆疊|帧]]。当调用方法时，Java虚拟机将新建一个帧；方法退出时，帧将自动消除。

每帧均提供一个“操作数栈”及一个“局部变量”数组。操作数栈用于计算操作数和接收被调用方法的返回值，而局部变量与寄存器的用途相同，也用于传递方法参数。故Java虚拟机既是[[堆疊結構機器|堆栈机器]]，也是[[寄存器机|寄存器机]]。

===字节码指令===
{{Main article|Java字节码}}

Java虚拟机拥有进行下列任务的[[指令集架構|指令集]]：[[加载/存储体系架构|加载与存储]]、[[算术|算术]]、[[类型转换|类型转换]]、[[記憶體管理|创建并控制对象]]、[[堆栈|操作数栈管理（放入及拉出）]]、[[分支_(計算機科學)|控制转移（分支）]]、[[子程序|方法调用并返回]]、[[异常处理|抛出异常]]、[[監視器_(程序同步化)|基于监视器的并发]]。

指令集存在的目的是为了保证二进制文件的兼容性。每个独立宿主[[操作系统|操作系统]]需要对Java虚拟机及运行时环境的不同实现。这些Java虚拟机以相同方式语义解析字节码，但具体实现可能有所不同。比模拟字节码更复杂的是在兼容且高效的情况下实现必须映射至不同的宿主操作系统的{{tsl|en|Java Class Library|Java类库|Java核心API}}。

上述指令集通过操作共同的{{vanchor|抽象[[資料類型|数据类型]]|DATA_TYPE}}执行命令，而非以使用特定[[指令集架構|指令集架构]]的[[資料類型|原生数据类型]]的方式运行。

===Java虚拟机语言===
{{Main article|Java虚拟机语言列表}}
Java虚拟机语言是指使用Java虚拟机托管的有效类文件来表示功能的任意编程语言。类文件中含有Java虚拟机指令集（[[Java字节码|Java字节码]]）、符号表及其他辅助信息。类文件是用于表达编译后的类及接口的二进制格式，与硬件及操作系统无关。<ref>{{cite web |url=http://docs.oracle.com/javase/specs/jvms/se7/jvms7.pdf |format=PDF |title=The Java Virtual Machine Specification : Java SE 7 Edition |publisher=Docs.oracle.com |accessdate=2015-06-26 |archive-date=2021-02-04 |archive-url=https://web.archive.org/web/20210204093304/https://docs.oracle.com/javase/specs/jvms/se7/jvms7.pdf |dead-url=no }}</ref>

市面上有多种Java虚拟机语言，既有移植至Java虚拟机的旧语言，也有全新的语言。[[JRuby|JRuby]]及[[Jython|Jython]]可能为最知名的移植语言之二；除此之外，也有从零编写的全新语言，如热门的[[Clojure|Clojure]]、[[Groovy|Apache Groovy]]、[[Scala|Scala]]及[[Kotlin|Kotlin]]。Java虚拟机语言的一大显著特征是都{{tsl|en|Language interoperability|语言互操作性|互相兼容}}，举例来说，Scala库可与Java程序互用，反之亦然。<ref>{{cite web |url=http://www.scala-lang.org/old/faq/4 |title=Frequently Asked Questions - Java Interoperability |author=<!--Staff writer(s); no by-line.--> |website=scala-lang.org |accessdate=2015-11-18 |archive-date=2020-08-09 |archive-url=https://web.archive.org/web/20200809214018/https://www.scala-lang.org/old/faq/4 |dead-url=no }}</ref>

Java 7虚拟机在Java平台上实现了《JSR 292：动态类型语言支持》<ref>{{cite web |url=https://jcp.org/en/jsr/detail?id=292 |title=The Java Community Process(SM) Program - JSRs: Java Specification Requests - detail JSR# 292 |publisher=Jcp.org |date= |accessdate=2015-06-26 |archive-date=2020-12-20 |archive-url=https://web.archive.org/web/20201220200733/https://jcp.org/en/jsr/detail?id=292 |dead-url=no }}</ref>。此特性由{{tsl|en|Da Vinci Machine|达芬奇机器|达芬奇机器}}项目开发完成，旨在延伸Java虚拟机的功能，进而支持除Java外的其他语言。<ref>{{cite web |url=http://openjdk.java.net/projects/mlvm/ |title=Da Vinci Machine project |publisher=Openjdk.java.net |date= |accessdate=2015-06-26 |archive-date=2020-11-11 |archive-url=https://web.archive.org/web/20201111162302/https://openjdk.java.net/projects/mlvm/ |dead-url=no }}</ref><ref>{{cite web |url=http://www.oracle.com/technetwork/articles/javase/dyntypelang-142348.html |title=New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine |publisher=Oracle.com |date= |accessdate=2015-06-26 |archive-date=2018-09-13 |archive-url=https://web.archive.org/web/20180913101203/http://www.oracle.com/technetwork/articles/javase/dyntypelang-142348.html |dead-url=no }}</ref>

== 语言实现 ==
由于JVM并不是专为Java所实现的运行时，实际上只要有其他编程语言的编译器能生成正确Java bytecode文件，则这个语言也能实现在JVM上运行。

以下为原生就在JVM上实现运行的语言：
*[[BBj|BBj]]
*[[BeanShell|BeanShell]]
*[[Ceylon|Ceylon]]
*[[Clojure|Clojure]]
*[[Fantom|Fantom]]
*[[Groovy|Groovy]]
*[[Java|Java]]
*[[Kotlin|Kotlin]]
*[[MIDletPascal|MIDletPascal]]
*[[Scala|Scala]]
*[[Xtend|Xtend]]

以下为实现了相应的JVM编译器的语言及其编译（解释）器，意味着下列语言可以使用基于Java开发的编译器进行编译或解释：
*[[Erlang|Erlang]]：[[Erjang|Erjang]]
*[[JavaScript|JavaScript]]：[[Rhino_(JavaScript引擎)|Rhino]]
*[[Pascal|Pascal]]：[[Free_Pascal|Free Pascal]]
*[[PHP|PHP]]：{{tsl|en|Quercus (software)|Quercus (软件)|Quercus}}
*[[Python|Python]]：[[Jython|Jython]]
*[[REXX|REXX]]：[[NetRexx|NetRexx]]{{NoteTag|1996, possibly the first new language specifically designed to run on the JVM}}
*[[Ruby|Ruby]]：[[JRuby|JRuby]]
*[[Scheme|Scheme]]：{{tsl|en|Kawa (Scheme实现)|Kawa}}
*[[Tcl|Tcl]]：[[Tcl/Java|Jacl]]

== 注释 ==
{{NoteFoot}}

== 参考文献 ==
{{Reflist}}

== 外部链接 ==
* [http://java-virtual-machine.net/download.html Java虚拟机下载] {{Wayback|url=http://java-virtual-machine.net/download.html |date=20210124234328 }}

== 参见 ==
{{Portal box|软件}}
* [[虚拟机|虚拟机]]

{{-}}
{{Java Virtual Machine}}
{{Java (Sun)}}
{{Sun Microsystems}}

[[Category:Java规范请求|Category:Java规范请求]]
[[Category:Java虚拟机|]]
[[Category:Java平台軟體|Category:Java平台軟體]]
[[Category:跨平台軟體|Category:跨平台軟體]]