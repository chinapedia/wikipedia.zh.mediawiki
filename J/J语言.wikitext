{{NoteTA
|G1=IT
}}
{{Infobox programming language
 | name                   = J
 | logo                   = 
 | file ext               
 | paradigm               = [[阵列编程|阵列]]、[[隐式编程|隐式]]、[[函数级编程|函数级]]、[[函数式编程|函数式]]
 | released               = {{Start date and age|1990}}<ref name="j1990">{{cite web|url=https://www.jsoftware.com/papers/J1990.htm|title=APL\?|author=Roger K.W. Hui, Kenneth E. Iverson, {{en-link|Eugene McDonnell|Eugene McDonnell|E. E. McDonnell}}, {{en-link|Arthur Whitney (计算机科学家)|Arthur Whitney (computer scientist)|Arthur T. Whitney}}|year=1990|quote=This paper describes a version of APL based upon the dictionary, but significantly simplified and enhanced, and directly usable on any machine that provides ASCII characters. It also describes salient features of a C implementation that has been tested on several machines, and is available as freeware.}}</ref>
 | designer               = [[Kenneth_E._Iverson|Kenneth E. Iverson]]、{{en-link|许国华 (计算机科学家)|Roger Hui|許國華}}
 | developer              = JSoftware
 | latest release version = J903-release-b
 | latest release date    = {{Start date and age|2022|01|28|df=yes}}<ref>{{cite web |url= https://github.com/jsoftware/jsource/releases/tag/903-release-b |title= 903-release-b |access-date= 2022-04-28 |archive-date= 2022-04-28 |archive-url= https://web.archive.org/web/20220428190200/https://github.com/jsoftware/jsource/releases/tag/903-release-b }}</ref>
 | latest preview version = 
 | latest preview date    = 
 | typing                 = [[类型系统|动态类型]]
 | implementations        = J
 | dialects               = 
 | influenced by          = [[APL语言|APL]]
 | influenced             = Dyalog APL, [http://www.nars2000.org/ NARS2000], [https://github.com/mlochbaum/ILanguage I], [https://mlochbaum.github.io/BQN/ BQN], [https://github.com/DennisMitchell/jellylanguage Jelly], [[SuperCollider|SuperCollider]]<ref name="SuperCollider documentation">{{Cite web |url=http://doc.sccode.org/Reference/Adverbs.html |title=SuperCollider documentation, Adverbs for Binary Operators |accessdate=2020-04-18 |archive-date=2020-12-11 |archive-url=https://web.archive.org/web/20201211174840/https://doc.sccode.org/Reference/Adverbs.html |dead-url=no }}</ref>, [[GNU_Octave|Octave]]<ref>{{cite web|url=https://docs.octave.org/v7.1.0/Broadcasting.html|title=GNU Octave Manual, Broadcasting}}</ref>, [[NumPy|NumPy]]<ref>{{cite web|url=https://numpy.org/doc/stable/user/basics.broadcasting.html|title=NumPy fundamentals, Broadcasting}}</ref>
 | operating system       = [[跨平台|跨平台]]: [[Microsoft_Windows|Windows]], [[Linux|Linux]], [[macOS|macOS]]
 | license                = [[GNU_General_Public_License|GPLv3]]
 | website                = {{URL|www.jsoftware.com}}
 | wikibooks              = 
}}
'''J'''语言，是一种[[阵列编程|阵列编程]][[程序设计语言|语言]]，由[[肯尼斯·艾佛森|肯尼斯·艾佛森]]和{{en-link|许国华 (计算机科学家)|Roger Hui|許國華}}於1990年代初發明，是[[APL语言|APL]]語言的一种方言<ref>{{cite web|url=https://www.jsoftware.com/papers/APLPersonalView.htm|title=A Personal View of APL|year=1991|author=K. E. Iverson|quote=Roger and I then began a collaboration on the design and implementation of a dialect of APL (later named J by Roger), first deciding to roughly follow “A Dictionary of APL” and to impose no requirement of compatibility with any existing dialect. We were assisted by suggestions from many sources, particularly in the design of the spelling scheme (E.B. Iverson and A.T. Whitney) and in the treatment of cells, items, and formatting (A.T. Whitney, based on his work on SHARP/HP and on the dialect A reported at the APL89 conference in New York).}}</ref><ref>{{cite web|title=APL since 1978|url=https://dl.acm.org/doi/pdf/10.1145/3386319|author=Roger K. W. Hui, Morten J. Kromberg|publisher=Proceedings of the ACM on Programming Languages, Volume 4, Issue HOPL|year=2020|quote=In 1989, Iverson, together with Roger Hui and with input from Arthur Whitney, produced J, with a goal of providing a “shareware” APL implementation for use in teaching. The special APL characters were abandoned because it was felt that they require technical solutions which at that time were still prohibitively expensive in an educational environment. ……<br />J was clearly a “rationalization” of SHARP APL. ……<br />ACM SIGAPL, the ACM Special Interest Group on APL, reinterpreted the “APL” in its name in early 2009 as Array Programming Languages, so that J, k, Nial, etc. would be included in its purview.}}</ref>。J语言非常簡潔和強力，在[[數學|數學]]和[[统计学|统计学]]程式設計上十分有效，特別是在需要进行[[矩陣|矩陣]]运算的场合。

==简介==
{{CSS image crop |Image = KEI&Hui.jpg |bSize = 400 |cWidth = 200 |cHeight = 260 |oTop = 30 |oLeft = 80 |Location= right |Description = Ken Iverson（右）和Roger Hui在1996年的照片}}
最初起步于Kenneth E. Iverson在1987年发表的《APL字典》<ref>
{{cite web|url=https://www.jsoftware.com/papers/APLDictionary.htm|author=Kenneth E. Iverson|title=A Dictionary of APL|year=1987|quote=A dictionary should not be read as an introduction to a language, but should rather be consulted in conjunction with other material that uses the language in some context of interest to the reader. Even the general section on grammar, which may be intelligible even to the beginner, should perhaps be studied only after a certain amount of other exposure to the language.<br />On the other hand, a dictionary should not be used only to find the meanings of individual words, but should also be studied to gain an overall view of the language. In particular, the grammar may be profitably reviewed again and again in the light of increased knowledge of the language, and the study of groups of related verbs and adverbs can reveal important relationships otherwise easily overlooked.}}
</ref>，J语言提供[[隐式编程|隐式定义]]机制包括[[秩_(J编程语言)|秩]]、叉子（fork）和{{en-link|函数复合 (计算机科学)|function composition (computer science)|函数复合}}<ref>
{{cite web|url=https://www.jsoftware.com/papers/TacitDefn.htm|title=Tacit Definition|author=Roger K.W. Hui, Kenneth E. Iverson, {{en-link|Eugene McDonnell|Eugene McDonnell|Eugene E. McDonnell}}|year=1991|quote=To appreciate the more general use of tacit definition, it is necessary to understand three key notions of J: cells and rank, forks, and composition.……<br />The conjunction <code>&</code> is called ''with'', and applies to nouns (variables) <code>a</code> and <code>b</code> as well as to verbs <code>f</code> and <code>g</code> as follows:<br /><code><nowiki>  </nowiki>a&g y</code> is <code>a g y</code></br /><code><nowiki>  </nowiki>f&b y</code> is <code>x f y</code><br /><code><nowiki>  </nowiki>f&g y</code> is <code>f g y</code><br /><code>x f&g y</code> is <code>(g x) f (g y)</code><br />……<br />A number of other constructs in J similarly enhance the utility of tacit definitions. The more important are the ''under'' (or ''dual''), ''atop'' (a second form of composition), the power conjunction <code>^:</code>, and further forms of partitions.}}
</ref>，特别是等价于[[组合子逻辑|组合子逻辑]]中[[SKI组合子演算|<code>S</code>组合子]]的钩子（hook）<ref name="hook">
{{cite web|author=Kenneth E. Iverson, {{en-link|Eugene McDonnell}}|title=Phrasal Forms|publisher=APL 89 Conference Proceedings|date=August 1989|url=https://www.jsoftware.com/papers/fork.htm|quote=In [[组合子逻辑|combinatory logic]] one of the most useful primitive combinators is designated by [[SKI组合子演算|<code>S</code>]] [Sch24]. [[哈斯凯尔·柯里|Curry]] defines <code>Sfgx</code> in prefix notation to be <code>fx(gx)</code> [CuFeCr74]. In common mathematical infix notation this would be given by <code>(x)f(g(x))</code>, which one can write in APL as <code>xfgx</code>, and this is the hook form <code>(fg)x</code>. The combinatory logician appreciates this form because of its great expressiveness: it can be shown that <code>S</code>, along with <code>K</code>, the constancy combinator, suffice to define all other combinators of interest [Ro50]. (The constancy combinator <code>K</code> is defined in infix notation so that <code>cKx</code> has the value <code>c</code> for all <code>x</code>.) Users of APL will appreciate the hook for the same reasons. ……<br />[[哈斯凯尔·柯里|Curry]] [Cu31] defines a ''formalizing combinator'', <code>Φ</code>, in prefix notation, such that <code>Φfghx</code> means <code>f(gx)(hx)</code>. In common mathematical infix notation this would be designated by <code>(g(x))f(h(x))</code>. An example of this form is <code>Φ+sin2cos2θ</code>, meaning <code>sin2θ+cos2θ</code>. The fork <code>(f g h)⍵</code> has the same meaning, namely <code>(f⍵)g(h⍵)</code>. Curry named this the formalizing combinator because of its role in defining formal implication in terms of ordinary implication.<br />Iverson and Whitney have made several earlier suggestions of ways to achieve what the fork form provides: the ''scalar operators'' of [Iv78], [Iv79a], [Iv 79b], the ''til'' operator of [Iv82], the ''union'' and ''intersection'' conjunctions of [Iv87], and the ''yoke'' adverb of [Iv88]. Benkard [Bk87] has also suggested a way to achieve the meaning of this form, in his proposal for <code>↑g/(f h)⍺ ⍵</code>, using the notion of ''function pair'' (<code>↑</code> is APL2’s ''first'' function). The present proposal has significant advantages over these earlier ones.}}
</ref>，并介入了作为[[头等对象|头等对象]]的[[动名词|动名词]]（gerund），用以建立控制结构<ref>
{{cite paper|author={{en-link|Robert Bernecky}}, Roger K. W. Hui|title=Gerunds and representations|url=https://dl.acm.org/doi/pdf/10.1145/114054.114059|year=1991|quote=Gerunds, verbal forms that can be used as nouns, are recognized as having utility in the realm of programming languages. We show that gerunds can be viewed as arrays of atomic repmentations of verbs (functions), in a way which is consistent with the syntax and semantics of APL, and which allows verbs to be first class objects in the language. We define derivations of verbs from gerunds in the J dialect of APL, and show how these derivations provide control structures for sequencing, selection (in the sense of generalized forms of CASE or SWITCH statements and IF/THEN/ELSE), iteration (DO UNTIL), recursion, and parallel computation (MIMD, or Multiple Instruction, Multiple Data). We conclude with alternative representations of verbs which are useful in other contexts.}}<br />
{{cite web|url=https://www.jsoftware.com/docs/archive/release/status.htm#v4.0|title=Changes in Version 4.0, 1991 11 23|year=1991|quote=<br />`:1    replaced by u^:v<br />`:4    replaced by m~<br />`:5    replaced by @.}}
</ref>，它常被作为[[隱式編程|隱式編程]]的典范<ref name="train">
{{cite web|title=Tacit programming|url=https://aplwiki.com/wiki/Tacit_programming|quote=Most dialects define a 2-train is an atop, equivalent to the function derived using the Atop operator. …… J instead defines the 2-train as a hook, equivalent to the function derived using the Withe operator.}}</ref>。

為了避免APL使用特殊的字符而遇到的問題，J语言只需基本的[[ASCII|ASCII]]字符集，但使用点号<code>.</code>和冒号<code>:</code>作为“[[词形变化|屈折]]”<ref>{{Cite web |url=http://code.jsoftware.com/wiki/Vocabulary/Words |title=Vocabulary/Words |accessdate=2020-05-18 |archive-date=2016-03-07 |archive-url=https://web.archive.org/web/20160307123518/http://code.jsoftware.com/wiki/Vocabulary/Words |dead-url=no }}</ref>。点号和冒号除了前导着{{en-link|空白字符|Whitespace character}}的情况之外，都与紧前字符形成类似[[三字符组与双字符组|双字符组]]的短字。多数“基础”或“原始”的J单字，都充当数学符号，通过点号或冒号来扩展这些可用基本字符的含义。在其他语言中经常是成对的很多字符，比如<code>[] {} "" `` <></code>，在J语言中被当作单独的字，或者在有屈折的时候，作为多字符字的单字符[[词根|字根]]。

J语言的算符，没有优先级并且最右先行，<code>2 * 3 + 4</code>的结果是<code>14</code>。历史上，APL使用<code>/</code>来指示[[fold_(高阶函数)|fold]]函数，所以<code>+/1 2 3</code>等价于<code>1 + 2 + 3</code>。在APL中，除法被表示为数学[[除号|除号]]{{code|÷}}，它将减号和冒号一起{{en-link|重复打印|overstrike}}在[[EBCDIC|EBCDIC]]和[[ASCII|ASCII]]二者的纸质[[终端|文本终端]]上。J语言使用<code>%</code>表示除法，作为一种可见的近似或提示。

J语言承袭最初于1968年推出的IBM APL\360采用了平坦阵列模型，不支持由NARS（嵌套阵列研究系统）于1981年介入的嵌套阵列模型<ref>
{{cite web|url=https://dl.acm.org/doi/pdf/10.1145/390007.805376|title=Nested arrays, operators, and functions|author=Bob Smith|year=1981|quote=In general, a system with nested arrays extends the power of APL by being able to represent data of non-zero depth. Also, in keeping with the past, the system includes a set of primitive functions and operators, tailor-made for manipulating these new data structures.<br />Continuing the above example, the names of the months of the year are best represented in a 12-item vector whose items are each character vectors. This structure has a depth of one. Note that because the individual names are in separate items, we need no longer resort to artifices like pad characters. Moreover, explicit delimiters are not needed as the separation between items is represented through structure rather than data. This particular representation is called a vector of vectors, and can be created as follows:<br /><code>MONTHS ← ('JANUARY') ('FEBRUARY') ...</code><br />The above line also illustrates strand notation, used to enter a nested vector in a simple and convenient manner. ……<br />Of the several new operators, the only one specific to nested arrays is the each operator(symbol <code>¨</code>), which is monadic as an operator, and produces an ambivalent derived function. It is used to apply the f unction which is its argument to the items of an array to produce corresponding items in the result. For example, to determine the length of the names of the months in the above example, use<br /><code><nowiki>      </nowiki>⍴¨MONTHS</code><br /><code>(7) (8) (5) (5) (3) (4) (4) (6) (9) (7) (8) (8)</code><br />Since monadic rho returns a vector , each item of the above result is a vector (specifically in these cases a one-item vector). The parentheses in the display indicate that the item is not a simple scalar.}}
</ref>，它被IBM APL2采纳<ref>
{{cite web|author={{en-link|Jim Brown (计算机科学家)|Jim Brown (computer scientist)|James A. Brown}}|year=1984|title=The Principles of APL2|publisher=TR 03.247. IBM Santa Teresa Laboratory, San Jose, California|url=https://www.softwarepreservation.org/projects/apl/Papers/PRINCIPLESOFAPL2|quote=The arrays of APL2 are finite rectangular arrays which contain arrays as items. When the term array is used, it means this subset of all possible arrays. ……<br />An array one of whose items is other than a single number or character (a simple scalar) is called a nested array. An array containing only numbers or containing only characters is called a homogeneous array. An array all of whose items are either single numbers or single characters is called a simple array. The arrays of APL1 are simple and homogeneous.<br />In some sense every array in APL2 is nested because it contains other arrays. The term is reserved for those which contain at least one item which is not a single number or character. Thus the universe of arrays is partitioned into two subsets: simple arrays and nested arrays. ……<br />A function is pervasive if pick distributes over it. ……<br />Since the pick function may select an item at an arbitrary depth in a nested array, it may select deep enough to access a simple scalar (because nested arrays have finite depth). Thus a pervasive function may be thought of as applying independently to each simple scalar in its argument(s). ……<br />In APL2 the scalar functions and only the scalar functions are pervasive.}}
</ref>；J语言增加了Kenneth E. Iverson于1978年在《运算符和函数》中提出的盒装数据类型<ref name="box">
{{cite web|url=https://www.jsoftware.com/papers/opfns.htm|author=Kenneth E. Iverson|title=Operators and Functions|year=1978|quote=The enclose function (denoted by <code><</code>) produces a scalar representation of its argument in the sense that the result is of rank zero, and that there exists an inverse function (called disclose, and denoted by <code>></code>) such that <code>a ↔ ><a</code> for all <code>a</code>. Any result producible by an expression which does not employ the enclose function is called a simple array, or is said to be simple.<br />Selection and reshaping functions apply without change to non-simple arrays. However, non-simple arrays are outside the domain of all other functions except for enclose, disclose, and equality (together with those functions such as <code>≠</code> and <code>∊</code> which are defined in terms of equality).<br />The equality function is extended to non-simple scalar arguments as follows:<br />1. <code>(<a)≠a</code> for all <code>a</code><br/>2. If <code>a</code> equals <code>b</code>(in rank, shape, and all elements), then <code>(<a)=(<b)</code> yields <code>1</code><br />……<br />The disclose function is scalar in the sense that it applies to each element of its argument, the new axes disclosed becoming the final axes of the result. ……<br />The disclose function applied to a simple array <code>a</code> produces a result identical to <code>a</code>. Thus <code>(<a)=<>a</code> is a test for whether <code>a</code> is simple.}}
</ref>，它由SHARP APL于1981年在其技术说明SATN-41中介入，并于1983年在I.P. Sharp协会研究报告《理性化APL》中，列入与APL2相比较的限定子集（RS）而著重强调<ref>
{{cite web|url=https://www.jsoftware.com/papers/RationalizedAPL.htm|author=Kenneth E. Iverson|title=Rationalized APL|year=1983|quote=APL2 provides two significant facilities which apply at “depth” in the enclosure structure of an argument, the dyadic pick function, and the pervasive functions. RS provides no primitive corresponding to pick; it could be defined recursively by:<br /><code><nowiki>   pick←''∇('→2+0=⍴⍺'⊃'(>0{⍺){(1↓⍺)∆⍵'⊃'⍵')</nowiki></code><br />……<br />Since pervasiveness is a property assigned to functions, it would, in the framework of RS, be provided by an operator. Such an operator could be applied to any function (defined or derived as well as primitive) and, if defined to be dyadic, could provide greater variety. ……<br />If each essential space in an expression is counted as a character, then the link function and strand notation used to form non-simple vectors from simple vectors require expressions of nearly identical length. ……<br />RS does not include the heterogeneous arrays of APL2, and the production of equivalent constructs requires greater use of enclosure. However, the structure of RS does not preclude their introduction. ……<br />The monadic enclose functions defined in RS (<code><</code>) and in APL2 (<code>⊂</code>) differ in one respect: if <code>s</code> is a simple scalar, then <code>s≡⊂s</code>, but <code>~s≡<s</code>. Although <code><</code> can therefore produce some structures not producible by <code>⊂</code>, the differences between them (in the contexts of the respective systems) cannot, in most cases, be discerned.}}</ref>。

[[秩_(J编程语言)|秩]]是J语言中至关重要的概念<ref>
{{cite web|url=https://www.jsoftware.com/papers/opfns.htm|author=Kenneth E. Iverson|title=Operators and Functions|year=1978|quote=Nuclear Axis Operators － The nuax operator (denoted by <code>⍤</code>) applies to a function left argument and a variable right argument to specify the axes which define the nuclei to which the function is to apply. ……The coax operator <code>⍥</code> is also provided; its argument specifies the axes complementary to the nuclear axes.}}<br />
{{cite web|url=https://www.jsoftware.com/papers/RationalizedAPL.htm|author=Kenneth E. Iverson|title=Rationalized APL|year=1983|quote=In conventional APL, the scalar functions (which apply to scalar elements and produce scalar results) extend to higher rank arrays according to simple general rules; no corresponding general rules exist for the remaining so-called mixed functions. ……<br />Function rank is the most important notion needed to provide a simple and systematic basis for the uniform treatment of all “mixed” or non-scalar functions. ……<br />If <code>f</code> has rank <code>r</code>, then <code>f⍵</code> is determined by applying <code>f</code> to each of the “cells” of shape <code>(-r)↑⍴⍵</code>, producing a common shape <code>s</code> for each, and assembling the whole into a result of shape <code>((-r)↓⍴⍵),s</code>. ……<br />If the function <code>g←f⍤r</code> is to be applied dyadically as well as monadically (the only cases addressed in the preceding sections), then it is necessary that <code>r</code> specify three independent ranks, the monadic, the left, and the right. The general argument <code>r</code> is therefore a three-element vector that specifies the ranks in the order just indicated. Moreover, <code>r</code> is extended by reshape if necessary, so that <code>f⍤r ←→ f⍤(⌽3⍴⌽r)</code>.}}
</ref>。J语言不再支持APL\360的方括号索引，转而支持Kenneth E. Iverson在《运算符和函数》中提出的，采用“出自”（from）运算符的索引机制<ref>
{{cite web|url=https://www.jsoftware.com/papers/opfns.htm|author=Kenneth E. Iverson|title=Operators and Functions|year=1978|quote=We also introduce a form of indexing called from denoted by <code>⌷</code>, ……. The basic definition is:<br /><code>i⌷a ↔ (,a)[⍉(⍴a)⊥⍉i]</code><br />The function <code>⌷</code> distributes over any scalar function; thus, <code>i⌷a+b ↔ (i⌷a)+(i⌷b)</code>.}}<br />
{{cite web|url=https://www.jsoftware.com/papers/RationalizedAPL.htm|author=Kenneth E. Iverson|title=Rationalized APL|year=1983|quote=The enclose function as defined in [Operators and Enclosed Arrays] has made it possible to produce by straightforward APL functions the “index lists” required in indexing expressions of the form <code>a[i;j]</code>, and therefore makes it possible to define a corresponding indexing function, which will be denoted by <code>{</code> and called from:<br /><code>i{a ←→ a[>i[0];>i[1]; ...]</code><br />Since the disclose function <code>></code> is permissive, the selection of any single element of a can be written without enclosures as, for example, <code>1 2 3{a3</code>. Moreover, the left rank of <code>{</code> is <code>1</code> and its right rank is infinite, so that …… a simple left argument <code>i</code> of rank greater than <code>1</code> produces an array of shape <code>¯1↓⍴i</code> of elements chosen by the index vectors along its last axis, yielding what is sometimes called “scattered” indexing. For examp1e:<br /><code>(3 2⍴⍳6){a2 ←→ a2[0;1],a2[2;3],a2[4;5]</code><br />……<br />In forming the left arguments of the indexing function, it will often be convenient to use the link function <code>⊃</code> defined as follows:<br /><code><nowiki> </nowiki>⊃b ←→ <b</code> if <code>b</code> is simple<br /><code><nowiki>        </nowiki>b</code> if <code>b</code> is non-simple<br /><code>a⊃b ←→ (<a),⊃b</code><br />For example, <code>(2 3⊃4⊃∘⊃5 6){a4 ←→ a[2 3;4;;5 6]</code>.<br />The indexing function <code>{</code> as defined thus far provides all of the facilities provided by conventional indexing, and “scattered” and “complementary” indexing as well. Its power is further enhanced by allowing negative indexing …….}}<br />
{{cite web|author=Roger Hui|title=Some Uses of { and }|year=1987|url=https://www.jsoftware.com/papers/from.htm|quote=Dyadic <code>{</code> encompasses all computations expressible by <code>[;]</code> indexing of APL\360, as well as the new negative indexing and complementary indexing.}}
</ref>，它也被称为“班组”（squad）索引。J语言支持[[AVX指令集|AVX2]][[指令集|指令集]]进行[[SIMD|SIMD]]运算<ref>
{{Cite web |url=https://code.jsoftware.com/wiki/Guides/AVX |title=Guides/AVX |access-date=2021-12-20 |archive-date=2021-12-20 |archive-url=https://web.archive.org/web/20211220161255/https://code.jsoftware.com/wiki/Guides/AVX |dead-url=no }}
</ref>。

不同于支持面向对象编程的多数语言，J语言灵活的层次名字空间机制，这里所有名字都存在于特定语境（locale）中，可以有效的用作[[基于类编程|基于类]]和[[基于原型编程|基于原型]]的面向对象编程二者的框架。它还被用于[[极限编程|极限编程]]<ref>{{Citation |contribution= Software Development as a Collaborative Writing Project |title= Extreme programming and agile processes in software engineering |place= Oulu, Finland |year= 2006 |first1= Brian |last1= Bussell |first2= Stephen |last2= Taylor |pages= 21–31 |publisher= [[Springer_Science+Business_Media|Springer]] |isbn= 978-3-540-35094-1}}</ref>和[[网络性能|网络性能]]分析<ref>{{Citation |first= Alan |last= Holt |title= Network Performance Analysis: Using the J Programming Language |isbn= 978-1-84628-822-7 |year= 2007 |publisher= [[Springer_Science+Business_Media|Springer]]}}</ref>。

自从2011年3月，J语言成为了[[自由和开源软件|自由和开源软件]]，采用了[[GNU通用公共许可证|GNU通用公共许可证]]版本3（GPLv3）<ref name="j source download">{{Cite web |url=https://www.jsoftware.com/#/source |title=Jsoftware's source download page |accessdate=2020-05-18 |archive-date=2021-01-26 |archive-url=https://web.archive.org/web/20210126072432/https://www.jsoftware.com/#/source |dead-url=no }}</ref><ref name="j_gpl">{{cite web |url= http://thread.gmane.org/gmane.comp.lang.j.programming/20882 |title= J Source GPL |date= 1 March 2011 |author= Eric Iverson |work= J programming mailing list |access-date= 2020-05-18 |archive-url= https://web.archive.org/web/20160923133425/http://thread.gmane.org/gmane.comp.lang.j.programming/20882 |archive-date= 2016-09-23 |dead-url= yes }}</ref>。人们还可以在Jsoftware的商业许可证下利用源代码<ref name="j_source">{{Cite web |url=https://www.jsoftware.com/#/source |title=Jsoftware's sourcing policy |accessdate=2020-05-18 |archive-date=2021-01-26 |archive-url=https://web.archive.org/web/20210126072432/https://www.jsoftware.com/#/source |dead-url=no }}</ref>。

==词类与文档==
在J语言中的字，被识别为[[名词|名词]]<ref>[http://code.jsoftware.com/wiki/Vocabulary/Nouns 名词]{{Wayback|url=http://code.jsoftware.com/wiki/Vocabulary/Nouns |date=20160307125301 }}</ref>、[[动词|动词]]<ref>[http://code.jsoftware.com/wiki/Vocabulary/Verbs 动词]{{Wayback|url=http://code.jsoftware.com/wiki/Vocabulary/Verbs |date=20160307123937 }}</ref>、[[定语|定语]]<ref>[http://code.jsoftware.com/wiki/Vocabulary/Modifiers 定语] {{Wayback|url=http://code.jsoftware.com/wiki/Vocabulary/Modifiers |date=20200619030438 }}</ref>（[[副词|副词]]和[[连词|连词]]）、[[系词|系词]]、[[标点符号|标点符号]]、[[控制流程|控制字]]。一个程序或例程，有时接受数据作为输入并产生数据作为输出，被称为“[[动词|动词]]”，与之相对，数据参数被称为“[[名词|名词]]”。

J语言有一组丰富的预定义的动词，它们都自动的起作用于多种数据类型之上。用户的程序可以命名，并可以用在任何允许使用原语的地方。注意动词有两种形式：参数只在右侧的[[元数|一元]]（monad）形式，和参数在左右两侧的[[元数|二元]]（dyad）形式。例如，在<code>-1</code>中横杠是一元动词，而在<code>3-2</code>中横杠是二元动词。一元定义很大程度上独立于二元定义，不管这个动词是原语动词还是派生动词。

J语言的文档包括于NuVoc中<ref>[https://code.jsoftware.com/wiki/NuVoc NuVoc] {{Wayback|url=https://code.jsoftware.com/wiki/NuVoc |date=20201112000748 }}</ref>。主要的字罗列于“J原语”中，其中使用颜色标示出它们分别的词类<ref>[http://code.jsoftware.com/wiki/Vocabulary/PartsOfSpeech 词类]{{Wayback|url=http://code.jsoftware.com/wiki/Vocabulary/PartsOfSpeech |date=20160307124606 }}</ref>。早期的文档还有入门<ref>[https://www.jsoftware.com/help/primer/contents.htm 入门] {{Wayback|url=https://www.jsoftware.com/help/primer/contents.htm |date=20201230223259 }}</ref>和字典<ref>[https://www.jsoftware.com/help/dictionary/contents.htm 字典] {{Wayback|url=https://www.jsoftware.com/help/dictionary/contents.htm |date=20201112020108 }}</ref>。

== 起步示例 ==
J语言的程序可以非常精简，以至于一些编程者将它称为难以阅读的[[只写语言|只写语言]]。在计算机的终端上执行<code>ijconsole</code>，即可进入J语言的[[REPL|REPL]]解释器界面。

===Hello, World!===
J语言的“[[Hello_World|Hello, World!]]”程序：
<syntaxhighlight lang="j" highlight="2">
   'Hello, world!'
Hello, world!
</syntaxhighlight>
这个hello world的实现反映了J语言的传统用法，就是把程序录入到J解释器会话中，显示出表达式结果。还可以准备J脚本来作为独立程序来执行，在[[Linux|Linux]]系统上，可以编辑如下内容的一个文本文件，并命名为比如<code>test01.ijs</code>：
<syntaxhighlight lang="j">
#!/usr/bin/ijconsole
echo 'Hello, world!'
exit ''
</syntaxhighlight>
注意第一行的<code>#!</code>必须顶头，然后在终端界面中执行这个文件：
<syntaxhighlight lang="console" highlight="2,5">
$ ijconsole test01.ijs
Hello, world!
$ chmod +x test01.ijs # 另一种执行方式，授予这个文件可执行权限
$ ./test01.ijs
Hello, world!
</syntaxhighlight>

===平均===
在J语言中函数一般称为动词，例如定义一个叫做<code>avg</code>的动词，计算一序列数的[[平均值|平均]]：
<syntaxhighlight lang="j" highlight="3">
   avg=: +/ % #
   avg 1 2 3 4
2.5
</syntaxhighlight>

一元动词<code>#</code>“计数”（tally），总计阵列中项目的总个数。动词<code>+</code>“加”（plus）和副词<code>/</code>“插入”（insert），派生出的动词<code>+/</code>，合计这个阵列的项目的总和。二元动词<code>%</code>“除”（divide）将这个总和除以这个总个数。上述的<code>avg</code>使用一连串的三个动词（<code>+/</code>、<code>%</code>和 <code>#</code>）来定义，术语叫“叉子”（fork）。<code>(f g h) y</code>同于<code>(f y) g (h y)</code>，这里的<code>f</code>、<code>g</code>和<code>h</code>指示动词，而<code>y</code>指示一个名词。

使用<code>avg</code>的一些例子：
<syntaxhighlight lang="j" highlight="2,4,6,8-11,13,15">
   ]a=: ?. 20 $100  NB. 产生100以内20个随机整数的一个向量
94 56 8 6 85 48 66 96 76 59 33 72 63 1 89 52 17 20 9 65
   avg a
50.75
   4 avg\ a         NB. 周期大小为4的移动平均
41 38.75 36.75 51.25 73.75 71.5 74.25 66 60 56.75 42.25 56.25 51.25 39.75 44.5 24.5 27.75
   ]b=: ?. 4 5 $50  NB. 产生50以内20个随机整数的一个矩阵
44  6  8  6 35
48 16 46 26  9
33 22 13  1 39
 2 17 20  9 15
   avg b
31.75 15.25 21.75 10.5 24.5
   avg"1 b          NB. 应用avg于m的每个秩为1的子阵列
19.8 29 21.6 12.6
</syntaxhighlight>
一元动词<code>]</code>“相同”（same），[[恒等函数|恒等]]于给它的单一右参数，常像这样用来在赋值之后显示变量的内容。计算[[移动平均|移动平均]]用到的二元副词<code>\</code>“中缀”（infix），将作为数据参数的列表划分成一系列的指定大小的连续项目的子列表，将所修饰动词应用于其上，并将这些结果形成一个列表。

一元动词<code>?.</code>“掷骰/固定种子”（roll/fixed seed），以固定的种子，生成数据参数项目所指定大小范围内的[[随机数|随机数]]。这里用到的连词<code>"</code>“秩”（rank），在后面的[[#定语|定语章节]]和[[秩_(J编程语言)|单独条目]]中论述。

===查找与排序===
二元动词<code>i.</code>“出现索引”（index of），和二元动词<code>i:</code>“最后出现索引”（index of last），在任何大小的阵列内[[搜索算法|查找]]匹配者，并返回它的位置索引，如果未找到匹配者，则返回这个阵列的大小。例如：
<syntaxhighlight lang="j" highlight="3,5">
   a=: 3 1 4 1 5 9
   a i. 1 2  NB. 找到1和2的第一次出现的索引
1 6
   a i: 1 2  NB. 找到1和2的最后一次出现的索引
3 6
</syntaxhighlight>

在J语言中，[[排序算法|排序]]可以按APL传统的两步骤方式，使用一元动词<code>/:</code>“升序索引”（grade up）或<code>\:</code>“降序索引”（grade down），二元动词<code>{</code>“出自”（from），和一元动词<code>]</code>“相同”（same），三者形成的一个叉子来完成。J语言还提供专用的二元动词<code>/:</code>“上升排序”（sort up）或<code>\:</code>“下降排序”（sort down）。下面是用例：
<syntaxhighlight lang="j" highlight="3,5,7,9">
   a=: 15 2 9 10 4 0 13 13 18 7
   /: a        NB. 产生参数阵列的升序索引，它也叫置换向量
5 1 4 9 2 3 6 7 0 8
   (/: { ]) a  NB. 从参数阵列中按升序索引选取出各个项目
0 2 4 7 9 10 13 13 15 18
   /:~ a
0 2 4 7 9 10 13 13 15 18
   (a - 10) /: a
_10 _8 _6 _3 _1 0 3 3 5 8
</syntaxhighlight>
这里用到的一元副词<code>~</code>“反身”（reflex），在后面[[#定语|定语章节]]介绍。

===插件===
除了使用标准库<ref>[https://code.jsoftware.com/wiki/Standard_Library/Overview 标准库] {{Wayback|url=https://code.jsoftware.com/wiki/Standard_Library/Overview |date=20191220190015 }}</ref>，还可以通过包管理器<ref>{{Cite web |url=https://code.jsoftware.com/wiki/Pacman |title=包管理器 |access-date=2020-05-22 |archive-date=2021-04-06 |archive-url=https://web.archive.org/web/20210406163322/https://code.jsoftware.com/wiki/Pacman |dead-url=no }}</ref>，安装各种插件<ref>[https://code.jsoftware.com/wiki/Vocabulary/Libraries 插件] {{Wayback|url=https://code.jsoftware.com/wiki/Vocabulary/Libraries |date=20190814150514 }}</ref>，例如在管理员权限下，安装[[逗号分隔值|CSV]]文件插件<ref>[https://code.jsoftware.com/wiki/Addons/tables/csv Addons/tables/csv]<br />[https://github.com/jsoftware/tables_csv  github.com/jsoftware/tables_csv]</ref>：
<syntaxhighlight lang="j">
   load 'pacman'                NB. 加载包管理器
   'install' jpkg 'tables/csv'  NB. 安装CSV文件插件
   'showinstalled' jpkg ''      NB. 查看已经安装插件
</syntaxhighlight>
一个CSV文件简单用例：
<syntaxhighlight lang="j" highlight="4,6-10,12,13">
   load 'tables/csv'                  NB. 加载CSV插件
   a=: i. 2 3                 
   a writecsv jpath '~/test01.csv'    NB. 将一个阵列写入一个CSV文件
12
   ]b=: readcsv jpath '~/test01.csv'  NB. 从一个CSV文件读入一个盒子阵列
┌─┬─┬─┐
│0│1│2│
├─┼─┼─┤
│3│4│5│
└─┴─┴─┘
   ]c=: makenum b                     NB. 尽可能的将盒子阵列转换成数值阵列
0 1 2
3 4 5
</syntaxhighlight>
下面演示使用J语言编写在[[管道_(软件)|管道]]中的过滤器，例如在[[Linux|Linux]]系统中建立如下内容的文本文件，并命名为比如<code>filter01.ijs</code>：
<syntaxhighlight lang="j">
#!/usr/bin/ijconsole
load 'tables/csv'
stdout makecsv 10 + makenum fixcsv stdin ''
exit ''
</syntaxhighlight>
然后在终端界面中执行如下命令行：
<syntaxhighlight lang="console" highlight="2,3">
$ cat test01.csv | ijconsole filter01.ijs
10,11,12
13,14,15
</syntaxhighlight>

==数据类型和结构==
J语言支持三种简单类型：
* 数值
* 文字（字符）
* 盒装
其中数值有很多变种。J语言提供的唯一[[集合_(计算机科学)|搜集]]（collection）类型，是任意维度的阵列。多数算法可以使用这些阵列来简洁的表达。

===数值===
J语言的数值类型之一是“[[位元|位]]”。有两个位值：<code>0</code>和<code>1</code>。位还可以形成列表。例如，<code>1 0 1 0 1 1 0 0</code>是8个位的列表。在语法上，J分析器将位当作一个字。空格字符被识别为字形成字符，位于在其他数值字的字符之间。支持任意长度的列表。

进一步的，J语言在这些列表之上支持所有常见二元运算，比如具有动词<code>*.</code>“与”（and）、<code>+.</code>“或”（or）、<code>-.</code>“非”（not）、<code>|.</code>“反转·旋转”（reverse·rotate）、<code>|.!.f</code>“移位”（shift）等。J语言还支持位的二维、三维等阵列。上面的运算同样的运行在这些阵列之上。

其他数值类型包括[[整数|整数]]（比如3, 42）、[[浮点数|浮点数]]（3.14, 8.8e22）、[[複數_(數學)|複數]]（0j1, 2.5j3e88）、扩展[[精度|精度]]整数（12345678901234567890x）和（扩展精度）[[有理数|有理]][[分数|分数]]（1r2, 3r4）。同位一样，它们可以形成列表或任意维度的阵列。同位一样，运算可以在一个阵列的所有数之上。下面例子展示[[圆周率|π]]的前50位，超出了[[IEEE_754|IEEE 754]][[双精度浮点数|双精度浮点数]]的53位二进制尾数能精确表示的最大范围，这要用到J语言的扩展精度整数：
<syntaxhighlight lang="j" highlight="2,4">
   0j15 ": o. 1   NB. π在双精度浮点数下精确值的位数
3.141592653589793
   <.@o. 10x ^50  NB. π乘以扩展精度10的50次幂
314159265358979323846264338327950288419716939937510
</syntaxhighlight>

这里采用一元动词<code>o.</code>“π乘以”（pi times），和一元动词<code><.</code>“下取整”（floor）二者的[[复合函数|复合]]，得到预期的结果<ref>{{cite web|author=Roger K.W. Hui|title=Extended Integers in J|url=https://www.jsoftware.com/papers/extint.htm|year=1996|quote=Some verbs <code>v</code> signal domain error on some extended arguments because the result is not integral; however, <code><.@v</code> and <code>>.@v</code> are closed on extended arguments.}}</ref>。位的列表可以使用一元动词<code>#.</code>“基数2”（base 2）[[解码|解码]]成整数。整数可以使用一元动词<code>#:</code>“反基数2”（antibase 2）[[编码|编码]]为位的列表。

===文字与盒装===
J语言还支持文字即[[字符_(计算机科学)|字符]]类型。文字包围在引号之间，比如<code>'a'</code>或<code>'b'</code>。文字的列表，通过将多个字符放入引号之内的常规[[字符串|字符串]]约定来支持，比如<code>'abcdefg'</code>。典型的，单独的文字是8-位宽（字节）的[[ASCII|ASCII]]字符，但是J语言还支持其他[[Unicode|Unicode]]文字。

不支持在文字上的数值和布尔运算，但支持面向搜集的运算，比如旋转等。使用动词<code>".</code>“执行·数值”（do·numbers），将字节阵列转换成数值；使用动词<code>":</code>“缺省格式·格式”（default format·format），将数值转换成字节阵列。

盒装类型的值是0维标量<ref name="box" />，而不管所包含的是怎样的数据结构。使用一元动词<code><</code>“盒装”（box），将数据放置入盒子中；使用一元动词<code>></code>“打开”（open），打开盒子中取出其中数据。还可以通过二元动词<code>;</code>“链接”（link）建立盒子的列表，通过一元动词<code>;</code>“拆除”（raze）移除一层盒子的列表。盒子内可以装入其他盒子，还可以通过二元动词<code>$</code>“重制形状”（reshape）和二元动词<code>#</code>“计件复制”（copy）等操作盒子及其列表。

===结构===
J语言的阵列，具有同质（homogeneous）的项目类型，例如列表<code>1 2 3</code>是整数的列表，尽管<code>1</code>可以是一个位。在极大程度上，这种的类型问题，对于编程者是透明的。只有特定的特殊运算，显露出在类型上的不同。例如，列表<code>1.0  0.0 1.0 0.0</code>，对大多数运算，将被当作是完全同于列表<code>1 0 1 0</code>。

J语言支持数值[[稀疏矩阵|稀疏阵列]]，这里用它们的下标存储非零数值。这在非零数值相对很少的情况下，是有效率的机制。

J语言还支持[[对象_(计算机科学)|对象]]和[[类_(计算机科学)|类]]<ref>{{Cite web |url=http://www.jsoftware.com/help/learning/25.htm |title=Chapter 25: Object-Oriented Programming |accessdate=2020-05-18 |archive-date=2020-06-25 |archive-url=https://web.archive.org/web/20200625213000/https://www.jsoftware.com/help/learning/25.htm |dead-url=no }}</ref>，但是它们是事物命名方式的加工制作，而非数据类型。实际上，使用盒装文字来提及对象和类。J数据有值语义，然而对象和类需要引用语义。

此外还有一个伪类型即[[内存映射文件|内存映射文件]]<ref>[https://code.jsoftware.com/wiki/Studio/Mapped_Files 内存映射文件] {{Wayback|url=https://code.jsoftware.com/wiki/Studio/Mapped_Files |date=20190202160722 }}</ref>，它关联于名字而非数值。

==简要词汇表==
下面的表格简要列出了常用词汇，使用<code>@</code>、<code>&</code>和<code>`</code>及其屈折形式的连词，对于[[隐式编程|隐式编程]]有重大意义，在后面的章节中专门论述。如果含义中用了间隔号（ · ）分隔，通常前者是只有一个右侧参数的一元含义，后者是左右两侧都有参数的二元含义。列出的对应APL符号，是Dyalog等现代APL所采用的符号。
===基本===
{| class="wikitable"
|-
! J词汇 !! APL<br />符号 !! 词类 !! 含义 !! 例子
|-
| <code>=.</code> || rowspan="2"| <code>←</code> ||系词 || 是（is，局部赋值） || <code>loc=. 1 2</code> 
|-
| <code>=:</code> || 系词 || 是（is，全局赋值）|| <code>GLO=: 'foo'</code> 
|-
| <code>NB.</code> || <code>⍝</code> || 系词 || 注释（comment） || <code>NB. negative vs. negate</code> 
|-
| colspan="2" |<code>'<small>文字</small>'</code> || 名词 || 字符串（character string） || <code>'Hello, World!'</code>
|-
| <code>_</code> || <code>¯</code> || 名词 || [[负号|负号]]（negative sign）/ [[无穷|无穷]]（infinity） || <code>_3 = -3</code> 
|-
| colspan="2" |<code>=</code> || 动词 || [[相等|等于]]（equal） || <code>3 = i. 5</code>      
|-
| rowspan="2" |<code><</code> ||  <code><</code> || 动词 || <small>（二元）</small>[[不等|小于]]（lesser） || <code>8 < 7 8 9</code>
|-
| <code>⊂</code> || 动词 || <small>（一元）</small>盒装（box）|| <code>(< i. 2 3) , < i. 3 2</code>
|-
| rowspan="2" |<code>></code> || <code>></code> || 动词 || <small>（二元）</small>[[不等|大于]]（greater） || <code>8 > 7 8 9</code> 
|-
| <code>↑</code> || 动词 || <small>（一元）</small>打开（open） || <code>> (i. 2 3) ; i. 3 2</code>
|-
| <code>L.</code> || rowspan="2" |<code>≡</code> || 动词 || <small>（一元）</small>最大盒装层数（level of）|| <code>L. (<1) , (<<2) , <<<3</code>
|-
| <code>-:</code> || 动词 || <small>（二元）</small>[[匹配|匹配]]（match）{{refn|group=注|name=one|这个J单字另有一元形式，见数学表格。}} || <code>'no' -: 'yes'</code>
|-
| rowspan="2"|<code>{::</code> ||  || 动词 || <small>（一元）</small>地图（map） || <code>{:: (<1) , (<<2) , <<<3</code>
|-
| <code>⊃</code> || 动词 || <small>（二元）</small>获取（fetch） || <code>1 {:: (<1) , (<<2) , <<<3</code>
|-
| <code><:</code> || <code>≤</code> || 动词 || <small>（二元）</small>[[不等|小于等于]]（less or equal）{{refn|group=注|name=one}} || <code>8 <: 7 8 9</code>
|-
| <code>>:</code> || <code>≥</code> || 动词 || <small>（二元）</small>[[不等|大于等于]]（larger or equal）{{refn|group=注|name=one}} || <code>8 >: 7 8 9</code>
|-
| <code>~.</code> || <code>∪</code> || 动词 || <small>（一元）</small>唯一值（nub）|| <code>~. 'abracadabra'</code>
|-
| rowspan="2" |<code>~:</code> ||  || 动词 ||  <small>（一元）</small>唯一值筛选（nub sieve） || <code>~: 'abracadabra'</code>
|-
| <code>≠</code> || 动词 ||  <small>（二元）</small>[[不等|不等于]]（not-equal） || <code>3 ~: i. 5</code>
|-
| rowspan="2"| <code>e.</code> || || 动词 || <small>（一元）</small>拆盒值隶属矩阵（raze in）|| <code>e. 'ab' ; 'c' ; 'de'</code>
|-
| <code>∊</code> || 动词 || <small>（二元）</small>[[元素_(數學)|成员关系]]（member/in）|| <code>'a' e. 'alpha'</code>
|-
| <code>E.</code> || <code>⍷</code> || 动词 || 寻找匹配子阵列起点（find match） || <code>'co' E. 'cocoa'</code>
|-
| <code>#.</code> || <code>⊥</code> || 动词 || [[二进制|基数2]]（base 2）· [[底数_(进制)|基数]]（base）|| <code>#. 1 0 1 0 1</code> 
|-
| <code>#:</code> || <code>⊤</code> || 动词 || 反基数2（antibase 2）· 反基数（antibase）|| <code>24 60 60 #: 86399</code>
|-
| <code>[</code> || <code>⊣</code> || 动词 || [[恒等函数|相同]]（same）· 左参数（left）|| <code>p=: 3 [ q=: 5</code> 
|-
| <code>]</code> || <code>⊢</code> || 动词 || [[恒等函数|相同]]（same）· 右参数（right）|| <code>(2 { ]) 3 1 4 1 5 9</code>
|-
| <code>".</code> || <code>⍎</code> || 动词 || 执行（do）· 数值（numbers）|| <code>9999 ". '56 NULL'</code> 
|-
| <code>":</code> || <code>⍕</code> || 动词 || 缺省格式（default format）· 格式（format）|| <code>10j2 ": 6</code> 
|-
| <code>"</code> || <code>⍤</code> || 连词 || 秩（rank）|| <code>+/"1 i. 3 4</code> 
|-
| <code>~</code> || <code>⍨</code> || 副词 || 返身（reflex）· 被动（passive）|| <code>+~ 1 2 3</code>
|-
| <code>^:</code> || <code>⍣</code> || 连词 || 动词幂（power of verb）|| <code>+: ^:(6&<) 12</code> 
|- 
| <code>:</code> || rowspan="2"| <code>∇</code> || 连词 || 定义（definition）|| <code>dist=: 4 : '%: +/ *: x - y'</code> 
|- 
| <code>$:</code> || 动词 || 自引用（self-reference）|| <code>fact=: 1: ` (* $:@<:) @. *</code> 
|-
|  || colspan="6"| {{Reflist|group=注}}
|}

===结构===
{| class="wikitable"
|-
! J词汇 !! APL<br />符号 !! 词类 !! 含义 !! 例子
|-
| <code>$</code> || <code>⍴</code> || 动词 || 形状（shape of）· 重制形状（reshape） || <code>2 2 4 $ 1 2 11 22</code>
|-
| rowspan="2" |<code>#</code> || <code>≢</code> || 动词 || <small>（一元）</small>[[计数符号|计数]]（tally）|| <code># 1 2 3</code>
|-
| <code>⌿</code> <code>/</code> || 动词 || <small>（二元）</small>复制（copy） || <code>1 2 3 # 1 2 3</code>
|-
| <code><nowiki>|</nowiki>.</code>|| <code>⊖</code> <code>⌽</code> || 动词 || 反转（reverse）· 旋转（rotate）|| <code><nowiki>|</nowiki>. 2 <nowiki>|</nowiki>. i. 6 2</code>
|-
| <code><nowiki>|</nowiki>:</code>|| <code>⍉</code> || 动词 || [[转置矩阵|转置]]（transpose）· 重排轴（rearrange axes）|| <code><nowiki>|</nowiki>: 'abc' ,: 'def'</code>
|-
| rowspan="2" |<code>,</code> || <code>,</code> || 动词 || <small>（一元）</small>散开（ravel） || <code>, i. 2 3 4</code>
|-
| rowspan="2" |<code>⍪</code> || 动词 || <small>（二元）</small>附加（append） || <code>(i. 2 3) , i. 4 3</code>
|-
| rowspan="2" |<code>,.</code> || 动词 || <small>（一元）</small>散开项目（ravel items） || <code>,. i. 2 3 4</code>
|-
|  <code>,</code> || 动词 || <small>（二元）</small>缝合（stitch） || <code>(i. 2 3) ,. i. 2 4</code>
|-
| <code>,:</code> ||  || 动词 || 项目化扩秩（itemize）· 迭片（laminate） || <code>(i. 2 3) ,: i. 3 2</code> 
|-
| <code>;</code> ||  || 动词 || 拆除（raze）· 链接（link）{{refn|group=注|name=raze|在SHARP APL中raze对应<code>↓</code>，link对应</code><code>⊃</code>，对于现代APL，raze近似于<code>↑⍪/</code>，link实现了<code>{(⊂⍺),⊆⍵}</code>。}}|| <code>; (i. 2 3) ; i. 3 2</code> 
|-
| <code>;:</code> ||  || 动词 || 划分单字（words）· [[米利型有限状态机|顺序机器]]（sequential machine） || <code>;: 'ab cde'</code>
|-
| <code>;.3</code> || <code>⌺</code> || 副词 || 极大立方体（max cubes）· 剪切子阵列（subarrays）|| <code>(2 2 ,: 2 4) <;.3 i. 5 6</code> 
|-
| rowspan="2" |<code>/</code> || <code>∘.</code> || 副词 || <small>（二元）</small>形成[[外积|表格]]（table） || <code>*/~ >: i. 6</code>
|-
| rowspan="2" |<code>⌿</code> <code>/</code> || 副词|| <small>（一元）</small>插入（insert） || <code>+/ 1 10 100</code>
|-
| rowspan="2" |<code>\</code> || 副词 || <small>（二元）</small>中缀（infix） || <code>3 <\ 'abcdefg'</code>
|-
| <code>⍀</code> <code>\</code> || 副词 || <small>（一元）</small>{{en-link|前缀和|Prefix sum|前缀}}（prefix） || <code>]\ 'banana'</code>
|-
| <code>\.</code> || || 副词 || 后缀（suffix）· 外缀（outfix） || <code>_1 ]\. 1 2 3 4</code>
|-
| rowspan="2" |<code>/.</code> || || 副词 || <small>（一元）</small>斜对角（oblique） || <code>< /. i. 4 4</code>
|-
| <code>⌸</code> || 副词 || <small>（二元）</small>{{en-link|分组 (SQL)|Group by (SQL)|键分组}}（key） || <code>1 0 0 1 0 </. AbcDe'</code>
|-
|  || colspan="6"| {{Reflist|group=注}}
|}

===索引===
{| class="wikitable"
|-
! J词汇 !! APL<br />符号 !! 词类 !! 含义 !! 例子
|-
| <code>i.</code> || <code>⍳</code> || 动词 || [[整数|整数]]生成（integers）· 出现索引（index of） || <code>i. 10</code>
|-
| <code>i:</code> ||  || 动词 || 阶梯（steps）· 最后出现索引（index of last） || <code>'abcd' i: 'c'</code>
|-
| <code>I.</code> || <code>⍸</code> || 动词 ||  存有索引（indices）· [[区间|区间]]索引（interval index）|| <code>I. 0 0 1 0 1 0</code>
|-
| rowspan="2" |<code>/:</code> || <code>⍋</code> || 动词 || <small>（一元）</small>升序索引（grade up） || <code>(/: { ]) 10 ? 20</code>
|-
|   || 动词 || <small>（二元）</small>上升排序（sort up） || <code>/:~ 10 ? 20</code>
|-
| rowspan="2" |<code>\:</code> || <code>⍒</code> || 动词 || <small>（一元）</small>降序索引（grade down） || <code>(\: { ]) 10 ? 20</code>
|-
|  || 动词 || <small>（二元）</small>下降排序（sort down） || <code>\:~ 10 ? 20</code>
|-
| rowspan="2" |<code>{</code> || || 动词 || <small>（一元）</small>方格目录（catalogue） || <code>{ 0 1 ; 7 8 9</code>
|-
| <code>⌷</code> || 动词 || <small>（二元）</small>出自（from） || <code>2 4 { 'abcde'</code>
|-
| rowspan="2" |<code>}</code>  ||  || 副词 || <small>（一元）</small>合成项目（composite item） || <code>'gw' (0 3)} 'cross'</code>
|-
| <code>@</code> || 副词 || <small>（二元）</small>修改（amend） || <code>0 1 } 'ab' ,: 'AB''</code>
|-
| rowspan="2" |<code>{.</code> ||  || 动词 || <small>（一元）</small>头部（head）{{refn|group=注|name=one|这个J单字与现代APL中first<code>⊃</code>类似但不相同，first是在ravel次序下的第一个元素。}} || <code>{. 'foot'</code> 
|-
| <code>↑</code> || 动词 || <small>（二元）</small>选取（take）|| <code>3 {. 'foot'</code> 
|-
| rowspan="2" |<code>}.</code> ||  || 动词 || <small>（一元）</small>掐头（behead）|| <code>}. 1 2 3 4</code>
|-
|  <code>↓</code> || 动词 || <small>（二元）</small>舍弃（drop） || <code>2 }. 1 2 3 4</code>
|-
|  || colspan="6"| {{Reflist|group=注}}
|}

===数学===
{| class="wikitable"
|-
! J词汇 !! APL<br />符号 !! 词类 !! 含义 !! 例子
|-
|  colspan="2" |<code>+</code> || 动词 || [[共轭复数|共轭复数]]（conjugate）· [[加法|加]]（plus） || <code>2 + 3 30</code>
|-
| rowspan="2" |<code>+.</code> ||  || 动词 || <small>（一元）</small>[[复数_(数学)|实部]]/[[复数_(数学)|虚部]]（real/imaginary）|| <code> +. 3j5</code>
|-
| <code>∨</code> || 动词 || <small>（二元）</small>[[最大公因数|最大公约]]/[[逻辑或|或]]（GCD/or）|| <code> 0 0 1 1 +. 0 1 0 1</code>
|-
| rowspan="2" |<code>+:</code> ||  || 动词 || <small>（一元）</small>双倍（double）|| <code>+: 7</code>
|-
| <code>⍱</code> || 动词 || <small>（二元）</small>[[逻辑或非|或非]]（not-or）|| <code>0 0 1 1 +: 0 1 0 1</code>
|-
| <code>*</code> || <code>×</code> || 动词 || [[符号函数|符号函数]]（signum）· [[乘法|乘]]（times） || <code>3 30 * 2</code>
|-
| rowspan="2" |<code>*.</code> ||  || 动词 || <small>（一元）</small>[[绝对值|模长]]/[[幅角|幅角]]（length/angle）|| <code>*. 3j4</code>
|-
| <code>∧</code> || 动词 || <small>（二元）</small>[[最小公倍数|最小公倍]]/[[逻辑与|与]]（LCM/and）|| <code>0 0 1 1 *. 0 1 0 1</code>
|-
| rowspan="2" |<code>*:</code> ||  || 动词 || <small>（一元）</small>[[平方|平方]]（square）|| <code>*: 7</code>
|-
| <code>⍲</code> || 动词 || <small>（二元）</small>[[逻辑与非|与非]]（not-and）|| <code>0 0 1 1 *: 0 1 0 1</code>
|-
| <code>-</code> || <code>−</code> || 动词 || [[加法逆元|相反数]]（negate）· [[减法|减]]（subtract） || <code>1 10 - 5 6</code>
|-
| <code>-.</code> || <code>∼</code> || 动词 || [[逻辑非|非]]（not）· [[补集#相对补集|差]]（less） || <code>-. 0 1</code>
|-
| <code>-:</code> ||  || 动词 || <small>（一元）</small>[[二分之一|一半]]（halve）{{refn|group=注|name=two|这个J单字另有二元形式，见基本表格。}} || <code>-：7</code>
|-
| <code>%</code> || <code>÷</code> || 动词 || [[倒数|倒数]]（reciprocal）· [[除法|除]]（divide） || <code>2 3 5 % 3 4 6</code>
|-
| <code>%.</code> || <code>⌹</code> || 动词 || [[逆矩阵|逆矩阵]]（matrix inverse）· 矩阵除（matrix divide）|| <code>%. ? 3 3 $ 10 </code>
|-
| colspan="2" |<code><nowiki>|</nowiki></code>  || 动词 || [[绝对值|幅值]]（magnitude）· [[模除|余数]]（residue） || <code>2 <nowiki>|</nowiki> i. 7</code>
|-
| <code>^</code> || <code>⋆</code> || 动词 || [[指数函数|指数]]（exponential）· [[幂|幂]]（power） || <code>2 ^ i. 17</code>
|-
| <code>^.</code> || <code>⍟</code> || 动词 || [[自然对数|自然对数]]（natural log）· [[对数|对数]]（log） || <code>2 10 ^. 4 100</code>
|-
| <code>o.</code> || <code>○</code> || 动词 || [[圆周率|<math>\pi \,</math>]]乘以（pi times）· [[三角函数|圆函数]]（circle function）|| <code>sin=: 1&o.</code>
|-
| <code>j.</code> ||  || 动词 || [[虚数单位|<math>i \,</math>]]乘以（imaginary）· 形成[[复数_(数学)|复数]]（complex）|| <code>3 j. 4</code>
|-
| <code><.</code> || <code>⌊</code> || 动词 || [[取整函数|下取整]]（floor）· [[极值|极小]]（minimum） || <code>2 3 4 <. 9 1 2</code>
|-
| <code>>.</code> || <code>⌈</code> || 动词 || [[取整函数|上取整]]（ceiling）· [[极值|极大]]（maximum） || <code>>. 1.1 0.5 1.9</code>
|-
| <code><:</code> ||  || 动词 || <small>（一元）</small>[[增值和减值操作符|增加]]（decrement）{{refn|group=注|name=two}} || <code><: 7 8 9</code>
|-
| <code>>:</code> ||  || 动词 || <small>（一元）</small>[[增值和减值操作符|减少]]（increment）{{refn|group=注|name=two}} || <code>>: 7 8 9</code>
|-
| colspan="2" |<code>!</code> || 动词 || [[阶乘|阶乘]]（factorial）· [[组合|抽取]]（out of） || <code>2 ! 10</code>
|-
| colspan="2" |<code>?</code> || 动词 || [[随机数|掷骰]]（roll）· {{en-link|随机置换|Random permutation|发牌}}（deal） || <code>3 ? 10</code>
|-
| colspan="2" |<code>.</code> || 连词 || [[行列式|行列式]]（determinant）· [[矩阵乘法|矩阵积]]（matrix product） || <code>(i. 3 2) (+/ . *) i. 2 3</code>
|-
|  || colspan="6"| {{Reflist|group=注}}
|}

==定语==
J语言的能力，很大程度上来自它的“[[定语|定语]]”（modifier：修饰词），这个范畴包括“[[副词|副词]]”和“[[连词|连词]]”：这些符号接受名词和动词作为运算元（operand），并以指定方式应用这些运算元。定语都可以应用于任何动词，包括用户写的动词，用户可以写自己的定语。

一元副词<code>/</code>“插入”（insert），接受位于它左侧的一个运算元，并产生将这个动词应用于其参数的每个项目之间的一个动词。就是说，<code>+/</code>是一个动词，定义为应用<code>+</code>于给它的参数的各个项目之间。副词<code>\</code>“前缀·中缀”（prefix·infix），副词<code>\.</code>“后缀·外缀”（suffix·outfix），和连词<code>;.</code>“剪切”（cut）<ref>{{cite web|url=https://www.jsoftware.com/papers/APLDictionary.htm|author=Kenneth E. Iverson|title=A Dictionary of APL|year=1987|quote=The case <code>3⍤v</code> also has left rank <code>2</code> , and <code>⍺3⍤v⍵</code> applies <code>v</code> to each element produced by a tessellation of <code>⍵</code>, using a size <code>1{⍺</code>, and beginning points that are multiples of the “shift” <code>0{⍺</code>.}}</ref>，指定参数的诸个规则或不规则子集，并在其上执行运算。

[[秩_(J编程语言)|秩]]采用连词<code>"</code>“秩”（rank）来操纵<ref>[https://code.jsoftware.com/wiki/Vocabulary/RankInfo 秩] {{Wayback|url=https://code.jsoftware.com/wiki/Vocabulary/RankInfo |date=20180609034543 }}</ref>，它有三种形式：<code>u"n</code>“指定秩”（assign），<code>m"n</code>“[[常数函数|常量动词]]”（constant），<code>u"v</code>和<code>m"v</code>“复制秩”（copy），这里的<code>u</code>表示定语的动词运算元，而<code>m</code>表示定语的名词运算元。

===复合===
连词<code>@:</code>“在于”（at）、<code>@</code>“顶上”（atop）、<code>&:</code>“并列”（appose）、<code>&</code>“合成”（compose），是四种[[函数复合|复合]]（composition）。J语言支持叫作“钩子”（hook）和“叉子”（fork）的隐形连词<ref name="hook" />，二种隐形连词和四种复合连词，规定了如何将参数或将所饰动词应用于参数的结果，提供给所饰动词来进行应用的规则。下表列出它们的含义：
{| class="wikitable"
|-
! 连词 || APL<br />符号 !! 一元 !! 二元 !! 秩
|-
| hook || || <code>(u v) y = y u (v y)</code> || <code>x (u v) y = x u (v y)</code>  || <code>_ _ _</code>
|-
| fork || || <code> (f g h) y = (f y) g (h y)</code> || <code>x (f g h) y = (x f y) g (x h y)</code> || <code>_ _ _</code>
|-
| <code>@:</code> || <code>⍤</code> ||<code>(u @: v) y = u (v y)</code> || <code>x (u @: v) y = u (x v y)</code> || <code>_ _ _</code>
|-
| <code>@</code> || || <code>(u @ v) y = (u @: v)"v y</code> || <code>x (u @ v) y = x (u @: v)"v y</code> || <code>mv lv rv</code>
|-
| <code>&:</code> || <code>⍥</code> || 同于<code>@:</code>故而弃用 || <code>x (u &: v) y = (v x) u (v y)</code> || <code>_ _ _</code>
|-
| <code>&</code> || || 同于<code>@</code>故而弃用 || <code>x (u & v) y = x (u &: v)"mv y|| <code>mv mv mv</code>
|}
在上表中，<code>mv=: 0{g b.0</code>，<code>lv=: 1{g b.0</code>，<code>rv=: 2{g b.0</code>，这里的<code>g b.0</code>给出动词<code>g</code>的一个一元秩和两个二元秩<ref>[https://code.jsoftware.com/wiki/Vocabulary/bdotu 动词信息]</ref>。复合连词<code>@:</code>和<code>&:</code>对应的APL符号，是Dyalog等现代APL所采用的符号。<code>@</code>和<code>&</code>分别对应于《APL字典》中的符号<code>⍥</code>和<code>⍤</code><ref>{{cite web|url=https://www.jsoftware.com/papers/APLDictionary.htm|author=Kenneth E. Iverson|title=A Dictionary of APL|year=1987|quote=<br /><code>u⍤v</code><tt>    </tt>Rank: mv mv mv<tt>    </tt>On; On<br/>Monad. In the simplest case <code>u⍤v ⍵</code> is equivalent to <code>u v ⍵</code>. …… more generally, the rank of the derived function <code>u⍤v</code> is the rank of <code>v</code>; that is, the expression <code>u v</code> is applied to each of the cells of <code>⍵</code> relative to <code>v</code>. ……<br />Dyad. The left and right ranks of <code>u⍤v</code> are both the monadic rank of <code>v</code>. Therefore <code>⍺ u⍤v ⍵</code> is equivalent to <code>(v⍺) u v ⍵</code>.<br /><code>u⍥v</code><tt>    </tt>Rank: mv lv rv<tt>    </tt>Upon; Upon<br />The monad <code>u</code> is applied to the result of <code>v</code>, that is:<br /><code><nowiki>  </nowiki>u⍥v ⍵ ←→ u v ⍵ ←→ u⍤v ⍵</code><br /><code>⍺ u⍥v ⍵ ←→ u ⍺ v ⍵</code>}}</ref>，hook对应于《APL字典》中的符号<code>⍩</code>“枝条”（withe）<ref>{{cite web|url=https://www.jsoftware.com/papers/APLDictionary.htm|author=Kenneth E. Iverson|title=A Dictionary of APL|year=1987|quote=Withe (<code>u⍩v</code>) is similar to (<code>u⍤v</code>), but applies <code>v</code> only to the right argument:<br /><code>⍺ u⍩v ⍵ ←→ ⍺ u v ⍵</code><br /><code><nowiki>  </nowiki>u⍩v ⍵ ←→ ⍵ u v ⍵</code>
}}</ref>。现代APL将<code>⍤</code>称为“atop”，<code>⍥</code>称为“over”；并增加了<code>∘</code>“边上”（beside）<ref>[https://aplwiki.com/wiki/Function_composition Function composition]</ref>，<code>∘</code>的一元形式同于<code>⍤</code>，而二元形式同于hook。

四种复合中，<code>@:</code>和<code>&:</code>，对第一步运算的中间结果进行收集和填充<ref>[https://code.jsoftware.com/wiki/Vocabulary/FramingFill 帧填充]</ref>；而<code>@</code>和<code>&</code>，在中间结果的诸单元上进行第二步运算。四种复合的运作机制，可详见官方文档的图示<ref>[https://code.jsoftware.com/wiki/Vocabulary/RankFromV 定语生成的动词的秩]</ref>，下面例子展示四种复合的中间结果的单元差异：
<syntaxhighlight lang="j" highlight="2,3,5,7-10,12-16,18-21,23-37">
   ] a =: >:i. 2 3
1 2 3
4 5 6
   ] b =: 0.1*>:i. 2
0.1 0.2
   a (< @: +) b
┌───────────┐
│1.1 2.1 3.1│
│4.2 5.2 6.2│
└───────────┘
   a (< @ +) b
┌───┬───┬───┐
│1.1│2.1│3.1│
├───┼───┼───┤
│4.2│5.2│6.2│
└───┴───┴───┘
   a (; &: +:) b
┌───────┬───────┐
│2  4  6│0.2 0.4│
│8 10 12│       │
└───────┴───────┘
   a (; & +:) b
┌──┬───┐
│2 │0.2│
├──┼───┤
│4 │0.2│
├──┼───┤
│6 │0.2│
└──┴───┘

┌──┬───┐
│8 │0.4│
├──┼───┤
│10│0.4│
├──┼───┤
│12│0.4│
└──┴───┘
</syntaxhighlight>

当连词<code>&</code>的一个运算元是名词的时候，表示“粘上”（bond），对应于APL符号<code>∘</code>“绑上”（bind），即通过向二元动词固定提供其一个参数的值，而产生一个一元动词，如果存在左参数，它表示应用这个派生动词于右参数的次数。副词<code>~</code>“反身·被动”（reflex·passive），将提供给动词的单一右参数重复放置在左参数位置上，或者将提供给动词的左右两个参数对换位置。下面是简单的示例<ref>{{cite web|title=APL since 1978|url=https://dl.acm.org/doi/pdf/10.1145/3386319|author=Roger K. W. Hui, Morten J. Kromberg|publisher=Proceedings of the ACM on Programming Languages, Volume 4, Issue HOPL|year=2020|quote=What is being indexed is an array (of course) but the indices themselves (the “subscripts”) can also be arrays. For example [Hui 2016a, §4]:<br /><code><nowiki>   </nowiki>x← 3 1 4 1 5 9</code><br/><code><nowiki>   </nowiki>'.⎕'[x∘.>⍳⌈⌿x]</code><br />……<br />In the example, the 2-element character vector <code>'.⎕'</code> is indexed by a 6-by-9 Boolean matrix.}}</ref>：
<syntaxhighlight lang="j" highlight="3,6-12">
   norm=: %: @ +/ @: *: "1
   norm >:i. 2 2
2.23607 5
   x=: 3 1 4 1 5 9
   { &('.',u:9109) (>/ i. @ (>./)) x
⎕⎕⎕......
⎕........
⎕⎕⎕⎕.....
⎕........
⎕⎕⎕⎕⎕....
⎕⎕⎕⎕⎕⎕⎕⎕⎕
</syntaxhighlight>

在J语言中，孤立的动词序列叫做“列车”（train）<ref name="train" />， <code>e f g h</code>意味着<code>(e (f g h))</code>，<code>d e f g h</code>意味着<code>(d e (f g h))</code>，而<code>c d e f g h</code>意味着<code>(c (d e (f g h)))</code>；以此类推，动词列车的一般模式<code>(a b c ...)</code>，依赖于动词的数目，在偶数时形式为<code>(a (b c ...))</code>，最外层是个“钩子”（hook）；而在奇数时形式为<code>(a b (c ...))</code>，最外层是个“叉子”（fork）；二者的内部都是可能有多层的嵌套的叉子。

在钩子里处在前面的，和在叉子里处在中间的第二步运算，都应是二元动词；在惯用法<code>([: g h)</code>中<ref>[https://code.jsoftware.com/wiki/Essays/Tacit_Expressions#Train_of_Verbs Tacit Expressions]</ref>，并不实际执行的隐式动词<code>[:</code>“遮帽”（cap），屏蔽了叉子的左分支，形成了特殊化的叉子，这种叉子里处在中间的第二步运算，应是一元动词。

J语言还提供连词<code>&.:</code>“底下”（under）和<code>&.</code>“对偶”（dual）。<code>&.:</code>的秩是<code>_ _ _</code>，对应的APL符号是<code>⍢</code><ref>{{cite web|url=https://www.jsoftware.com/papers/opfns.htm|author=Kenneth E. Iverson|title=Operators and Functions|year=1978|quote=The dual operator, denoted by <code>⍢</code>, is a slight extension of the notion of dual functions implicit in [[德·摩根定律|deMorgan’s law]] (<code>∨⍢~ ↔ ^</code> and <code>≠⍢~ ↔ =</code>), the extension being to include a monadic left argument, as in <code>⌊⍢-x ↔ ⌈x</code>. ……<br />Composition and the dual operator applied to a divalent left argument and a monadic (or divalent) right argument yield parallel definitions of divalent derived functions as follows:<br />……<br />Dual:<code><nowiki>  </nowiki>f⍢g y ↔ (g⍣¯1) f (g y)</code><br /><code><nowiki>    </nowiki>x f⍢g y ↔ (g⍣¯1) (g x) f (g y)</code><br />It should be noted that the extension of the dual to include the monadic definition makes the identities <code>⌈⍢- ↔ ⌊</code> and <code>⌊⍢- ↔ ⌈</code> hold for both the monadic case (floor and ceiling) and for the dyadic case (minimum and maximum). Moreover, for the dyadic case the exponential function yields the identities <code>×⍢* ↔ + </code>and <code>+⍢⍟ ↔ ×</code>, the latter of which provides the basis for the use of natural logarithms in multiplication, just as the identity <code>+⍢(10¨⍟) ↔ x</code> forms the basis for the use of base ten logarithms.}}</ref>，<code>u &.: v</code>相同于<code>v^:_1 @: u &: v</code>。<code>&.</code>的秩是<code>mv mv mv</code>，对应于《APL字典》中的符号<code>¨</code><ref>{{cite web|url=https://www.jsoftware.com/papers/APLDictionary.htm|author=Kenneth E. Iverson|title=A Dictionary of APL|year=1987|quote=<br /><code>u¨v</code><tt>    </tt>Rank: mv mv mv<tt>    </tt>Under; Under<br />This function is equivalent to composition (<code>u⍤v</code>) except that the function inverse to <code>v</code> is applied to the result of each cell. …… The function <code>u¨v</code> is often called “the dual of <code>u</code> with respect to <code>v</code>”, but the phrase “<code>u</code> under <code>v</code>” is probably better, suggesting that <code>u</code> is performed after preparatory work by <code>v</code>, and before the task is sewn up by reversing the effect of <code>v</code>. The expression <code>u¨v</code> is valid only if <code>v</code> possesses an inverse.}}</ref>，<code>u &. v</code>相同于<code>(u &.: v)"mv</code>，而动词幂<code>^:_1</code>表示[[逆函数|逆运算]]，详见下面章节的介绍。现代APL中另有<code>¨</code>“每个”（each），<code>f¨</code>相当于J语言中的<code>f &. ></code><ref>{{cite web|url=https://www.jsoftware.com/papers/opfns.htm|author=Kenneth E. Iverson|title=Operators and Functions|year=1978|quote=The expression <code>f⍢></code> produces a derived function which applies the function <code>f</code> to its argument in an “item-wise” fashion, by disclosing each element of the argument, applying <code>f</code>, and enclosing the result to produce the corresponding element of the overall result.}}</ref>。

===控制结构===
连词<code>^:</code>动词幂”（power of verb）<ref>{{cite web|url=https://www.jsoftware.com/papers/opfns.htm|author=Kenneth E. Iverson|title=Operators and Functions|year=1978|quote=The power operator, denoted by <code>⍣</code>, applies to a monadic function left argument <code>f</code> and an integer right argument <code>k</code> to produce the <code>k</code>th power of <code>f</code> in the following sense: <code>f⍣k ↔ f f⍣k-1</code>, and <code>f⍣1 ↔ f</code>. In particular, <code>f⍣0</code> is the identity function and <code>f⍣¯1</code> is the inverse of <code>f</code>. Moreover, <code>f⍣_</code> denotes the limit of <code>f</code>, that is, the limiting function <code>f⍣n</code> for <code>n</code> large. Similarly, <code>f⍣¯</code> denotes the limit of the inverse of <code>f</code>.}}</ref>，有两种形式：
*<code>^:n</code>，是操作元为名词的“固定幂”。
*<code>^:v</code>，是操作元为动词的“动态幂”。
对于固定幂<code>x u ^:n y</code>，分别在<code>x</code>存在或缺席的情况下，应用动词<code>x&u</code>或<code>u</code>到<code>y</code>共<code>n</code>次。如果<code>n</code>是<code>0</code>或<code>1</code>，则形成布尔值条件执行；如果<code>n</code>是<code>_1</code>，则进行<code>u</code>的[[反函數|逆运算]]；如果<code>n</code>是<code>_</code>，则意味着“[[极限_(数学)|收敛]]”，即反复应用<code>u</code>直到结果不再变化。例如：
<syntaxhighlight lang="j" highlight="3,6,8">
   flag=: 1
   'Mr. ' , ^:flag 'Jones'
Mr. Jones
   flag=: 0
   'Mr. ' , ^:flag 'Jones'
Jones
   (+: ^:_1) 14 
7
</syntaxhighlight>

对于动态幂<code>x u ^:v y</code>，如果<code>x</code>存在，<code>(x u ^:v y)</code>应用动词<code>x&u</code>到<code>y</code>共<code>(x v y)</code>次；如果<code>x</code>缺席，<code>(u ^:v y)</code>应用动词<code>u</code>到<code>y</code>共<code>(v y)</code>次。动词幂可以形成动态条件执行，这里的动词<code>v</code>必须总是产生布尔值结果，应用动词<code>u</code>当且仅当<code>v</code>返回<code>1</code>。进而<code>(u ^:v ^:_ y)</code>可以形成while-do构造，只要<code>v</code>返回<code>1</code>，就反复的执行<code>u</code>，直到<code>v</code>返回<code>0</code>，或者<code>u</code>将它的参数无变化的返回。例如：
<syntaxhighlight lang="j" highlight="2,4">
   (+: ^:(6&<) "0) 0 3 6 12      NB. 只对大于6的列表项目乘以2
0 3 6 24
   (3&* ^:(100&>) ^:_ "0) 5 100  NB. 重复的三倍y，只要它小于100
135 100
</syntaxhighlight>
在J语言中，[[动名词|动名词]]（gerund）是叫做“原子表示”（atomic representation）的特殊盒子的一个列表，这种盒子可以像任何其他盒子一样使用，并可以最终转变回到要执行的动词。基于动名词的运算有：
*连词<code>`</code>“连结成动名词”（tie or gerund），建立动名词。
*连词<code>`:</code>“唤起动名词”（evoke gerund），在加以运算元之后成为：
**<code>`:6</code>，将动名词转变成动词列车；
**<code>`:0</code>，将转变回来的这些动词分别单独应用，并将它们的结果收集入一个列表。
*连词<code>@.</code>“议程”（agenda），<code>m @. n</code>从动名词<code>m</code>中，选择出第<code>n</code>个原子表示，将它转变回到动词并执行它。
下面举例说明：
<syntaxhighlight lang="j" highlight="3-11,13,15,17,18,20">
   grd =: * ` (+&2)  NB. 建立一个动名词
   grd               NB. 显示原子表示，这里的符号'0'标识名词
┌─┬─────────────┐
│*│┌─┬─────────┐│
│ ││&│┌─┬─────┐││
│ ││ ││+│┌─┬─┐│││
│ ││ ││ ││0│2││││
│ ││ ││ │└─┴─┘│││
│ ││ │└─┴─────┘││
│ │└─┴─────────┘│
└─┴─────────────┘
   grd `:6          NB. 将动名词转变回动词
* +&2
   (grd `:6) 2 3    NB. 实际运行这个动词
8 15
   (+: ` *:) `:0 i. 3
0 2 4
0 1 4
   ((%&2) ` (+&3) @. (2&|) "0) 5 6 7 8
8 3 10 4
</syntaxhighlight>

==定义==
J语言支持用户进行显式定义<ref>{{cite web|author=Kenneth E. Iverson|title=Formal Function Definition|year=1974|url=https://www.jsoftware.com/papers/DirectDef.htm|publisher=Elementary Functions, IBM Corp. Chapter 10|quote=The recursive definition of factorial therefore requires the following three pieces of information:<br />The primary expression : <code>⍵×f ⍵-1</code><br />A proposition<nowiki>                      </nowiki>: <code>⍵=1</code><br />A secondary expression : <code>1</code><br />In a formal definition these three data are presented in the foregoing order with colons separating them. Thus:<br /><code><nowiki>    </nowiki>fac:⍵×fac ⍵-1:⍵=1:1</code><br /><code><nowiki>    </nowiki>fac 4</code><br /><code>24</code><br />A proposition is a function which yields one of two values, 0 (representing false) or 1 (representing true). In a recursive definition the proposition is executed first; its result determines which defining expression is to be used, the primary if the result is <code>0</code>, and the secondary if the result is <code>1</code>. The secondary expression must not include within it the function being defined.}}<br />{{cite web|author=Kenneth E. Iverson, Peter K. Wooster|title=A Function Definition Operator|url=https://dl.acm.org/doi/pdf/10.1145/390007.805349|publisher=APL Quote Quad, Volume 12, Number 1, Proceedings of APL81, ACM|date=September 1981|quote=This paper proposes two related extensions to APL: the extension of assignment to allow a name <code>F</code> to be assigned to a derived function by an expression of the form <code>F←+.x</code>, and the introduction of a dyadic operator <code>∇</code> to apply to character arrays <code>D</code> and <code>M</code> so that <code>D∇M</code> produces an ambivalent function in which the dyadic case is defined by <code>D</code> and the monadic case by <code>M</code>.}}<br />{{cite web|url=https://www.jsoftware.com/papers/RationalizedAPL.htm|author=Kenneth E. Iverson|title=Rationalized APL|year=1983|quote=The proposed replacement for <code>⎕fx</code> is a modification of the direct definition operator <code>∇</code> defined in [A Function Definition Operator], ……<br />A function produced by the operator <code>∇</code> may be assigned a name (as in <code>f←m∇d</code> or in <code>a(f←m∇d)b</code>), but it may also be used without assigning a name, as in <code><nowiki>y←''∇'⍺+÷⍵'/x</nowiki></code>.}}
</ref>，和<code>{{</code>……<code>}}</code>形式的{{en-link|直接函数|Direct function|直接定义}}<ref>{{cite web|author={{en-link|John M. Scholes|John M. Scholes|John Scholes}}|title=Direct Functions in Dyalog APL|date=October 1996|url=http://www.dyalog.com/uploads/documents/Papers/dfns.pdf|quote=A Direct Function (dfn) is a new function definition style, which bridges the gap between named function expressions such as <code>rank←⍴∘⍴</code> and APL’s traditional ‘header’ style definition.}}<br />
{{cite web|title=System/ReleaseNotes/J902|url=https://code.jsoftware.com/wiki/System/ReleaseNotes/J902|date=14 May 2020|quote=Explicit entities can be defined using direct definition. The digraphs <code>{{</code> and <code>}}</code> are reserved for delimiters, and text found between <code>{{ }}</code> is taken to define a verb/adverb/conjunction. The text may be multiple lines long and may contain other embedded definitions. The part of speech of the defined entity is inferred from the words in it. }}</ref>。下面以五种[[复合函数|复合]]的显式定义为例：
<syntaxhighlight lang="j">
   at=: conjunction define 
     u (v y)
   :
     u (x v y)
   )
   atop=: conjunction def '(u at v)"v'
   beside=: conjunction define 
     u (v y)
   :
     x u (v y)
   )
   appose=: conjunction define
     u (v y)
   :
     (v x) u (v y)
   )
   compose=: conjunction def '(u appose v)"(0{v b.0)'
</syntaxhighlight>

在显式定义中提供了类似其他过程语言的控制结构<ref>[https://code.jsoftware.com/wiki/Vocabulary/ControlStructures 控制结构]</ref>。这里列出的是每个范畴内的代表性控制字：
{| class="wikitable"
|-
! 范畴 !! 控制结构
|-
| 断言触发 ||<code>assert.</code>
|-
| 返结果退出 ||<code>return.</code>
|-
| 跳转到标号 ||<code>goto_label. label_lbl.</code>
|-
| 条件执行 ||<code>if. T do. B else. B1 end.</code>
|-
| 情况执行 ||<code>select. T case. T0 do. B0 end.</code>
|-
| 条件循环 ||<code>while. T do. B end. </code>
|-
| 逐项执行 ||<code>for. T do. B end.</code>
|-
| 终止循环 ||<code>break.</code>
|-
| 终止本次迭代 ||<code>continue.</code>
|-
| 尝试执行捕获异常 ||<code>try. B catch. B1 end.</code>
|-
| 抛出异常 ||<code>throw.</code>
|}

==例子程序==
===斐波那契数列===
下面的例子演示递归的计算[[斐波那契数列|斐波那契数列]]：
<syntaxhighlight lang="j">
   fibonacci=: 1: ` (fibonacci@(-&2) + fibonacci@<:) @. (>&2) "0
</syntaxhighlight>

注意这里的<code>1:</code>是常量动词。下面的代码，不再通过名字引用动词，转而使用动词<code>$:</code>：
<syntaxhighlight lang="j">
   fibonacci=: 1: ` ($:@(-&2) + $:@<:) @. (>&2) "0
</syntaxhighlight>

用例：
<syntaxhighlight lang="j" highlight="2">
   fibonacci }.i.10
1 1 2 3 5 8 13 21 34
</syntaxhighlight>

===快速排序===
下面的例子代码是升序[[快速排序|快速排序]]的直接定义<ref>{{cite web|title=APL since 1978|url=https://dl.acm.org/doi/pdf/10.1145/3386319|author=Roger K. W. Hui, Morten J. Kromberg|publisher=Proceedings of the ACM on Programming Languages, Volume 4, Issue HOPL|year=2020|quote=Quicksort works by choosing a “pivot” at random among the major cells, then catenating the sorted major cells which strictly precede the pivot, the major cells equal to the pivot, and the sorted major cells which strictly follow the pivot, as determined by a comparison function <code>⍺⍺</code>. Defined as an operator <code>Q</code>:<br /><code><nowiki>   </nowiki>Q←{1≥≢⍵:⍵ ⋄ s←⍵ ⍺⍺ ⍵⌷⍨?≢⍵ ⋄ (∇ ⍵⌿⍨0>s)⍪(⍵⌿⍨0=s)⍪(∇ ⍵⌿⍨0<s)}</code><br />……<br />The above formulation is not new; see for example Figure 3.7 of the classic The Design and Analysis of Computer Algorithms [Aho et al. 1974]. However, unlike the pidgin ALGOL program in Figure 3.7, <code>Q</code> is executable, and the partial order used in the sorting is an operand, the <code>(×-)</code> and <code>cmp¨</code> and <code>cmp⍤1</code> in the examples above.}}</ref>：
<syntaxhighlight lang="j">
   cmp=: * @ -
   quicksort=: {{
     if. 1 >: #y do. y
     else.
       s=. (cmp ({~ ?@#)) y
       (quicksort (0 > s) # y) , ((0 = s) # y) , (quicksort (0 < s) # y) 
     end. }}
</syntaxhighlight>
这里定义一个复合动词<code>cmp</code>，它通过逐个做两个数的差并取其符号，得到取值为<code>_1</code>、<code>0</code>或<code>1</code>的[[平衡三进制|平衡三进制]]值的一个列表。在<code>quicksort</code>动词定义中，首先向局部变量<code>s</code>赋值的表达式，是两层的钩子（hook）。在显式定义和直接定义中可以不采用钩子，而写成更显然的：{{code|y cmp y {~?# y|lang="j"}}。

外层的一元钩子的第一步随机选择支点（pivot）运算，是个嵌套的一元钩子，它的第一步运算<code>?@#</code>，生成在数据总个数范围内的[[随机数|随机数]]，而它的第二步运算是二元索引运算<code>{</code>，这需要对换了左右参数位置，它选择出在随机数指定的位置上的支点值。外层的一元钩子的第二步运算，将二元动词<code>cmp</code>，应用到其左参数的数据列表，和右参数即嵌套钩子给出的支点值之上。

随后是串接分治运算结果，在给递归调用的数据参数中，将平衡三进制值列表，分别与<code>0</code>做逐项的[[三分律|三分法]]比较，得到三个布尔值列表。然后以这种列表中的<code>0</code>和<code>1</code>作为件数，复制出数据列表的符合这个条件一个新的子列表。

下面的快速排序实现，展示了[[隐式编程|隐式编程]]<ref name="train" />，即将函数复合在一起，而不显式的引用任何变量，和要应用于其上的形式参数，这里消隐了前面代码中的局部变量<code>s</code>，和形式参数<code>y</code>：
<syntaxhighlight lang="j" highlight="4">
   cmp=: * @ -
   quicksort=: {{((($: @ #~ 0&>) , (#~ 0&=) , ($: @ #~ 0&<)) (u ({~ ?@#))) ^: (1<#)}}}
   cmp quicksort 15 2 9 10 4 0 13 13 18 7 
0 2 4 7 9 10 13 13 15 18
</syntaxhighlight>
提供给连词<code>^:</code>的左侧运算元，外层是个一元钩子，它将提供给它的单一右数据参数，重复放置在它的左数据参数位置上。这个外层一元钩子的第一步运算，是生成平衡三进制值列表的两层钩子；而外层一元钩子的第二步运算，是串接起来的三个递归调用，数据列表是它们三个的左参数，而平衡三进制值列表是它们三个的右参数。递归调用是自引用<code>$:</code>和嵌套的二元钩子的复合，这个嵌套的二元钩子的第二步运算，是二元复制运算<code>#</code>，它需要对换了左右参数的位置。

这里定义的<code>quicksort</code>是副词，把<code>cmp</code>的表达式，代入定义中的左运算元<code>u</code>，就能得到前面那样的动词，同时也不再需要采用直接定义的形式。

===内存映射文件===
将J语言中的变量映射到文件系统中的持久文件，需要安装[[内存映射文件|内存映射文件]]插件<code>'data/jmf'</code>，下面是简单用例：
<syntaxhighlight lang="j" highlight="9,12,13,15">
   load 'data/jmf'       NB. 加载插件
   V=: 2 2 $ 1 2 3 4     NB. 测试用阵列数值
   S=: 64000             NB. 文件大小（字节）
   F=: '~/persis.jmf'    NB. 文件路径及名字
   createjmf_jmf_ F ; S  NB. 建立并打开持久文件
   map_jmf_ 'P' ; F      NB. 映射变量至持久文件
   P=: V                 NB. 将测试内容赋值到P
   unmap_jmf_ 'P'        NB. 解除映射并关闭文件
0
   map_jmf_ 'Q' ; F      NB. 再次建立映射
   ] Q                   NB. 查看持久文件保存内容
1 2
3 4
   unmap_jmf_ 'Q'        NB. 再次解除映射
0
</syntaxhighlight>

==调试==
J语言拥有常规设施，可以停止在动词内错误或特定位置上。它还有一个唯一的可视调试器，叫做Dissect<ref>[http://code.jsoftware.com/wiki/Vocabulary/Dissect 剖析] {{Wayback|url=http://code.jsoftware.com/wiki/Vocabulary/Dissect |date=20200614212752 }}</ref>，给出一个单一的J句子执行的2-D交互显示。因为J语言的一个单一句子在低层语言中，是作为一个完整的子例程进行计算的，这个可视显示非常有用。

==参见==
* [[秩_(J编程语言)|秩 (J编程语言)]]

==引用==
{{reflist|2}}

== 外部連結 ==
*[http://www.jsoftware.com JSoftware]{{Wayback|url=http://www.jsoftware.com/ |date=20041120005318 }}，J的官方網站
*{{GitHub|jsoftware}} – Repository
*[http://www.jsoftware.com/help/learning/contents.htm Learning J] {{Wayback|url=http://www.jsoftware.com/help/learning/contents.htm |date=20201111170920 }} – An Introduction to the J Programming Language by Roger Stokes
*[https://www.jsoftware.com/help/jforc/contents.htm J for C Programmers] {{Wayback|url=https://www.jsoftware.com/help/jforc/contents.htm |date=20201112002908 }} by Henry Rich
*[https://www.jsoftware.com/papers/j4apl.htm J for the APL Programmer] {{Wayback|url=https://www.jsoftware.com/papers/j4apl.htm |date=20180716014828 }} by Chris Burke and Roger Hui
*[https://www.jsoftware.com/ioj/ioj.htm An Implementation of J] {{Wayback|url=https://www.jsoftware.com/ioj/ioj.htm |date=20200607231048 }} by Roger K.W. Hui
*[https://code.jsoftware.com/wiki/APL2JPhraseBook APL to J Phrasebook] {{Wayback|url=https://code.jsoftware.com/wiki/APL2JPhraseBook |date=20170818204530 }}
*[https://aplwiki.com/wiki/J J － APL Wiki]
*[http://faculty.ndhu.edu.tw/~pkuo/computer/dicttw/main.htm 郭平欣譯J字典] {{Wayback|url=http://faculty.ndhu.edu.tw/~pkuo/computer/dicttw/main.htm |date=20171014095636 }} 

{{APL编程语言}}
{{程序设计语言|J}}
{{Authority control}}

[[Category:APL編程語言家族|Category:APL編程語言家族]]
[[Category:陣列編程語言|Category:陣列編程語言]]
[[Category:动态类型编程语言|Category:动态类型编程语言]]
[[Category:函数式编程语言|Category:函数式编程语言]]
[[Category:函数级语言|Category:函数级语言]]
[[Category:面向对象的编程语言|Category:面向对象的编程语言]]
[[Category:基于类的编程语言|Category:基于类的编程语言]]