'''替换失败并非错误''' ('''Substitution failure is not an error, SFINAE''')是指[[C++|C++]]语言在[[模板_(C++)|模板]]参数匹配失败时不认为这是一个编译错误。{{tsl|en|David Vandevoorde|戴维·范德沃德}}最先引入SFINAE缩写描述相关编程技术。<ref>{{cite book | last=Vandevoorde | first=David |author2=Nicolai M. Josuttis  | title=C++ Templates: The Complete Guide | url=https://archive.org/details/ctemplatescomple0000vand | publisher=Addison-Wesley Professional | year=2002 | isbn=0-201-73484-2}}</ref>

具体说，当创建一个[[函数重载|重载函数]]的候选集时，某些（或全部）候选函数是用模板实参替换（可能的推导）模板形参的模板实例化结果。如果某个模板的实参替换时失败，编译器将在候选集中删除该模板，而不是当作一个编译错误从而中断编译过程，这需要C++语言标准授予如此处理的许可。<ref>International Organization for Standardization. "ISO/IEC 14882:2003, Programming languages — C++", § 14.8.2.</ref> 如果一个或多个候选保留下来，那么函数重载的解析就是成功的，函数调用也是良好的。 

==例子==
下属简单例子解释了SFINAE：

<syntaxhighlight lang="cpp">
struct Test {
  typedef int foo;
};

template <typename T>
void f(typename T::foo) {}  // Definition #1

template <typename T>
void f(T) {}  // Definition #2

int main() {
  f<Test>(10);  // Call #1.
  f<int>(10);   // Call #2. 并无编译错误(即使没有 int::foo)
                // thanks to SFINAE.
}
</syntaxhighlight>

在限定名字解析时(<code>T::foo</code>)使用非类的数据类型，导致<code>f<int></code>推导失败因为<code>int</code>并无嵌套数据类型<code>foo</code>, 但程序仍是良好定义的，因为候选函数集中还有一个有效的函数。

虽然SFINAE最初引入时是用于避免在不相关模板声明可见时（如通过包含头文件）产生不良程序。许多程序员后来发现这种行为可用于编译时[[内省_(计算机科学)|内省]]（introspection）。具体说，在模板实例化时允许模板确定模板参数的特定性质。

例如，SFINAE用于确定一个类型是否包含特定typedef：

<syntaxhighlight lang="cpp">
#include <iostream>

template <typename T>
struct has_typedef_foobar {
  // Types "yes" and "no" are guaranteed to have different sizes,
  // specifically sizeof(yes) == 1 and sizeof(no) == 2.
  typedef char yes[1];
  typedef char no[2];

  template <typename C>
  static yes& test(typename C::foobar*);

  template <typename>
  static no& test(...);

  // If the "sizeof" of the result of calling test<T>(nullptr) is equal to
  // sizeof(yes), the first overload worked and T has a nested type named
  // foobar.
  static const bool value = sizeof(test<T>(nullptr)) == sizeof(yes);
};

struct foo {
  typedef float foobar;
};

int main() {
  std::cout << std::boolalpha;
  std::cout << has_typedef_foobar<int>::value << std::endl;  // Prints false
  std::cout << has_typedef_foobar<foo>::value << std::endl;  // Prints true
}
</syntaxhighlight>

当类型<code>T</code>有嵌套类型<code>foobar</code>，<code>test</code>的第一个定义被实例化并且空指针常量被作为参数传入。（结果类型是<code>yes</code>。）如果不能匹配嵌套类型<code>foobar</code>，唯一可用函数是第二个<code>test</code>定义，且表达式的结果类型为<code>no</code>。省略号（ellipsis）不仅用于接收任何类型，它的转换的优先级是最低的，因而优先匹配第一个定义，这去除了二义性。

== C++11的简化==
[[C++11|C++11]]中，上述代码可以简化为:

<syntaxhighlight lang="cpp">
#include <iostream>
#include <type_traits>

template <typename... Ts>
using void_t = void;

template <typename T, typename = void>
struct has_typedef_foobar : std::false_type {};

template <typename T>
struct has_typedef_foobar<T, void_t<typename T::foobar>> : std::true_type {};

struct foo {
  using foobar = float;
};

int main() {
  std::cout << std::boolalpha;
  std::cout << has_typedef_foobar<int>::value << std::endl;
  std::cout << has_typedef_foobar<foo>::value << std::endl;
}
</syntaxhighlight>

C++标准的未来版本中[http://en.cppreference.com/w/cpp/experimental/lib_extensions_2 Library fundamental v2 (n4562)] {{Wayback|url=http://en.cppreference.com/w/cpp/experimental/lib_extensions_2 |date=20201112012859 }}建议把上述代码改写为:
<syntaxhighlight lang="cpp">
#include <iostream>
#include <type_traits>

template <typename T>
using has_typedef_foobar_t = typename T::foobar;

struct foo {
  using foobar = float;
};

int main() {
  std::cout << std::boolalpha;
  std::cout << std::is_detected<has_typedef_foobar_t, int>::value << std::endl;
  std::cout << std::is_detected<has_typedef_foobar_t, foo>::value << std::endl;
}
</syntaxhighlight> 

[[Boost_C++_Libraries|Boost]]的使用者在boost::enable_if<ref name="enable_if">{{Cite web |url=http://www.boost.org/doc/libs/release/libs/utility/enable_if.html |title=Boost Enable If |access-date=2020-08-18 |archive-date=2008-09-05 |archive-url=https://web.archive.org/web/20080905115749/http://www.boost.org/doc/libs/release/libs/utility/enable_if.html |dead-url=no }}</ref>中使用SFINAE。

==参考文献==
{{reflist}}
[[Category:C++|Category:C++]]