{{multiple issues|
{{expand|time=2013-10-03T04:02:54+00:00}}
{{expert|time=2013-10-03T04:02:54+00:00}}
{{lead section|time=2013-10-03T04:02:54+00:00}}

}}
{{for|元维基全域锁定方针|meta:Global locks/zh}}
{{noteTA
|G1=IT
}}

在[[计算机科学|计算机科学]]中，'''锁'''是在执行[[多线程|多线程]]时用于强行限制资源访问的[[同步|同步]]机制，即用于在[[并发控制|并发控制]]中保证对[[互斥|互斥]]要求的满足。

一般的鎖是建議鎖（advisory lock），每個線程在訪問對應資源前都需取得鎖的資訊，再根據資訊決定是否可以存取。若存取對應資訊，鎖的狀態會改變為鎖定，因此其他線程此時不會訪問該資源，當資源結束後，會恢復鎖的狀態，允許其他線程的訪問。我们日常使用的基本都是建议锁，它并不强制生效。这里的不强制生效的意思是，如果某一个进程对一个文件持有一把锁之后，其他进程仍然可以直接对文件进行各种操作的，比如open、read、write。只有当多个进程在操作文件前都去检查和对相关锁进行锁操作的时候，文件锁的规则才会生效。这就是一般建议锁的行为。

有些系統有強制鎖（mandatory lock），若有未授權的線程想要訪問鎖定的資料，在訪問時就會產生[[异常处理|异常]]。强制锁试图实现一套内核级的锁操作。当有进程对某个文件上锁之后，其他进程即使不在操作文件之前检查锁，也会在open、read或write等文件操作时发生错误。内核将对有锁的文件在任何情况下的锁规则都生效，这就是强制锁的行为。由此可以理解，如果内核想要支持强制锁，将需要在内核实现open、read、write等系统调用内部进行支持<ref>{{Cite web |title=Linux的进程间通信-文件和文件锁 |url=https://zorro.gitbooks.io/poor-zorro-s-linux-book/content/linuxde-jin-cheng-jian-tong-4fe1-wen-jian-he-wen-jian-suo.html?q= |website=https://zorro.gitbooks.io/ |access-date=2022-06-26 |dead-url=no}}</ref>。

==相關條目==
* [[线程安全|线程安全]]
*[[互斥锁|互斥锁]]
*[[封锁_(数据库)|封锁 (数据库)]]


{{软件设计模式}}
[[Category:软件设计模式|Category:软件设计模式]]
[[分類:協同控制|分類:協同控制]]