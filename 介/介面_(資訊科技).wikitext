{{noteTA
|G1=IT
}}

{{各地中文名
 | t     = 1 
 | name  = interface
 | cn    = 界面、接口
 | tw    = 介面
 | hk    = 界面、介面
}}

'''-{zh:介面;zh-cn:接口;zh-tw:介面}-'''（{{lang-en|'''interface'''}}），台灣譯為-{介}-面，'''仲介之面'''的意思；中國大陆譯作-{界}-面，也譯作-{接口}-，但「port」大陸也是譯作-{接口}-。介面泛指實體把自己提供給外界的一種[[抽象化_(電腦科學)|抽象化]]物（可以為另一實體），用以由內部操作分離出外部溝通方法，使其能被修改內部而不影響外界其他實體與其互動的方式，就如[[物件導向程式設計|物件導向程式設計]]提供的[[多态_(计算机科学)|多重抽象化]]。

介面是兩實體交換資料的媒介，交換資料的實體可以是[[軟體|軟體]]、[[硬體|電腦硬體]]、[[外部设备|外部设备]]、人等等<ref name="HookwayInterface14">{{cite book |url=https://books.google.com/books?id=BQM_AwAAQBAJ |chapter=Chapter 1: The Subject of the Interface |title=Interface |author=Hookway, B. |publisher=MIT Press |pages=1–58 |year=2014 |isbn=9780262525503 |access-date=2020-09-24 |archive-date=2020-07-29 |archive-url=https://web.archive.org/web/20200729165931/https://books.google.com/books?id=BQM_AwAAQBAJ |dead-url=no }}</ref>。有些介面（例如[[觸控式螢幕|觸控式螢幕]]）是雙向的，可以傳送資訊，同時接收資訊，有些介面（例如滑鼠或喇叭）則是單向的，只能傳送或接收資訊<ref>{{cite encyclopedia
 | year = 2000
 | title = IEEE 100 - The Authoritative Dictionary Of IEEE Standards Terms 
 | publisher = IEEE Press
 | location = NYC, NY, USA
 | isbn = 9780738126012
 | pages = 574–575}}</ref>。人類與電腦等資訊機器或人類與[[计算机程序|程式]]之間的介面稱為[[使用者介面|使用者介面]]。電腦等資訊機器硬體元件間的介面叫硬體介面。電腦等資訊機器軟體元件間的介面叫軟體介面。

介面可能也提供某種意義上的在講不同語言的實體之間的翻譯，諸如人類與電腦之間。因為介面是一種間接手段，所以相比起直接溝通，會引致些額外負擔。

==硬體介面==
{{main|电子连接器}}
硬體介面為電腦等的資訊機器的[[硬體|硬體]]之間通信時的物理[[連接器_(電腦硬體)|連接器]]形狀、傳送接收信號的方法（[[通訊協定|協定]]）等等的規格。主要可分為[[并行通信|並列]]連結的和[[位元|位元]][[序列|序列]]連結的。序列連結者相比起並列連結者，多得多使用同一電線作為信號控制線和電源供應線。[[個人電腦|個人電腦]]領域，因並列連結向更高傳輸速度的發展遇到瓶項，而在向各介面的序列連結方式遷移（參看[[匯流排_(數據)|匯流排]]）。

==軟體介面==
{{See also|应用二进制接口|应用程序接口}}

軟體介面可能會指不同層次上的各種介面：[[作業系統|作業系統]]和硬體之間會有介面、電腦上運行的[[应用程序|应用程序]]或[[计算机程序|计算机程序]]需要有介面來處理[[字串流|字串流]]、{{le|過濾器 (軟體)|Filter (software)|過濾器}}及[[管道_(軟體)|管道]]<ref name="BuyyaMastering13">{{cite book |url=https://books.google.com/books?id=VSDZAgAAQBAJ&pg=SA2-PA13 |title=Mastering Cloud Computing |author=Buyya, R. |publisher=Tata McGraw-Hill Education |page=2.13 |year=2013 |isbn=9781259029950 |access-date=2020-09-24 |archive-date=2020-07-29 |archive-url=https://web.archive.org/web/20200729160339/https://books.google.com/books?id=VSDZAgAAQBAJ&pg=SA2-PA13 |dead-url=no }}</ref>、在[[面向对象程序设计|面向对象程序设计]]中，應用程式中的物件會透過[[方法_(電腦科學)|方法]]來和外面互動，這也是一種介面<ref name="PooObject08">{{cite book |chapter=Chapter 2: Object, Class, Message and Method |title=Object-Oriented Programming and Java |url=https://archive.org/details/springer_10.1007-978-1-84628-963-7 |author1=Poo, D. |author2=Kiong, D. |author3=Ashok, S. |publisher=Springer-Verlag |pages=7–15 |year=2008 |isbn=9781846289637}}</ref>。而[[軟體|軟體]]間通訊時傳遞消息（message）的規格、[[行程間通訊|行程間通訊]]或[[電腦網路|電腦網路]]也都有介面的特性。

=== 軟體實務上 ===
{{main|介面 (程式設計)}}
在程式設計時的一個基本原則是：所有的資源預設都是不允許直接存取的，只允許透過有良好定義的介面來存取<ref>{{cite web
 |accessdate  = 2011-08-03
 |author      = Bill Venners
 |date        = 2005-06-06
 |location    = http://www.artima.com/index.jsp
 |publisher   = artima developer
 |title       = Leading-Edge Java: Design Principles from Design Patterns: Program to an interface, not an implementation - A Conversation with Erich Gamma, Part III
 |quote       = Once you depend on interfaces only, you're decoupled from the implementation. That means the implementation can vary, and that is a healthy dependency relationship. For example, for testing purposes you can replace a heavy database implementation with a lighter-weight mock implementation. Fortunately, with today's refactoring support you no longer have to come up with an interface up front. You can distill an interface from a concrete class once you have the full insights into a problem. The intended interface is just one 'extract interface' refactoring away. ...
 |url         = http://www.artima.com/lejava/articles/designprinciples.html
 |archiveurl  = https://web.archive.org/web/20110805191904/http://www.artima.com/lejava/articles/designprinciples.html
 |archivedate = 2011-08-05
 |dead-url    = no
}}</ref>。軟體介面提供可以存取電腦系統中資源（例如記憶體、CPU、儲存裝置）的方式。若軟體沒有透過界面存取資源，而是直接存取相關資源，對機能以及穩定性都會造成不良的（而且可能是災難性的）後果{{citation needed|date=2020年9月}}

軟體模組中的介面會提供{{le|常數 (電腦科學)|constant (computer science)|常數}}、[[資料類型|資料類型]]、[[子程序|子程序]]的類型、[[异常处理|异常处理]]規格、以及[[类型特征|类型特征]]。有時介面中也會定義公共[[变量_(程序设计)|变量]]<ref name="PattersonComputer04">{{cite book |title=Computer Organization and Design: The Hardware/Software Interface |author1=Patterson, D.A. |author2=Hennessy, J.L. |publisher=Elsevier |edition=3rd |pages=656 |isbn=9780080502571}}</ref>。

軟體模組''A''的介面會刻意的和模組的[[實現|實現]]分開定義。模組的實現會包括要有關介面的模組以及介面的實際程式碼，也包括模組中的私有程序及方法。另一個軟體模組 ''B''，假設是軟體模組''A''的[[客户端|客户端]]，需通過公開提供的介面才能存取軟體模組''A''。這樣安排在實務的好處是：若將軟體模組''A''的實現方式改成其他方式，但介面不變，軟體模組''B''仍然可以存取軟體模組''A''，軟體模組''A''實現介面的作法不會影響''B''，這就是[[关注点分离|关注点分离]]，只關注介面的規格（也可以參照[[里氏替换原则|里氏替换原则]]）{{citation needed|date=2020年9月}}。

=== 物件導向語言中的介面 ===
在一些[[面向对象程序设计|面向对象程序设计]]語言中（特別是沒有完整[[多重继承|多重继承]]的語言），會用「介面」來定義沒有資料，只有方法的[[抽象資料型別|抽象資料型別]]，以此為{{le|方法 (計算機科學|Method (computer science)|方法}}的簽名（signatures）。任一個具有程式及資料的[[类_(计算机科学)|类 (计算机科学)]]，只要有「介面」中所有的方法，就是「實現」此一介面<ref>{{cite web|url=http://docs.oracle.com/javase/tutorial/java/concepts/interface.html|title=What Is an Interface|work=The Java Tutorials|publisher=Oracle|accessdate=2012-05-01|archiveurl=https://web.archive.org/web/20120412093619/http://docs.oracle.com/javase/tutorial/java/concepts/interface.html|archivedate=2012-04-12|dead-url=no}}</ref>。而且，就算在單一繼承語言中，也可以實現多個介面，因此可以同時「符合」多種型態<ref>{{cite web|url=http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html|title=Interfaces|work=The Java Tutorials|publisher=Oracle|accessdate=2012-05-01|archiveurl=https://web.archive.org/web/20120526080117/http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html|archivedate=2012-05-26|dead-url=no}}</ref>。

介面是[[資料類型|資料類型]]的定義：物件可以改變其型態（例如[[子程序|子程序]]或[[方法_(電腦科學)|方法]]呼叫中），方式是用其所實現的介面或基底類，而不是直接列出具體的[[类_(计算机科学)|类]]。因此所有實現這個介面的类都可以使用{{citation needed|date=2020年10月}}。例如在最終實現之前，可以用[[虛設代碼|虛設代碼]]來讓軟體開發得以進行。另外，在[[测试驱动开发|测试驱动开发]]中，可以在測試過程中用mock物件來取代實際的物件，這類的[[桩_(计算机)|桩]]實現會在後續開發中，再改為真正實作的程式碼。

一般而言，介面中的方法沒有實際的程式碼，因此無法執行。若要執行，需要由非抽象的類別實現其介面，讓方法有實際的程式碼，才能執行{{citation needed|date=2020年10月}}。例如一種稱為<code>[[堆栈|Stack]]</code>的介面需要支援兩種方法：<code>push()</code> and <code>pop()</code>。可以用不同的方式來實現，例如<code>FastStack</code>及<code>GenericStack</code>，第一個可能是快速的，其資料結構是固定長度的，第二個的資料結構其長度可以調整，不過速度較慢。

介面可能會包括許多方法，不過也有可能只有一種方法，甚至完全沒有方法。例如[[Java|Java]]語言定義了介面<code>Readable</code>，只有一個<code>read()</code>方法：會因為不同的用途而有許多不同的實現，例如<code>BufferedReader</code>、<code>FileReader</code>、<code>InputStreamReader</code>、<code>PipedReader</code>及<code>StringReader</code>。像是<code>Serializable</code>等{{le|標記介面模式|Marker interface pattern|標記介面}}完全沒有方法，是在通用處理時，用[[反射式编程|反射]]來提供運行時資訊<ref>{{cite web
 |accessdate  = 2011-08-04
 |location    = http://www.precisejava.com/
 |publisher   = Precise Java
 |title       = Performance improvement techniques in Serialization
 |quote       = We will talk initially about Serializable interface. This is a marker interface and does not have any methods.
 |url         = http://www.precisejava.com/javaperf/j2se/Serialization.htm
 |archiveurl  = https://web.archive.org/web/20110824150046/http://www.precisejava.com/javaperf/j2se/Serialization.htm
 |archivedate = 2011-08-24
 |dead-url    = no
}}</ref>。

=== 介面上的程式設計 ===
介面的使用也可以形成一種稱為「介面上的程式設計」（programming to the interface）的程式設計風格。此作法背後的概念是將程式的邏輯以其物件的介面來呈現，而不是內部實現的細節。介面上的程式設計可以減少和實現相關的相依性，也提高程式的復用性<ref>{{cite book
 | last = Gamma
 | last2 = Helm
 | last3 = Johnson
 | last4 = Vlissides
 | year = 1995
 | title = Design Patterns: Elements of Reusable Object-Oriented Software
 | url = https://archive.org/details/designpatternsel00gamm
 | publisher = Addison Wesley
 | pages = [https://archive.org/details/designpatternsel00gamm/page/17 17–18]}}</ref>。

[[控制反转|控制反转]]是將上述概念推到極致後的一種設計原則。

==使用者介面==
[[使用者介面|使用者介面]]是指人類與機器、裝置、電腦程式或其他複雜工具互動的中介物的聚合。常用於電腦系統和電子裝置文脈。有時也會將[[機械|機械]]系統、交通工具或[[工業|工業]]設備的使用者介面稱為[[人機介面|人機介面]]（Human-Machine Interface ，縮寫為 HMI）。

==參看==
* [[匯流排_(數據)|匯流排 (數據)]]
* [[介面卡|介面卡]]
* [[網路介面|網路介面]]
* [[通訊協定|通訊協定]]
* {{le|抽象倒置|Abstraction inversion}}
* [[应用二进制接口|应用二进制接口]]（ABI）
* [[应用程序接口|应用程序接口]]（API）
* {{le|商業互操作介面|Business Interoperability Interface}}
* {{le|硬碟機介面|Hard disk drive interface}}
* {{le|實現 (計算機科學)|Implementation (computer science)}}
* [[继承_(计算机科学)|继承 (计算机科学)]]
<!--* [[Inheritance_semantics|Inheritance semantics]]-->
* [[模块化编程|模块化编程]]
* [[基于组件的软件工程|基于组件的软件工程]]
* [[虚继承|虚继承]]

==參考資料==
{{reflist}}
[[Category:信息技术|Category:信息技术]]
[[Category:计算机科学|Category:计算机科学]]
[[Category:電子工程|Category:電子工程]]
[[Category:人機互動|Category:人機互動]]
[[Category:介面|]]