{{TA
|G1=IT
}}
在[[物件導向程式設計|物件導向程式設計]]方法中，'''封裝'''（{{lang-en|Encapsulation}}）是指，一種將[[抽象化_(計算機科學)|抽象]]性函式介面的實作細節部份包裝、隱藏起來的方法。同時，它也是一種防止外界呼叫端，去存取[[物件|物件]]內部實作細節的手段，這個手段是由程式語言本身來提供的。封裝被視為是[[物件導向|物件導向]]的四項原則之一。

適當的封裝，可以將物件使用介面的程式實作部份隱藏起來，不讓使用者看到，同時確保使用者無法任意更改物件內部的重要資料，若想接触資料只能通过'''公开接入方法（Publicly accessible methods）'''的方式（ 如："getters" 和"setters"）。它可以讓程式碼更容易理解與維護，{{Citation needed|也加強了程式碼的安全性。|time=2022-06-27T02:27:38+00:00}}


== 解释 ==
在面向对象的语言里，封装往往指以下两个相关联但是独立的概念，有时候这两者是存在因果关系。<ref>{{cite book |first=Michael Lee |last=Scott |title=Programming language pragmatics |url=https://archive.org/details/programminglangu00scot_812 |edition= 2 |publisher=Morgan Kaufmann |year=2006 |isbn=978-0-12-633951-2 |page=[https://archive.org/details/programminglangu00scot_812/page/n513 481] |quote=Encapsulation mechanisms enable the programmer to group data and the subroutines that operate on them together in one place, and to hide irrelevant details from the users of an abstraction.}}</ref><ref name="Dale">{{cite book |first=Nell B. |last=Dale |first2=Chip |last2=Weems |title=Programming and problem solving with Java |url=https://archive.org/details/programmingprobl0000dale |edition= 2nd |publisher=Jones & Bartlett |year=2007 |isbn=978-0-7637-3402-2 |page=[https://archive.org/details/programmingprobl0000dale/page/396 396]}}</ref>

# 一种编程语言的机制，限制直接访问某些对象的部件。<ref>{{cite book |authorlink=John C. Mitchell |first=John C. |last=Mitchell |title=Concepts in programming languages |url=https://archive.org/details/conceptsprogramm00mitc |publisher=Cambridge University Press |year=2003 |isbn=978-0-521-78098-8 |page=[https://archive.org/details/conceptsprogramm00mitc/page/n533 522]}}</ref><ref name=Pierce>{{cite book |last=Pierce |first=Benjamin |authorlink=Benjamin C. Pierce |title=Types and Programming Languages |publisher=MIT Press |year=2002 |isbn=978-0-262-16209-8 |page=[https://archive.org/details/typesprogramming00pier_694/page/n287 266] |ref=harv|title-link=Types and Programming Languages }}</ref>
# 一种编程语言的结构体，其将数据和操作该数据的[[方法_(電腦科學)|方法]]绑在一起，提供了便利性。<ref name=Rogers01>{{cite web |first=Wm. Paul |last=Rogers |url=http://www.javaworld.com/javaworld/jw-05-2001/jw-0518-encapsulation.html?page=9 |title=Encapsulation is not information hiding |publisher=JavaWorld |date=18 May 2001 |access-date=2019-11-22 |archive-url=https://web.archive.org/web/20131029193301/http://www.javaworld.com/javaworld/jw-05-2001/jw-0518-encapsulation.html?page=9 |archive-date=2013-10-29 |dead-url=yes }}</ref><ref>{{cite book |first=Thomas M. |last=Connolly |first2=Carolyn E. |last2=Begg |title=Database systems: a practical approach to design, implementation, and management |url=https://archive.org/details/databasesystemsp00conn_262 |edition=  4th |publisher=Pearson Education |year=2005 |isbn=978-0-321-21025-8 |chapter=Ch. 25: Introduction to Object DMBS § Object-oriented concepts |page=[https://archive.org/details/databasesystemsp00conn_262/page/n864 814]}}</ref>

一些编程语言的研究者和学者将定义①或者定义①+②作为辨认一门语言是否为面向对象语言的标准之一。一些编程语言提供了[[闭包_(计算机科学)|闭包]]作为封装，但是这种功能不属于面向对象的范畴。

在许多编程语言里，组件并不会自动隐藏并且能够被重写，因此，一些倾向于定义②的人会将[[信息隐藏|信息隐藏]]（information hiding）作为一个单独的定义③列举出来。

在使用类的大多面向对象的编程语言中，虽然封装是被支持的，但是仍有其他替代品可以选择。

=== 封装和[[继承_(计算机科学)|继承]] ===
《Design Patterns》的作者们曾经大篇幅地讨论封装和继承的矛盾。根据他们自身的经验，设计师们滥用继承。他们认为继承将破坏封装，考虑父类的实现细节将暴露给子类。<ref name="GoF">{{cite book
| last1            = Gamma
| first1            = Erich
| last2            = Helm
| first2            = Richard
| last3            = Johnson
| first3            = Ralph
| last4            = Vlissides
| first4            = John
| title            = Design Patterns
| date            = 1994
| publisher            = Addison-Wesley
| isbn            = 978-0-201-63361-0
| url            = https://archive.org/details/designpatternsel00gamm
}}</ref>

父类的内部实现对于子类来说是不透明的（实现一个子类时， 你需要了解父类的实现细节， 以此决定是否需要重写某个方法）。<ref>{{Cite web|title=怎样理解“组合优于继承”以及“OO的反模块化”，在这些方面FP具体来说有什么优势？|url=https://www.zhihu.com/question/21862257/answer/181179184|accessdate=2019-11-22|author=萧萧|date=2017-06-09|format=|publisher=|language=zh-hans|archive-date=2020-02-04|archive-url=https://web.archive.org/web/20200204031856/https://www.zhihu.com/question/21862257/answer/181179184|dead-url=no}}</ref>同时，一旦父类被修改，因为子类依赖着父类，所以子类的实现也需要被重新审视。

== 信息隐藏 ==
封装可以隐藏成员变量以及成员函数，对象的内部实现通常被隐藏，并用定义代替。举个例子，仅仅对象自身的方法能够直接接触或者操作这些成员变量。隐藏对象内部信息能供保证一致性：当用户擅自修改内部部件的数据，这可能造成内部状态不一致或者不可用；隐藏对象内部信息能阻止这种后果。一个众所周知的好处是，降低系统的复杂度和提高[[健壮性_(计算机科学)|健壮性]]。

大多数语言（如：C++、C#、 Delphi、Java）通过设定等级去控制内部信息隐藏，经典的是通过'''保留字'''<code>public</code> 暴露信息和 <code>private</code>去隐藏信息。一些语言（如： [[Smalltalk|Smalltalk]] 和 [[Ruby|Ruby]] ）只允许对象去访问隐藏信息。

通常，也是存在方法去暴露隐藏信息，如通过[[反射式编程|反射]](Ruby、Java、C#、etc.)或[[名字修饰|名字修饰]](Python)。

==程式範例==

=== [[保留字|保留字]] ===

====C#範例====
这是一段[[C♯|C#]]代码，演示了如何使用<code>private</code>关键字限制变量的访问：
<syntaxhighlight lang="csharp">
namespace Encapsulation 
{
	class Program 
	{
		public class Account 
		{
			private decimal accountBalance = 500.00m;

			public decimal CheckBalance() 
			{
				return accountBalance;
			}
		}

		static void Main() 
		{
			Account myAccount = new Account();
			decimal myBalance = myAccount.CheckBalance();

			/* Main方法能够通过public的“CheckBalance”方法确认账户余额，但是不能更改它 */
		}
	}
}
</syntaxhighlight>

====JAVA範例====
下面是Java的演示程序:
<syntaxhighlight lang="java">

public class Employee {
    private BigDecimal salary = new BigDecimal(50000.00);
    
    public BigDecimal getSalary() {
        return salary;
    }

    public static void main() {
        Employee e = new Employee();
        BigDecimal sal = e.getSalary();
    }
}
</syntaxhighlight>

=== [[名字修饰|名字修饰]]（Name mangling） ===
下面是Python的要给实例，Python并不支持隐藏变量。然而约定俗成，<code>_var</code> 形式的变量被认为是私有变量。<syntaxhighlight lang="python3">
class Car: 
    def __init__(self):
        self._maxspeed = 200
 
    def drive(self):
        print(f'maximum speed is {self._maxspeed}')
 
redcar = Car()
redcar.drive()  # 打印 'maximum speed is 200'

redcar._maxspeed = 10
redcar.drive()  # 打印 'maximum speed is 10'
</syntaxhighlight>

== 参考文献 ==
{{DEFAULTSORT:Encapsulation}}
[[Category:面向对象的程序设计|Category:面向对象的程序设计]]