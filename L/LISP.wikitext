{{noteTA
|G1=IT}}
{{Infobox programming language
| name = Lisp
| logo = Lisp-glossy-120.jpg
| logo_size = 160px
| paradigm = [[编程范型|多范型]]：[[函数编程语言|函数式]]，[[过程式编程|过程式]]，[[同像性|同像性]]，[[反射式编程|反射式]]，[[元编程|元编程]]
| year = {{Start date and age|1958}}
| designer = [[约翰·麦卡锡|约翰·麦卡锡]]
| developer = [[史帝芬·羅素|史帝芬·羅素]], Timothy P. Hart和Mike Levin
| latest release version =
| latest release date =
| turing-complete = 是
| typing = [[类型系统|动态类型]]，[[强类型|强类型]]
| implementations =
| dialects = [[Arc|Arc]], [[AutoLISP|AutoLISP]], [[Clojure|Clojure]], [[Common_Lisp|Common Lisp]], [[Emacs_Lisp|Emacs Lisp]], [[ISLISP|ISLISP]], [[newLISP|newLISP]], [[PicoLisp|PicoLisp]], [[Racket|Racket]], [[Scheme|Scheme]], [[Cadence_SKILL|SKILL]], {{en-link|T (编程语言)|T (programming language)|T}}
| influenced by = [[資訊處理語言|IPL]]
| influenced =  [[CLU|CLU]], [[Dylan_(编程语言)|Dylan]], [[Falcon|Falcon]], [[Forth|Forth]], [[Haskell|Haskell]], [[Io_(编程语言)|Io]], Ioke, [[JavaScript|JavaScript]], [[Julia_(编程语言)|Julia]]<ref name="Julia">{{cite web |url=http://julia.readthedocs.org/en/latest/manual/introduction/ |title=Introduction |work=The Julia Manual |publisher=Read the Docs |access-date=2016-12-10 |url-status=dead |archive-url=https://web.archive.org/web/20160408134008/http://julia.readthedocs.org/en/latest/manual/introduction/ |archive-date=2016-04-08}}</ref>, [[Logo语言|Logo]], [[Lua|Lua]], [[LPC_(程式语言)|LPC]], {{en-link|MDL (编程语言)|MDL (programming language)|MDL}}, [[ML语言|ML]], {{tsl|en|Nu (programming_language)|Nu语言|Nu}}, {{tsl|en|OPS5|}}, [[Perl|Perl]], [[POP-2|POP-2]]/{{tsl|en|POP-11||11}}, [[Python|Python]], [[REBOL|REBOL]], [[Ruby|Ruby]], [[Smalltalk|Smalltalk]], [[Wolfram语言|Wolfram语言]]<ref name="Wolfram">{{cite web |url=https://www.wolfram.com/language/faq/ |title=Wolfram Language Q&A |publisher=Wolfram Research |access-date=2016-12-10 |archive-date=2019-05-20 |archive-url=https://web.archive.org/web/20190520223239/http://wolfram.com/language/faq/ }}</ref>
}}
'''Lisp'''（歷史上拼寫為'''LISP'''），是具有悠久歷史的計算機編程語言家族，有獨特和完全用括號的[[波兰表示法|前綴符號表示法]]<ref name="6AN93">{{cite book | title = Milestones in computer science and information technology | author = Edwin D. Reilly | publisher = Greenwood Publishing Group | year = 2003 | isbn = 978-1-57356-521-9 | pages = 156–157 | url = https://books.google.com/books?id=JTYPKxug49IC&pg=PA157 | access-date = 2021-10-24 | archive-date = 2020-08-05 | archive-url = https://web.archive.org/web/20200805044724/https://books.google.com/books?id=JTYPKxug49IC&pg=PA157 }}</ref>。起源於1958年<ref>{{cite web | first = John | last = McCarthy | authorlink = John McCarthy (computer scientist) | title = History of Lisp | publisher = Artificial Intelligence Laboratory, Stanford University | date = 12 February 1979 | url = http://jmc.stanford.edu/articles/lisp/lisp.pdf | quote = There were two motivations for developing a language for the [[IBM_704|IBM 704]]. First, IBM was generously establishing a New England Computation Center at M.I.T. …… Second, IBM was undertaking to develop a program for proving theorems in plane geometry (based on an idea of Marvin Minsky’s), ……. ……<br />In connection with IBM’s plane geometry project, [[Nathaniel_Rochester|Nathaniel Rochester]] and {{en-link|Herbert Gelernter}} (on the advice of McCarthy) decided to implement a list processing language within FORTRAN, ……. This work was undertaken by Herbert Gelernter and Carl Gerberich at IBM and led to FLPL, standing for FORTRAN List Processing Language. ……<br />I spent the summer of 1958 at the IBM Information Research Department at the invitation of Nathaniel Rochester and chose differentiating algebraic expressions as a sample problem. It led to the following innovations beyond FLPL:<br />a. Writing recursive function definitions using conditional expressions. ……<br />b. The maplist function that forms a list of applications of a functional argument to the elements of a list. ……<br />c. To use functions as arguments, one needs a notation for functions, and it seemed natural to use the λ-notation of Church (1941). I didn’t understand the rest of his book, so I wasn’t tempted to try to implement his more general mechanism for defining functions. Church used higher order functionals instead of using conditional expressions. Conditional expressions are much more readily implemented on computers.<br />d. The recursive definition of differentiation made no provision for erasure of abandoned list structure. ……<br />The implementation of LISP began in Fall 1958. …… The programs to be hand-compiled were written in an informal notation called {{en-link|M-表达式|M-expression|M-expressions}} intended to resemble FORTRAN as much as possible. | access-date = 2021-10-25 | archive-date = 2020-11-07 | archive-url = https://web.archive.org/web/20201107223933/http://jmc.stanford.edu/articles/lisp/lisp.pdf }}</ref>，是現今第二悠久而仍廣泛使用的高階編程語言。只有[[Fortran|FORTRAN]]編程語言比它更早一年<ref name="uOUnJ">{{cite web|url=http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-5.html|archive-url=https://web.archive.org/web/20010727170154/http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-5.html|url-status=dead|archive-date=2001-07-27|quote=Lisp is a survivor, having been in use for about a quarter of a century. Among the active programming languages only Fortran has had a longer life.|title=SICP: Foreword}}</ref><ref name="AfFRW">{{cite web|url=http://www-formal.stanford.edu/jmc/history/lisp/node6.html#SECTION00060000000000000000|title=Conclusions|access-date=2014-06-04|archive-url=https://web.archive.org/web/20140403021353/http://www-formal.stanford.edu/jmc/history/lisp/node6.html#SECTION00060000000000000000|archive-date=2014-04-03|url-status=dead}}</ref>。Lisp編程語族已經演變出許多種方言。現代最著名的通用編程語種是[[Scheme|Scheme]]、[[Common_Lisp|Common Lisp]]、[[Racket|Racket]]和[[Clojure|Clojure]]。

Lisp最初創建時受到[[阿隆佐·邱奇|阿隆佐·邱奇]]的[[λ演算|lambda演算]]的影響<ref>{{cite web|author={{en-link|David Turner|David Turner (computer scientist)|David Turner}}|title=Some History of Functional Programming Languages|url=https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf|quote=LISP was not based on the lambda calculus, despite using the word “LAMBDA” to denote functions. At the time he invented LISP, McCarthy was aware of (Church 1941) but had not studied it. The theoretical model behind LISP was Kleene’s theory of first order recursive functions. (McCarthy made these statements, or very similar ones, in a contribution from the floor at the 1982 ACM symposium on LISP and functional programming in Pittsburgh. No written version of this exists, as far as know.)|access-date=2021-10-25|archive-date=2020-04-15|archive-url=https://web.archive.org/web/20200415053847/https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf}}<br />{{cite web|url=http://www.cs.yale.edu/homes/fischer/pubs/lambda.pdf|author={{en-link|Michael J. Fischer}}|title=Lambda-Calculus Schemata|year=1993|publisher=LISP AND SYMBOLIC COMPUTATION: An International Journal, 6, 259–288|quote=Pure LISP allows the definition and evaluation of functions over S-expressions. The lambda notation for functional abstraction is borrowed from Church’s lambda calculus, but otherwise there is little similarity between the two systems. Pure LISP has no higher-order functions, and call-by-value evaluation order is implicitly assumed. Two special constructs, conditional expressions and the label operator, allow recursive functions to be defined. Limited as it is, pure LISP is nevertheless powerful enough to express all partial recursive functions and hence provides an adequate basis for a theory of computation.|access-date=2021-10-25|archive-date=2022-03-02|archive-url=https://web.archive.org/web/20220302172407/http://www.cs.yale.edu/homes/fischer/pubs/lambda.pdf}}</ref>，用來作為計算機程序實用的數學表達<ref name="Steele, Guy Lewis, Jr.; Sussman, Gerald Jay">{{cite web |url=https://dspace.mit.edu/handle/1721.1/6094/ |title=The Art of the Interpreter, or the Modularity Complex (Parts Zero, One, and Two), Part Zero, P. 4 |publisher=MIT Libraries |hdl=1721.1/6094 |access-date=2020-08-01 |archive-date=2021-01-24 |archive-url=https://web.archive.org/web/20210124191506/https://dspace.mit.edu/handle/1721.1/6094 }}</ref>。因為是早期的高階編程語言之一，它很快成為人工智能研究中最受歡迎的編程語言<ref name="APRO">{{cite web |url=https://apro-software.com/top-programming-languages-in-ai/ |title=The Top Programming Languages in Artificial Intelligence |work=[[Artificial_Intelligence|Artificial Intelligence]] |publisher=APRO |access-date=2021-02-15 |url-status=live |archive-url=https://web.archive.org/web/20201030142849/https://apro-software.com/top-programming-languages-in-ai/ |archive-date=2020-10-30}}</ref>。在計算機科學領域，Lisp開創了許多先驅概念，包括：[[树结构|树结构]]、[[垃圾回收_(計算機科學)|自動記憶體管理]]、[[类型系统|动态类型]]、[[条件表达式|条件表达式]]、[[高階函數|高階函數]]、[[遞迴|遞迴]]<ref name="rec">{{Cite book | url = http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf | title = LISP 1.5 Programmer's Manual | publisher = [[MIT_Press|MIT Press]] | author = [[John_McCarthy|John McCarthy]], Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, Michael I. Levin | isbn = 0-262-13011-4 | orig-year = 1962 | edition = 2nd | year = 1985 | quote = A function can be simply a name. In this case its meaning must be previously understood. A function may be defined by using the lambda notation and establishing a correspondence between the arguments and the variables used in a form. If the function is recursive, it must be given a name by using a label. ……<br /> When a symbol stands for a function, the situation is similar to that in which a symbol stands for an argument. When a function is recursive, it must be given a name. This is done by means of the form LABEL, which pairs the name with the function definition on the a-list. The name is then bound to the function definition, just as a variable is bound to its value.<br />In actual practice, LABEL is seldom used. It is usually more convenient to attach the name to the definition in a uniform manner. This is done by putting on the property list of the name, the symbol EXPR followed by the function definition. The pseudo-function <code>define</code> used at the beginning of this section accomplishes this. When <code>apply</code> interprets a function represented by an atomic symbol, it searches the p-list of the atomic symbol before searching the current a-list. Thus a <code>define</code> will override a LABEL. | access-date = 2021-10-25 | archive-date = 2021-03-02 | archive-url = https://web.archive.org/web/20210302065612/http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf }}</ref>、自主（self-hosting）編譯器<ref name="Graham">{{cite web |title=Revenge of the Nerds |author=Paul Graham |url=http://www.paulgraham.com/icad.html |access-date=2013-03-14 |archive-date=2019-06-07 |archive-url=https://web.archive.org/web/20190607061733/http://www.paulgraham.com/icad.html }}</ref>、[[讀取﹣求值﹣輸出循環|讀取﹣求值﹣輸出循環]]（REPL）<ref name="hC1qm">{{Cite book|url=http://www.informit.com/articles/article.aspx?p=1671639&seqNum=3|title=Influential Programming Languages, Part 4: Lisp|last=Chisnall|first=David|date=2011-01-12|access-date=2021-10-24|archive-date=2021-03-01|archive-url=https://web.archive.org/web/20210301061922/https://www.informit.com/articles/article.aspx?p=1671639&seqNum=3}}</ref>。

"LISP"名稱源自「列表處理器」（{{lang-en|LISt Processor}}）的縮寫<ref name="ArtOfLisp">{{cite book|last1=Jones|first1=Robin|last2=Maynard|first2=Clive|last3=Stewart|first3=Ian|title=The Art of Lisp Programming|date=December 6, 2012|publisher=Springer Science & Business Media|isbn=9781447117193|page=2}}</ref>。[[連結串列|列表]]是Lisp的主要數據結構之一，Lisp編程代碼也同樣由列表組成。因此，Lisp程序可以把源代碼當作數據結構進行操作，而使用其中的宏系統，開發人員可將自己定義的新語法或領域專用的語言，嵌入在Lisp編程中。

代碼和數據的可互換性為Lisp提供了立即可辨識的語法。所有的Lisp程序代碼都寫為[[S-表達式|S-表達式]]或以括號表示的列表。函數調用或語義形式也同樣寫成列表，首先是函數或操作符的名稱，然後接著是一或多個參數：例如，取三個參數的函數<code>f</code>即為{{Lisp2|(f arg1 arg2 arg3)}}。

== 歷史 ==
[[File:John_McCarthy_Stanford.jpg|thumb]]]]
{{CSS image crop |Image = Stephen_Russell_2011_(cropped).jpg |bSize = 240 |cWidth = 200 |cHeight = 240 |oTop = 30 |oLeft = 25 |Location= right |Description = [[Steve_Russell_(computer_scientist)|Steve Russell]]}}
1958年，[[約翰·麥卡錫|約翰·麥卡錫]]在[[麻省理工學院|麻省理工學院]]發明了Lisp程式語言。1960年，他在《[[ACM通讯|ACM通讯]]》發表論文，名為《遞迴函數的符號表達式以及由機器運算的方式，第一部》<ref>{{cite journal|author=John McCarthy|author-link=John McCarthy (computer scientist)|title=Recursive functions of symbolic expressions and their computation by machine, Part I.|journal=Communications of the ACM|volume=3|issue=4|year=1960|pages=184–195|url=http://jmc.stanford.edu/articles/recursive/recursive.pdf|publisher=ACM New York, NY, USA|doi=10.1145/367177.367199|access-date=2021-09-23|archive-date=2021-02-19|archive-url=https://web.archive.org/web/20210219160021/http://jmc.stanford.edu/articles/recursive/recursive.pdf}}</ref>。在這篇論文中闡述了只要透過一些簡單的運算子，以及借鑒自[[阿隆佐·邱奇|阿隆佐·邱奇]]的用於匿名函數的表示法，就可以建立一個具[[圖靈完備性|圖靈完備性]]語言，可用於[[演算法|演算法]]中。

1955年至1956年間，[[資訊處理語言|資訊處理語言]]被創造出來用於[[人工智能|人工智能]]。它首先使用的列表處理與遞歸概念被用於了Lisp。

麥卡錫最初使用M-表達式寫程式碼，之後再轉成S-表達式，舉例來說{{en-link|M-表达式|M-expression}}的語法，{{Lisp2|car[cons[A,B]]}}，等同於[[S-表達式|S-表達式]]的{{Lisp2|(car (cons A B))}}。然而由於S-表達式具備[[同像性|同像性]]，即程式與資料由同樣的結構儲存，實際應用中一般只使用S-表達式，而棄用M-表達式。M-表達式曾出現在短暫存在的Horace Enea的{{en-link|MLisp}}<ref name="SMITH">{{cite web| title=MLISP Users Manual| author=David Canfield Smith| url=http://www.softwarepreservation.org/projects/LISP/stanford/Smith-MLISP-AIM-84.pdf| access-date=2006-10-13| archive-date=2021-02-26| archive-url=https://web.archive.org/web/20210226160646/http://www.softwarepreservation.org/projects/LISP/stanford/Smith-MLISP-AIM-84.pdf}}</ref>和{{en-link|Vaughan Pratt}}的{{en-link|CGOL}}之中。

約翰·麥卡錫的學生[[史帝芬·羅素|史帝芬·羅素]]在閱讀完此論文後，認為Lisp編程語言當中的<code>eval</code>函数可以用[[機器碼|機器碼]]來實做。他在[[IBM_704|IBM 704]]機器上，寫出了第一個Lisp[[解释器|解释器]]<ref name="Fs6VP">{{Cite journal |author1=[[John_McCarthy|John McCarthy]] |author2=Robert Brayton |author3=Daniel Edwards |author4={{en-link|Phyllis Fox}} |author5={{en-link|Louis Hodes}} |author6={{en-link|David Luckham}} |author7=Klim Maling |author8={{en-link|David Park|David Park (computer scientist)}} |author9=[[Steve_Russell|Steve Russell]] |title=LISP I Programmers Manual |place=[[Boston|Boston]], [[Massachusetts|Massachusetts]] |publisher=Artificial Intelligence Group, {{en-link|M.I.T. Computation Center}} and Research Laboratory |date=March 1960 |url=http://bitsavers.org/pdf/mit/rle_lisp/LISP_I_Programmers_Manual_Mar60.pdf |journal= |access-date=2021-09-23 |archive-date=2022-04-02 |archive-url=https://web.archive.org/web/20220402002001/http://bitsavers.org/pdf/mit/rle_lisp/LISP_I_Programmers_Manual_Mar60.pdf }}</ref>。1962年，Tim Hart與Mike Levin在麻省理工學院以Lisp編程語言，實做出第一個完整的Lisp編譯器<ref name="LEVIN">{{cite web| title=AI Memo 39-The new compiler| author=Tim Hart and Mike Levin| url=ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-039.pdf| archive-url=https://web.archive.org/web/20201213195043/ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-039.pdf| url-status=dead| archive-date=2020-12-13| access-date=2019-03-18}}</ref>。這兩人在筆記中使用的語法比麥卡錫早期的代碼更接近現代Lisp風格。

研究生Daniel Edwards在1962年之前開發的垃圾收集程序，使得在通用計算機上運行Lisp變得實用，但效率仍然是一個問題。在1963年，Timothy Hart提议向Lisp 1.5增加[[宏|宏]]<ref>{{cite document|title=AIM-057, MACRO Definitions for LISP, Timothy P. Hart|date=October 1963|hdl=1721.1/6111|last1=Hart|first1=Timothy P.}}</ref>。

在1975年，[[蓋伊·史提爾二世|蓋伊·史提爾二世]]和[[傑拉德·傑伊·薩斯曼|傑拉德·薩斯曼]]开发了[[Scheme|Scheme]]，它是使用[[词法作用域|词法作用域]]和[[尾调用|尾调用优化]]的第一个Lisp方言<ref>{{cite web|title=The Revised Report on SCHEME: A Dialect of LISP|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6283|year=1978|quote=SCHEME is a dialect of LISP. It is an expression-oriented, applicative order, interpreter-based language which allows one to manipulate programs as data. <br />It differs from most current dialects of LISP in that it closes all lambda-expressions in the environment of their definition or declaration, rather than in the execution environment. This has the consequence that variables are normally lexically scoped, as in ALGOL. However, in contrast with ALGOL, SCHEME treats procedures as a first-class data type. They can be the values of variables, the returned values of procedures, and components of data structures. <br />Another difference from LISP is that SCHEME is implemented in such a way that tail-recursions execute without net growth of the interpreter stack. The effect of this is that a procedure call behaves like a GOTO and thus procedure calls can be used to implement iterations, as in PLASMA.|access-date=2021-10-26|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235427/https://dspace.mit.edu/handle/1721.1/6283}}</ref>。在1980年代至1990年代期间，[[蓋伊·史提爾二世|蓋伊·史提爾二世]]等人在将新的Lisp方言（多数是[[Maclisp|Maclisp]]的后继者比如ZetaLisp和NIL）统一成单一语言上进行了巨大的努力。新语言[[Common_Lisp|Common Lisp]]，在某种程度上兼容于它所替代的方言。在1994年，[[ANSI|ANSI]]出版了Common Lisp标准《ANSI X3.226-1994信息技术编程语言Common Lisp》。此外还有嵌入到編輯器[[Emacs|Emacs]]中的[[Emacs_Lisp|Emacs Lisp]]，它非常流行并建立了自己的标准。

===联系于人工智能===
{{CSS image crop |Image = LISP machine.jpg |bSize = 300 |cWidth = 200 |cHeight = 300 |oTop = 20 |oLeft = 30 |Location= right |Description = [[Lisp机器|Lisp机器]]，现存于{{en-link|MIT博物馆|MIT Museum}}}}
自从创始以来，Lisp就密切联系于[[人工智能|人工智能]]研究社群，特别是在[[PDP-10|PDP-10]]系统之上<ref name="PYuEL">The 36-bit word size of the [[PDP-6|PDP-6]]/[[PDP-10|PDP-10]] was influenced by the usefulness of having two Lisp 18-bit pointers in a single word. {{cite newsgroup | quote = The PDP-6 project started in early 1963, as a 24-bit machine. It grew to 36 bits for LISP, a design goal. | url = http://groups.google.com/group/alt.folklore.computers/browse_thread/thread/6e5602ce733d0ec/17597705ae289112 | title = The History of TOPS or Life in the Fast ACs | newsgroup = alt.folklore.computers | message-id = 84950@tut.cis.ohio-state.edu | date = 18 October 1990 | author = Peter J. Hurley | access-date = 2021-10-24 | archive-date = 2013-05-28 | archive-url = https://web.archive.org/web/20130528033020/http://groups.google.com/group/alt.folklore.computers/browse_thread/thread/6e5602ce733d0ec/17597705ae289112 }}</ref>。在1970年[[傑拉德·傑伊·薩斯曼|傑拉德·薩斯曼]]和[[特里·威诺格拉德|特里·威诺格拉德]]使用Lisp实现了编程语言{{en-link|Planner (编程语言)|Planner (programming language)|Micro-Planner}}<ref>{{cite web|author=[[Gerald_Jay_Sussman|Gerald Jay Sussman]], [[Terry_Winograd|Terry Winograd]]|url=http://hdl.handle.net/1721.1/5833|title=Micro-planner Reference Manual|publisher=AI Memo No, 203, MIT Project MAC|year=1970|access-date=2021-11-13|archive-date=2008-08-20|archive-url=https://web.archive.org/web/20080820111643/http://hdl.handle.net/1721.1/5833}}</ref>，它被用在著名的AI系统[[SHRDLU|SHRDLU]]之中。

在1970年代，随着AI研究催生了商业分支，使用当时的編譯器技術和硬體，实现出的Lisp系统的性能成为日益严重的问题。這導致了專用於運行Lisp環境和程序的[[Lisp機器|Lisp機器]]的創建，隨着計算機硬體和編譯器技術的迅速發展，Lisp專用機器在1990年代早期被淘汰。

===谱系和方言===
在它六十余年的历史中，Lisp产生了在S-表达式语言的核心主旨上的很多变体。此外，每个给定方言又可能有多种实现，例如[[Common_Lisp|Common Lisp]]就有十余种以上的实现。在一种标准化了的方言之内，符合标准的实现支持相同的核心语言，但是有着不同的扩展和函数库。

在方言间的差异可能是非常显眼的，例如定义一个函数<ref>{{Cite book | url = http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf | title = LISP 1.5 Programmer's Manual | publisher = [[MIT_Press|MIT Press]] | author = [[John_McCarthy|John McCarthy]], Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, Michael I. Levin | isbn = 0-262-13011-4 | orig-year = 1962 | edition = 2nd | year = 1985 | quote = To define these functions, we use the pseudo-function <code>define</code>. …… A pseudo-function is a function that is executed for its effect on the system in core memory, as well as for its value. <code>define</code> causes these functions to be defined and available within the system. Its value is a list of the functions defined ……. | access-date = 2021-10-25 | archive-date = 2021-03-02 | archive-url = https://web.archive.org/web/20210302065612/http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf }}</ref>，Common Lisp使用关键字<code>defun</code><ref name="DEFUN">{{cite web|title=The Revised Maclisp Manual|url=http://maclisp.info/pitmanual/def.html#7.2.1|author={{en-link|Kent Pitman|Kent Pitman|Kent M. Pitman}}|year=1983, 2007|quote=DEFUN Special Form <code>(DEFUN namespec . definitionspec)</code><br />DEFUN offers a way of associating a functional definition with a symbol. …… DEFUN can be used to define both normal functions and special forms (fexprs and macros). ……<br ><code>;; Normal expr or lexpr function definitions<br />(DEFUN name bvl . body)</code><br />……<br />If name is a symbol and bvl is a list of symbols which is free of <code>&</code>keywords (to be described below), the definition is an expr or lexpr definition. In Maclisp, this would be essentially equivalent to writing<br /><code>(DEFPROP name (LAMBDA bvl . body) EXPR)</code>.<br />…… Note also that the keyword EXPR is used for both expr and lexpr definitions. The only distinction between expr and lexpr definitions is whether the bvl is a symbol or a list, but they are specified in the same way and looked up from the same property. ……<br />A {{en-link|fexpr}} is a function for which the formal parameters are not evaluated. The form of a fexpr definition is:<br /><code>(DEFUN name FEXPR (sym) . body)</code>.<br  />The lambda expression which describes a fexpr should expect to receive exactly one argument which will be the list of (unevaluated) arguments given in the call to the fexpr, so usually there is only one bound variable (sym) in the bound variable list. ……<br />DEFUN can also be used to instantiate a MACRO definition. …… The syntax for a macro definition is<br /><code>(DEFUN name MACRO (sym) . body)</code>,<br />where sym will become bound to the whole macro form to be expanded (including the name). Note that this argument convention is different than fexprs, which only receive the cdr of the call form. ……<br />DEFUN was introduced into Maclisp in March, 1969. Although now it is recognized as the standard function defining form because it shields the user from the implementational details of how the function is defined ……. ……<br />DEFPROP Function <code>(DEFPROP sym val indicator)</code><br />Gives sym a property called indicator with value val. The arguments are not evaluated. DEFPROP should not be used imbedded in other expressions. It is intended to occur at toplevel to assign properties that are set up once and never changed. In other places, use PUTPROP with three quoted arguments.|access-date=2021-10-26|archive-date=2022-03-28|archive-url=https://web.archive.org/web/20220328053659/http://www.maclisp.info/pitmanual/def.html#7.2.1}}</ref>，而Scheme使用<code>define</code><ref>{{cite wikisource|title=Scheme: An Interpreter for Extended Lambda Calculus|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|year=1975|quote=DEFINE － This is analogous to the MacLISP DEFUN primitive (but note that the LAMBDA must appear explicitly!). It is used for defining a function in the "global environment" permanently, as opposed to LABELS (see below), which is used for temporary definitions in a local environment. DEFINE takes a name and a lambda expression; it closes the lambda expression in the global environment and stores the closure in the LISP value cell of the name (which is a LISP atom).}}<br />{{cite web|title=The Revised Report on SCHEME: A Dialect of LISP|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6283|year=1978|quote=Atoms which are not atomic symbols (identifiers) evaluate to themselves. Typical examples of such atoms are numbers, arrays, and strings (character arrays). Symbols are treated as identifiers or variables. They may be lexically bound by lambda-expressions. There is a global environment containing values initially have as their values primitive operations such as, for example, <code>CAR</code>, <code>CONS</code>, and <code>PLUS</code>. SCHEME differs from most LISP systems in that the atom <code>CAR</code> is not itself an operation (in the sense of being an invocable object, e.g. a valid first argument to <code>APPLY</code>), but only has one as a value when considered as an identifier.|access-date=2021-10-26|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235427/https://dspace.mit.edu/handle/1721.1/6283}}</ref>。{{link-en|Richard P. Gabriel}}和{{link-en|Kent Pitman}}在1998年的一篇论文中，按采用统一的还是分立的函数与值[[命名空间|命名空间]]，将Lisp家族语言划分为Lisp<sub>1</sub>和Lisp<sub>2</sub><ref>{{cite journal |title=Technical Issues of Separation in Function Cells and Value Cells |url=http://www.nhplace.com/kent/Papers/Technical-Issues.html |author={{en-link|Richard P. Gabriel}} |author2={{en-link|Kent M. Pitman}} |journal=Lisp and Symbolic Computation |date=June 1988 |volume=1 |issue=1 |pages=81–101 |doi=10.1007/bf01806178 |s2cid=26716515 |quote=In this paper, we shall refer to two abstract dialects of Lisp called Lisp<sub>1</sub> and Lisp<sub>2</sub>.<br />Lisp<sub>1</sub> has a single namespace that serves a dual role as the function namespace and value namespace; that is, its function namespace and value namespace are not distinct. In Lisp<sub>1</sub>, the functional position of a form and the argument positions of forms are evaluated according to the same rules. Scheme [Rees 1986] and the language being designed by the EuLisp group [Padget 1986] are Lisp<sub>1</sub> dialects.<br />Lisp<sub>2</sub> has distinct function and value namespaces. In Lisp<sub>2</sub>, the rules for evaluation in the functional position of a form are distinct from those for evaluation in the argument positions of the form. Common Lisp is a Lisp<sub>2</sub> dialect. ……<br />Most Lisp dialects adopted a two-namespace approach to the naming problem. To some extent this is because most dialects followed Lisp 1.5 [McCarthy 1965] or dialects derived from Lisp 1.5. <br />Lisp 1.5 broke symbols into values and functions; values were stored on an {{en-link|关联列表|association list|association list}}, and function on the property lists of symbols. Compiled and interpreted code worked in different ways. ……<br />MacLisp [Pitman 1983] is a direct descendant of the PDP-6 Lisp and is a Lisp<sub>2</sub> dialect. MacLisp uses a sophisticated form of link table, which is made possible by the separation of namespaces. In particular, function-defining functions have controlled access into the places where functions are stored so that the link tables can be correctly maintained. ……<br />Common Lisp was the result of a compromise between a number of dialects of Lisp, most of them descendants of MacLisp, all of them Lisp<sub>2</sub>s. |access-date=2021-11-01 |archive-date=2006-11-13 |archive-url=https://web.archive.org/web/20061113140912/http://www.nhplace.com/kent/Papers/Technical-Issues.html }}</ref>。

====历史上的重要方言====
* LISP 1<ref name="Fs6VP" />，是第一个实现。
* LISP 1.5<ref name="1.5 manual">{{Cite book | url = http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf | title = LISP 1.5 Programmer's Manual | publisher = [[MIT_Press|MIT Press]] | author = [[John_McCarthy|John McCarthy]], Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, Michael I. Levin | isbn = 0-262-13011-4 | orig-year = 1962 | edition = 2nd | year = 1985 | access-date = 2021-10-25 | archive-date = 2021-03-02 | archive-url = https://web.archive.org/web/20210302065612/http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf }}</ref>，是第一个广泛发行的版本，由McCarthy和其他人在MIT开发。如此命名是因为它包含了对最初的LISP 1解释器的改进，但不是{{en-link|LISP 2}}规划的那种重大重构。
* Stanford LISP 1.6<ref name="7q5x9">{{Cite book | url = http://www.softwarepreservation.org/projects/LISP/stanford/SAILON-28.3.pdf | title = Stanford LISP 1.6 Manual | author = Lynn H. Quam | year = 1969 | access-date = 2021-12-29 | archive-date = 2022-03-03 | archive-url = https://web.archive.org/web/20220303000720/http://www.softwarepreservation.org/projects/LISP/stanford/SAILON-28.3.pdf }}</ref>，是{{en-link|斯坦福大学中心和研究所|Stanford University centers and institutes|斯坦福AI实验室}}开发的LISP 1.5后继者，广泛的发行于运行[[TOPS-10|TOPS-10]]操作系统的[[PDP-10|PDP-10]]系统。它被Maclisp和InterLisp所淘汰。
* [[Maclisp|MACLISP]]<ref name="UNDMs">{{cite web | url = http://www.avanthar.com/healyzh/doc/lisp.doc.txt | title = Maclisp Reference Manual | date = March 3, 1979 | access-date = 2021-10-29 | archive-date = 2022-03-28 | archive-url = https://web.archive.org/web/20220328182727/http://www.avanthar.com/healyzh/doc/lisp.doc.txt }}</ref>，由MIT的[[MIT計算機科學與人工智慧實驗室|MAC计划]]开发，MACLISP是LISP 1.5的直接后代。它运行在PDP-10和[[Multics|Multics]]系统上。MACLISP后来被叫做Maclisp，并通常被提及为MacLisp。在MACLISP中的“MAC”，既无关于Apple的[[Macintosh|Macintosh]]，又无关于[[John_McCarthy_(computer_scientist)|McCarthy]]。
* {{en-link|Interlisp}}<ref name="5CtB3">{{Cite book | url = http://www.softwarepreservation.org/projects/LISP/interlisp/Interlisp-Oct_1974.pdf | title = InterLisp Reference Manual | first = Warren | last = Teitelman | year = 1974 | access-date = 2021-10-29 | archive-date = 2022-03-03 | archive-url = https://web.archive.org/web/20220303000904/http://www.softwarepreservation.org/projects/LISP/interlisp/Interlisp-Oct_1974.pdf }}</ref>，由[[BBN_Technologies|BBN科技]]开发，用于运行{{en-link|TENEX (操作系统)|TENEX (operating system)|TENEX}}操作系统的PDP-10系统之上，后来InterLisp-D被[[Xerox|Xerox]] Lisp机器接纳并昵称为西海岸Lisp。还为基于[[MOS_6502|6502]]的{{en-link|Atari 8位机家族|Atari 8-bit family}}计算机发行了叫做“InterLISP 65”的小型版本。在很长一段时间内，Maclisp和InterLisp相互之间是强有力的竞争者。
* [[Franz_Lisp|Franz Lisp]]，起源于[[加利福尼亚大学伯克利分校|加利福尼亚大学伯克利分校]]的计划，后来由Franz Inc开发。这个名字是[[Franz_Liszt|Franz Liszt]]的幽默变形，它不牵涉到Franz Inc后来销售的{{en-link|Allegro Common Lisp}}。
* XLISP，由David Betz开发<ref>{{cite web|url=https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/xlisp/0.html|title=Package: lang/lisp/impl/xlisp/|website=cs.cmu.edu|access-date=2021-10-26|archive-date=2022-03-31|archive-url=https://web.archive.org/web/20220331234758/https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/xlisp/0.html}}</ref>，[[AutoLISP|AutoLISP]]基于了它。
* Standard Lisp和{{en-link|Portable Standard Lisp}}，是曾被广泛使用和移植的[[犹他大学|犹他大学]]开发的版本，特别是用它写成了计算机代数系统{{en-link|Reduce (computer algebra system)|Reduce (computer algebra system)|REDUCE}}。
* {{en-link|Lisp Machine Lisp|Lisp Machine Lisp|ZetaLisp}}，也叫做Lisp Machine Lisp，用在[[Lisp机器|Lisp机器]]之上，是Maclisp的直接后代。ZetaLisp对Common Lisp有巨大影响。
* [[Le_Lisp|Le Lisp]]，是一个法国Lisp方言。最早的{{en-link|图形用户界面建造器|Graphical user interface builder|界面建造器}}之一（叫做SOS界面<ref name="pq98z">{{Cite web |url=https://hal.archives-ouvertes.fr/file/index/docid/70041/filename/RT-0126.pdf |title=Outils de generation d’interfaces : etat de l’art et classification by H. El Mrabet |access-date=2021-10-24 |archive-date=2017-10-01 |archive-url=https://web.archive.org/web/20171001122327/https://hal.archives-ouvertes.fr/file/index/docid/70041/filename/RT-0126.pdf }}</ref>）是用Le Lisp写成的。
* [[Scheme|Scheme]]（1975年版）<ref>{{cite web|title=SCHEME: An Interpreter for Extended Lambda Calculus|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/5794|year=1975|quote=Inspired by [[演员模型|ACTORS]] [Greif and Hewitt][Smith and Hewitt], we have implemented an interpreter for a LISP-like language, SCHEME, based on the lambda calculus [Church], but extended for side effects, multiprocessing, and process synchronization. The purpose of this implementation is tutorial. We wish to:<br />⑴ alleviate the confusion caused by {{en-link|Planner (编程语言)|Planner (programming language)|Micro-PLANNER}}, CONNIVER, etc. by clarifying the embedding of non-recursive control structures in a recursive host language like LISP.<br />⑵ explain how to use these control structures, independent of such issues as pattern matching and data base manipulation.<br />⑶ have a simple concrete experimental domain for certain issues of programming semantics and style.|access-date=2021-10-27|archive-date=2022-04-17|archive-url=https://web.archive.org/web/20220417100809/http://dspace.mit.edu/handle/1721.1/5794}}</ref>。
* [[Common_Lisp|Common Lisp]]（1984年版）<ref name="cltl1">{{Cite book| title = Common Lisp the Language | edition = 1st edition | author = [[Guy_L._Steele,_Jr.|Guy L. Steele, Jr.]], {{en-link|Scott Fahlman}}, {{en-link|Richard P. Gabriel}}, {{en-link|David A. Moon}}, {{en-link|Daniel Weinreb}} | year = 1984 | isbn = 0-932376-41-X}}</ref>，是通过合并对Maclisp的不同尝试（ZetaLisp、{{en-link|Spice Lisp}}、{{en-link|NIL (编程语言)|NIL (programming language)|NIL}}和{{en-link|S-1 Lisp}}）而创建的方言<ref name="cltl2">{{Cite book | chapter-url = https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node6.html | title = Common Lisp the Language | edition = 2nd edition | chapter = Purpose | first = Guy L., Jr. | last = Steele | year = 1990 | isbn = 0-13-152414-3 | access-date = 2021-10-24 | archive-date = 2021-03-08 | archive-url = https://web.archive.org/web/20210308032843/https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node6.html }}</ref>，也具有来自Scheme方言的实质影响。这个版本的Common Lisp在广泛的平台上都能获得到，从而被众人接受为[[业界标准|业界标准]]<ref name="Xvsoj">{{cite web | url = https://www.cs.cmu.edu/Groups/AI/html/faqs/lang/lisp/part2/faq-doc-13.html | title = History: Where did Lisp come from? | work = FAQ: Lisp Frequently Asked Questions 2/7 | date = 20 February 1996 | first1 = Mark | last1 = Kantrowitz | first2 = Barry | last2 = Margolin | access-date = 2021-10-24 | archive-date = 2021-03-08 | archive-url = https://web.archive.org/web/20210308042125/https://www.cs.cmu.edu/Groups/AI/html/faqs/lang/lisp/part2/faq-doc-13.html }}</ref>，直至ANSI Common Lisp（ANSI X3.226-1994）出版。最广泛传播的Common Lisp子方言是[[Steel_Bank_Common_Lisp|Steel Bank Common Lisp]]（SBCL）、[[CMU_Common_Lisp|CMU Common Lisp]]（CMU-CL）、[[Clozure_CL|Clozure OpenMCL]]（不要混淆于Clojure）、GNU [[CLISP|CLISP]]和{{en-link|Allegro Common Lisp}}；所有这些实现都坚持了后来的ANSI CL标准。
* [[Dylan_(编程语言)|Dylan]]，在它的第一个版本中是Scheme和[[Common_Lisp对象系统|Common Lisp对象系统]]的混合。
* {{en-link|EuLisp}}，尝试开发一个新的高效和整洁的Lisp。
* [[ISLISP|ISLISP]]，尝试开发一个新的高效和整洁的Lisp。标准化为ISO/IEC 13816:1997<ref name="E4h75">{{cite web |url=http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=22987 |title=ISO/IEC 13816:1997 |publisher=Iso.org |date=2007-10-01 |access-date=2013-11-15 |archive-date=2016-07-30 |archive-url=https://web.archive.org/web/20160730151347/http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=22987 }}</ref>，后来修订为ISO/IEC 13816:2007<ref name="xECKU">{{cite web |url=http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=44338 |title=ISO/IEC 13816:2007 |publisher=Iso.org |date=2013-10-30 |access-date=2013-11-15 |archive-date=2016-07-30 |archive-url=https://web.archive.org/web/20160730135900/http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=44338 }}</ref>：《信息技术 – 编程语言，它们的环境和系统软件接口 – 编程语言 ISLISP》。
* IEEE [[Scheme|Scheme]]，IEEE标准1178–1990（停用日期：2019-11-07）<ref name="IEEE Scheme" />。
* ANSI [[Common_Lisp|Common Lisp]]（1994年版），是[[美国国家标准协会|美国国家标准协会]]（ANSI）的Common Lisp[[标准化|标准]] ，由{{en-link|X3J13}}委员会创建，其章程是<ref name="CAXAD">{{cite web | url = http://www.nhplace.com/kent/CL/x3j13-86-020.html | title = X3J13 Charter | access-date = 2021-10-24 | archive-date = 2021-03-05 | archive-url = https://web.archive.org/web/20210305194238/http://www.nhplace.com/kent/CL/x3j13-86-020.html }}</ref>：开始于以《{{en-link|Common Lisp语言|Common Lisp the Language}}》作为基础文档<ref name="cltl1" />，致力于通过公开的[[共识决策法|达成共识]]过程，找到Common Lisp实现的程序[[可移植性|可移植性]]和[[兼容性|兼容性]]这个共通问题的解决方案。尽管形式上是ANSI标准，ANSI Common Lisp的实现、销售、使用和影响一直都是世界范围的。
* [[ACL2|ACL2]]，是Common LISP的一个应用式（免于副作用）变体。ACL2既是可以建模计算机系统的编程语言，也是帮助证明这些模型性质的工具。
* {{en-link|Game Oriented Assembly Lisp}}（GOAL），是一个视频游戏编程语言，由{{en-link|Andy Gavin}}和{{en-link|Jak and Daxter}}团队在[[顽皮狗|顽皮狗]]开发。它是使用Allegro Common Lisp写成并被用于整个{{en-link|Jak and Daxter}}系列游戏的开发。

=== 2000年迄今 ===
在1990年代衰退之後，Lisp在2000年之後因一些關注而逐漸復甦。當其他人認為Lisp已經是過時陳舊的，如[[保羅·格雷厄姆|保羅·格雷厄姆]]和[[埃里克·雷蒙|埃里克·雷蒙]]等人繼續出版有關於Lisp編程的著作，一些新的開發人員受到這些作者啟發，經常將Lisp這種語言描述為令人大開眼界的經驗，並聲稱在本質上比較其它編程語言更有生產效率<ref name="sKh98">{{cite web |title=The Road To Lisp Survey |url=http://wiki.alu.org/The_Road_To_Lisp_Survey |access-date=2006-10-13 |archive-url=https://web.archive.org/web/20061004031130/http://wiki.alu.org/The_Road_To_Lisp_Survey |archive-date=2006-10-04 |url-status=dead}}</ref>。這種意識的提高可對比於，Lisp在1990年代中期“[[人工智慧低谷|人工智能冬季]]”的那種短暫增長<ref name="nb7MB">{{cite web |url=http://www.faqs.org/docs/artu/ch14s05.html |title=Trends for the Future |publisher=Faqs.org |access-date=2013-11-15 |archive-date=2013-06-03 |archive-url=https://web.archive.org/web/20130603002452/http://www.faqs.org/docs/artu/ch14s05.html}}</ref>。

在2007年出現了[[Clojure|Clojure]]，它是一个Lisp的新近方言，编译至[[Java虚拟机|Java虚拟机]]并特别关注[[并发性|并发性]]。現今與Lisp有關的大多數新活動，都集中在[[Scheme|Scheme]]、[[Common_Lisp|Common Lisp]]、[[Emacs_Lisp|Emacs Lisp]]、[[Racket|Racket]]和[[Clojure|Clojure]]的實作上，包括開發新的跨平台函式庫和應用。Dan Weinreb在他的2010年調查中，列出了11個積極維護中的Common Lisp實作<ref name="sWbGt">{{cite web|last=Weinreb|first=Daniel|title=Common Lisp Implementations: A Survey|url=http://common-lisp.net/~dlw/LispSurvey.html|access-date=4 April 2012|archive-url=https://web.archive.org/web/20120421181340/http://common-lisp.net/~dlw/LispSurvey.html|archive-date=2012-04-21|url-status=dead}}</ref>。

開源社群建立了至今仍活躍的支援基礎：{{en-link|CLiki}}是個收集Common Lisp相關資訊的維基，Planet Lisp收集了各種Lisp相關博客的內容，Common-lisp.net是開源專案的託管站點。Quicklisp則是含括了許多函式庫的裝載管理器。

Lisp50@OOPSLA慶祝了Lisp的50週年（1958-2008）<ref name="Q9GcA">{{cite web |url=http://www.lisp50.org/ |title=LISP50@OOPSLA |publisher=Lisp50.org |access-date=2013-11-15 |archive-date=2021-03-02 |archive-url=https://web.archive.org/web/20210302095929/https://lisp50.org/ }}</ref>。在波士頓、溫哥華和漢堡，有定期的當地用戶會議。其他活動包括歐洲共同Lisp會議、歐洲Lisp專題討論會和國際Lisp研討會。

[[Scheme|Scheme]]社群積極維護了二十多個實作。在2000年代開發了數個有意義的新實作（[[Chicken_(Scheme)|Chicken]]、[[Gambit_(Scheme实现)|Gambit]]、{{en-link|Gauche (Scheme实现)|Gauche (Scheme implementation)|Gauche}}、{{en-link|Ikarus (Scheme实现)|Ikarus (Scheme implementation)|Ikarus}}、{{en-link|Larceny (Scheme实现)|Larceny (Scheme implementation)|Larceny}}、{{en-link|Ypsilon (Scheme实现)|Ypsilon (Scheme implementation)|Ypsilon}}），[[Scheme|Scheme]]社群廣泛接納了R<sup>5</sup>RS語言標準<ref name="92GaL">{{cite web|url=http://www.schemers.org/Documents/Standards/R5RS/|title=The Revised<sup>5</sup> Report on the Algorithmic Language Scheme|publisher=schemers.org|year=1998|access-date=2021-10-24|archive-date=2007-01-05|archive-url=https://web.archive.org/web/20070105152327/http://www.schemers.org/Documents/Standards/R5RS/}}</ref>。Scheme實作需求過程建立了很多準標準函式庫和Scheme擴展功能。各種 Scheme實作的用戶社群持續地增長。一個新的語言標準化過程於2003年開始，並在2007年產生了R<sup>6</sup>RS標準<ref>{{cite web|title=The Revised<sup>6</sup> Report on the Algorithmic Language Scheme|url=http://www.r6rs.org/|year=2007|access-date=2021-11-04|archive-date=2013-06-25|archive-url=https://www.webcitation.org/6HcvveNv7?url=http://www.r6rs.org/}}</ref>。使用Scheme介紹計算機科學課程的學校似乎有所減少，麻省理工學院的計算機科學入門課程，已經不再使用Scheme<ref name="yVta1">{{cite news|url=http://cemerick.com/2009/03/24/why-mit-now-uses-python-instead-of-scheme-for-its-undergraduate-cs-program/|title=Why MIT now uses python instead of scheme for its undergraduate CS program|date=March 24, 2009|work=cemerick.com|access-date=November 10, 2013|archive-date=September 17, 2010|archive-url=https://web.archive.org/web/20100917102705/http://cemerick.com/2009/03/24/why-mit-now-uses-python-instead-of-scheme-for-its-undergraduate-cs-program/|url-status=dead}}</ref><ref name="XOiAA">{{cite news|url=http://mitadmissions.org/blogs/entry/the_end_of_an_era_1|title=The End of an Era|first=Evan|last=Broder|date=January 8, 2008|work=mitadmissions.org|access-date=November 10, 2013|archive-date=2018-08-21|archive-url=https://web.archive.org/web/20180821202714/http://mitadmissions.org/blogs/entry/the_end_of_an_era_1}}</ref>。

近年来又有了幾種新的Lisp方言：[[Arc|Arc]]、[[Hy_(编程语言)|Hy]]、Liskell<ref>{{cite web|title=Liskell － Haskell Semantics with Lisp Syntax|url=https://clemens.endorphin.org/ILC07-Liskell-draft.pdf|author=Clemens Fruhwirth|year=2007|access-date=2021-10-25|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235711/https://clemens.endorphin.org/ILC07-Liskell-draft.pdf}}</ref>和{{en-link|LFE (编程语言)|LFE (programming language)|LFE}}。此外，{{en-link|Nu (编程语言)|Nu (programming language)|Nu}}是[[OS_X|OS X]]上采用Lisp式语法的脚本语言；Chialisp是编译至CLVM的[[Chia|Chia]][[区块链|区块链]]的链上编程环境。

在2019年10月，[[保羅·格雷厄姆|保羅·格雷厄姆]]发布了一个新的Lisp方言Bel<ref>[http://paulgraham.com/bel.html a specification for Bel] {{Wayback|url=http://paulgraham.com/bel.html |date=20210520030701 }}, "a new dialect of Lisp."</ref>。

=== Lisp編程語族時間軸 ===
{{Lisp}}

==主要方言==
[[Common_Lisp|Common Lisp]]和[[Scheme|Scheme]]是Lisp发展的两大主流的代表。这些语言体现了显著不同的设计选择。

[[Common_Lisp|Common Lisp]]是[[Maclisp|Maclisp]]的后继者。对它有重要影响的是{{en-link|Lisp Machine Lisp}}、Maclisp、{{en-link|NIL (编程语言)|NIL (programming language)|NIL}}、{{en-link|S-1 Lisp}}、{{en-link|Spice Lisp}}和Scheme<ref name="uMuJD">Chapter 1.1.2, History, ANSI CL Standard</ref>。它拥有Lisp Machine Lisp（用于编程[[Lisp机器|Lisp机器]]的大型Lisp方言）的很多特征，但设计上能高效的实现在任何个人计算机或工作站上。Common Lisp是通用编程语言，因而拥有一个大型语言标准，包括很多内建数据类型、函数、宏和其他语言元素，以及一个对象系统（[[Common_Lisp对象系统|Common Lisp对象系统]]）。Common Lisp还从Scheme借鉴了特定特征，比如[[词法作用域|词法作用域]]和[[闭包_(计算机科学)|词法闭包]]。Common Lisp实现目标定为不同的平台，比如：[[LLVM|LLVM]]<ref name="hEWIZ">[https://www.cliki.net/Clasp] {{Wayback|url=https://www.cliki.net/Clasp |date=20210307210357 }} Clasp is a Common Lisp implementation that interoperates with C++ and uses LLVM for [[just-in-time_compilation|just-in-time compilation]] (JIT) to native code.</ref>、[[Java虚拟机|Java虚拟机]]<ref name="vBfvI">[https://common-lisp.net/project/armedbear/] {{Wayback|url=https://common-lisp.net/project/armedbear/ |date=20210324084453 }} "Armed Bear Common Lisp (ABCL) is a full implementation of the Common Lisp language featuring both an interpreter and a compiler, running in the JVM"</ref>、x86-64、PowerPC、Alpha、ARM、Motorola 68000和MIPS<ref name="za6Q8">[https://common-lisp.net/~dlw/LispSurvey.html] {{Webarchive|url=https://web.archive.org/web/20180622083812/https://common-lisp.net/~dlw/LispSurvey.html |date=2018-06-22}} Common Lisp Implementations: A Survey</ref>，和不同的操作系统，比如：Windows、macOS、Linux、Solaris、FreeBSD、NetBSD、OpenBSD、Dragonfly BSD和Heroku<ref name="QX6kG">[https://www.cliki.net/Common+Lisp+implementation] {{Wayback|url=https://www.cliki.net/Common+Lisp+implementation |date=20210308090345 }} Comparison of actively developed Common Lisp implementations</ref>。

[[Scheme|Scheme]]是一个静态作用域和正当尾递归的Lisp编程语言方言<ref>{{cite web|title=The First Report on Scheme Revisited|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://www.researchgate.net/publication/227202780_The_First_Report_on_Scheme_Revisited|year=1998|quote=Sussman had just been studying Algol. He suggested starting with a lexically scoped dialect of Lisp, because that seemed necessary to model the way names could refer to acquaintances in PLASMA. Lexical scoping would allow actors and functions to be created by almost identical mechanisms. Evaluating a form beginning with the word <code>lambda</code> would capture the current variable-lookup environment and create a [[闭包_(计算机科学)|closure]]; evaluating a form beginning with the word <code>alpha</code> would also capture the current environment but create an actor. Message passing could be expressed syntactically in the same way as function invocation. The difference between an actor and a function would be detected in the part of the interpreter traditionally known as <code>apply</code>. A function would return a value, but an actor would never return; instead, it would typically invoke a [[计算续体|continuation]], another actor that it knew about. Our interpreter also provided the necessary primitives for implementing the internal behavior of primitive actors, such as an addition operator that could accept two numbers and a continuation actor. ……<br />…… This led us to three important ideas:<br />• First, we realized that all the patterns of control structure that Hewitt had described in terms of actors could equally well be described by the λ-calculus. ……<br />• Second, we realized that the λ-calculus — a small, simple formalism — could serve as the core of a powerful and expressive programming language. (Lisp had adopted the λ-notation for functions but had failed to support the appropriate behavior for free variables. The original theoretical core of Lisp was recursion equations, not the λ-calculus.) ……<br />• Third, we realized that in our quest for the “ultimate AI language” we had come full circle. As the MIT school had struggled to find more and more powerful ways to express and manipulate control structure to support heuristic search, we had progressed from Lisp to CONVERT to Planner to Conniver to PLASMA to a simple variation of Lisp!|access-date=2021-10-28|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235711/https://www.researchgate.net/publication/227202780_The_First_Report_on_Scheme_Revisited}}</ref>，由[[Guy_L._Steele,_Jr.|Guy L. Steele, Jr.]]和[[Gerald_Jay_Sussman|Gerald Jay Sussman]]发明。它的设计有着异常清晰和简单的语义，和很少的形成表达式的不同方式。它的设计大约比Common Lisp早上一个年代，[[Scheme|Scheme]]是一个相当极简主义的设计。它拥有非常小的标准特征集合，但具有在Common Lisp中未规定的特定实现特征（比如[[尾递归|尾递归]]优化和完全[[计算续体|续体]]）。在Scheme中能方便的表达广阔的编程范型，包括指令式、函数式和消息传递风格。Scheme通过一系列的标准（第n次修订的算法语言Scheme报告）和一系列{{en-link|Scheme实现要求|Scheme Requests for Implementation}}而持续的演化。

[[Clojure|Clojure]]是Lisp的一个新近方言，其目标主要是[[Java虚拟机|Java虚拟机]]、[[通用语言运行库|通用语言运行库]]（CLR）和编译成[[JavaScript|JavaScript]]。它被设计为一个务实的通用编程语言。Clojure受到了[[Haskell|Haskell]]的相当大的影响，因而非常强烈的强调了[[不可变对象|不可变性]]<ref name="clojure-immutability">[http://www.infoq.com/articles/in-depth-look-clojure-collections An In-Depth Look at Clojure Collections] {{Wayback|url=http://www.infoq.com/articles/in-depth-look-clojure-collections |date=20210306154253 }}, Retrieved 2012-06-24</ref>。Clojure提供了对Java框架和库的访问，具有可选的类型提示和[[类型推论|类型推论]]，这样到Java的调用就可以避免反射并确使了快速的原始操作。Clojure设计上不后向兼容于其他Lisp方言<ref name="f6C82">{{cite web |title=Clojure rational |url=https://clojure.org/about/rationale |access-date=27 August 2019 |quote=Clojure is a Lisp not constrained by backwards compatibility |archive-date=2016-01-04 |archive-url=https://web.archive.org/web/20160104224634/http://clojure.org/rationale }}</ref>。

进一步的，Lisp方言在很多应用中被用作[[脚本语言|脚本语言]]，其中最周知的是在[[Emacs|Emacs]]编辑器中的[[Emacs_Lisp|Emacs Lisp]]，在[[AutoCAD|AutoCAD]]中的[[AutoLISP|AutoLISP]]和后来的Visual Lisp，[[Audacity|Audacity]]中的{{en-link|Nyquist (编程语言)|Nyquist (programming language)|Nyquist}}，和[[LilyPond|LilyPond]]中[[GNU_Guile|GNU Guile]]。有用的Scheme解释器潜在的有更小大小，使得它特别流行于嵌入式脚本。例子包括[[SIOD|SIOD]]和[[TinyScheme|TinyScheme]]，二者都曾经以共用名字“Script-fu”成功的嵌入到了[[GIMP|GIMP]]图像处理软件中<ref name="script-fu">[http://www.gimp.org/docs/script-fu-update.html Script-fu In GIMP 2.4] {{Wayback|url=http://www.gimp.org/docs/script-fu-update.html |date=20210225083546 }}, Retrieved 2009-10-29</ref>。LIBREP是John Harper最初基于[[Emacs_Lisp|Emacs Lisp]]语言开发的Lisp解释器，它已经嵌入到了[[Sawfish|Sawfish]][[窗口管理器|窗口管理器]]<ref name="librep">[http://sawfish.wikia.com/wiki/Librep librep] {{Wayback|url=http://sawfish.wikia.com/wiki/Librep |date=20170701130055 }} at Sawfish Wikia, retrieved 2009-10-29</ref>。

===标准化的方言===
Lisp有官方标准化和业界标准的方言：IEEE Scheme<ref name="IEEE Scheme">{{cite web |url=https://standards.ieee.org/standard/1178-1990.html |website=IEEE 1178-1990 - IEEE Standard for the Scheme Programming Language |access-date=27 August 2019 |title=IEEE Scheme |archive-date=2021-03-04 |archive-url=https://web.archive.org/web/20210304200431/https://standards.ieee.org/standard/1178-1990.html }}</ref>、[[Common_Lisp|ANSI Common Lisp]]、ISO [[ISLISP|ISLISP]]、[[Scheme|R<sup>5</sup>RS Scheme]]和[[Scheme#R7RS|R<sup>7</sup>RS Scheme]]。

== 语法和语义 ==
:'''注意'''：本文的例子是用[[Common_Lisp|Common Lisp]]书写（但是其中的多数在[[Scheme|Scheme]]中也是有效的）。

===符号表达式（S-表达式）===
Lisp是一个{{en-link|面向表达式编程语言|Expression-oriented programming language}}。不同于多数其他语言，在表达式和[[语句_(计算机科学)|语句]]之间不做区分<!-- (progn ...), (setq ...). There is no syntactic distinction, but sequential evaluation is there. -->。所有代码和数据都写为表达式。当求值一个表达式的时候，它产生一个值（在Common Lisp中可能有多个值），它可以接着被嵌入到其他表达式中。每个值都可以是任何数据类型的。

McCarthy的1958年论文介入两种类型的语法：符号表达式（[[S-表达式|S-表达式]]或sexps），它镜像了代码和数据的内部表示；和元表达式（{{en-link|M-表达式|M-expression}}），它表达S-表达式的函数。M-表达式从未得到青睐，几乎所有今天的Lisp都使用S-表达式来操纵代码和数据二者。

圆括号的使用是Lisp与其他编程语言家族最直接明显的差别。为此学生们一直将Lisp昵称为“迷失在愚蠢的括号中”（'''L'''ost '''I'''n '''S'''tupid '''P'''arentheses）或“大量烦人的多余括号”（'''L'''ots of '''I'''rritating '''S'''uperfluous '''P'''arentheses）<ref name="LEVIN2">{{cite web| title=The Jargon File - Lisp| url=http://www.catb.org/~esr/jargon/html/L/LISP.html| access-date=2006-10-13| archive-date=2021-04-18| archive-url=https://web.archive.org/web/20210418151700/http://www.catb.org/~esr/jargon/html/L/LISP.html}}</ref><!-- Add NO more nicknames. People can check the Jargon File for them. -->。但是S-表达式语法也承担了Lisp多数能力：语法极其正规，利于计算机操纵。然而Lisp的语法不局限于传统的括号表示法。它可以扩展为包括替代表示法。例如，XMLisp是Common Lisp扩展，它采用[[元对象#元对象协议|元对象协议]]来集成S-表达式和可扩展标记语言（[[XML|XML]]）。

有赖于表达式给予了语言巨大的灵活性。由于Lisp[[子程序|函数]]都写为列表，它们可以完全就像数据那样处理。这允许了轻易的书写能操纵其他程序的程序（[[元编程|元编程]]）。很多Lisp方言使用宏系统来利用这个特征，它确使了语言扩展而几乎没有限制。

===列表===
书写Lisp[[列表_(抽象数据类型)|列表]]，是以{{en-link|空白字符|Whitespace character|空白}}来分隔其元素，并包围以圆括号。例如，{{Lisp2|(1 2 foo)}}是其元素为三个原子{{Lisp2|1}}、{{Lisp2|2}}和[[foo|{{Lisp2]]的一个列表。这些值是隐含的有类型的：它们分别是两个整数和叫做“符号”的Lisp专有数据类型，但不需要显式的声明。

空列表{{Lisp2|()}}也表示为特殊原子{{Lisp2|nil}}。这是Lisp中既是原子又是列表的唯一实体。

表示式被写为使用[[波兰表示法|前缀表示法]]的列表。在列表中第一个元素是一个函数的名字、一个宏的名字、一个lambda表达式或特殊算符的名字（见后）。列表的余下部份是实际参数。例如，函数{{Lisp2|list}}将它的实际参数作为一个列表返回，所以表达式：
<syntaxhighlight lang="Lisp">
 (list 1 2 (quote foo))
</syntaxhighlight>
求值为列表{{Lisp2|(1 2 foo)}}。在前面例子中的[[foo|{{Lisp2]]之前的<code>quote</code>是特殊算符，它不求值就返回它的实际参数。任何未引述的表达式，在外围表达式被求值之前，都递归的被求值。例如：
<syntaxhighlight lang="Lisp">
 (list 1 2 (list 3 4))
</syntaxhighlight>
求值为列表{{Lisp2|(1 2 (3 4))}}。注意第三个实际参数是一个列表；列表是可以嵌套的。

===算符===
对算术算符的对待都是类似的。表达式：
<syntaxhighlight lang="Lisp">
 (+ 1 2 3 4)
</syntaxhighlight>
求值为<code>10</code>。其在[[中缀表示法|中缀表示法]]下的等价形式为"{{Lisp2|1 + 2 + 3 + 4}}"。

Lisp没有在Algol派生语言中实现的那样的算符概念。在Lisp中算术算符是[[可变参数函数|可变参数函数]]（或多元函数），能够接受任何数目的实际参数。C-风格的<code>++</code>增加算符，有时在名字<code>incf</code>之下实现，给出的语法是：
<syntaxhighlight lang="Lisp">
 (incf x)
</syntaxhighlight>
等价于<code>(setq x (+ x 1))</code>，它返回<code>x</code>的新值。

特殊算符（有时叫做特殊形式<ref>{{Cite book | url = http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf | title = LISP 1.5 Programmer's Manual | publisher = [[MIT_Press|MIT Press]] | author = [[John_McCarthy|John McCarthy]], Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, Michael I. Levin | isbn = 0-262-13011-4 | orig-year = 1962 | edition = 2nd | year = 1985 | quote = Special Forms － Normally, <code>eval</code> evaluates the arguments of a function before applying the function itself. Thus if eval is given (CONS X Y), it will evaluate X and Y, and then <code>cons</code> them. But if <code>eval</code> is given (QUOTE X), X should not be evaluated. QUOTE is a special form that prevents its argument from being evaluated.<br />A special form differs from a function in two ways. Its arguments are not evaluated before the special form sees them. COND, for example, has a very special way of evaluating its arguments by using <code>evcon</code>. The second way which special forms differ from functions is that they may have an indefinite number of arguments. Special forms have indicators on their property lists called FEXPR and FSUBR for LISP-defined forms and machine language coded forms, respectively. | access-date = 2021-10-25 | archive-date = 2021-03-02 | archive-url = https://web.archive.org/web/20210302065612/http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf }}</ref>）提供了Lisp的控制结构。例如，特殊算符{{Lisp2|if}}接受三个实际参数。如果第一个实际参数为非<code>nil</code>，它求值为第二实际参数；否则它求值为第三个实际参数。因此表达式：
<syntaxhighlight lang="Lisp">
 (if nil
     (list 1 2 "foo")
     (list 3 4 "bar"))
</syntaxhighlight>
求值为{{Lisp2|(3 4 "bar")}}。当然，如果在{{Lisp2|nil}}的位置替换上非平凡的表达式会更有用处。

Lisp还提供逻辑算符<code>and</code>、<code>or</code>和<code>not</code>。<code>and</code>和<code>or</code>算符进行[[短路求值|短路求值]]，并分别返回它们的第一个<code>nil</code>或非<code>nil</code>实际参数：
<syntaxhighlight lang="Lisp">
 (or (and "zero" nil "never") "James" 'task 'time)
</syntaxhighlight>
会求值为<code>"James"</code>。

===Lambda表达式和函数定义===
另一个特殊算符{{Lisp2|lambda}}，被用来绑定变量到值，接着对表达式求进行求值。这个算符还被用于建立函数：给{{Lisp2|lambda}}的实际参数是一个形式参数列表，和这个函数要求值的一个或多个表达式，它的返回值是其求值的最后一个表达式的值。表达式：
<syntaxhighlight lang="Lisp">
 (lambda (arg) (+ arg 1))
</syntaxhighlight>
求值为一个函数，它接受一个实际参数，绑定它到{{Lisp2|arg}}并返回比这个实际参数大一的数。对待Lambda表达式于命名函数没有区别；它们以相同方式调用。如下表达式：
<syntaxhighlight lang="Lisp">
 ((lambda (arg) (+ arg 1)) 5)
</syntaxhighlight>
求值为{{Lisp2|6}}。这里我们做了一次函数应用：我们通过传递给它值<code>5</code>而执行了这个[[匿名函数|匿名函数]]。

命名函数是通过使用<code>defun</code>宏<ref name="DEFUN" />，将一个lambda表达式存储在一个符号之中而建立的：
<syntaxhighlight lang="Lisp">
 (defun foo (a b c d) (+ a b c d))
</syntaxhighlight>

{{Lisp2|(defun f (a) b...)}}在全局环境中定义一个名为{{Lisp2|f}}的新函数。它在概念上类似于表达式：
<syntaxhighlight lang="Lisp">
 (setf (fdefinition 'f) #'(lambda (a) (block f b...)))
</syntaxhighlight>

这里的{{Lisp2|setf}}是一个宏，用来设置第一个实际参数{{Lisp2|fdefinition 'f}}为一个新的函数对象。{{Lisp2|fdefinition}}是对命名为{{Lisp2|f}}的函数的全局函数定义。{{Lisp2|#'}}是特殊算符{{Lisp2|function}}的简写，它返回一个[[函数对象|函数对象]]。

===作用域和闭包===
Lisp家族按变量[[作用域|作用域]]分裂为两大支系，分别使用动态作用域<ref>{{Cite book | url = http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf | title = LISP 1.5 Programmer's Manual | publisher = [[MIT_Press|MIT Press]] | author = [[John_McCarthy|John McCarthy]], Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, Michael I. Levin | isbn = 0-262-13011-4 | orig-year = 1962 | edition = 2nd | year = 1985 | quote = The variables in a lambda expression are dummy or bound variables because systematically changing them does not alter the meaning of the expression. Thus <code>λ<nowiki>[[u;v]</nowiki>;v<sup>2</sup>+u<nowiki>]</nowiki></code>_means_the_same_thing_as_<code>λ<nowiki>[[x;y]</nowiki>;y<sup>2</sup>+x<nowiki>]</nowiki></code>.<br_/>We_shall_sometimes_use_expressions_in_which_a_variable_is_not_bound_by_a_lambda._For_example,_in_the_function_of_two_variables_<code>λ<nowiki>[[x;y]</nowiki>;x<sup>n</sup>+y<sup>n</sup><nowiki>]</nowiki></code>_the_variable_<code>n</code>_is_not_bound._This_is_called_a_free_variable._It_may_be_regarded_as_a_parameter._Unless_<code>n</code>_has_been_given_a_value_before_trying_to_compute_with_this_function,_the_value_of_the_function_must_be_undefined._……<br_/>Free_Variables_－_A_variable_is_<code>bound</code>_in_a_particular_function_when_it_occurs_in_a_list_of_bound_variables_following_the_word_LAMBDA_or_PROG._Any_variable_that_is_not_bound_is_free._……<br_/>When_a_variable_is_used_free,_it_must_have_been_bound_by_a_higher_level_function._If_a_program_is_being_run_interpretively,_and_a_free_variable_is_used_without_having_bee_bound_on_a_higher_level,_error_diagnostic_*A_8*_will_occur.<br_/>If_the_program_is_being_run_complied,_the_diagnostic_may_not_occur,_and_the_variable_may_have_value_NIL.|access-date = 2021-10-25]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|year=1975|quote=There are several important consequences of closing every lambda expression in the environment from which it is passed (i.e., in its "lexical" or "static" environment). <br />First, the axioms of [[λ演算|lambda calculus]] are automatically preserved. Thus, referential transparency is enforced. This in turn implies that there are no "fluid" variable bindings (as there are in standard stack implementations of LISP such as [[MacLISP|MacLISP]]). <br />Second, the upward {{en-link|函数参数问题|funarg problem|funarg problem}} [Moses] requires that the environment structure be potentially tree-like. <br />Finally, the environment at any point in a computation can never be deeper than the lexical depth of the expression being evaluated at that time; i.e., the environment contains bindings only for variables bound in lambdas lexically surrounding the expression being evaluated. This is true even if recursive functions are involved. ……Furthermore, it is not even necessary to scan the environment for the variable, since its value must be in a known position relative to the top of the environment structure; this position can be computed by a compiler at compile time on the basis of lexical scope. }}</ref>。[[Scheme|Scheme]]、[[Common_Lisp|Common Lisp]]和[[Clojure|Clojure]]缺省使用静态作用域，而[[AutoLISP|AutoLISP]]、[[PicoLisp|PicoLisp]]<ref>{{cite web|author=Alexander Burger|title=PicoLisp Frequently Asked Questions|url=https://software-lab.de/doc/faq.html#dynamic|quote=Why do you use dynamic variable binding? Dynamic binding is very powerful, because there is only one single, dynamically changing environment active all the time. This makes it possible (e.g. for program snippets, interspersed with application data and/or passed over the network) to access the whole application context, freely, yet in a dynamically controlled manner. And (shallow) dynamic binding is the fastest method for a Lisp interpreter.<br />Lexical binding is more limited by definition, because each environment is deliberately restricted to the visible (textual) static scope within its establishing form. Therefore, most Lisps with lexical binding introduce "special variables" to support dynamic binding as well, and constructs like labels to extend the scope of variables beyond a single function.<br />In PicoLisp, function definitions are normal symbol values. They can be dynamically rebound like other variables. ……<br />Are there no problems caused by dynamic binding? You mean the funarg problem, or problems that arise when a variable might be bound to itself? For that reason we have a convention in PicoLisp to use transient symbols (instead of internal symbols) or private internal symbols ……<br />But with dynamic binding I cannot implement closures! This is not true. Closures are a matter of scope, not of binding.<br />For a closure it is necessary to build and maintain a separate environment. In a system with lexical bindings, this has to be done at each function call, and for compiled code it is the most efficient strategy anyway, because it is done once by the compiler, and can then be accessed as stack frames at runtime.<br />For an interpreter, however, this is quite an overhead. So it should not be done automatically at each and every function invocation, but only if needed.|access-date=2021-10-29|archive-date=2017-08-06|archive-url=https://web.archive.org/web/20170806221620/https://software-lab.de/doc/faq.html#dynamic}}</ref>和[[newLISP|newLISP]]<ref>{{cite web|author=Lutz Mueller|title=Comparison to Common Lisp and Scheme|url=http://www.newlisp.org/index.cgi?page=Differences_to_Other_LISPs|quote=Dynamic scoping inside isolated namespaces － newLISP is sometimes criticized for using dynamic scoping and fexprs. …… In newLISP, all variables are dynamically scoped by default. However, by defining a function in its own context, static/lexical scoping can be achieved. In newLISP, several functions and data can share a namespace. By enclosing functions in their own namespace, a lexical closure- like mechanism is achieved. Common Lisp and Scheme are lexically scoped by default and use lambda expressions as the closure mechanism. Common Lisp also offers special variables for dynamic scoping.<br />The problems of free variables in dynamic scoping can be avoided. In the rare cases when free variables must be used, you can partition code into namespace modules for easier control over free variables. You can then exploit the advantages of dynamic scoping. With dynamic scoping inside lexically-closed namespaces, newLISP combines the best of both scoping worlds.<br />newLISP has no funarg problem because it follows a simple rule: variables always show the binding of their current environment. When expressions with local variables are entered, newLISP saves the current variable state on a stack and restores it on exit of that expression. In newLISP, not only are function parameters and variables declared with let expressions local, loop variables in all looping expressions are local too.|access-date=2021-10-29|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235712/http://www.newlisp.org/index.cgi?page=Differences_to_Other_LISPs}}</ref>使用动态作用域。[[Emacs_Lisp|Emacs Lisp]]自从[[Emacs|Emacs]]版本24.1起使用动态和词法作用域二者<ref>{{cite web |url=http://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding#toc8 |title=Dynamic Binding Vs Lexical Binding |publisher=EmacsWiki |quote=dynamic － All variable names and their values live in one global table. lexical － Each binding scope (function, let syntax, …) creates a new table of variable names and values, organised in a hierarchy called “the environment”. ……<br />EmacsLisp as of 24.1 has both dynamic binding and lexical binding. Lexical binding must be enabled explicitly for a file or buffer. Individual variables can be <code>'defvar'</code>ed to make them “special”, like in CommonLisp. |access-date=2021-10-28 |archive-date=2022-05-09 |archive-url=https://web.archive.org/web/20220509003244/https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding#toc8 }}</ref>。

===原子===
在最初的LISP中，有两种基础[[数据类型|数据类型]]：原子和列表。列表是元素的一个有限有序序列，这里的每个元素要么是一个原子要么是一个列表，而原子要么是一个[[数|数]]要么是一个符号。符号实质上是唯一性命名的项目，在[[源代码|源代码]]中写为[[字母数字|字母数字]]串，并被要么用作一个变量名字要么{{en-link|计算机代数|Computer algebra|符号处理}}中的一个数据项目。例如，列表{{Lisp2|(FOO (BAR 1) 2)}}包含三个元素：符号{{Lisp2|FOO}}、列表{{Lisp2|(BAR 1)}}和数<code>2</code>。

在原子和列表之间的本质区别是原子是不可变的和唯一性的。出现在源代码中不同位置的两个原子，如果以完全相同方式写成则表示相同的对象，而每个列表都是一个分立的对象，它们可以独立于其他列表而改变 ，并可以通过比较算符而区分于其他列表。

随着后来的Lisp介入了更多的数据类型，和[[代码风格|编程风格]]的演化，原子的概念失去了重要性。很多方言出于[[向下兼容|遗产兼容性]]而保留了谓词<code>atom</code>，定义它为对不是<code>cons</code>的任何对象都为真。

===cons和列表===
{{Main|列表構造函數}}
[[File:Cons-cells.svg|thumb]]示意图]]
Lisp列表被实现为[[单向链表|单向链表]]<ref name="SebestaLanguages">{{cite book |last1=Sebesta |first1=Robert W. |title=Concepts of Programming Languages |chapter="2.4 Functional Programming: LISP";"6.9 List Types";"15.4 The First Functional Programming Language: LISP" |date=2012 |publisher=Addison-Wesley |location=Boston, MA, USA |isbn=978-0-13-139531-2 |pages=47–52;281–284;677–680 |edition=10th |url=https://www.pearson.com/us/higher-education/product/Sebesta-Concepts-of-Programming-Languages-10th-Edition/9780131395312.html |language=en |format=print |access-date=2021-10-23 |archive-date=2021-03-08 |archive-url=https://web.archive.org/web/20210308120634/https://www.pearson.com/us/higher-education/product/Sebesta-Concepts-of-Programming-Languages-10th-Edition/9780131395312.html }}</ref>。这个链表的每个单元都叫做<code>[[列表构造函数|cons]]</code>（在Scheme中叫做<code>pair</code>），它构成自两个[[指针|指针]]，分别叫做<code>{{en-link|CAR与CDR|CAR and CDR|car}}</code>和<code>{{en-link|CAR与CDR|CAR and CDR|cdr}}</code>。

在众多可以用<code>cons</code>单元构建的数据结构中，最基本一个叫做“正当列表”（proper list）。正当列表要么是特殊的{{Lisp2|nil}}（空列表）符号，要么是一个<code>cons</code>，它的{{Lisp2|car}}指向一个数据项（它可以是另一个<code>cons</code>结构比如一个列表），而{{Lisp2|cdr}}指向另一个正当列表。

如果一个给定<code>cons</code>被接受为一个链表的头部，那么它的<code>car</code>指向这个列表的第一个元素，而它的<code>cdr</code>指向这个列表的余下部份。为此，在提及作为链表（而非树等）一部份的<code>cons</code>的时候，{{Lisp2|car}}和{{Lisp2|cdr}}函数也分别叫做{{Lisp2|first}}和{{Lisp2|rest}}。

因此，Lisp列表不是原子对象，它们类似C++或Java中的容器类的实例。一个列表就是链接的<code>cons</code>的一个聚集。引用一个给定列表的变量，简单的就是到列表中第一个<code>cons</code>的指针。遍历一个列表可以通过逐一<code>cdr</code>这个列表来进行，就是说连续的选取<code>cdr</code>来访问这个列表的每个<code>cons</code>；或者通过使用任何一个将一个函数映射在一个列表之上的[[高阶函数|高阶函数]]。

由于<code>cons</code>和列表在Lisp系统中是普遍性的，经常有人误解它们是Lisp的唯一数据结构。事实上，除了最简单者之外的所有Lisp都有其他数据结构，比如向量（{{en-link|数组数据结构|Array data type|数组}}）、[[散列表|散列表]]、结构等等。

====S-表达式表示列表====
圆括号的S-表达式表示了链表结构。有多种方式将相同的列表表示为一个S-表达式。<code>cons</code>可以用“点对表示法”写为{{Lisp2|(a . b)}}，这里的{{Lisp2|a}}是<code>car</code>而{{Lisp2|b}}是<code>cdr</code>。更长的正当列表可以用点对表示法写为{{Lisp2|(a . (b . (c . (d . nil))))}}。这通常简写为列表表示法的{{Lisp2|(a b c d)}}。一个非正当列表<ref name="r3sL3">NB: a so-called "dotted list" is only one kind of "improper list". The other kind is the "circular list" where the cons cells form a loop. Typically this is represented using #n=(...) to represent the target cons cell that will have multiple references, and #n# is used to refer to this cons. For instance, (#1=(a b) . #1#) would normally be printed as ((a b) a b) (without circular structure printing enabled), but makes the reuse of the cons cell clear. #1=(a . #1#) cannot normally be printed as it is circular, although (a...) is sometimes displayed, the CDR of the cons cell defined by #1= is itself.</ref>，可以用二者的组合来书写，比如列表{{Lisp2|(a b c . d)}}有三个<code>cons</code>，最后的<code>cdr</code>是{{Lisp2|d}}（也就是完全特殊形式下的{{Lisp2|(a . (b . (c . d)))}}）。

====列表处理过程====
Lisp提供很多内建的过程，用来访问和控制列表。列表可以直接用{{Lisp2|list}}过程创建，它接受任何数目的实际参数，并返回这些实际参数的列表：
<syntaxhighlight lang="Lisp">
 (list 1 2 'a 3)
 ;Output: (1 2 a 3)

 (list 1 '(2 3) 4)
 ;Output: (1 (2 3) 4)
</syntaxhighlight>
由于列表是从[[列表构造函数|cons对]]构造而来，可以使用{{Lisp2|cons}}过程来在一个列表的前端增加一个元素。注意由于列表构造方法，{{Lisp2|cons}}在处理列表实际参数上是不对称的：
<syntaxhighlight lang="Lisp">
 (cons 1 '(2 3))
 ;Output: (1 2 3)
 
 (cons '(1 2) '(3 4))
 ;Output: ((1 2) 3 4)
</syntaxhighlight>
{{Lisp2|append}}过程将两个（或更多）列表相互附加。由于Lisp列表是链表，附加两个列表有[[大O符号|渐进时间复杂度]] <math>O(n)</math>：
<syntaxhighlight lang="Lisp">
 (append '(1 2) '(3 4))
 ;Output: (1 2 3 4)
 
 (append '(1 2 3) '() '(a) '(5 6))
 ;Output: (1 2 3 a 5 6)
</syntaxhighlight>

====共享结构====
Lisp列表，作为单向链表，可以相互共享结构。就是说，两个列表可以有相同的尾部，或者最终的<code>cons</code>序列。例如，在执行下列Common Lisp代码之后：
<syntaxhighlight lang="Lisp">
(setf foo (list 'a 'b 'c))
(setf bar (cons 'x (cdr foo)))
</syntaxhighlight>
列表{{Lisp2|foo}}和{{Lisp2|bar}}分别是{{Lisp2|(a b c)}}和{{Lisp2|(x b c)}}。然而，尾部{{Lisp2|(b c)}}在两个列表中都是相同的结构。它不是复件；对于两个列表指向{{Lisp2|b}}和{{Lisp2|c}}的<code>cons</code>单元都在相同的内存位置。

共享结构而非复制可以得到相当客观的性能提升。但是这种技术可能以未预期的方式，交互于改变作为实际参数传递给它的列表的那些函数。改变一个列表，比如替代{{Lisp2|c}}为{{Lisp2|goose}}，将会影响另一个列表：
<syntaxhighlight lang="Lisp">
 (setf (third foo) 'goose)
</syntaxhighlight>
这变更{{Lisp2|foo}}为{{Lisp2|(a b goose)}}，但是从而还变更了{{Lisp2|bar}}为{{Lisp2|(x b goose)}}，这是可能是未预期的结果。这是缺陷的来源，为此改变它们的实际参数的那些函数被文档标示为破坏性（destructive）的。

[[函数式编程|函数式编程]]爱好者避免破坏性函数。在青睐函数式风格的Scheme方言中，破坏性函数的名字都标记了警告性感叹号，或者叫做“bang”，比如{{Lisp2|set-car!}}（读作set car bang），它替换一个<code>cons</code>的<code>car</code>。在Common Lisp方言中，破坏性函数是司空见惯的，与{{Lisp2|set-car!}}等价的是{{Lisp2|rplaca}}，它的名字表示“replace car”。这个函数是不常见的，因为Common Lisp包括了一个特殊设施{{Lisp2|setf}}，用来轻易的定义和使用破坏性函数。在Common Lisp中常见的风格是在构建原型的时候写函数式代码（没有破坏性调用），接着将破坏性调用作为优化增加于可以安全的进行它们的地方。

===自求值形式和引述===
Lisp求值用户录入的表达式。符号和列表求值为某个其他（通常更简单的）表达式，例如：一个符号求值为它指名的变量的值；{{Lisp2|(+ 2 3)}}求值为{{Lisp2|5}}。但是，多数其他形式求值为其自身：如果录入{{Lisp2|5}}到Lisp中，它返回{{Lisp2|5}}。

任何表达式都可以标记上防止被求值（对于符号和列表是需要的）。这是特殊算符{{Lisp2|quote}}的角色，它也简写为{{Lisp2|'}}（一个单引号）。例如，通常如果录入了符号{{Lisp2|foo}}，它返回对应变量的值（没有这个变量则为一个错误）。要引用这个{{en-link|文字 (计算机编程)|Literal (computer programming)|文字}}符号，录入要么{{Lisp2|(quote foo)}} ，要么更常见的{{Lisp2|'foo}}。

Common Lisp和Scheme二者还支持“反引述”（backquote）算符（在Scheme中叫做{{en-link|准引述|quasiquote}}），这时录入{{Lisp2|`}}字符（[[重音符#编程用途|重音符]]）。它几乎同于普通引述，除了它允许表达式被求值，并将它们的值插入到引述列表之中，这些表达式标记了逗号{{Lisp2|,}}表示去引述，或逗号-[[@|at]]{{Lisp2|,@}}表示拼接算符。如果变量{{Lisp2|snue}}有值{{Lisp2|(bar baz)}}，则{{Lisp2|`(foo ,snue)}}求值为{{Lisp2|(foo (bar baz))}}，而{{Lisp2|`(foo ,@snue)}}求值为{{Lisp2|(foo bar baz)}}。反引述经常用于定义宏展开<ref name="cTQAG">{{cite web |url=http://www.cs.washington.edu/education/courses/cse341/04wi/lectures/14-scheme-quote.html |title=CSE 341: Scheme: Quote, Quasiquote, and Metaprogramming |publisher=Cs.washington.edu |date=1999-02-22 |access-date=2013-11-15 |archive-date=2013-08-23 |archive-url=https://web.archive.org/web/20130823040237/http://www.cs.washington.edu/education/courses/cse341/04wi/lectures/14-scheme-quote.html }}</ref><ref name="waVLs">{{cite web|author=Alan Bawden|title=Quasiquotation in Lisp|url=http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.142.1640&rep=rep1&type=pdf|year=1999|access-date=2021-10-29|archive-date=2021-10-29|archive-url=https://web.archive.org/web/20211029203150/http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.142.1640&rep=rep1&type=pdf}}</ref>。

自求值形式和引述形式是Lisp中{{en-link|文字 (计算机编程)|Literal (computer programming)|文字}}的等价者。在程序代码中可以修改（可变）文字的值。例如，如果一个函数返回一个引述形式，而调用这个函数的代码修改这个形式，这可以改变这个函数在后续调用时的行为：

<syntaxhighlight lang="lisp">
(defun should-be-constant ()
  '(one two three))

(let ((stuff (should-be-constant)))
  (setf (third stuff) 'bizarre))   ; bad!

(should-be-constant)   ; returns (one two bizarre)
</syntaxhighlight>

像这样修改一个引述形式通常被认为是不良风格，并且被ANSI Common Lisp定义为是危险的。它会导致在编译文件中的未定义的行为，因为文件编译器可以合并类似的常量并将它们放置到写保护内存中，等等。

Lisp的引述形式化已经被[[Douglas_Hofstadter|Douglas Hofstadter]]（在《[[Gödel,_Escher,_Bach|Gödel, Escher, Bach]]》中）和其他人注解为[[自指|自引用]]的[[哲学|哲学]]想法的例子。

===控制结构===
Lisp最初有很少的控制结构，但是在语言演化期间却增加了很多。Lisp的最初条件算符{{Lisp2|cond}}，是后来的{{Lisp2|if-then-else}}结构的先驱。

Scheme方言的编程者经常使用[[尾递归|尾递归]]表达循环。Scheme在学术计算机科学中的通行性，导致了一些学生相信尾递归是在Lisp中书写迭代的唯一的或最常用的方式，但是这是不正确的。所有常见的Lisp方言都有指令式风格的迭代构造，从Scheme的{{Lisp2|do}}循环到[[Common_Lisp|Common Lisp]]的复杂的{{Lisp2|loop}}表达式。此外，使得这成为客观上而非主观上的一件事的关键要点，是Scheme对[[尾递归|尾递归]]的处理提出了特殊要求，Scheme通常鼓励使用尾递归的原因，是语言定义明确的支持了这种实践。与之相反，ANSI Common Lisp不要求常称为尾递归消除的这种优化<ref name="lGnFp">[http://www.lispworks.com/documentation/HyperSpec/Body/03_bbc.htm 3.2.2.3 Semantic Constraints] {{Wayback|url=http://www.lispworks.com/documentation/HyperSpec/Body/03_bbc.htm |date=20210227191012 }} in [http://www.lispworks.com/documentation/HyperSpec/Front/index.htm ''Common Lisp HyperSpec''] {{Wayback|url=http://www.lispworks.com/documentation/HyperSpec/Front/index.htm |date=20210415060418 }}</ref>。因此，不鼓励将尾递归风格作为使用更传统的[[迭代|迭代]]构造（比如{{Lisp2|do}}、{{Lisp2|dolist}}或{{Lisp2|loop}}）的替代品<ref name="VY38C">4.3. Control Abstraction (Recursion vs. Iteration) in [http://www.cs.umd.edu/~nau/cmsc421/norvig-lisp-style.pdf Tutorial on Good Lisp Programming Style] {{Wayback|url=http://www.cs.umd.edu/~nau/cmsc421/norvig-lisp-style.pdf |date=20210501225429 }} by {{en-link|Kent Pitman}} and [[Peter_Norvig|Peter Norvig]], August, 1993.</ref>。在Common Lisp中不只是风格偏好的问题，而是潜在的效率问题，因为在Common Lisp中明显的尾递归可能未被编译为简单的<code>[[分支_(计算机科学)|jump]]</code>；和程序正确性问题，因为在Common Lisp中尾递归可能增加栈的使用而有[[堆栈溢出|堆栈溢出]]风险。

一些Lisp控制构造是特殊算符，等价于其他语言的语法关键字。使用这些算符的表达式与函数调用有着相同的表面外观，但是不同之处在于参数不是必须求值的，或者在迭代表达式的情况下，可以被求值多于一次。

对比于多数其他主要编程语言，Lisp允许使用语言自身实现控制结构。一些控制结构被实现为Lisp宏，想知道它们是如何工作的编程者甚至可以通过宏展开来研究。

Common Lisp和Scheme二者都有非局部控制流程算符。在这些算符中的不同是在这两种方言之间最深的差异。Scheme使用{{Lisp2|call/cc}}过程支持可重入的[[计算续体|续体]]，它允许一个程序保存（并在将来恢复）执行中的特定位置。Common Lisp不支持可重入的续体，但是支持处理逃脱续体的一些方式。

相同的算法在Lisp中经常可以用要么指令式要么函数式风格来表达。如上所述，Scheme趋于青睐函数式风格，使用尾递归和续体来表达控制流程。但是，指令式风格仍是很有可能的。很多Common Lisp编程者偏好的风格，可能让使用结构化编程语言比如C的编程者看着更加熟悉，而Scheme编程者偏好的风格更加密切类似于纯函数式编程语言比如[[Haskell|Haskell]]。

由于Lisp在列表处理上的早期遗产，它拥有与在序列上迭代有关的一组广泛的[[高阶函数|高阶函数]]。在其他语言中需要显式循环（比如C中的{{Lisp2|for}}循环）的很多情况下，在Lisp和很多函数式编程语言中，相同的任务可以通过高阶函数来完成。

一个好的例子是在Scheme中叫做{{Lisp2|map}}而在Common Lisp中叫做{{Lisp2|mapcar}}的函数。给定一个函数和一个或多个列表，{{Lisp2|mapcar}}依次这个列表的元素之上连续的应用这个函数，并将结果收集入一个新的列表：
<syntaxhighlight lang="Lisp">
 (mapcar #'+ '(1 2 3 4 5) '(10 20 30 40 50))
</syntaxhighlight>
这个<code>[[map_(高阶函数)|mapcar]]</code>函数将{{Lisp2|+}}函数应用于每个对应的元素对之上，产生结果{{Lisp2|(11 22 33 44 55)}}。

===程序代码的列表结构===
在Lisp和其他语言之间的基本区别是，在Lisp中一个程序的文本表示，简单的是人类可读的描述，它同于底层Lisp系统使用的内部数据结构（链表、符号、数、字符等)。

Lisp利用这一点来实现了一个非常强力的[[宏|宏]]系统。就像其他宏语言比如[[C语言|C]]，一个宏返回可以接着被编译的代码。但是不同于C的宏，Lisp的宏是函数因而可以利用Lisp的全部能力。

进一步的，因为Lisp代码作为列表有着相同的结构，宏可以使用语言中任何列表处理函数来建造。简要的说，Lisp可以在数据结构上做的任何事情，Lisp宏都可以在代码上做。相反的，在多数其他语言中，解析器的输出是纯粹的内部于语言实现的而不能被编程者操纵。

这个特征可以在语言中开发高效语言。例如，Common Lisp对象系统可以使用宏清晰的实现为一个语言扩展。这意味着如果一个应用需要不同的继承机制，它可以使用不同的对象系统。这直接的对立于多数其他语言；例如，Java不能支持多重继承并且没有增加它的合理方式。

在简单的Lisp实现中，这个列表结构被直接的[[解释器|解释]]来运行这个程序；一个函数是在文字上的一段列表结构，它被解释器在执行它的时候遍历。但是，多数后来的Lisp系统还包括一个编译器。编译器将列表结构转换成机器代码或[[字节码|字节码]]用于执行。这个代码可以像用常规语言比如C编译的代码一样快速。

宏在编译步骤之前展开，因而提供一些有价值的选项。如果一个程序需要一个预先计算了的表格，那么一个宏可以在编译时间建立这个表格，所以编译器只需要输出这个表格，而不需要在运行时间调用代码来建立这个表格。一些Lisp实现甚至拥有一种<code>eval-when</code>机制，允许代码在编译时间期间出现（在一个宏需要它的时候），而不出现在发行的模块中<ref name="0iFgm">[https://www.gnu.org/software/emacs/manual/html_node/cl/Time-of-Evaluation.html Time of Evaluation - Common Lisp Extensions] {{Wayback|url=https://www.gnu.org/software/emacs/manual/html_node/cl/Time-of-Evaluation.html |date=20210308031956 }}. Gnu.org. Retrieved on 2013-07-17.</ref>。

===求值和读取–求值–打印循环===
Lisp语言经常被以交互式[[命令行|命令行]]来使用，它还可以结合入[[集成开发环境|集成开发环境]]（IDE）。用户在命令行录入表达式，或指示IDE将它们传送给Lisp系统。Lisp读取录入的表达式，求值它们，并打印结果。为此，Lisp命令行被叫做[[读取﹣求值﹣输出循环|读取﹣求值﹣输出循环]]（REPL）。

REPL的基本操作描述如下。这是一个简化的描述，省略了很多真实Lisp的元素，比如引述和宏。

{{Lisp2|read}}函数接受文本的S-表达式作为输入，并将它们解析为内部数据结构。例如，如果你在提示符下录入文本{{Lisp2|(+ 1 2)}}，{{Lisp2|read}}将它转换成有三个元素的一个链表：符号{{Lisp2|+}}、数<code>1</code>和数<code>2</code>。恰巧这个列表也是一段有效的Lisp代码，就是说它是可以被求值的。这是因为<code>car</code>这个列表指名了一个函数即加法运算。

注意{{Lisp2|foo}}将被读作一个单一符号。{{Lisp2|123}}将被读作数一百二十三。{{Lisp2|"123"}}将被读作字符串<code>"123"</code>。

{{Lisp2|eval}}函数求值数据，返回零或多个其他Lisp数据作为结果。求值不必然意味着解释；一些Lisp系统编译所有的表达式为机器代码。但将求值描述为解释是很简单的：要求值其<code>car</code>指名一个函数的一个列表，{{Lisp2|eval}}首先求值在它的<code>cdr</code>中的每个实际参数，接着应用这个函数于这些实际参数。在这个案例中，这个函数是加法，而应用它于实际参数列表{{Lisp2|(1 2)}}产生答案{{Lisp2|3}}。这是这个求值的结果。

符号{{Lisp2|foo}}求值为符号<code>foo</code>的值。数据比如字符串<code>"123"</code>求值为相同的字符串。列表{{Lisp2|(quote (1 2 3))}}求值为列表<code>(1 2 3)</code>。

{{Lisp2|print}}函数的工作是将输入表示给用户。对于简单结果比如{{Lisp2|3}}这是平凡的。求值为一段列表结构的一个表达式会要求{{Lisp2|print}}遍历这个列表并将结果输出为一个S-表达式。

要实现一个Lisp REPL，必需的只是实现这三个函数和一个无限循环函数。实现{{Lisp2|eval}}函数会很复杂是自然的，因为它必须也要实现所有特殊算符比如{{Lisp2|if}}或{{Lisp2|lambda}}。它们完成后，一个基本的REPL就是一行代码：{{Lisp2|(loop (print (eval (read))))}}。

Lisp REPL典型的也提供输入编辑、输入历史、错误处理和到调试器的接口。

Lisp通常使用[[及早求值|及早求值]]。在[[Common_Lisp|Common Lisp]]中，实际参数以应用式次序（最左最内为先）求值，而在[[Scheme|Scheme]]中实际参数的次序是未定义的，为编译器优化留下了余地<ref>{{cite web|title=The Revised Report on SCHEME: A Dialect of LISP|author=[[Gerald_J._Sussman|Gerald J. Sussman]], [[Guy_L._Steele_Jr.|Guy L. Steele Jr.]]|url=https://dspace.mit.edu/handle/1721.1/6283|year=1978|quote=Magic forms are recognized by then presence of a "magic (reserved) word" in the <code>car</code> position of the form. All non-atomic forms which are not magic forms are considered to be combinations. The system has a small initial set of magic words; there is also a mechanism for creating new ones {Note FUNCALL is a Pain}.<br />A combination is considered to be a list of subforms. These subforms are all evaluated. The first value mub be a procedure; it is applied to the other values to get the value of the combination. There are four important points here:<br />(1) the procedure Position is always evaluated just like any other position. (This is why the primitive operators are the values of global identifiers.)<br />(2) the procedure is never "re-evaluated"; if the first subform fails to evaluate to a applicable procedure, it is an error. Thus, unlike most LISP systems, SCHEME always evaluates the first subform of a combination exactly once.<br />(3) the arguments are all completely evaluated before the procedure is applied; that is, SCHEME, like most LISP systems, is an applicative-order language. Many SCHEME programs exploit this fact.<br />(4) the argument forms (and procedure form) may in principle be evaluated in any order. This is unlike the usual LISP left-to-right order. (All SCHEME interpreters implemented so far have in fact performed left-to-right evaluation, but we do not wish programs to depend on this fact. Indeed, there are some reasons why a clever interpreter might want to evaluate them right-to-left, e.g. to get things on a stack in the correct order.)}}</ref>。

== Lisp 1.5的7个原始运算 ==
[[保罗·格雷厄姆|Paul Graham]]从[[John_McCarthy|John McCarthy]]的最初论文中提炼出如下7个原始运算<ref>{{cite web|title=The Roots of Lisp|url=http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf|author=[[Paul_Graham|Paul Graham]]|year=2002|access-date=2021-10-28|archive-date=2021-10-28|archive-url=https://web.archive.org/web/20211028160512/http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf}}</ref>，示例采用的Common Lisp实现是[[SBCL|SBCL]]：
=== quote ===
<code>(quote x)</code>返回<code>x</code>，我们简记为<code>'x</code>：

<syntaxhighlight lang="lisp">
* (quote a)
A
* 'a
A
* (quote (a b c))
(A B C)
</syntaxhighlight>
將<code>quote</code>寫成<code>'</code>只是一種[[語法糖|語法糖]]。

=== atom ===
<code>(atom x)</code>当<code>x</code>是一个<code>atom</code>或者空的<code>list</code>时返回原子<code>t</code>，否则返回<code>NIL</code>。在Common Lisp中我们习惯用原子<code>t</code>列表示真，而用空列表<code>()</code>或<code>NIL</code>列表示假。例如：
<syntaxhighlight lang="lisp">
* (atom 'a)
T
* (atom '(a b c))
NIL
* (atom '())
T
</syntaxhighlight>
现在我们有了第一个需要求出实际参数值的算符，让我们来看看<code>quote</code>算符的作用——通过引述一个列表，我们避免它被求值（<code>eval</code>）。一个未被引述的列表达式作为实际参数，<code>atom</code>将其视为代码，例如：
<syntaxhighlight lang="lisp">
* (atom (atom 'a))
T
</syntaxhighlight>
这是因为<code>(atom 'a)</code>已求值出结果<code>t</code>，把它代入<code>(atom (atom 'a))</code>，成为<code>(atom t)</code>，从而这个列表达式的结果是<code>t</code>。

反之一个被引述的列表仅仅被视为列表，例如：
<syntaxhighlight lang="lisp">
* (atom '(atom 'a))
NIL
</syntaxhighlight>
引用看上去有些奇怪，因为你很难在其它语言中找到类似的概念，但正是这一特征构成了Lisp最为与众不同的特点：代码和数据使用相同的结构来列表示，只用<code>quote</code>来区分它们。

=== eq ===
<code>(eq x y)</code>当<code>x</code>和<code>y</code>指向相同的对象的时候返回<code>t</code>，否则返回<code>NIL</code>，例如：
<syntaxhighlight lang="lisp">
* (eq 'a 'a)
T
* (eq 'a 'b)
NIL
* (eq '() '())
T
* (eq '(a b c) '(a b c))
NIL
</syntaxhighlight>
值得注意的是在Common Lisp中，原子对象在内存中只会有一份拷贝，所以<code>(eq 'a 'a)</code>返回<code>t</code>。

=== car ===
<code>(car x)</code>要求<code>x</code>是一个列表，它返回<code>x</code>中的第一个元素，例如：
<syntaxhighlight lang="lisp">
* (car '(a b))
A
</syntaxhighlight>

=== cdr ===
<code>(cdr x)</code>同样要求<code>x</code>是一个列表，它返回<code>x</code>中除第一个元素之外的所有元素组成的列表，例如：
<syntaxhighlight lang="lisp">
* (cdr '(a b c))
(B C)
</syntaxhighlight>

=== cons ===
<code>cons x y</code>预期<code>y</code>的值是一个列表，并且返回包含<code>x</code>的值和随后<code>y</code>的值的那些元素的一个列表，例如：
<syntaxhighlight lang="lisp">
* (cons 'a 'b)
(A . B)
* (cons 'a (cons 'b 'c))
(A B . C)
* (cons 'a  (cons 'b ()))
(A B)
* (cons 'a (cons 'b (cons 'c ())))
(A B C)
</syntaxhighlight>

=== cond ===
<code>(cond (p<sub>1</sub> e<sub>1</sub>) ...(p<sub>n</sub> e<sub>n</sub>))</code>的求值规则如下：对“条件列表达式<code>p</code>”依次求值，直到有一个返回<code>t</code>。如果能找到这样的<code>p</code>列表达式，相应的“结果列表达式<code>e</code>”的值，作为整个<code>cond</code>列表达式的返回值。例如：

<syntaxhighlight lang="lisp">
* (cond ((eq 'a 'b) 'first)  ((atom 'a)  'second))
SECOND
</syntaxhighlight>

== 範例 ==
===Hello World!===
这个[[Hello_World!|Hello World!]]例子展示Lisp的三种主要方言，在基本输出和函数定义上的用法：
{| class = wikitable
|-
! [[Scheme|Scheme]] !! [[Common_Lisp|Common Lisp]] !! [[Clojure|Clojure]]
|- style="vertical-align:top"
|
<syntaxhighlight lang="scheme">
;; 显示过程在屏幕中打印字符串
;; 并返回未规定值
(display "Hello, world!")

;; 定义过程hello-world
(define (hello-world)
  (display "Hello, world!"))
 
;; 调用过程hello-world
(hello-world)
</syntaxhighlight>
||
<syntaxhighlight lang="lisp">
;; 格式化函数在第一个参数是t时, 
;; 在屏幕中打印字符串，并返回NIL
(format t "hello, world!")

;; 定义函数hello-world
(defun hello-world ()
  (format t "hello, world!"))

;; 调用函数hello-world
(hello-world)
</syntaxhighlight>
||
<syntaxhighlight lang="clojure">
;; 打印函数在屏幕中打印字符串
;; 并返回nil
(print "hello, world!")

;; 定义函数hello-world
(defn hello-world []
  (print "hello, world!"))

;; 调用函数hello-world
(hello-world)
</syntaxhighlight>
|}

===阶乘===
Lisp语法自然的适合于递归。数学问题比如递归定义集合的枚举，在这种表示法中表达是很容易的。例如，要求值一个数的[[阶乘|阶乘]]：
<syntaxhighlight lang="Lisp">
(defun factorial (n)
    (if (zerop n) 1
        (* n (factorial (1- n)))))
</syntaxhighlight>

下面的版本在底层Lisp系统进行[[尾递归|尾递归]]优化时比前面版本取用更少的堆栈空间：
<syntaxhighlight lang="Lisp">
(defun factorial (n &optional (acc 1))
    (if (zerop n) acc
        (factorial (1- n) (* acc n))))
</syntaxhighlight>

对比上述例子，下面的指令式版本使用了[[Common_Lisp|Common Lisp]]的{{Lisp2|loop}}宏：
<syntaxhighlight lang="Lisp">
(defun factorial (n)
    (loop for i from 1 to n
        for fac = 1 then (* fac i)
        finally (return fac)))
</syntaxhighlight>

===反转列表===
下列函数反转一个列表。它与Lisp内建的<code>reverse</code>函数做同样的事情：
<syntaxhighlight lang="Lisp">
(defun -reverse (list)
    (let ((return-value))
      (dolist (e list) (push e return-value))
      return-value))
</syntaxhighlight>

==对象系统==
已经有各种对象系统和模型建造在Lisp之上、旁边或其中，包括：
* [[Common_Lisp对象系统|Common Lisp对象系统]]（CLOS），是ANSI Common Lisp内在的一部份。CLOS衍生自New Flavors和CommonLOOPS。ANSI Common Lisp是第一个标准化的面向对象编程语言（1994, ANSI X3J13）。
* ObjectLisp<ref name="NRrCu">{{cite web|title=CommonLoops: Merging Lisp and Object-Oriented Programming|url=https://www.researchgate.net/publication/234819179_CommonLoops_Merging_Lisp_and_Object-Oriented_Programming|author=Daniel G. Bobrow, Kenneth Kahn, Gregor Kiczales, Larry Masinter, Mark Stefik, Frank Zdybel|year=1986|access-date=2021-10-29|archive-date=2022-04-06|archive-url=https://web.archive.org/web/20220406235711/https://www.researchgate.net/publication/234819179_CommonLoops_Merging_Lisp_and_Object-Oriented_Programming}}</ref>或{{en-link|Object Lisp}}，用于{{en-link|Lisp机器公司|Lisp Machines}}和早期版本的Macintosh Common Lisp。
* LOOPS（Lisp面向对象编程系统）和后来的{{en-link|CommonLOOPS}}。
* {{en-link|Flavors (编程语言)|Flavors (programming language)|Flavors}}，建造于[[MIT|MIT]]，它的后代是New Flavors（由{{en-link|Symbolics}}开发）。
* KR（知识表达），它是用来辅助书写[[Common_Lisp|Common Lisp]]的GUI库Garnet的基于{{en-link|约束满足|Constraint satisfaction|约束}}的对象系统。
* {{en-link|知识工程环境|Knowledge Engineering Environment}}（KEE）使用叫做UNITS的对象系统并集成入了[[推理机|推理机]]<ref name="YxD5o">"A History and Description of CLOS", by Jim Veitch. Pages 107–158 of ''Handbook of Programming Languages, Volume IV: Functional and Logic Programming Languages'', ed. {{en-link|Peter H. Salus}}. 1998 (1st edition), Macmillan Technical Publishing; {{ISBN|1-57870-011-6}}</ref>和{{en-link|推理维护|Reason maintenance|推理维护系统}}（ATMS）。

== 参见 ==
{{Portal|计算机程序设计}}
* [[自修改代码|自修改代码]]

== 参考文献 ==
{{Reflist|2}}

==延伸阅读==
{{Refbegin}}
* {{cite web
| last = McCarthy
| first = John
| title = The implementation of Lisp
| work = History of Lisp
| publisher = Stanford University
| date = 1979-02-12
| url = http://www-formal.stanford.edu/jmc/history/lisp/node3.html
| access-date = 2008-10-17}}
* {{Cite conference
| first = Guy L.
| last = Steele, Jr.
|author2=Richard P. Gabriel
 | title = The evolution of Lisp
| conference = The second ACM SIGPLAN conference on History of programming languages
| pages = 231–270
| publisher = ACM
| year = 1993
| location = New York, NY
| url = http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=025DEBBA2F21953AA2D2FB245EA0F25D?doi=10.1.1.49.7238&rep=rep1&type=pdf
| isbn = 0-89791-570-4
| access-date = 2008-10-17}}
* {{Cite book
| first = Jim
| last = Veitch
| editor-last = Salus
| editor-first = Peter H
| contribution = A history and description of CLOS
| title = Handbook of programming languages
| volume = Volume IV, Functional and logic programming languages
| edition = first
| year = 1998
| pages = [https://archive.org/details/handbookofprogra0000unse/page/107 107–158]
| place = Indianapolis, IN
| publisher = Macmillan Technical Publishing
| url = https://archive.org/details/handbookofprogra0000unse/page/107
| isbn = 1-57870-011-6
}}
* {{Cite book
 |title= [[Structure_and_Interpretation_of_Computer_Programs|Structure and Interpretation of Computer Programs]]
 |first1= Harold
 |last1= Abelson
 |author-link= Harold Abelson
 |first2= Gerald Jay
 |last2= Sussman
 |author2-link= Gerald Jay Sussman
 |first3= Julie
 |last3= Sussman
 |author3-link= Julie Sussman
 |year= 1996
 |edition= 2nd
 |publisher= MIT Press
 |isbn= 0-262-01153-0
 }}
* [https://www.gnu.org/gnu/rms-lisp.html My Lisp Experiences and the Development of GNU Emacs] {{Wayback|url=https://www.gnu.org/gnu/rms-lisp.html |date=20031004070753 }}, {{en-link|转录 (语言学)|Transcription (linguistics)|transcript}} of [[Richard_Stallman|Richard Stallman]]'s speech, 28 October 2002, at the International Lisp Conference
* {{Cite book
 |first= Paul
 |last= Graham
 |author-link= Paul Graham (computer programmer)
 |title=  {{en-link|黑客与画家|Hackers & Painters|Hackers & Painters. Big Ideas from the Computer Age}}
 |year= 2004
 |publisher= O'Reilly
 |isbn= 0-596-00662-4
 }}
* {{Cite book
 |author1 = {{en-link|Edmund Berkeley}}
 |author2 = {{en-link|Daniel G. Bobrow}}
 |title= The Programming Language LISP: Its Operation and Applications
 |url= http://www.softwarepreservation.org/projects/LISP/book/III_LispBook_Apr66.pdf
 |date= March 1964
 |publisher= MIT Press
 |location= Cambridge, Massachusetts
 }}
** Article largely based on the ''LISP - A Simple Introduction'' chapter: {{cite journal |last1=Berkeley |first1=Edmund C. |title=THE PROGRAMMING LANGUAGE LISP: AN INTRODUCTION AND APPRAISAL |journal=Computers and Automation |date=Sep 1964 |pages=[https://archive.org/details/bitsavers_computersA_6908895/page/n15 16]-23 |url=https://archive.org/details/bitsavers_computersA_6908895}}
* {{Cite book
 |last= Weissman
 |first= Clark
 |title= LISP 1.5 Primer
 |year= 1967
 |url= http://www.softwarepreservation.org/projects/LISP/book/Weismann_LISP1.5_Primer_1967.pdf
 |publisher= Dickenson Publishing Company Inc.
 |location= Belmont, California
 }}
{{Refend}}

== 外部链接 ==
{{Sister project links|wikt=en:Lisp|commons=Category:Lisp (programming language)|n=no|q=en:Lisp programming language|b=en:Subject:Lisp programming language|v=en:Topic:Lisp|s=en:Lambda Papers}}
;历史
* [http://www-formal.stanford.edu/jmc/history/lisp/lisp.html History of Lisp] {{Wayback|url=http://www-formal.stanford.edu/jmc/history/lisp/lisp.html |date=20210429044122 }} – [[约翰·麦卡锡|John McCarthy]]'s history of 12 February 1979
* [https://web.archive.org/web/20050617031004/http://www8.informatik.uni-erlangen.de/html/lisp-enter.html Lisp History] – Herbert Stoyan's history compiled from the documents (acknowledged by McCarthy as more complete than his own, see: [http://www-formal.stanford.edu/jmc/history/ McCarthy's history links] {{Wayback|url=http://www-formal.stanford.edu/jmc/history/ |date=20210429044124 }})
* [http://www.softwarepreservation.org/projects/LISP/ History of LISP at the Computer History Museum] {{Wayback|url=http://www.softwarepreservation.org/projects/LISP/ |date=20210626141159 }}
;图书和教程
* [http://www.lisperati.com/casting.html Casting SPELs in Lisp] {{Wayback|url=http://www.lisperati.com/casting.html |date=20050825210205 }}, a comic-book style introductory tutorial
* [http://paulgraham.com/onlisptext.html On Lisp] {{Wayback|url=http://paulgraham.com/onlisptext.html |date=20210501042953 }}, a free book by [[保羅·格雷厄姆|Paul Graham]]
* [http://www.gigamonkeys.com/book/ Practical Common Lisp] {{Wayback|url=http://www.gigamonkeys.com/book/ |date=20050729002714 }}, freeware edition by Peter Seibel
* [https://doc.lagout.org/programmation/Lisp/Land%20of%20Lisp_%20Learn%20to%20Program%20in%20Lisp%2C%20One%20Game%20at%20a%20Time%20%5BBarski%202010-11-15%5D.pdf Land of Lisp] {{Wayback|url=https://doc.lagout.org/programmation/Lisp/Land%20of%20Lisp_%20Learn%20to%20Program%20in%20Lisp%2C%20One%20Game%20at%20a%20Time%20%5BBarski%202010-11-15%5D.pdf |date=20220303000635 }}, Official [http://landoflisp.com/ Website] {{Wayback|url=http://landoflisp.com/ |date=20171213002134 }} for the book
* [https://github.com/kanaka/mal/ mal - Make a Lisp] {{Wayback|url=https://github.com/kanaka/mal/ |date=20220502053212 }}
;资源
* [https://github.com/CodyReichert/awesome-cl Awesome Common Lisp] {{Wayback|url=https://github.com/CodyReichert/awesome-cl |date=20220508213217 }}
* [http://www.cliki.net/ CLiki: the Common Lisp wiki] {{Wayback|url=http://www.cliki.net/ |date=20080828041826 }}
* [http://www.faqs.org/faqs/lisp-faq/ Lisp FAQ Index] {{Wayback|url=http://www.faqs.org/faqs/lisp-faq/ |date=20210430044918 }}
* [http://planet.lisp.org/ Planet Lisp] {{Wayback|url=http://planet.lisp.org/ |date=20210621091440 }}
* {{Curlie|Computers/Programming/Languages/Lisp|Lisp}}
{{-}}

{{Lisp programming language}}
{{程序设计语言|Lisp}}
{{Authority control}}
[[Category:动态类型编程语言|Category:动态类型编程语言]]
[[Category:函数式编程语言|Category:函数式编程语言]]
[[Category:学术的编程语言|Category:学术的编程语言]]
[[Category:程序设计语言|Category:程序设计语言]]
[[Category:LISP程式語言|]]