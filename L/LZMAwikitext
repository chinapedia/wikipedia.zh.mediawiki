{{noteTA|G1=IT}}
'''LZMA'''（{{lang-en|Lempel–Ziv–Markov chain algorithm}}）是2001年以来得到发展的一个[[数据压缩|数据压缩]]算法，它用于[[7-Zip|7-Zip]]归档工具中的[[7z|7z]]格式和 [[Unix-like|Unix-like]] 下的 [[xz|xz]] 格式。它使用类似于[[LZ77与LZ78|LZ77]]的{{tsl|en|Dictionary coder|字典编码}}机制，在一般的情況下壓縮率比[[bzip2|bzip2]]為高，用於壓縮的字典檔案大小可達4GB。

[[C++|C++]]语言写成的LZMA[[开放源码|开放源码]]压缩库使用了[[区间编码|区间编码]]支持的[[LZ77与LZ78|LZ77]]改进压缩算法以及特殊的用于二进制的预处理程序。LZMA 对数据流、重复序列大小以及重续序列位置单独进行了压缩。LZMA支持几种[[散列链|散列链]]变体、[[二叉树|二叉树]]以及[[基数树|基数树]]作为它的字典查找算法基础。

== 特性 ==

=== BCJ / BCJ2二进制文件压缩 ===

BCJ / BCJ2压缩工具所附带的LZMA SDK包括：在[[X86|X86]]、[[ARM|ARM]]、[[PowerPC|PowerPC]]、[[IA-64|IA-64]]以及[[ARM#Thumb|ARM Thumb]]处理器上在压缩之前跳转目标进行归一化处理。对于x86平台来说，这是一个近跳转、近调用以及近条件跳转需要从“向后跳1665字节”这样的机器语言归一化到“跳转到5554”这样的格式，但是短跳转及短条件跳转不需要进行这样的处理。

BCJ与BCJ2之间的区别在于前者只将近跳转及近调用目标地址转换到归一化的形式，而BCJ2只将x86平台下的近跳转、近调用及条件近跳转目标分别进行压缩。

== 实现和可移植性 ==

一些[[Windows作業系統|Windows作業系統]]专有的特性深深嵌入在原始程序中，使得最初很难生成一个与[[Unix|Unix]]等系统兼容的版本。然而，LZMA 由于其[[开放源码|开放源码]]特性，仍然最终获得了各种平台的实现：

=== 7-Zip/p7zip 参考实现 ===

{{main|7-zip|p7zip}}

在[[GPL|GNU通用公共許可證]]下發佈的 7-zip 參考版本有以下幾個特點：

* 高壓縮比
* 解壓縮程式碼較小：約5 KB
* 解壓縮時僅需少量記憶體（取決於字典大小）
* 解壓縮速度：在一部2GHz的處理器上運行，約可達10-20MB每秒的速度。
* 支援在[[多核心|多核心]]系统上[[多執行緒|多執行緒]]运行（包括[[超執行緒|超執行緒]]）。

这个特点使得这个这个算法的解压过程非常适合于[[嵌入式系统|嵌入式系统]]应用的场合。p7zip 为 [[7-zip|7-zip]] 的 POSIX 系统移植。

=== xz 和 LZMA Unix Port ===

{{main|xz}}

LZMA Unix Port 是一个只移植了 7-zip 中 LZMA 压缩代码的版本，内含命令行参数类似于 [[gzip|gzip]] 的基于数据流的压缩工具。它不是一个归档工具，而只是一个普通的压缩工具，并且由于它在没有数据头中没有未压缩文件大小的UInt64变量，所以它与7-zip生成的LZMA数据流中不同。[[7-zip|7-zip]]使用一种更加灵活的归档格式[[7z|7z]]，因此不能被此工具解压。

后来类似的 xz 替代了 LZMA Unix Port，提供了更好的压缩功能，并最终以其优异的性能和压缩比<ref>{{cite web|author1=Lasse Collin|title=A Quick Benchmark: Gzip vs. Bzip2 vs. LZMA|url=http://tukaani.org/lzma/benchmarks.html|accessdate=2015-10-21|ref=gzip_bzip_lzma_bench|date=2005-05-31|archive-date=2020-11-12|archive-url=https://web.archive.org/web/20201112013945/https://tukaani.org/lzma/benchmarks.html}}</ref>成为了不少开源软件（例如 [[Linux|Linux]] 内核源码、[[Debian|Debian]] deb<ref name=dpkg_use_xz>{{cite web|author1=Guillem Jover|title=Accepted dpkg 1.17.0 (source amd64 all)|url=http://packages.qa.debian.org/d/dpkg/news/20130727T040302Z.html|website=Debian Package QA|accessdate=2015-10-21|archive-date=2017-07-06|archive-url=https://web.archive.org/web/20170706124615/https://packages.qa.debian.org/d/dpkg/news/20130727T040302Z.html}}</ref> 和 [[Fedora_(作業系統)|Fedora]] rpm）的压缩方式之一，甚至是默认压缩方式。xz 命令行程序曾有过一个名为 pxz 的分支，提供多线程压缩功能，后来 xz 在 5.2 时本身就直接提供多线程了。

=== lzip ===
{{main|{{tsl|en|lzip|}}}}

Lzip 是另一个 [[Unix-like|Unix-like]] 系统下的 LZMA 压缩格式，其主要目的之一就是和 xz 竞争。与 xz 相比，它的最大亮点在于提供更简单的文件格式和因此得来的更方便的数据恢复<ref name=lzip_bench>{{cite web|last1=Diaz|first1=Diaz|title=Lzip Benchmarks|url=http://lzip.nongnu.org/lzip_benchmark.html|publisher=LZIP (nongnu)|access-date=2015-10-21|archive-date=2020-06-07|archive-url=https://web.archive.org/web/20200607220953/http://lzip.nongnu.org/lzip_benchmark.html}}</ref><ref>{{cite web|title=lziprecover|author1=Antonio Diaz Diaz|url=http://lzip.nongnu.org/lziprecover.html|access-date=2015-10-21|archive-date=2020-06-27|archive-url=https://web.archive.org/web/20200627025910/http://lzip.nongnu.org/lziprecover.html}}</ref>。Lzip 的格式如此简单以至于其文档中就存在一个解压器实现，于是未来的数据考古学家即使在[[量子计算机|量子计算机]]使得 LZMA 无用多时之后只靠文档也能成功解压文件。

== 应用 ==

使用或者支持LZMA的软件有：

* [[Nullsoft_Scriptable_Install_System|Nullsoft Scriptable Install System]]
* [[Inno_Setup|Inno Setup]]
* [[Linux|Linux]] 内核（[[cramfs|cramfs]]、[[SquashFS|SquashFS]]、[[initrd|initrd]] 等）、[[GRUB|GRUB]]
* [http://ck.kolivas.org/apps/lrzip/ lrzip] {{Wayback|url=http://ck.kolivas.org/apps/lrzip/ |date=20201130041617 }}（"long range zip", or "LZMA [[rzip|rzip]]"）
* [http://www.joachim-bauch.de/projects/python/pylzma PyLZMA] {{Wayback|url=http://www.joachim-bauch.de/projects/python/pylzma |date=20100402042916 }}，Igor Pavlov的LZMA SDK的[[Python|Python]]语言接口
* [http://freearc.narod.ru/ FreeArc] {{Wayback|url=http://freearc.narod.ru/ |date=20201021011924 }}，归档工具及LZMA SDK的[[Haskell|Haskell]]语言接口
* 用于[[Pascal|Pascal]]语言的[http://www.birtles.org.uk/programming/ LZMA SDK] {{Wayback|url=http://www.birtles.org.uk/programming/ |date=20201128180344 }}
* [[7-Zip|7-Zip]]
* [[osu!|osu!]](用于记录玩家的游戏回放，[[osu!|osu!]]将光标移动信息以[[LZMA|LZMA]]格式压缩为存档。)

== 压缩格式表示 ==

LZMA的压缩输出流是一个比特流，采用自适应二进制行程编码器（adaptive binary range coder）。比特流划分为包（packet），每个包或者表示一个字节的被压缩数据，或者如同LZ77的压缩输出序列那样的长度与距离的对（pair）。每个包得每个部分作为独立的上下文（context），从而对每个比特的概率预测仅相关于前一个包的同类型比特值。

有7类包：<ref>{{Cite web |url=http://7-zip.org/sdk.html |title=the source of LZMA SDK  |access-date=2016-08-04 |archive-date=2014-06-09 |archive-url=https://wayback.archive-it.org/all/20140609200859/http://www.7-zip.org/sdk.html }}</ref>

{| class="wikitable" border="1"
|-
! 包的比特序列
! 包名
! 描述
|-
| 0 + byteCode
| LIT
| 单个字节，采用自适应二进制行程编码器。
|-
| 1+0 + len + dist
| MATCH
| 一个典型的LZ77序列使用长度与距离。
|-
| 1+1+0+0
| SHORTREP
| 单个字节的LZ77序列。距离等于上个LZ77包使用的距离。
|-
| 1+1+0+1 + len
| LONGREP[0]
| 单个LZ77序列。距离等于上个LZ77包使用的距离。
|-
| 1+1+1+0 + len
| LONGREP[1]
| 单个LZ77序列。距离等于倒数第二个LZ77包使用的距离。
|-
| 1+1+1+1+0 + len
| LONGREP[2]
| 单个LZ77序列。距离等于倒数第三个LZ77包使用的距离。
|-
| 1+1+1+1+1 + len
| LONGREP[3]
| 单个LZ77序列。距离等于倒数第四个LZ77包使用的距离。
|}

LONGREP[*] 表示LONGREP[0-3]四种包, *REP指称LONGREP 与SHORTREP, *MATCH指称MATCH或*REP.

LONGREP[n]包删除了对距离的直接表示，而是使用包序列最近四个距离。


包的长度部分表示如下：
{| class="wikitable" border="1"
|-
! 长度比特序列
! 描述
|-
| 0+ 3 bits
| 长度用3比特编码，表示 2 到 9.
|-
| 1+0+ 3 bits
| 长度用3比特编码，表示 10到17.
|-
| 1+1+ 8 bits
| 长度用8比特编码，表示 18到273.
|}

如同LZ77, 长度不一定要小于距离。

距离在逻辑上是32比特，距离0表示最近增加到词典的那个字节。

距离的编码以6比特"distance slot"开始，由此可知后面跟着多少比特来补全。这是可变长编码。
距离解码后为比特流，从最显著位到最不显著位。distance slots 0−3直接编码了0−3.

{| class="wikitable" border="1"
|-
! 6-bit distance slot
! Highest 2 bits
! Fixed 0.5 probability bits
! 跟随的比特位数
|-
| 0
| 00
| 0
| 0
|-
| 1
| 01
| 0
| 0
|-
| 2
| 10
| 0
| 0
|-
| 3
| 11
| 0
| 0
|-
| 4
| 10
| 0
| 1
|-
| 5
| 11
| 0
| 1
|-
| 6
| 10
| 0
| 2
|-
| 7
| 11
| 0
| 2
|-
| 8
| 10
| 0
| 3
|-
| 9
| 11
| 0
| 3
|-
| 10
| 10
| 0
| 4
|-
| 11
| 11
| 0
| 4
|-
| 12
| 10
| 0
| 5
|-
| 13
| 11
| 0
| 5
|-
| 14–62 (even)
| 10
| ((slot / 2) − 5)
| 4
|-
| 15–63 (odd)
| 11
| (((slot − 1) / 2) − 5)
| 4
|}
== 解压缩算法描述 ==
依据嵌入到Linux kernel的 [[Xz|XZ]]解码算法源文件<ref>{{cite web
| url=https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/lib/xz/xz_dec_lzma2.c
| title=lib/xz/xz_dec_lzma2.c
| first1=Lasse
| last1=Collin
| first2=Igor
| last2=Pavlov
| accessdate=2013-06-16
| archive-date=2019-10-18
| archive-url=https://web.archive.org/web/20191018032241/https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/lib/xz/xz_dec_lzma2.c
}}</ref>。
<!--
===比特的区间编码===

LZMA data is at the lowest level decoded one bit at a time by the range decoder, at the direction of the LZMA decoder.

Context-based range decoding is invoked by the LZMA algorithm passing it a reference to the "context", which consists of the unsigned 11-bit variable ''prob'' (typically implemented using a 16-bit data type) representing the predicted probability of the bit being 1, which is read and updated by the range decoder (and should be initialized to 2^10, representing 0.5 probability).

Fixed probability range decoding instead assumes a 0.5 probability, but operates slightly differently from context-based range decoding.

The range decoder state consists of two unsigned 32-bit variables, ''range'' (representing the range size), and ''code'' (representing the encoded point within the range).

Initialization of the range decoder consists of setting ''range'' to 2<sup>32</sup> − 1, and ''code'' to the 32-bit value starting at the second byte in the stream interpreted as big-endian; the first byte in the stream is completely ignored.

Normalization proceeds in this way:
# Shift both ''range'' and ''code'' left by 8 bits
# Read a byte from the compressed stream
# Set the least significant 8 bits of ''code'' to the byte value read

Context-based range decoding of a bit using the ''prob'' probability variable proceeds in this way:
# If ''range'' is less than 2^24, perform normalization
# Set ''bound'' to floor(''range'' / 2^11) * ''prob''
# If ''code'' is less than ''bound'':
## Set ''range'' to ''bound''
## Set ''prob'' to ''prob'' + floor((2^11 - ''prob'') / 2^5)
## Return bit 0
# Otherwise (if ''code'' is greater than or equal to the ''bound''):
## Set ''range'' to ''range'' - ''bound''
## Set ''code'' to ''code'' - ''bound''
## Set ''prob'' to ''prob'' - floor(''prob'' / 2^5)
## Return bit 1

Fixed-probability range decoding of a bit proceeds in this way:
# If ''range'' is less than 2^24, perform normalization
# Set ''range'' to floor(''range'' / 2)
# If ''code'' is less than ''range'':
## Return bit 0
# Otherwise (if ''code'' is greater or equal than ''range''):
## Set ''code'' to ''code'' - ''range''
## Return bit 1

The Linux kernel implementation of fixed-probability decoding in rc_direct, for performance reasons, doesn't include a conditional branch, but instead subtracts ''range'' from ''code'' unconditionally, and uses the resulting sign bit to both decide the bit to return, and to generate a mask that is combined with ''code'' and added to ''range''.

Note that:
# The division by 2^11 when computing ''bound'' and floor operation is done before the multiplication, not after (apparently to avoid requiring fast hardware support for 32-bit multiplication with a 64-bit result)
# Fixed probability decoding is not strictly equivalent to context-based range decoding with any ''prob'' value, due to the fact that context-based range decoding discards the lower 11 bits of ''range'' before multiplying by ''prob'' as just described, while fixed probability decoding only discards the last bit

===Range coding of integers ===

The range decoder also provides the bit-tree, reverse bit-tree and fixed probability integer decoding facilities, which are used to decode integers, and generalize the single-bit decoding described above.
To decode unsigned integers less than ''limit'', an array of (''limit'' − 1) 11-bit probability variables is provided, which are conceptually arranged as the internal nodes of a complete binary tree with ''limit'' leaves.

Non-reverse bit-tree decoding works by keeping a pointer to the tree of variables, which starts at the root. As long as the pointer doesn't point to a leaf, a bit is decoded using the variable indicated by the pointer, and the pointer is moved to either the left or right children depending on whether the bit is 0 or 1; when the pointer points to a leaf, the number associated with the leaf is returned.

Non-reverse bit-tree decoding thus happens from most significant to least significant bit, stopping when only one value in the valid range is possible (this conceptually allows to have range sizes that are not powers of two, even though LZMA doesn't make use of this).

Reverse bit-tree decoding instead decodes from least significant bit to most significant bits, and thus only supports ranges that are powers of two, and always decodes the same number of bits. It is equivalent to performing non-reverse bittree decoding with a power of two ''limit'', and reversing the last log2(''limit'') bits of the result.

Note that in the rc_bittree function in the Linux kernel, integers are actually returned in the [''limit'', 2 * ''limit'') range (with ''limit'' added to the conceptual value), and the variable at index 0 in the array is unused, while the one at index 1 is the root, and the left and right children indices are computed as 2''i'' and 2''i'' + 1. The rc_bittree_reverse function instead adds integers in the [0, ''limit'') range to a caller-provided variable, where ''limit'' is implicitly represented by its logarithm, and has its own independent implementation for efficiency reasons.

Fixed probability integer decoding simply performs fixed probability bit decoding repeatedly, reading bits from the most to the least significant.

===LZMA configuration===

The LZMA decoder is configured by an ''lclppb'' "properties" byte and a dictionary size.

The value of the ''lclppb'' byte is ''lc'' + ''lp'' * 9 + ''pb'' * 9 * 5, where:
*''lc'' is the number of high bits of the previous byte to use as a context for literal encoding (the default value used by the LZMA SDK is 3)
*''lp'' is the number of low bits of the dictionary position to include in ''literal_pos_state'' (the default value used by the LZMA SDK is 0)
*''pb'' is the number of low bits of the dictionary position to include in ''pos_state'' (the default value used by the LZMA SDK is 2)

In non-LZMA2 streams, ''lc'' must not be greater than 8, and ''lp'' and ''pb'' must not be greater than 4.
In LZMA2 streams, (''lc'' + ''lp'') and ''pb'' must not be greater than 4.

In the 7-zip LZMA file format, configuration is performed by a header containing the "properties" byte followed by the 32-bit little-endian dictionary size in bytes. In LZMA2, the properties byte can optionally be changed at the start of LZMA2 LZMA packets, while the dictionary size is specified in the LZMA2 header as later described.

===LZMA coding contexts===

The LZMA packet format has already been described, and this section specifies how LZMA statistically models the LZ-encoded streams, or in other words which probability variables are passed to the range decoder to decode each bit.

Those probability variables are implemented as multi-dimensional arrays; before introducing them, a few values that are used as indices in these multidimensional arrays are defined.

The ''state'' value is conceptually based on which of the patterns in the following table match the latest 2-4 packet types seen, and is implemented as a state machine state updated according to the transition table listed in the table every time a packet is output.

The initial state is 0, and thus packets before the beginning are assumed to be LIT packets.
{| class="wikitable" border="1"
|-
! state
! colspan="4" | previous packets
! colspan="4" | next state when next packet is
|-
!
! 4th previous
! 3rd previous
! 2nd previous
! previous
! LIT
! MATCH
! LONGREP[*]
! SHORTREP
|-
| 0
|
| LIT
| LIT
| LIT
| 0
| 7
| 8
| 9
|-
| 1
|
| MATCH
| LIT
| LIT
| 0
| 7
| 8
| 9
|-
| rowspan="2" | 2
|
| LONGREP[*]
| rowspan="2" | LIT
| rowspan="2" | LIT
| rowspan="2" | 0
| rowspan="2" | 7
| rowspan="2" | 8
| rowspan="2" | 9
|-
| *MATCH
| SHORTREP
|-
| 3
| LIT
| SHORTREP
| LIT
| LIT
| 0
| 7
| 8
| 9
|-
| 4
|
|
| MATCH
| LIT
| 1
| 7
| 8
| 9
|-
| rowspan="2" | 5
| rowspan="2" |
|
| LONGREP[*]
| rowspan="2" | LIT
| rowspan="2" | 2
| rowspan="2" | 7
| rowspan="2" | 8
| rowspan="2" | 9
|-
| *MATCH
| SHORTREP
|-
| 6
|
| LIT
| SHORTREP
| LIT
| 3
| 7
| 8
| 9
|-
| 7
|
|
| LIT
| MATCH
| 4
| 10
| 11
| 11
|-
| 8
|
|
| LIT
| LONGREP[*]
| 5
| 10
| 11
| 11
|-
| 9
|
|
| LIT
| SHORTREP
| 6
| 10
| 11
| 11
|-
| 10
|
|
| *MATCH
| MATCH
| 4
| 10
| 11
| 11
|-
| 11
|
|
| *MATCH
| *REP
| 5
| 10
| 11
| 11
|}

The ''pos_state'' and ''literal_pos_state'' values consist of respectively the ''pb'' and ''lp'' (up to 4, from the LZMA header or LZMA2 properties packet) least significant bits of the dictionary position (the number of bytes coded since the last dictionary reset modulo the dictionary size). Note that the dictionary size is normally the multiple of a large power of 2, so these values are equivalently described as the least significant bits of the number of uncompressed bytes seen since the last dictionary reset.

The ''prev_byte_lc_msbs'' value is set to the ''lc'' (up to 4, from the LZMA header or LZMA2 properties packet) most significant bits of the previous uncompressed byte.

The ''is_REP'' value denotes whether a packet that includes a length is a LONGREP rather than a MATCH.

The ''match_byte'' value is the byte that would have been decoded if a SHORTREP packet had been used (in other words, the byte found at the dictionary at the last used distance); it is only used just after a *MATCH packet.

''literal_bit_mode'' is an array of 8 values in the 0-2 range, one for each bit position in a byte, which are 1 or 2 if the previous packet was a *MATCH and it is either the most significant bit position or all the more significant bits in the literal to encode/decode are equal to the bits in the corresponding positions in ''match_byte'', while otherwise it is 0; the choice between the 1 or 2 values depends on the value of the bit at the same position in ''match_byte''.

The literal/Literal set of variables can be seen as a "pseudo-bit-tree" similar to a bit-tree but with 3 variables instead of 1 in every node, chosen depending on the ''literal_bit_mode'' value at the bit position of the next bit to decode after the bit-tree context denoted by the node.

The claim, found in some sources, that literals after a *MATCH are coded as the XOR of the byte value with ''match_byte'' is incorrect; they are instead coded simply as their byte value, but using the pseudo-bit-tree just described and the additional context listed in the table below.

The probability variable groups used in LZMA are those:
{| class="wikitable" border="1"
|-
! XZ name
! LZMA SDK name
! parameterized by
! used when
! coding mode
! if bit 0 then
! if bit 1 then
|-
| is_match
| IsMatch
| ''state'', ''pos_state''
| packet start
| bit
| LIT
| *MATCH
|-
| is_rep
| IsRep
| ''state''
| after bit sequence 1
| bit
| MATCH
| *REP
|-
| is_rep0
| IsRepG0
| ''state''
| after bit sequence 11
| bit
| SHORTREP/
LONGREP[0]
| LONGREP[1-3]
|-
| is_rep0_long
| IsRep0Long
| ''state'', ''pos_state''
| after bit sequence 110
| bit
| SHORTREP
| LONGREP[0]
|-
| is_rep1
| IsRepG1
| ''state''
| after bit sequence 111
| bit
| LONGREP[1]
| LONGREP[2/3]
|-
| is_rep2
| IsRepG2
| ''state''
| after bit sequence 1111
| bit
| LONGREP[2]
| LONGREP[3]
|-
| literal
| Literal
| ''prev_byte_lc_msbs'', ''literal_pos_state'', ''literal_bit_mode''[bit position], bit-tree context
| after bit sequence 0
| 256 values pseudo-bit-tree
| colspan="2" | literal byte value
|-
| dist_slot
| PosSlot
| min(''match_length'', 5), bit-tree context
| distance: start
| 64 values bit-tree
| colspan="2" | distance slot
|-
| dist_special
| SpecPos
| ''distance_slot'', reverse bit-tree context
| distance: 4-13 distance slots
| ((''distance_slot'' >> 1) − 1)-bit reverse bit-tree
| colspan="2" | low bits of distance
|-
| dist_align
| Align
| reverse bit-tree context
| distance: 14+ distance slots, after fixed probability bits
| 4-bit reverse bit-tree
| colspan="2" | low bits of distance
|-
| len_dec.choice
| LenChoice
| ''is_REP''
| match length: start
| bit
| 2-9 length
| 10+ length
|-
| len_dec.choice2
| LenChoice2
| ''is_REP''
| match length: after bit sequence 1
| bit
| 10-17 length
| 18+ length
|-
| len_dec.low
| LenLow
| ''is_REP'', ''pos_state'', bit-tree context
| match length: after bit sequence 0
| 8 values bit-tree
| colspan="2" | low bits of length
|-
| len_dec.mid
| LenMid
| ''is_REP'', ''pos_state'', bit-tree context
| match length: after bit sequence 10
| 8 values bit-tree
| colspan="2" | middle bits of length
|-
| len_dec.high
| LenHigh
| ''is_REP'', bit-tree context
| match length: after bit sequence 11
| 256 values bit-tree
| colspan="2" | high bits of length
|}

===LZMA2 format===

The LZMA2 container supports multiple runs of compressed LZMA data and uncompressed data. Each LZMA compressed run can have a different LZMA configuration and dictionary. This improves the compression of partially or completely incompressible files and allows multithreaded compression and multithreaded decompression by breaking the file into runs that can be compressed or decompressed independently in parallel.

The LZMA2 header consists of a byte indicating the dictionary size:
* 40 indicates a 4 GB − 1 dictionary size
* Even values less than 40 indicate a 2<sup>''v''/2 + 12</sup> bytes dictionary size
* Odd values less than 40 indicate a 3×2<sup>(''v'' − 1)/2 + 11</sup> bytes dictionary size
* Values higher than 40 are invalid

LZMA2 data consists of packets starting with a control byte, with the following values:
* 0 denotes the end of the file
* 1 denotes a dictionary reset followed by an uncompressed chunk
* 2 denotes an uncompressed chunk without a dictionary reset
* 3-0x7f are invalid values
* 0x80-0xff denotes an LZMA chunk, where the lowest 5 bits are used as bit 16-20 of the uncompressed size minus one, and bit 5-6 indicates what should be reset

Bits 5-6 for LZMA chunks can be:
* 0: nothing reset
* 1: state reset
* 2: state reset, properties reset using properties byte
* 3: state reset,  properties reset using properties byte, dictionary reset

LZMA state resets cause a reset of all LZMA state except the dictionary, and specifically:
* The range coder
* The ''state'' value
* The last distances for repeated matches
* All LZMA probabilities

Uncompressed chunks consist of:
* A 16-bit big-endian value encoding the data size minus one
* The data to be copied verbatim into the dictionary and the output

LZMA chunks consist of:
* A 16-bit big-endian value encoding the low 16-bits of the uncompressed size minus one
* A 16-bit big-endian value encoding the compressed size minus one
* A properties/lclppb byte if bit 6 in the control byte is set
* The LZMA compressed data, starting with the 5 bytes (of which the first is ignored) used to initialize the range coder (which are included in the compressed size)
 -->

== 參考資料 ==
{{reflist}}

== 外部链接 ==

* [http://www.7-zip.org/ 7-Zip Official Web-Site] {{Wayback|url=http://www.7-zip.org/ |date=20060512045746 }}
* [http://www.7-zip.org/sdk.html LZMA SDK] {{Wayback|url=http://www.7-zip.org/sdk.html |date=20210202185328 }}
* [http://sourceforge.net/projects/p7zip/ p7zip Unix port of command-line utilities] {{Wayback|url=http://sourceforge.net/projects/p7zip/ |date=20210202185255 }}
* [http://www.joachim-bauch.de/projects/python/pylzma PyLZMA Python Wrapper] {{Wayback|url=http://www.joachim-bauch.de/projects/python/pylzma |date=20100402042916 }}
* [https://web.archive.org/web/20080516065536/http://nsis.sourceforge.net/ Nullsoft Installer uses LZMA]
* [http://www.jrsoftware.org/isinfo.php Inno Setup supports LZMA] {{Wayback|url=http://www.jrsoftware.org/isinfo.php |date=20210126030059 }}
* [https://web.archive.org/web/20060903100509/http://www.fromconcentratesoftware.com/Compress/ Compress home page]
* [http://babel.ls.fi.upm.es/~aacosta/twiki/bin/view/Projects/CramfsPatches LZMA support for cramfs filesystem]{{Dead link|date=2019年5月 |bot=InternetArchiveBot |fix-attempted=yes }}（dead）
* [http://tukaani.org/lzma/ LZMA utils] {{Wayback|url=http://tukaani.org/lzma/ |date=20201027013625 }}
* [http://freearc.narod.ru/ FreeArc archiver and Haskell interface to the LZMA library] {{Wayback|url=http://freearc.narod.ru/ |date=20201021011924 }}
* [http://search.cpan.org/search?query=lzma at least one perl interface to LZMA library has been published] {{Wayback|url=http://search.cpan.org/search?query=lzma |date=20191018032240 }}
* [http://www.birtles.org.uk/programming/ Pascal port of the LZMA SDK] {{Wayback|url=http://www.birtles.org.uk/programming/ |date=20201128180344 }}

{{压缩方法}}
{{Archive formats}}

[[Category:无损压缩算法|Category:无损压缩算法]]