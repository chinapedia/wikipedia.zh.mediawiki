{{noteTA
|G1=IT
}}
{{Infobox software
| name = Entity Framework
| logo = <!-- Image name is enough -->
| logo caption = 
| author = [[Microsoft|Microsoft]]
| developer = [[.NET_Foundation|.NET Foundation]]
| released = {{Start date and age|2008|08|11}}
| discontinued = 
| latest release version = Entity Framework 6: v6.4.4<br />Entity Framework Core: v5.0.0
| latest release date = Entity Framework 6: {{Start date and age|2020|04|22}}<ref name="FrameworkVer">{{cite web |title=Releases · dotnet/ef6 · GitHub|url=https://github.com/dotnet/ef6/releases}}</ref><br />Entity Framework Core: {{Start date and age|2020|10|24}}<ref name="CoreVer">{{cite web |title=Releases · dotnet/efcore · GitHub|url=https://github.com/dotnet/efcore/releases}}</ref>
| latest preview version = 
| latest preview date = 
| repo = {{URL|https://github.com/dotnet/ef6}}<br />{{URL|https://github.com/dotnet/efcore}}
| programming language = [[C_Sharp_(programming_language)|C#]]
| operating system = 
| platform = [[.NET_Framework|.NET Framework]],<br />[[.NET_Core|.NET Core]]
| size = 
| language = 
| language count = <!-- DO NOT include this parameter unless you know what it does -->
| language footnote = 
| genre = [[對象關係映射|對象關係映射]](ORM)
| license = [[Apache_License_2.0|Apache License 2.0]]
| website = {{URL|https://docs.microsoft.com/en-us/ef/}}
| standard = 
| AsOf = 
| logo_size = 
| logo_alt = 
}}
'''Entity Framework''' (又稱ADO.NET Entity Framework) 是微軟以 ADO.NET 為基礎所發展出來的'''[[對象關係映射|物件關聯對應]] (O/R Mapping)''' 解決方案，早期被稱為 ObjectSpace，包含在 .NET Framework中發表。从版本6开始独立发布。

== 背景 ==

長久以來，程式設計師和資料庫總是保持著一種微妙的關係，在商用應用程式中，資料庫一定是不可或缺的元件，這讓程式設計師一定要為了連接與存取資料庫而去學習 [[SQL|SQL]] 指令，因此在資訊業中有很多人都在研究如何將程式設計模型和資料庫整合在一起，[[對象關係映射|物件關聯對應]] (Object-Relational Mapping) 的技術就是由此而生，像[[Hibernate|Hibernate]]或[[NHibernate|NHibernate]]都是這個技術下的產物，而微軟雖然有了[[ADO.NET|ADO.NET]]這個資料存取的利器，但卻沒有像NHibernate這樣的物件對應工具，因此微軟在.NET Framework 2.0發展時期，就提出了一個ObjectSpace的概念，ObjectSpace可以讓應用程式可以用完全物件化的方法連接與存取資料庫，其技術概念與NHibernate相當類似，然而ObjectSpace工程相當大，在.NET Framework 2.0完成時仍無法全部完成，因此微軟將ObjectSpace納入下一版本的.NET Framework中，並且再加上一個設計的工具（Designer），構成了現在的 ADO.NET Entity Framework。

Entity Framework是[[ADO.NET|ADO.NET]]之上支持面向数据应用程序开发，使得开发者工作于领域相关的对象和属性的数据级，如客户、客户地址等，不必关注存储数据的底层表、列。这种在更高层次上创建、维护面向数据的应用程序可以大大节约编码量。<ref>{{Cite web|url=https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ef/overview|title = Entity Framework Overview - ADO.NET}}</ref>

Entity Framework 利用了'''抽象化'''資料結構的方式，將每個資料庫物件都轉換成'''應用程式物件''' (entity)，而資料欄位都轉換為'''屬性''' (property)，關聯則轉換為'''結合屬性''' (association)，讓資料庫的 E/R 模型完全的轉成物件模型，如此讓程式設計師能用最熟悉的程式語言來呼叫存取。而在抽象化的結構之下，則是高度整合與對應結構的概念層、對應層和儲存層，以及支援 Entity Framework 的資料提供者 (provider)，讓資料存取的工作得以順利與完整的進行。

* 概念層：負責向上的物件與屬性顯露與存取。
* 對應層：將上方的概念層和底下的儲存層的資料結構對應在一起。
* 儲存層：依不同資料庫與資料結構，而顯露出實體的資料結構體，和 Provider 一起，負責實際對資料庫的存取和 SQL 的產生。
== 历史==
2008年8月11日，Entity Framework的第一版(EFv1)随.NET Framework 3.5 Service Pack 1和[[Microsoft_Visual_Studio|Visual Studio 2008]] Service Pack 1发布。该版受到了广泛的批评。<ref name="vonc">[http://efvote.wufoo.com/forms/ado-net-entity-framework-vote-of-no-confidence/ ADO .NET Entity Framework Vote of No Confidence]</ref>

2010年4月12日，Entity Framework第2版，称为Entity Framework 4.0 (EFv4)发布，解决了第一版的很多问题。<ref name="verfour">{{cite web
 |url         = http://blogs.msdn.com/adonet/archive/2009/05/11/update-on-the-entity-framework-in-net-4-and-visual-studio-2010.aspx
 |title       = Update on the Entity Framework in .NET 4 and Visual Studio 2010
 |date        = May 11, 2009
 |access-date  = November 1, 2011
 |publisher   = ADO.NET team blog
 |url-status     = dead
 |archive-url  = https://web.archive.org/web/20100120170901/http://blogs.msdn.com/adonet/archive/2009/05/11/update-on-the-entity-framework-in-net-4-and-visual-studio-2010.aspx
 |archive-date = January 20, 2010
}}</ref>该版本完全包含在.NET Framework中。

2011年4月12日发布了Entity Framework第3个版本，称为version 4.1，开始支持Code First。2011年7月25日发布了Entity Framework 4.1 Update 1。

2012年2月29日发布了version 4.3.1。<ref name="verfourthreeone">{{cite web
 |url         = http://blogs.msdn.com/b/adonet/archive/2012/02/29/ef4-3-1-and-ef5-beta-1-available-on-nuget.aspx
 |title       = EF4.3.1 and EF5 Beta 1 Available on NuGet
 |date        = February 29, 2012
 |access-date  = March 27, 2012
 |publisher   = ADO.NET team blog
 |url-status     = dead
 |archive-url  = https://web.archive.org/web/20120325142128/http://blogs.msdn.com/b/adonet/archive/2012/02/29/ef4-3-1-and-ef5-beta-1-available-on-nuget.aspx
 |archive-date = March 25, 2012
}}</ref>

2012年8月11日发布了Version 5.0.0。<ref name="verfive">{{ cite web
 | url=https://entityframework.codeplex.com/releases/view/86738
 | title=EF5 Available on CodePlex
 | date=August 11, 2012
}}</ref>与.NET framework 4.5配套。

2013年10月17日发布了Version 6.0。<ref name="versionsix">{{ cite web
 |url         = http://blogs.msdn.com/b/adonet/archive/2013/10/17/ef6-rtm-available.aspx
 |title       = EF6 RTM Available
 |date        = October 17, 2013
 |url-status     = dead
 |archive-url  = https://web.archive.org/web/20140330034136/http://blogs.msdn.com/b/adonet/archive/2013/10/17/ef6-rtm-available.aspx
 |archive-date = 2014-03-30
}}</ref>并成为开源软件，使用[[Apache_License|Apache License]] v2. 类似于[[ASP.NET_MVC|ASP.NET MVC]]，开源发布于[[GitHub|GitHub]]。<ref>{{cite web
 | url=https://github.com/aspnet/EntityFramework6
 | title=Entity Framework - Home
 | date=September 14, 2016
}}</ref> This version has a number of improvements for [[Code_First|code-first]] support.<ref name="versiximprovements">{{ cite web
 | url=http://msdn.microsoft.com/en-US/data/jj574253
 | title=EF Version History
}}</ref>Entity Framework 6.0、6.1、6.2、6.3 和 6.4 完全作为NuGet包提供。

2014年5月19日，微软决定为了让其.NET能跨平台，下一版Entity Framework将完全重写。<ref name="versionseven">{{ cite web
 |url=http://blogs.msdn.com/b/adonet/archive/2014/05/19/ef7-new-platforms-new-data-stores.aspx 
 |title=EF7 - New Platforms, New Data Stores 
 |date=May 19, 2014 
 |url-status=dead 
 |archive-url=https://web.archive.org/web/20150929124551/http://blogs.msdn.com/b/adonet/archive/2014/05/19/ef7-new-platforms-new-data-stores.aspx 
 |archive-date=2015-09-29 
}}</ref>2016年6月27日，发布了Entity Framework Core 1.0, 伴随着ASP.NET Core 1.0 和 .NET Core 1.0.<ref name="efcore-10-available">{{ cite web
 | url=https://blogs.msdn.microsoft.com/dotnet/2016/06/27/entity-framework-core-1-0-0-available/
 | title=Entity Framework Core 1.0.0 Available
 | date=27 June 2016
}}</ref>本来其命名为Entity Framework 7，但为了突出其是完全重写而不是替换EF6所以重新命名。<ref>{{Cite web|url=http://www.hanselman.com/blog/ASPNET5IsDeadIntroducingASPNETCore10AndNETCore10.aspx|title=ASP.NET 5 is dead - Introducing ASP.NET Core 1.0 and .NET Core 1.0 - Scott Hanselman|last=Hanselman|first=Scott|website=www.hanselman.com|access-date=2016-07-11}}</ref>

== 架構 ==
[[File:ADO_NET_Entity_Framework_Architecture.png|thumb]]
{{stack|[[File:ADO.NET_Entity_Framework_stack.png|thumb]]}}
ADO.NET Entity Framework架构，从底向上包括：

* '''Data source specific providers''', ADO.NET抽象接口连接到数据库。
* '''Map provider''', 特定数据库的provider，翻译Entity SQL命令树到数据库本地SQL方言查询。包括'''Store-specific bridge'''，负责把一般命令树翻译为存储特定的命令树。 
* '''EDM parser and view mapping''', 把数据模型的特定的SDL规范和如何映射到关系模型。从关系模式角度，它创建了对应于概念模型的数据views。它聚合（aggregate）多张表的信息成为一个实体（entity），把一个到实体的修改（update）分割为到多个表的修改。
* '''Query and update pipeline''', 处理查询、过滤器、修改等请求，转化为经典命令树。 
* '''Metadata services''', 处理实体、关系、映射的所有元数据。
* '''Transactions''', 集成基础存储的事务能力。如果基础存储不支持事务，则在这个层次上实现事务。 
* '''Conceptual layer API''', 提供了概念模式下的编程接口。遵从ADO.NET模式，使用Connection对象引用map provider, 使用Command对象发送查询，返回EntityResultSets 或 EntitySets 以包含结果。
* '''Disconnected components''', ADO.NET Entity Framework使用的本地缓存数据集和实体集，在偶尔连接环境。
* '''Embedded database''': ADO.NET Entity Framework包含一个轻量嵌入数据库用于客户端缓存和查询关系数据库。 
* '''Design tools''', 如Mapping Designer, ADO.NET Entity Framework包含的用于简化映射从概念模式到关系模式，指出实体类型的哪些属性映射到数据库的哪个表。 
* '''Programming layer''', 暴露EDM作为编程结构，可被编程语言使用
** '''Object services''', 自动产生CLR类代码，把同一属性作为一个实体，允许实体实例作为.NET 对象.
** '''Web services''', 暴露web服务的实体
* '''High-level services''', 如工作在实体上的报告服务。

=== 概念層結構 ===

概念層結構定義了物件模型 (Object Model)，讓上層的應用程式碼可以如物件導向的方式般存取資料，概念層結構是由 CSDL (Conceptual Schema Definition Language) 所撰寫<ref>{{Cite web |url=http://msdn.microsoft.com/en-us/library/bb399292.aspx |title=Schemas and Mappings Specification: CSDL |accessdate=2008-10-02 |archive-date=2008-12-12 |archive-url=https://web.archive.org/web/20081212110339/http://msdn.microsoft.com/en-us/library/bb399292.aspx |dead-url=no }}</ref>。

一份概念層結構定義如下所示：
<syntaxhighlight lang="xml">
<?xml version="1.0" encoding="utf-8"?>
<Schema Namespace="Employees" Alias="Self" ns="http://schemas.microsoft.com/ado/2006/04/edm">
  <EntityContainer Name="EmployeesContext">
    <EntitySet Name="Employees" EntityType="Employees.Employees" />
  </EntityContainer>
  <EntityType Name="Employees">
    <Key>
      <PropertyRef Name="EmployeeId" />
    </Key>
    <Property Name="EmployeeId" Type="Guid" Nullable="false" />
    <Property Name="LastName" Type="String" Nullable="false" />
    <Property Name="FirstName" Type="String" Nullable="false" />
    <Property Name="Email" Type="String" Nullable="false" />
  </EntityType>
</Schema>
</syntaxhighlight>

=== 對應層結構 ===

對應層結構負責將上層的概念層結構以及下層的儲存體結構中的成員結合在一起，以確認資料的來源與流向。對應層結構是由 MSL (Mapping Specification Language) 所撰寫<ref>{{Cite web |url=http://msdn.microsoft.com/en-us/library/bb399202.aspx |title=Schemas and Mappings Specification: MSL |accessdate=2008-10-02 |archive-date=2008-09-14 |archive-url=https://web.archive.org/web/20080914182701/http://msdn.microsoft.com/en-us/library/bb399202.aspx |dead-url=no }}</ref>。

一份對應層結構定義如下所示：
<syntaxhighlight lang="xml">
<?xml version="1.0" encoding="utf-8"?>
<Mapping Space="C-S" ns="urn:schemas-microsoft-com:windows:storage:mapping:CS">

  <EntityContainerMapping StorageEntityContainer="dbo" CdmEntityContainer="EmployeesContext">
    <EntitySetMapping Name="Employees" StoreEntitySet="Employees" TypeName="Employees.Employees">

      <ScalarProperty Name="EmployeeId" ColumnName="EmployeeId" />
      <ScalarProperty Name="LastName" ColumnName="LastName" />
      <ScalarProperty Name="FirstName" ColumnName="FirstName" />
      <ScalarProperty Name="Email" ColumnName="Email" />

    </EntitySetMapping>
  </EntityContainerMapping>
</Mapping>
</syntaxhighlight>

=== 儲存層結構 ===

儲存層結構是負責與[[資料庫管理系統|資料庫管理系統]]（[[DBMS|DBMS]]）中的資料表做實體對應 (Physical Mapping)，讓資料可以輸入正確的資料來源中，或者由正確的資料來源取出。它是由 SSDL (Storage Schema Definition Language) 所撰寫<ref>{{Cite web |url=http://msdn.microsoft.com/en-us/library/bb399559.aspx |title=Schemas and Mappings Specification: SSDL |accessdate=2008-10-02 |archive-date=2008-12-29 |archive-url=https://web.archive.org/web/20081229062524/http://msdn.microsoft.com/en-us/library/bb399559.aspx |dead-url=no }}</ref>。

一份儲存層結構定義如下所示：
<syntaxhighlight lang="xml">
<?xml version="1.0" encoding="utf-8"?>
<Schema Namespace="Employees.Store" Alias="Self"
    Provider="System.Data.SqlClient"
    ProviderManifestToken="2005"
    ns="http://schemas.microsoft.com/ado/2006/04/edm/ssdl">
  <EntityContainer Name="dbo">
    <EntitySet Name="Employees" EntityType="Employees.Store.Employees" />
  </EntityContainer>
  <EntityType Name="Employees">
    <Key>
      <PropertyRef Name="EmployeeId" />
    </Key>
    <Property Name="EmployeeId" Type="uniqueidentifier" Nullable="false" />
    <Property Name="LastName" Type="nvarchar" Nullable="false" MaxLength="50" />
    <Property Name="FirstName" Type="nvarchar" Nullable="false" />
    <Property Name="Email" Type="nvarchar" Nullable="false" />
  </EntityType>
</Schema>
</syntaxhighlight>
 
== Entity Data Model<!--'Entity Data Model' redirects here--> ==
'''Entity Data Model'''<!--boldface per WP:R#PLA--> ('''EDM''') 给出数据的概念模型(CSDL) ，这所使用的建模技术被称为Entity Data Model, 是''[[ER模型|实体-关系模型]]''的扩展版。<ref name="entitydatamodel">{{cite web | url=http://msdn.microsoft.com/en-us/library/ee382825.aspx | title=Entity Data Model | date=August 2, 2012 | access-date=August 15, 2013 | publisher=MSDN, Microsoft}}</ref>数据模型主要描述了实体和其涉及的关联（Association）。EDM模式用''Schema Definition Language'' (SDL)表述，这事XML的一种应用。此外，从概念模式(CSDL)到存储模式(SSDL)的映射(MSL)也必须用XML表示。<ref name="CsdlMslSsdl" />

Visual Studio提供了''Entity Designer'' 可视化创建EDM和映射规范。该工具输出XML文件(*.edmx)来描述这种模式和映射。Edmx文件包含EF元数据(CSDL/MSL/SSDL内容)。也可手工编辑这3个文件(csdl, msl, ssdl)。

=== Mapping ===
Visual Studio的Entity Data Model Wizard<ref name="EdmWizard"/>在大部分情况下最初产生数据库模式和概念模式的1对1映射。关系模式下，表和主键、外键组成元素。“实体类型”定义了概念模式下的数据。

实体类型是多个类型字段的聚合，每个字段映射到数据库的特定列，可以包含来自多个物理表的信息。实体类型可以彼此有关系，且独立于物理模式内的关系。相关的实体可以通过字段的名字表示这种关系，以代替从数据库的列获取值，通过这种字段可以遍历相关的实体，返回一个实体或实体集合。 

实体类型形成了对象的类，实体是整个类型的实例。实体是应用程序的单个对象，用一个键索引。

ADO.NET Entity Framework使用'''Entity Data Model''' (EDM)表示这种映射。

ADO.NET Entity Framework使用eSQL，SQL的一个派生，来执行查询、集合论操作、修改实体及其关系。<ref>{{Citation | title=ASP.NET 3.5 Black Book | author=Kogent Solutions Inc. | publisher=Dreamtech Press | year=2009 | isbn=978-81-7722-831-1}}</ref>

=== 实体===
实体是“实体类型”的实例，表示单个对象的实例（如“客户”、“订单”）。ADO.NET Entity Framework中的实体属性是完全类型化的，完全兼容于DBMS的类型系统和.NET Framework的Common Type System。属性可以是''SimpleType''或''ComplexType''或多值的。所有''EntityType''属于某个命名空间，并包含一个''EntityKey''属性。

所有实体实例在EntityContainers中。每个项目有一个或多个EntityContainers。

EDM基础类型(简单类型):<ref name="SimpleTypes" /><ref name="ConceptualModelTypes" />
{|class="wikitable"
!EDM 类型
!CLR 类型映射
|-
| {{mono|Edm.Binary}}
| {{mono|Byte[]}}
|-
| {{mono|Edm.Boolean}}
| {{mono|Boolean}}
|-
| {{mono|Edm.Byte}}
| {{mono|Byte}}
|-
| {{mono|Edm.DateTime}}
| {{mono|DateTime}}
|-
| {{mono|Edm.DateTimeOffset}}
| {{mono|DateTimeOffset}}
|-
| {{mono|Edm.Decimal}}
| {{mono|Decimal}}
|-
| {{mono|Edm.Double}}
| {{mono|Double}}
|-
| {{mono|Edm.Guid}}
| {{mono|Guid}}
|-
| {{mono|Edm.Int16}}
| {{mono|Int16}}
|-
| {{mono|Edm.Int32}}
| {{mono|Int32}}
|-
| {{mono|Edm.Int64}}
| {{mono|Int64}}
|-
| {{mono|Edm.SByte}}
| {{mono|SByte}}
|-
| {{mono|Edm.Single}}
| {{mono|Single}}
|-
| {{mono|Edm.String}}
| {{mono|String}}
|-
| {{mono|Edm.Time}}
| {{mono|TimeSpan}}
|}

=== 关系 ===
任何两个实体类型可以是相关的，或者是''Association''关系或者''Containment''关系。用''Relationship Type''来表示。

关系类型用degree (arity)和multiplicity刻画。ADO.NET Entity Framework支持二元双向关系，multiplicity包括一对一、一对多、多对多。实体间的关系是有名的，称为Role。定义了关系的目的。

关系类型可以有''Operation''或''Action''。例如，删除一个实体，其关联的关系可以采取：
* '''Cascade'''：删除关系实例和所有相关联的实体实例。
* '''None'''.
 

=== 模式定义语言 ===
ADO.NET Entity Framework使用基于XML的数据定义语言称为 ''Schema Definition Language'' (SDL)定义EDM Schema。SDL定义了SimpleTypes类似于[[Common_Type_System|CTS]]基础类型，包括''String'', ''Int32'', ''Double'', ''Decimal'', ''Guid'', 和 ''DateTime''等等。枚举类型定义了基础值和其名字的映射，也被认为是简单类型。ComplexTypes为其他类型的聚合。属性的集合定义了实体类型。写为巴恩斯瑙尔范式：
<syntaxhighlight lang="ebnf">
EntityType ::= 
  ENTITYTYPE entityTypeName [BASE entityTypeName]
    [ABSTRACT true|false] KEY propertyName [, propertyName]*
    {(propertyName PropertyType [PropertyFacet]*) +}

PropertyType ::= (
  (PrimitiveType [PrimitiveTypeFacets]*)
    | (complexTypeName)
    | RowType

  PropertyFacet ::= (
    [NULLABLE true | false]
    | [DEFAULT defaultVal] 
    | [MULTIPLICITY [1|*]]
  )

  PropertyTypeFacet ::= 
    MAXLENGTH | PRECISION | SCALE 
    | UNICODE | FIXEDLENGTH | COLLATION
    | DATETIMEKIND | PRESERVESECONDS

  PrimitiveType ::= 
    BINARY | STRING | BOOLEAN
    | SINGLE | DOUBLE | DECIMAL | GUID
    | BYTE | SBYTE | INT16 | INT32 | INT64
    | DATETIME | DATETIMEOFFSET | TIME
)
</syntaxhighlight>

''Facets''用于描述属性的元数据，如是否为可空、缺省值、为单值或多值。 

<syntaxhighlight lang="XML">
<ComplexType Name="Addr">
    <Property Name="Street" Type="String" Nullable="false" />
    <Property Name="City" Type="String" Nullable="false" />
    <Property Name="Country" Type="String" Nullable="false" />
    <Property Name="PostalCode" Type="Int32" />
</ComplexType>
<EntityType Name="Customer">
    <Key>
        <PropertyRef Name="Email" />
    </Key>
    <Property Name="Name" Type="String" />
    <Property Name="Email" Type="String" Nullable="false" />
    <Property Name="Address" Type="Addr" />
</EntityType>
</syntaxhighlight>
关系类型，如客户和订单是1对多关系。
<syntaxhighlight lang="XML">
<Association Name="CustomerAndOrders">
    <End Type="Customer" Multiplicity="1" />
    <End Type="Orders" Multiplicity="*">
        <OnDelete Action="Cascade" />
    </End>
</Association>
</syntaxhighlight>
== 查詢物件 ==

ADO.NET 實體資料模型工具會產生從 ObjectContext (代表概念模型中所定義的實體容器) 衍生而來的類別。 ObjectContext 類別支援針對將實體當成物件傳回之概念模型進行查詢，也支援建立、更新和刪除實體物件。 Entity Framework 支援針對概念模型進行物件查詢。 這些查詢可以使用 Entity SQL 、Language-Integrated Query (LINQ) 和物件查詢產生器方法來撰寫。<ref>{{Cite web |url=http://msdn.microsoft.com/zh-tw/library/bb399760(v=vs.100).aspx |title=處理實體資料 |accessdate=2014-10-12 |archive-date=2014-10-18 |archive-url=https://web.archive.org/web/20141018094019/http://msdn.microsoft.com/zh-tw/library/bb399760(v=vs.100).aspx |dead-url=no }}</ref>

=== Entity SQL ===
Entity Client 是 ADO.NET Entity Framework 中的原生用戶端 (Native Client)。它的物件模型和 ADO.NET 的其他用戶端非常相似，一樣有 Connection, Command, DataReader 等物件，但最大的差異就是，它有自己的 SQL 指令 (Entity SQL)，可以用 SQL 的方式存取 EDM。但没有明确的''joins''。簡單的說，就是把 EDM 當成一個實體資料庫。

查询管线分析Entity SQL查询为一棵命令树， query into a command tree, 分开多个表上的查询，再移交EntityClient provider。EntityClient provider使用''Connection''对象初始化。EntityClient provider再把Entity SQL命令树转化为数据库的本地SQL查询。查询返回Entity SQL ResultSet，但不限于一个表的结果。
<syntaxhighlight lang="csharp">
// Initialize the EntityConnectionStringBuilder.
EntityConnectionStringBuilder entityBuilder = new EntityConnectionStringBuilder();

// Set the provider name.
entityBuilder.Provider = providerName;

// Set the provider-specific connection string.
entityBuilder.ProviderConnectionString = providerString;

// Set the Metadata location.
entityBuilder.Metadata =  @"res://*/AdventureWorksModel.csdl|
                            res://*/AdventureWorksModel.ssdl|
                            res://*/AdventureWorksModel.msl";

Console.WriteLine(entityBuilder.ToString());                                                                                                                     

using (EntityConnection conn = new EntityConnection(entityBuilder.ToString()))
{
    conn.Open();
    Console.WriteLine("Just testing the connection.");
    conn.Close();
}
</syntaxhighlight>
==== Entity SQL经典函数 ====
Entity Framework兼容的data providers都支持的函数，可用于Entity SQL查询。LINQ to Entities的大部门扩展方法都翻译为经典函数。ADO.NET data provider会把经典函数翻译为期望的SQL语句。 

{|class="wikitable"
!类别
!经典函数<ref name="MsdnCanonicalFunctions" />
|-
|width=15%|聚类函数
|{{mono|Avg, BigCount, Count, Max, Min, StDev, StDevP, Sum, Var, VarP}}
|-
|数学函数
|{{mono|Abs, Ceiling, Floor, Power, Round, Truncate}}
|-
|字符串函数
|{{mono|Concat, Contains, EndsWith, IndexOf, Left, Length, LTrim, Replace, Reverse, Right, RTrim, Substring, StartsWith, ToLower, ToUpper, Trim}}
|-
|日期时间函数
|{{mono|AddMicroseconds, AddMilliseconds, AddSeconds, AddMinutes, AddHours, AddNanoseconds, AddDays, AddYears, CreateDateTime, AddMonths, CreateDateTimeOffset, CreateTime, CurrentDateTime, CurrentDateTimeOffset, CurrentUtcDateTime, Day, DayOfYear, DiffNanoseconds, DiffMilliseconds, DiffMicroseconds, DiffSeconds, DiffMinutes, DiffHours, DiffDays, DiffMonths, DiffYears, GetTotalOffsetMinutes, Hour, Millisecond, Minute, Month, Second, TruncateTime, Year}}
|-
|Bitwise 函数
|{{mono|BitWiseAnd, BitWiseNot, BitWiseOr, BitWiseXor}}
|-
|其他函数
|{{mono|NewGuid}}
|}
 
=== LINQ to Entities ===

實作 IEnumerable<T> 泛型介面或 IQueryable<T> 泛型介面的資料來源可以透過 LINQ 進行查詢。 實作泛型 IQueryable<T> 介面之泛型 ObjectQuery<T> 類別的執行個體會當做 LINQ to Entities 查詢的資料來源。 ObjectQuery<T> 泛型類別表示傳回零個或多個具型別物件之集合的查詢。 使用 C# 的 var 關鍵字 (在 Visual Basic 中為 Dim)，您也可以讓編譯器推斷實體類型。<ref>{{Cite web |url=http://msdn.microsoft.com/zh-tw/library/bb399367(v=vs.110).aspx |title=LINQ to Entities 中的查詢 |accessdate=2014-12-12 |archive-date=2014-10-22 |archive-url=https://web.archive.org/web/20141022060700/http://msdn.microsoft.com/zh-tw/library/bb399367(v=vs.110).aspx |dead-url=no }}</ref>

<syntaxhighlight lang="csharp">
using (AdventureWorksEntities AWEntities = new AdventureWorksEntities())
{
    ObjectQuery<Product> products = AWEntities.Products;

    // LINQ Query syntax:
    IOrderedQueryable<Product> query =
        from product in products
        orderby product.Name, product.ListPrice descending
        select product;

    // LINQ Method syntax:
    IOrderedQueryable<Product> query = products
        .OrderBy(product => product.Name)
        .ThenByDescending(product => product.ListPrice);
}
</syntaxhighlight>

=== 查詢產生器方法 ===

ObjectQuery 類別支援對概念模型進行 LINQ to Entities 和 Entity SQL 查詢。 ObjectQuery 也會實作一組查詢產生器方法，這些方法可用來循序建構與 Entity SQL 相等的查詢命令。由於 ObjectQuery 會實作 IQueryable 和 IEnumerable，所以將 ObjectQuery 所實作的查詢產生器方法結合 LINQ 特定的標準查詢運算子方法 (如 First 或 Count) 是可行的。 LINQ 運算子並不會傳回 ObjectQuery，與查詢產生器方法不同。<ref>{{Cite web |url=http://msdn.microsoft.com/zh-tw/library/bb896238(v=vs.100).aspx |title=查詢產生器方法 (Entity Framework) |accessdate=2014-10-12 |archive-date=2014-10-18 |archive-url=https://web.archive.org/web/20141018094023/http://msdn.microsoft.com/zh-tw/library/bb896238(v=vs.100).aspx |dead-url=no }}</ref>

<syntaxhighlight lang="csharp">
// Get the contacts with the specified name.
ObjectQuery<Contact> contactQuery = context.Contact
    .Where("it.LastName = @ln AND it.FirstName = @fn",
    new ObjectParameter("ln", lastName), 
    new ObjectParameter("fn", firstName));
</syntaxhighlight>

== 開發工具 ==

目前 ADO.NET Entity Framework 的開發，在 [[Visual_Studio|Visual Studio]] 2008 中有充分的支援，在安裝 Visual Studio 2008 Service Pack 1 後，檔案範本中即會出現 ADO.NET 實體資料模型 (ADO.NET Entity Data Model) 可讓開發人員利用 Entity Model Designer 來設計 EDM，EDM 亦可由Windows記事本等文字編輯器所編輯。

== 衍生服務 ==

{{main|ADO.NET Data Services}}

微軟特別針對了網路上各種不同的應用程式（例如 [[AJAX|AJAX]]，[[Silverlight|Silverlight]]，[[Mashup|Mashup]] 應用程式）開發了一個基於 ADO.NET Entity Framework 之上的服務，稱為 [[ADO.NET_Data_Services|ADO.NET Data Services]]（專案代號為 '''Astoria'''），並與 ADO.NET Entity Framework 一起包裝在 .NET Framework 3.5 Service Pack 1 中發表。

== 支援廠商 ==

目前已有數個資料庫廠商或元件開發商宣布要支援 ADO.NET Entity Framework<ref>{{Cite web |url=http://www.microsoft.com/presspass/press/2007/dec07/12-06EntityBeta3PR.mspx |title=Microsoft Simplifies Data-Centric Development in Heterogeneous IT Environments |accessdate=2008-10-01 |archive-date=2008-12-10 |archive-url=https://web.archive.org/web/20081210170521/http://www.microsoft.com/presspass/press/2007/dec07/12-06EntityBeta3PR.mspx |dead-url=no }}</ref>:
* Mircosoft,支持MsSQL.
* Core Lab，支援Oracle、MySQL、PostgreSQL 與 SQLite 資料庫。
* IBM，實作 [[IBM_DB2|DB2]] 使用的 LINQ Provider。
* MySQL，發展 MySQL Server 所用的 Provider。
* Npqsql，發展 PostgreSQL 所用的 Provider。
* OpenLink Software，發展支援多種資料庫所用的 Provider。
* Phoenix Software International，發展支援 SQLite 資料庫的 Provider。
* Sybase，將支援 Anywhere 資料庫。
* VistaDB Software，將支援 VistaDB 資料庫。
* DataDirect Technologies，發展支援多種資料庫所用的 Provider。
* Firebird，支援 Firebird 資料庫。

== 參考資料 ==
<div class="references-small">
<references />
</div>

== 外部連結 ==
* {{en}} [http://msdn.microsoft.com/en-us/library/bb399572.aspx MSDN Library : ADO.NET Entity Framework]{{Wayback|url=http://msdn.microsoft.com/en-us/library/bb399572.aspx |date=20080828050120 }}
* {{zh-tw}} [http://www.microsoft.com/taiwan/msdn/columns/jhu_ming_jhong/ADO.NET_Entity_Framework_Entity_Operation.htm 讀寫 ADO.NET Entity Framework]{{Wayback|url=http://www.microsoft.com/taiwan/msdn/columns/jhu_ming_jhong/ADO.NET_Entity_Framework_Entity_Operation.htm |date=20080908071404 }}
* {{zh-tw}} [http://www.microsoft.com/taiwan/msdn/columns/jhu_ming_jhong/ADO.NET_Entity_Framework_Integration_with_exist_applications.htm 整合 ADO.NET Entity Framework 到應用程式中]{{Wayback|url=http://www.microsoft.com/taiwan/msdn/columns/jhu_ming_jhong/ADO.NET_Entity_Framework_Integration_with_exist_applications.htm |date=20090120073403 }}
* {{zh-tw}} [http://www.microsoft.com/taiwan/msdn/columns/jhu_ming_jhong/ADO.NET_Entity_Framework_A_First_look.htm 首次接觸 ADO.NET Entity Framework]{{Wayback|url=http://www.microsoft.com/taiwan/msdn/columns/jhu_ming_jhong/ADO.NET_Entity_Framework_A_First_look.htm |date=20081213005900 }}
* {{zh-tw}} [http://www.microsoft.com/taiwan/msdn/columns/jhu_ming_jhong/ADO.NET_Entity_Framework_Overview.htm ADO.NET Entity Framework 概觀]{{Wayback|url=http://www.microsoft.com/taiwan/msdn/columns/jhu_ming_jhong/ADO.NET_Entity_Framework_Overview.htm |date=20081226101325 }}
* {{en}} [https://web.archive.org/web/20081224110354/http://blogs.msdn.com/adonet/archive/2008/05/06/recent-ado-net-entity-framework-provider-news-demos-and-downloads.aspx Recent ADO.NET Entity Framework provider news - Demos and downloads] 

{{Microsoft Cloud Computing Platform}}
{{Microsoft APIs}}
{{DotNET}}

[[Category:.NET|Category:.NET]]