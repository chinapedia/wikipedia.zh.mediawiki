{{NoteTA
|G1 = IT
|1 = zh-cn:宏; zh-tw:巨集;
}}
{{Infobox programming language
| logo                   = 
| caption                = Elixir
| name                   = Elixir
| paradigm = [[多范式|多范式]]：[[函数式编程|函数式]]、[[并发计算|并行式]]、[[面向进程编程|面向进程]]、[[同像性|同像性]]
| year                   = {{start date and age|2012}}
| typing = [[动态类型|动态类型]]、[[强类型|强类型]]
| influenced_by          = [[Clojure|Clojure]]、[[Erlang|Erlang]]、[[Ruby|Ruby]] 
| creator               = [[José_Valim|José Valim]]
| latest release version = {{wikidata|property|edit|reference|P348}}
| latest release date = {{wikidata|qualifier|single|P348|P577}}，{{time ago|{{wikidata|qualifier|single|raw|P348|P577}}}}
| license                = [[Apache_License|Apache License]]
| website                = {{URL|https://elixir-lang.org/}}
| file_ext               = .ex、.exs
}}
'''Elixir'''是一个基于[[Erlang|Erlang]][[虚拟机|虚拟机]]的[[函数式编程|函数式]]、面向[[并发计算|并行]]的通用[[编程语言|编程语言]]。Elixir以Erlang为基础，支持分布式、高容错、实时应用程序的开发，亦可通过[[宏|宏]]实现[[元编程|元编程]]对其进行扩展，并通过[[协议_(面向对象编程)|协议]]支持[[多态_(面向对象程序设计)|多态]]。<ref>{{cite web|url=https://elixir-lang.org|title=Elixir|work=José Valim|accessdate=2013-02-17|archive-date=2017-09-30|archive-url=https://web.archive.org/web/20170930173701/https://elixir-lang.org/|dead-url=no}}</ref>

== 历史 ==

José Valim是Elixir语言的设计者。他创造该语言的目标是在维持与现有Erlang工具链及生态环境兼容性的同时，让人们可以在Erlang虚拟机上进行扩展性更好的、高生产率的开发。<ref>{{cite web|url=http://vimeo.com/53221562|title=Elixir - A modern approach to programming for the Erlang VM|accessdate=2013-02-17|archive-date=2012-11-29|archive-url=https://web.archive.org/web/20121129055534/http://vimeo.com/53221562|dead-url=no}}</ref>

== 特性 ==

* 基于[[Erlang|Erlang]]虚拟机（BEAM）。
* 与Erlang语言的无缝衔接；与Erlang的互调几乎无任何额外开销。
* 基于[[宏|宏]]的[[元编程|元编程]]能力，语言的[[抽象语法树|抽象语法树]]作为头等公民。
* 基于[[协议_(面向对象编程)|协议]]的[[多态_(面向对象程序设计)|多态]]实现。受到[[Clojure|Clojure]]启发，协议提供了[[动态分派|动态分派]]机制。但是不可混淆于[[多分派|多分派]]，因为Elixir协议在一个单一类型上进行分派。
* 完善的文档支持。
* 通过[[消息传递|消息传递]]（[[演员模型|演员模型]]）支持 Shared-nothing 并行事务。
* 强调利用[[递归|递归]]和[[高阶函数|高阶函数]]的函数式编程胜过基于[[副作用|副作用]]和[[迴圈|迴圈]]的命令式编程。
* 一切均为[[表达式|表达式]]。
* [[惰性求值|惰性求值]]，拥有诸如futures和promises一类的[[异步|异步]]流数据类型。
* [[模式匹配|模式匹配]]。
* [[Unicode|Unicode]]支持，[[UTF-8|UTF-8]]字符串。

==示例==
以下示例可以在iex shell中运行或保存在文件中，并通过命令行键入命令运行 <code>elixir ''<filename>''</code>.

经典的 [[Hello_world|Hello world]] 例子:

<syntaxhighlight lang="iex">
iex> IO.puts("Hello World!")
Hello World!
</syntaxhighlight>

Enumerable 推导
<syntaxhighlight lang="iex">
iex> for n <- [1,2,3,4,5], rem(n, 2) == 1, do: n*n
[1, 9, 25]
</syntaxhighlight>

模式匹配（解构）
<syntaxhighlight lang="iex">
iex> [1, a] = [1, 2]
iex> a
2

iex> {:ok, [hello: a]} = {:ok, [hello: "world"]}
iex> a
"world"
</syntaxhighlight>

模式匹配（多子句）
<syntaxhighlight lang="iex">
iex> case File.read("path/to/file") do
iex>   {:ok, contents} -> IO.puts("found file: #{contents}")
iex>   {:error, reason} -> IO.puts("missing file: #{reason}")
iex> end
</syntaxhighlight>

管道操作符
<syntaxhighlight lang="iex">
iex> "1" |> String.to_integer() |> Kernel.*(2)
2
</syntaxhighlight>

模块
<syntaxhighlight lang="elixir">
defmodule Fun do
  def fib(0), do: 0
  def fib(1), do: 1
  def fib(n), do: fib(n-2) + fib(n-1)  
end
</syntaxhighlight>

顺序产生1000个进程
<syntaxhighlight lang=elixir>
for num <- 1..1000, do: spawn fn -> IO.puts("#{num * 2}") end
</syntaxhighlight>

执行异步任务
<syntaxhighlight lang=elixir>
task = Task.async fn -> perform_complex_action() end
other_time_consuming_action()
Task.await task
</syntaxhighlight>

== 参考资料 ==
{{reflist|1}}

== 外部链接 ==
{{Portal|Free software}}
* [https://elixir-lang.org/ Elixir language website]{{Wayback|url=https://elixir-lang.org/ |date=20170930173701 }}
* [https://github.com/elixir-lang/elixir/ Code on GitHub]{{Wayback|url=https://github.com/elixir-lang/elixir/ |date=20150203014708 }}
* [http://elixirschool.com/cn/ Elixir School]{{Wayback|url=http://elixirschool.com/cn/ |date=20170425204901 }}
* [http://vimeo.com/53221562 Elixir - A modern approach to programming for the Erlang VM video presentation]{{Wayback|url=http://vimeo.com/53221562 |date=20140307123804 }}
* [https://web.archive.org/web/20150610090110/https://pragprog.com/book/elixir/programming-elixir Dave Thomas: "Programming Elixir: Functional |> Concurrent |> Pragmatic |> Fun" (book)]
* [http://shop.oreilly.com/product/0636920030584.do Simon St. Laurent, J. David Eisenberg: "Introducing Elixir" (book)]{{Wayback|url=http://shop.oreilly.com/product/0636920030584.do |date=20140704071600 }}
* [https://web.archive.org/web/20130819053404/http://joearms.github.io/2013/05/31/a-week-with-elixir.html Joe Armstrong: "A Week with Elixir" (blog entry)]
* [https://github.com/oldratlee/translations/blob/master/a-week-with-elixir/README.md Erlang之父学习Elixir语言的一周]{{Wayback|url=https://github.com/oldratlee/translations/blob/master/a-week-with-elixir/README.md |date=20190216004351 }}

{{程序设计语言}}

[[Category:程序设计语言|Category:程序设计语言]]
[[Category:函数式编程语言|Category:函数式编程语言]]
[[Category:模式匹配编程语言|Category:模式匹配编程语言]]
[[Category:2012年建立的程式語言|Category:2012年建立的程式語言]]