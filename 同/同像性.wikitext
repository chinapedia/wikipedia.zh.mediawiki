{{编程范式}}
在计算机编程中，同像性（homoiconicity來自希臘語單詞，homo-意為相同，icon含義表像），是某些编程语言的特殊屬性，它意味着一个程序的结构与其[[句法|句法]]是相似的，因此易于通过阅读程序来推测程序的内在涵义。如果一门编程语言具备了同像性，说明该语言的文本表示（通常指源代码），與其[[抽象語法樹|抽象語法樹]]（AST）具有相同的結構（即AST和語法是同形的）。该特性允許使用相同的表示語法，將語言中的所有代碼當成-{zh-hans:数据;zh-hant:資料}-，來存取以及轉換，提供了“代码即数据”的理论前提。

==簡介==
同像性編程語言中，程序的主要呈現方式，也是語言本身原始類型中的資料結構。這使得[[元編程|元編程]]更加容易，因為程序代碼可以被視為資料：語言中的[[反射式编程|反射]]（運行時檢查程序的實體）取決於單一的、性質相同的結構，而且它不必去處理，其它一些不同結構所導致的複雜語法。換句話說，同像性是程序的源代碼即是基本的資料結構，而這個語言本身知道如何存取源碼的文本。

[[Lisp|Lisp]]編程语言，是具有同像性質的典型範例，它的設計很容易進行對列表的操作，而且其語法結構，即採用嵌套列表形式的[[S-表达式|S-表达式]]<ref>{{cite web |title=Readable Lisp S-expressions |first=David A. |last=Wheeler |url=http://sourceforge.net/p/readable/wiki/Rationale/ |access-date=2022-01-29 |archive-date=2022-01-29 |archive-url=https://web.archive.org/web/20220129144702/https://sourceforge.net/p/readable/wiki/Rationale/ }}</ref>。LISP程式以列表的形式來編寫，所以可在運行時存取本身擁有的函數和程序，並以編程的方式重新設計自己。具有同像屬性的語言，通常有對句法巨集的全面支持，允許程序員以簡明的方式來表達程序的變換。這類語言有[[Clojure|Clojure]]（現代流行的LISP方言），[[Rebol|Rebol]]和{{en-link|Refal|}}，以及最近的[[Julia_(编程语言)|Julia]]等等編程語言。

== 歷史 ==
同像性一詞的原始來源，是論文《編譯器語言的巨集指令擴展》<ref name="macro_instruction">{{cite journal |author-link=Douglas McIlroy |first=Douglas |last=McIlroy |title=Macro Instruction Extensions of Compiler Languages |journal=Comm. ACM |volume=3 |issue=4 |pages=214–220 |year=1960 |doi=10.1145/367177.367223 }}</ref>。根據早期具影響力的論文《{{en-link|TRAC (编程语言)|TRAC (programming language)|TRAC}}文本處理語言》中提到<ref name="trac_paper">{{cite book |first=C.N. |last=Mooers |author-link=Calvin Mooers |first2=L.P. |last2=Deutsch |author-link2=L. Peter Deutsch |chapter=TRAC, A Text-Handling Language |title=Proceeding ACM '65 Proceedings of the 1965 20th national conference  |pages=229–246 |year=1965 |doi=10.1145/800197.806048 }}</ref>：{{quote|主要設計目標之一，是TRAC的輸入腳本（用戶所輸入的），應該相同一致於指示TRAC處理器內部動作的文本。換句話說，TRAC程序應該是以字串被儲存於記憶體中，正如同用戶在鍵盤上鍵入它們一樣。如果TRAC程序本身發展成為新的程序，同一個腳本中也應該陳述列出這些新程序。TRAC處理器在其操作中，將此腳本直譯為其程序。換句話說，TRAC解析器（處理器），將計算機有成效地轉換為，具有新程序語言（TRAC語言）的新計算機。程序或過程資訊，在任何時候的呈現，都應該相同於TRAC處理器執行期間，對其作用的形式。我們期望內部代碼的字符表示，和外部代碼表示，相同一致或非常相似。在本TRAC實作中，內部字符基於[[ASCII|ASCII]]，因為TRAC程序和文本，在處理器內部和外部，都具有相同的表示，所以術語同像性（homoiconic）一詞是適用的，homo涵義相同，icon義為呈現。

[...]

跟从[[沃伦·麦卡洛克|沃伦·麦卡洛克]]的提議，依據[[查尔斯·桑德斯·皮尔士|查尔斯·桑德斯·皮尔士]]的術語，參見[[道格拉斯·麥克羅伊|道格拉斯·麥克羅伊]]的“編譯器語言的巨集指令擴展”，ACM通訊，頁214-220; 1960年4月。}}

[[艾倫·凱|艾倫·凱]]在他1969年的博士論文中，使用並可能推廣了同像性這個術語<ref name="kay_thesis">{{cite thesis |author-link=Alan Kay |first=Alan |last=Kay |url=http://www.mprove.de/diplom/gui/kay69.html |title=The Reactive Engine |type=PhD |year=1969 |publisher=University of Utah |access-date=2014-03-28 |archive-date=2018-09-15 |archive-url=https://web.archive.org/web/20180915153142/https://www.mprove.de/diplom/gui/kay69.html }}</ref>：{{quote|所有先前的系統中，顯著的一組例外是Interactive LISP[...]和TRAC。兩者都是函數導向的（一為列表，另一為字符串），都用一種語言與用戶交談，並且都具有 “同像性的”，因為它們內部和外部表示本質上相同。它們都具有動態創建新函數的能力，然後可隨著用戶的興趣進階發展。他們唯一最大的缺點是，以它們寫出的程序看起來就像，蘇美爾人把[[布尔那布里亚什二世|布尔那·布里亚什]]國王的信寫成巴比倫楔形文！[...]}}

== 用途及優缺點 ==
同像性的一個優點是，以新概念擴展語言通常變得更簡單，因為表示代碼的資料，可在程序的元和基本層之間傳遞。函數的抽象語法樹，可以作為元層中的資料結構來組成和操作，然後被評估。它可以更容易理解如何操作代碼，因為它可以被理解為簡單的資料（語言本身的格式亦同為資料格式）。

允許這樣做的簡單性也帶來了一個缺點：有人認為至少在類似LISP的列表導向的語言的情況下，它會消除許多能幫助人們分析語言結構的視覺線索，而可能導致陡峭的[[學習曲線|學習曲線]]<ref>{{cite web|url=http://www.winestockwebdesign.com/Essays/Lisp_Curse.html|title=The Lisp Curse|access-date=2022-01-29|archive-date=2022-05-16|archive-url=https://web.archive.org/web/20220516133531/http://www.winestockwebdesign.com/Essays/Lisp_Curse.html}}</ref>。

同像性的典型演示是[[自循環直譯器|元循環求值]]（meta-circular evaluator，同於[[讀取﹣求值﹣輸出循環|REPL]]）。

== 實作方法 ==
所有[[范紐曼型架構|范紐曼型架構]]的系統，其中包括絕大多數當今的通用計算機，由於原始機器代碼在記憶體中執行的資料類型是[[位元組|位元組]]，可以隱含地描述為具有同像性。但是這個功能也可以在編程語言層別就抽取出來。

[[Lisp|Lisp]]及其方言例如[[Scheme|Scheme]]，[[Clojure|Clojure]]，[[Racket|Racket]]等，使用[[S-表達式|S-表達式]]來實現同像性。

其他被认为具有同像性的语言包括：
{{div col|colwidth=10em}}
* [[Curl_(编程语言)|Curl]]<ref name="c2">{{Cite web |url=http://c2.com/cgi/wiki?HomoiconicLanguages |title=Homoiconic Languages |accessdate=2020-04-23 |archive-date=2013-04-23 |archive-url=https://web.archive.org/web/20130423102240/http://c2.com/cgi/wiki?HomoiconicLanguages |dead-url=no }}</ref>
* [[Elixir|Elixir]]<ref>{{cite web|website=8thlight.com|title=Lispy Elixir|quote=Elixir, on the surface, is not homoiconic. However, the syntax on the surface is just a facade for the homoiconic structure underneath.|url=https://8thlight.com/blog/patrick-gombert/2013/11/26/lispy-elixir.html|access-date=2022-01-29|archive-date=2022-03-05|archive-url=https://web.archive.org/web/20220305131041/https://8thlight.com/blog/patrick-gombert/2013/11/26/lispy-elixir.html}}</ref>
* [[Io_(编程语言)|Io]]<ref name="c2"/>
* [[Julia_(编程语言)|Julia]]<ref>{{cite web|url=http://julialang.org/blog/2012/02/why-we-created-julia|title=Why we created Julia|website=julialang.org|quote=We want a language that’s homoiconic, with true macros like Lisp, but with obvious, familiar mathematical notation like Matlab.|accessdate=2020-04-23|archive-date=2019-02-19|archive-url=https://web.archive.org/web/20190219031333/https://julialang.org/blog/2012/02/why-we-created-julia|dead-url=no}}</ref><ref>{{cite web|url=http://docs.julialang.org/en/latest/manual/metaprogramming/|website=docs.julialang.org|title=metaprogramming|quote=Like Lisp, Julia represents its own code as a data structure of the language itself.|accessdate=2020-04-23|archive-date=2013-05-04|archive-url=https://web.archive.org/web/20130504074021/http://docs.julialang.org/en/latest/manual/metaprogramming/|dead-url=no}}</ref><ref name="c2"/>
* [[Prolog|Prolog]]<ref name="c2"/><ref name=AOP94>{{cite book |author1=Shapiro, Ehud Y. |author2=Sterling, Leon |title=The art of Prolog: advanced programming techniques |publisher=MIT Press |year=1994 |pages= |isbn=0-262-19338-8 |oclc= |doi= |accessdate=}}</ref>
* [[R语言|R]]语言<ref>{{Citation|title=R Language Definition|url=https://cran.r-project.org/doc/manuals/r-release/R-lang.pdf|publication-date=2021-05-18|page=6|quote=... the semantics are of the FPL (functional programming language) variety with stronger affinities with Lisp and APL. In particular, it allows “computing on the language”, which in turn makes it possible to write functions that take expressions as input, something that is often useful for statistical modeling and graphics.|accessdate=2022-01-29|archive-date=2022-04-22|archive-url=https://web.archive.org/web/20220422075028/https://cran.r-project.org/doc/manuals/r-release/R-lang.pdf}}</ref><ref>{{citation |title="expression: Unevaluated Expressions" |url=https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/expression |accessdate=2022-01-29 |archive-date=2022-01-29 |archive-url=https://web.archive.org/web/20220129135734/https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/expression }}</ref>
* [[Rebol|Rebol]]<ref name="c2"/>
* {{en-link|Red (编程语言)|Red (programming language)|Red}}
* [[SNOBOL|SNOBOL]]<ref name="c2"/>
* [[Tcl|Tcl]]<ref name=blueblog>[https://web.archive.org/web/20130202074222/https://blogs.oracle.com/blue/entry/homoiconic_languages Homoiconic languages (archived)], in ''true Blue'' blog at Oracle</ref><ref name="c2"/>
* [[XSLT|XSLT]]<ref>{{cite book |first=S. |last=Ramsay |first2=B. |last2=Pytlik-Zillig |chapter=Code-Generation Techniques for XML Collections Interoperability |chapterurl=http://www.dh2012.uni-hamburg.de/conference/programme/abstracts/code-generation-techniques-for-xml-collections-interoperability/ |title=dh2012 Digital Humanities Conference Proceedings |publisher= |location= |year=2012 |access-date=2020-04-23 |archive-date=2016-03-03 |archive-url=https://web.archive.org/web/20160303220627/http://www.dh2012.uni-hamburg.de/conference/programme/abstracts/code-generation-techniques-for-xml-collections-interoperability/ |dead-url=no }}</ref>
* {{en-link|Refal|}}<ref name="c2"/>
* [[REXX|Rexx]]
* [[Wolfram语言|Wolfram语言]]<ref>{{cite web|website=[[Stack_Exchange|Stack Exchange]]|url=http://mathematica.stackexchange.com/questions/2335/metaprogramming-in-mathematica|title=Metaprogramming in mathematica|quote=Mathematica is [...] Homoiconic language (programs written in own data structures - Mathematica expressions. This is code-as-data paradigm, like Lisp which uses lists for this)|access-date=2020-04-23|archive-date=2018-08-20|archive-url=https://web.archive.org/web/20180820074610/https://mathematica.stackexchange.com/questions/2335/metaprogramming-in-mathematica|dead-url=no}}</ref><ref>{{cite web |title=Notes for Programming Language Experts |date=2017 |work=Wolfram Language |publisher=Wolfram |url=http://www.wolfram.com/language/for-experts/ |access-date=2020-04-23 |archive-date=2022-01-04 |archive-url=https://web.archive.org/web/20220104003437/https://www.wolfram.com/language/for-experts/ }}</ref>
{{div col end}}

== 同像性語言的編程範例 ==
=== Lisp ===
Lisp使用[[S-表達式|S-表達式]]作為資料和源碼的外部表示。可以用基本函數<code>READ</code>讀取S-表達式。<code>READ</code>回傳Lisp資料：列表、符號、數字和字串。基本函數<code>EVAL</code>使用以資料形式呈現的Lisp源碼，計算副作用並得出返回結果。結果由基本函數<code>PRINT</code>打印出來，從Lisp資料產生一個外部的S-表達式。

Lisp資料是含有不同類型的列表：（子）列表，符號，字串和整數。
<syntaxhighlight lang=lisp>
((:name "john" :age 20) (:name "mary" :age 18) (:name "alice" :age 22))
</syntaxhighlight>

以下[[Common_Lisp|Common Lisp]]源碼範例使用列表，符號和數字。
<syntaxhighlight lang=lisp>
(* (sin 1.1) (cos 2.03))      ; 中綴表示法為 sin(1.1)*cos(2.03)
</syntaxhighlight>

使用基本函數<code>LIST</code>產生上面的表達式，並將變量EXPRESSION設置為結果：
<syntaxhighlight lang=lisp>
(defvar expression)
-> EXPRESSION

(setf expression  (list '* (list 'sin 1.1) (list 'cos 2.03)) )  
-> (* (SIN 1.1) (COS 2.03))    ; Lisp傳回並打印結果

(third expression)    ; 表達式中的第三項
-> (COS 2.03)
</syntaxhighlight>

將<code>COS</code>這項變更為<code>SIN</code>：
<syntaxhighlight lang=lisp>
(setf (first (third expression)) 'SIN)
; 變更之後的表達式為 (* (SIN 1.1) (SIN 2.03)).
</syntaxhighlight>

評估表達式：
<syntaxhighlight lang=lisp>
(eval expression)
-> 0.7988834
</syntaxhighlight>

將表達式打印到字串：
<syntaxhighlight lang=lisp>
(princ-to-string expression)
->  "(* (SIN 1.1) (SIN 2.03))"
</syntaxhighlight>

從字串中讀取表達式：
<syntaxhighlight lang=lisp>
(read-from-string "(* (SIN 1.1) (SIN 2.03))")
->  (* (SIN 1.1) (SIN 2.03))     ; 傳回一個其中有列表，數字和符號的列表
</syntaxhighlight>

=== Prolog ===
[[Prolog|Prolog]]是同像性语言并且提供了很多[[反射式编程|反射]]设施。
<syntaxhighlight lang=lisp>
1 ?- X is 2*5.
X = 10.

2 ?- L = (X is 2*5), write_canonical(L).
is(_, *(2, 5))
L = (X is 2*5).

3 ?- L = (ten(X):-(X is 2*5)), write_canonical(L).
:-(ten(A), is(A, *(2, 5)))
L = (ten(X):-X is 2*5).

4 ?- L = (ten(X):-(X is 2*5)), assert(L).
L = (ten(X):-X is 2*5).

5 ?- ten(X).
X = 10.

6 ?-
</syntaxhighlight>

在第4行建立一个新子句。算符<code>:-</code>分隔一个子句的头部和主体。通过<code>assert/1</code>将它增加到现存的子句中，即增加它到“数据库”，这样我们可以以后调用它。在其他语言中可以称为“在运行时间建立一个函数”。还可以使用<code>abolish/1</code>或<code>retract/1</code>从数据库中移除子句。注意在子句名字后的数，是它可以接受的实际参数的数目，它也叫做[[元数|元数]]。

我们可以查询数据库来得到一个子句的主体：

<syntaxhighlight lang=lisp>
7 ?- clause(ten(X),Y).
Y = (X is 2*5).

8 ?- clause(ten(X),Y), Y = (X is Z).
Y = (X is 2*5),
Z = 2*5.

9 ?- clause(ten(X),Y), call(Y).
X = 10,
Y = (10 is 2*5).

</syntaxhighlight>

<code>call</code>类似于Lisp的<code>eval</code>函数。

=== Rebol ===
[[Rebol|Rebol]]可巧妙的演示将代码当作数据来操纵和求值的概念。Rebol不像Lisp，不要求用原括号来分隔表达式。下面是Rebol代码的例子，注意<code>>></code>表示解释器提示符，出于可读性而在某些元素之间增加了空格：
 >> <syntaxhighlight lang="smalltalk" inline>repeat i 3 [ print [ i "hello" ] ]</syntaxhighlight>
 1 hello
 2 hello
 3 hello

在Rebol中<code>repeat</code>事实上是内建函数而非语言构造或关键字。通过将代码包围在方括号中，解释器不求值它，而是将它当作包含字的块：
<syntaxhighlight lang="smalltalk">
[ repeat i 3 [ print [ i "hello" ] ] ]
</syntaxhighlight>

这个块有类型<code>block!</code>，并且使用近乎赋值的语法，可以进一步的将它指定为一个字的值，这种语法实际上可以被解释器理解为特殊类型<code>set-word!</code>，并采用一个字跟随一个冒号的形式：
 >> <syntaxhighlight lang="smalltalk" inline>block1: [ repeat i 3 [ print [ i "hello" ] ] ]</syntaxhighlight> ;; 将这个块的值赋值给字`block1`
 == [repeat i 3 [print [i "hello"]]]
 >> <syntaxhighlight lang="smalltalk" inline>type? block1</syntaxhighlight> ;; 求值字`block1`的类型
 == block!

这个块仍可以使用Rebol中提供的<code>do</code>函数来解释，它类似于Lisp中的[[Eval#Lisp|<code>eval</code>]]。有可能审查块的元素并变更它们的值，从而改变要求值代码的行为：
 >> <syntaxhighlight lang="smalltalk" inline>block1/3</syntaxhighlight> ;; 这个块的第三个元素
 == 3
 >> <syntaxhighlight lang="smalltalk" inline>block1/3: 5</syntaxhighlight> ;; 设置第三个元素的值为5
 == 5
 >> <syntaxhighlight lang="smalltalk" inline>probe block1</syntaxhighlight> ;; 展示变更了的块
 == [repeat i 5 [print [i "hello"]]]
 >> <syntaxhighlight lang="smalltalk" inline>do block1</syntaxhighlight> ;; 求值这个块
 1 hello
 2 hello
 3 hello
 4 hello
 5 hello

== 另見 ==
* {{en-link|标记法的认知维度|Cognitive dimensions of notations}}，编程语言语法的设计原理。
* [[串接编程语言|串接编程语言]]。
* [[面向语言编程|面向语言编程]]。
* [[符号式编程|符号式编程]]。
* [[自修改代码|自修改代码]]。
* [[LISP|LISP]]，同像性语言的可能最周知的例子。
* [[元编程|元编程]]，对同像性非常有用的编程技术。
* [[实化|实化]]。

== 参考文献 ==
; 引用
{{Reflist|2}}

== 外部連結 ==
* [http://c2.com/cgi/wiki?DefinitionOfHomoiconic Definition of Homoiconic at the C2 Wiki] {{Wayback|url=http://c2.com/cgi/wiki?DefinitionOfHomoiconic |date=20110515022228 }}

[[Category:編程典範|Category:編程典範]]
[[Category:編程語言語義|Category:編程語言語義]]