{{otheruses}}
{{noteTA
|G1=IT
|G2=FL
|1=zh-hans:软件; zh-hant:軟體;
|2=zh-hans:程序; zh-hant:程式;
|3=zh-hans:缩进; zh-hant:縮排;
|4=zh-hans:操作系统; zh-hant:作業系統;
|5=zh-hans:调试; zh-hant:偵錯;
|6=zh-cn:解释器;zh-tw:直譯器;
|7=zh-cn:解释型;zh-tw:直譯式;
|8=zh-cn:解释;zh-tw:直譯;
|9=zh-cn:编程; zh-tw:程式;
|10=zh-cn:代码; zh-tw:程式碼;
}}
{{Infobox programming language
| name                   = Python
| logo                   = Python-logo-notext.svg
| logo size = 160px
| paradigm               = [[编程范型|多范型]]：[[函数式编程|函数式]]、[[指令式编程|指令式]]、[[反射式编程|反射式]]、[[结构化编程|结构化]]、[[面向对象的程序设计|面向对象]]
| year                   = {{start date and age|1991}}<ref name=guttag>{{Cite book| publisher = MIT Press| isbn = 978-0-262-52962-4| last = Guttag| first = John V.| title = Introduction to Computation and Programming Using Python: With Application to Understanding Data| date = 12 August 2016}}</ref>
| designer               = [[吉多·范罗苏姆|吉多·范罗苏姆]]
| developer              = [[Python软件基金会|Python软件基金会]]
| latest release version = {{wikidata|property|reference|edit|P548=Q2804309|P348}}
| latest release date    = {{wikidata|qualifier|P548=Q2804309|single|P348|P577}}，{{Time ago|{{wikidata|qualifier|single|raw|P548=Q2804309|P348|P577}}}}
| latest preview version = {{wikidata|property|edit|reference|P548=Q51930650|P348}}
| latest preview date    = {{wikidata|qualifier|single|P548=Q51930650|P348|P577}}，{{Time ago|{{wikidata|qualifier|single|raw|P548=Q51930650|P348|P577}}}}
| typing = [[鸭子类型|鸭子类型]]、[[类型系统|动态]]、[[强类型|强类型]]<ref>{{Cite web|title=Why is Python a dynamic language and also a strongly typed language - Python Wiki|url=https://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language|access-date=2021-01-27|website=wiki.python.org|archive-date=2021-03-14|archive-url=https://web.archive.org/web/20210314173706/https://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language}}</ref>、{{en-link|渐进类型|gradual typing|渐进}}（自从3.5）<ref>{{cite web|url=https://www.python.org/dev/peps/pep-0483/|title=PEP 483 -- The Theory of Type Hints|website=Python.org|accessdate=2020-04-22|archive-date=2020-06-14|archive-url=https://web.archive.org/web/20200614153558/https://www.python.org/dev/peps/pep-0483/|dead-url=no}}</ref>
| implementations        = [[CPython|CPython]]、[[PyPy|PyPy]]、[[IronPython|IronPython]]、[[Jython|Jython]]、[[Stackless_Python|Stackless Python]]、[[MicroPython|MicroPython]]、{{tsl|en|CircuitPython|CircuitPython}}、RustPython<ref>{{cite web|url=https://rustpython.github.io/|title=RustPython|access-date=2022-03-04|archive-date=2022-04-24|archive-url=https://web.archive.org/web/20220424020708/https://rustpython.github.io/}}</ref>
| dialects               = [[Cython|Cython]]、[[PyPy#RPython|RPython]]、{{en-link|Bazel (软件)|Bazel (software)|Starlark}}<ref>{{cite web|title=Starlark Language|url=https://docs.bazel.build/versions/master/skylark/language.html|access-date=25 May 2019|archive-date=2020-06-15|archive-url=https://web.archive.org/web/20200615140534/https://docs.bazel.build/versions/master/skylark/language.html}}</ref>
| influenced_by          = [[ABC_(程式語言)|ABC]]<ref name="faq-created"/>、[[Ada|Ada]]<ref>{{cite web | url=http://archive.adaic.com/standards/83lrm/html/lrm-11-03.html#11.3 | title=Ada 83 Reference Manual (raise statement) | access-date=2021-03-14 | archive-date=2019-10-22 | archive-url=https://web.archive.org/web/20191022155758/http://archive.adaic.com/standards/83lrm/html/lrm-11-03.html#11.3 }}</ref>、[[ALGOL_68|ALGOL 68]]<ref name="98-interview">{{cite web |url=http://www.amk.ca/python/writing/gvr-interview |title=Interview with Guido van Rossum (July 1998) |last=Kuchling |first=Andrew M. |work=amk.ca |date=22 December 2006 |access-date=12 March 2012 |archive-url=https://web.archive.org/web/20070501105422/http://www.amk.ca/python/writing/gvr-interview |archive-date=1 May 2007}}</ref>、[[APL语言|APL]]<ref name="python.org">{{cite web|url=https://docs.python.org/3/library/itertools.html|title=itertools — Functions creating iterators for efficient looping — Python 3.7.1 documentation|website=docs.python.org|access-date=2020-04-22|archive-date=2020-06-14|archive-url=https://web.archive.org/web/20200614153629/https://docs.python.org/3/library/itertools.html}}</ref>、[[C語言|C]]<ref name="AutoNT-1">{{cite journal |last=van Rossum |first=Guido |year=1993 |url=http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.2023&rep=rep1&type=pdf |title=An Introduction to Python for UNIX/C Programmers |journal=Proceedings of the NLUUG Najaarsconferentie (Dutch UNIX Users Group) |quote=even though the design of C is far from ideal, its influence on Python is considerable. |access-date=2021-03-14 |archive-date=2013-06-17 |archive-url=https://web.archive.org/web/20130617064553/http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.2023&rep=rep1&type=pdf }}</ref>、[[C++|C++]]<ref name="classmix">{{cite web |url=https://docs.python.org/tutorial/classes.html |title=Classes |work=The Python Tutorial |publisher=Python Software Foundation |access-date=20 February 2012 |quote=It is a mixture of the class mechanisms found in C++ and Modula-3 |archive-date=2012-10-23 |archive-url=https://web.archive.org/web/20121023030209/http://docs.python.org/tutorial/classes.html }}</ref>、[[CLU|CLU]]<ref name="effbot-call-by-object">{{cite web |url=http://effbot.org/zone/call-by-object.htm |title=Call By Object |work=effbot.org |last=Lundh |first=Fredrik |quote=replace "CLU" with "Python", "record" with "instance", and "procedure" with "function or method", and you get a pretty accurate description of Python's object model. |access-date=21 November 2017 |archive-date=2019-11-23 |archive-url=https://web.archive.org/web/20191123043655/http://effbot.org/zone/call-by-object.htm }}</ref>、[[Dylan_(编程语言)|Dylan]]<ref name="AutoNT-2">{{cite web |url=https://www.python.org/download/releases/2.3/mro/ |title=The Python 2.3 Method Resolution Order |last=Simionato |first=Michele |publisher=Python Software Foundation |quote=The C3 method itself has nothing to do with Python, since it was invented by people working on Dylan and it is described in a paper intended for lispers |access-date=2021-03-14 |archive-date=2020-08-20 |archive-url=https://web.archive.org/web/20200820231854/https://www.python.org/download/releases/2.3/mro/ }}</ref>、[[Haskell|Haskell]]<ref name="AutoNT-3">{{cite web |url=https://docs.python.org/howto/functional.html |title=Functional Programming HOWTO |last=Kuchling |first=A. M. |work=Python v2.7.2 documentation |publisher=Python Software Foundation |access-date=9 February 2012 |archive-date=2012-10-24 |archive-url=https://web.archive.org/web/20121024163217/http://docs.python.org/howto/functional.html }}</ref>、[[Icon_(编程語言)|Icon]]<ref name="AutoNT-4">{{cite web |url=https://www.python.org/dev/peps/pep-0255/ |title=PEP 255 – Simple Generators |first1=Neil |last1=Schemenauer |first2=Tim |last2=Peters |first3=Magnus Lie |last3=Hetland |date=18 May 2001 |work=Python Enhancement Proposals |publisher=Python Software Foundation |access-date=9 February 2012 |archive-date=2020-06-05 |archive-url=https://web.archive.org/web/20200605012926/https://www.python.org/dev/peps/pep-0255/ }}</ref>、[[Java|Java]]<ref name="AutoNT-5">{{cite web |url=https://www.python.org/dev/peps/pep-0318/ |title=PEP 318 – Decorators for Functions and Methods |first1=Kevin D. |last1=Smith |first2=Jim J. |last2=Jewett |first3=Skip |last3=Montanaro |first4=Anthony |last4=Baxter |date=2 September 2004 |work=Python Enhancement Proposals |publisher=Python Software Foundation |access-date=24 February 2012 |archive-date=2020-06-03 |archive-url=https://web.archive.org/web/20200603133734/https://www.python.org/dev/peps/pep-0318/ }}</ref>、[[Lisp|Lisp]]<ref name="AutoNT-6">{{cite web |url=https://docs.python.org/3.2/tutorial/controlflow.html |title=More Control Flow Tools |work=Python 3 documentation |publisher=Python Software Foundation |access-date=24 July 2015 |archive-date=2016-06-04 |archive-url=https://web.archive.org/web/20160604080843/https://docs.python.org/3.2/tutorial/controlflow.html }}</ref>、[[Modula-3|Modula-3]]<ref name="classmix" />、[[Perl|Perl]]、[[Standard_ML|Standard ML]]<ref name="python.org"/>
| influenced             = [[Boo|Boo]]、{{tsl|en|Cobra (programming language)|Cobra}}、[[CoffeeScript|CoffeeScript]]<ref>{{Cite web|url=https://coffeescript.org/|title=CoffeeScript|website=coffeescript.org|access-date=2021-03-14|archive-date=2020-06-12|archive-url=https://web.archive.org/web/20200612100004/http://coffeescript.org/}}</ref>、[[D语言|D]]、[[F♯|F#]]、[[Falcon|Falcon]]、[[Genie_(程式語言)|Genie]]<ref>{{cite web |url=https://wiki.gnome.org/action/show/Projects/Genie |title=The Genie Programming Language Tutorial |access-date=28 February 2020 |archive-date=2020-06-01 |archive-url=https://web.archive.org/web/20200601133216/https://wiki.gnome.org/action/show/Projects/Genie }}</ref>、[[Go|Go]]、[[Groovy|Groovy]]、[[JavaScript|JavaScript]]<ref>{{cite web |title=Perl and Python influences in JavaScript |date=24 February 2013 |website=www.2ality.com |url=http://www.2ality.com/2013/02/javascript-influences.html |access-date=15 May 2015 |archive-date=2018-12-26 |archive-url=https://web.archive.org/web/20181226141121/http://2ality.com/2013/02/javascript-influences.html%0A }}</ref><ref>{{cite web |title=Chapter 3: The Nature of JavaScript; Influences |last=Rauschmayer |first=Axel |website=O'Reilly, Speaking JavaScript |url=http://speakingjs.com/es5/ch03.html |access-date=15 May 2015 |archive-date=2018-12-26 |archive-url=https://web.archive.org/web/20181226141123/http://speakingjs.com/es5/ch03.html%0A }}</ref>、[[Julia_(编程语言)|Julia]]<ref name=Julia/>、[[Nim|Nim]]、Ring<ref name="The Ring programming language and other languages">{{cite web |url=http://ring-lang.sourceforge.net/doc1.6/introduction.html#ring-and-other-languages |title=Ring and other languages |author=Ring Team |date=4 December 2017 |work=ring-lang.net |publisher=[[ring-lang|ring-lang]] |access-date=2021-03-14 |archive-date=2018-12-25 |archive-url=https://web.archive.org/web/20181225175312/http://ring-lang.sourceforge.net/doc1.6/introduction.html#ring-and-other-languages }}</ref>、[[Ruby|Ruby]]<ref name="bini">{{cite book |last=Bini |first=Ola |title=Practical JRuby on Rails Web 2.0 Projects: bringing Ruby on Rails to the Java platform |year=2007 |publisher=APress |location=Berkeley |isbn=978-1-59059-881-8 |page=[https://archive.org/details/practicaljrubyon0000bini/page/3 3] |url=https://archive.org/details/practicaljrubyon0000bini/page/3 }}</ref>、[[Swift|Swift]]<ref name="lattner2014">{{cite web |url=http://nondot.org/sabre/ |title=Chris Lattner's Homepage |last=Lattner |first=Chris |date=3 June 2014 |access-date=3 June 2014 |publisher=Chris Lattner |quote=The Swift language is the product of tireless effort from a team of language experts, documentation gurus, compiler optimization ninjas, and an incredibly important internal dogfooding group who provided feedback to help refine and battle-test ideas. Of course, it also greatly benefited from the experiences hard-won by many other languages in the field, drawing ideas from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list. |archive-date=2018-12-25 |archive-url=https://web.archive.org/web/20181225131628/http://nondot.org/sabre/ }}</ref>
| operating_system       = [[跨平臺|跨平臺]]：[[Microsoft_Windows|Windows]]、[[Linux|Linux]]/[[Unix|Unix]]、[[macOS|macOS]]等
| license                = [[Python软件基金会许可证|Python软件基金会许可证]]
| website                = {{official URL}}
| file ext = .py、.pyi、.pyc、.pyd、.pyo（3.5之前）<ref>File extension .pyo was removed in Python 3.5. See [https://www.python.org/dev/peps/pep-0488/ PEP 0488] {{Wayback|url=https://www.python.org/dev/peps/pep-0488/ |date=20200601133202 }}</ref>、{{notatypo|.pyw}}、.pyz（自从3.5）<ref>{{cite web |url=https://www.python.org/dev/peps/pep-0441/ |last=Holth |first=Moore |date=2014-03-30 |accessdate=2015-11-12 |title=PEP 0441 -- Improving Python ZIP Application Support |archive-date=2018-12-26 |archive-url=https://web.archive.org/web/20181226141117/https://www.python.org/dev/peps/pep-0441/%20 |dead-url=no }}</ref>
| wikibooks              = zh:Python
}}

'''Python'''（{{IPA-en|ˈpaɪθən|UK}} {{IPA-en|ˈpaɪθɑːn|US}}），是一种广泛使用的[[直譯语言|解释型]]、[[高级語言|高级]]和[[通用编程语言|通用]]的[[编程语言|编程语言]]。Python支持多种编程范型，包括函数式、指令式、反射式、结构化和面向对象编程。它拥有[[類型系統|动态类型系统]]和[[垃圾回收_(計算機科學)|垃圾回收]]功能，能够自动管理内存使用，并且其本身拥有一个巨大而广泛的标准库。它的语言结构以及[[面向对象程序设计|面向对象]]的方法旨在帮助程序员为小型的和大型的项目编写清晰的、合乎逻辑的代码。

[[吉多·范罗苏姆|吉多·范罗苏姆]]于1980年代后期开始研发Python，它是作为[[ABC_(程式語言)|ABC语言]]的后继者，也可以視之為使用叫做的{{en-link|M-表达式|M-expression}}的一種传统[[中缀表示法|中缀表示法]]的[[LISP|LISP]]方言<ref>{{cite web|url=https://norvig.com/python-lisp.html|title=Python for Lisp Programmers|author=彼德·諾米格|authorlink=彼德·諾米格|quote=Python can be seen as a dialect of Lisp with "traditional" syntax (what Lisp people call "infix" or "m-lisp" syntax).|accessdate=2020-04-21|archive-date=2020-06-14|archive-url=https://web.archive.org/web/20200614153604/https://norvig.com/python-lisp.html|dead-url=no}}</ref>。[[吉多·范罗苏姆|吉多·范罗苏姆]]于1991年首次发布 Python 0.9.0<ref>{{Cite web|last=Rossum|first=Guido Van|date=2009-01-20|title=The History of Python: A Brief Timeline of Python|url=https://python-history.blogspot.com/2009/01/brief-timeline-of-python.html|access-date=2021-03-05|website=The History of Python|archive-date=5 June 2020|archive-url=https://web.archive.org/web/20200605032200/https://python-history.blogspot.com/2009/01/brief-timeline-of-python.html|url-status=live}}</ref>。Python 2.0于2000 年发布并引入了新功能。Python 3.0于2008年发布，是该语言的主要修订版，并非完全[[向下兼容|向后兼容]]。Python 2于2020年随2.7.18版停止支持<ref>{{Cite web|url=https://pythoninsider.blogspot.com/2020/04/python-2718-last-release-of-python-2.html|title=Python Insider: Python 2.7.18, the last release of Python 2|last=Peterson|first=Benjamin|date=20 April 2020|website=Python Insider|access-date=27 April 2020|archive-date=26 April 2020|archive-url=https://web.archive.org/web/20200426204118/https://pythoninsider.blogspot.com/2020/04/python-2718-last-release-of-python-2.html|url-status=live}}</ref>。

Python的设计哲学强调代码的[[程式可讀性|可读性]]和简洁的语法，尤其是使用[[越位规则|空格缩进]]划分代码块。相比於[[C语言|C]]或[[Java|Java]]，Python让开发者能够用更少的代码表达想法。

Python[[解释器|解释器]]本身几乎可以在所有的[[操作系统|操作系统]]中运行。Python的官方[[直譯器|直譯器]][[CPython|CPython]]是用[[C语言|C语言]]编写的，它是一個由社群驱动的自由[[軟體|软件]]，目前由[[Python軟體基金會|Python软件基金会]]管理。Python是最受欢迎的编程语言之一<ref>{{Cite web|title=Stack Overflow Developer Survey 2020|url=https://insights.stackoverflow.com/survey/2020/|access-date=2021-03-05|website=Stack Overflow|archive-date=2 March 2021|archive-url=https://web.archive.org/web/20210302140729/https://insights.stackoverflow.com/survey/2020|url-status=live}}</ref><ref>{{Cite web|title=The State of Developer Ecosystem in 2020 Infographic|url=https://www.jetbrains.com/lp/devecosystem-2020/|access-date=2021-03-05|website=JetBrains: Developer Tools for Professionals and Teams|language=en|archive-date=1 March 2021|archive-url=https://web.archive.org/web/20210301062411/https://www.jetbrains.com/lp/devecosystem-2020/|url-status=live}}</ref><ref>{{Cite web|title=index {{!}} TIOBE - The Software Quality Company|url=https://www.tiobe.com/tiobe-index/|access-date=2021-02-02|quote=Python has won the TIOBE programming language of the year award! This is for the fourth time in the history, which is a record! The title is awarded to the programming language that has gained most popularity in one year.|website=www.tiobe.com|archive-date=25 February 2018|archive-url=https://web.archive.org/web/20180225101948/https://www.tiobe.com/tiobe-index/|url-status=live}}</ref><ref>{{Cite web|title=PYPL PopularitY of Programming Language index|url=https://pypl.github.io/PYPL.html|access-date=2021-03-26|website=pypl.github.io|language=en|archive-date=14 March 2017|archive-url=https://web.archive.org/web/20170314232030/https://pypl.github.io/PYPL.html|url-status=live}}</ref>。

== 歷史 ==
{{main|Python史}}
[[File:Guido_van_Rossum_OSCON_2006_cropped.png|thumb]].]]

Python的創始人為[[吉多·范羅蘇姆|吉多·范羅蘇姆]]，当时他在[[阿姆斯特丹|阿姆斯特丹]]的[[荷兰数学和计算机科学研究学会|荷兰数学和计算机科学研究学会]]工作。1989年的聖誕節期間，[[吉多·范羅蘇姆|吉多·范羅蘇姆]]為了在打發时间，決心開發一個新的腳本解釋程式，作為[[ABC語言|ABC語言]]的一種繼承，替代使用[[Unix_shell|Unix shell]]和[[C语言|C语言]]进行系统管理，担负同{{en-link|Amoeba (操作系统)|Amoeba (operating system)|Amoeba操作系统}}的交互和[[异常处理|异常处理]]<ref name = "faq-created">{{cite web |url=https://www.python.org/doc/faq/general/#why-was-python-created-in-the-first-place |title=Why was Python created in the first place? |publisher=Python FAQ |accessdate=2007-03-22 |archive-date=2008-02-23 |archive-url=https://web.archive.org/web/20080223222507/http://www.python.org/doc/faq/general/#why-was-python-created-in-the-first-place |dead-url=no }}</ref>。之所以選中Python作為程式的名字，是因為他是[[英國廣播公司|BBC]]電視劇——《[[蒙提·派森的飛行馬戲團|蒙提·派森的飛行馬戲團]]》（{{lang|en|Monty Python's Flying Circus}}）的愛好者<ref name="tutorial-chapter1">{{cite web |url=https://docs.python.org/tutorial/appetite.html |title=Whetting Your Appetite |work=The Python Tutorial |publisher=Python Software Foundation |accessdate=2012-02-20 |archive-date=2012-10-26 |archive-url=https://web.archive.org/web/20121026063559/http://docs.python.org/tutorial/appetite.html |dead-url=no }}</ref>。范羅蘇姆作为Python的主要開發者独自担负这个项目的职责，直到2018年7月12日，他宣布从作为[[終身仁慈獨裁者|終身仁慈獨裁者]]（BDFL）的职责上“永久休假”，Python社群向他授予这个头衔，反映了他长期担任整個Python語言的發展方向的决策者<ref>{{cite news |url=http://www.linuxformat.co.uk/modules.php?op=modload&name=Sections&file=index&req=viewarticle&artid=10 |title=Benevolent dictator for life |publisher=[[Linux_Format|Linux Format]] |date=2005-02-01 |accessdate=2007-11-01 |archiveurl=https://web.archive.org/web/20061001143603/http://www.linuxformat.co.uk/modules.php?op=modload&name=Sections&file=index&req=viewarticle&artid=10 |archivedate=2006-10-01 |dead-url=yes }}</ref><ref>{{cite news|url=https://www.mail-archive.com/python-committers@python.org/msg05628.html|title=Transfer of power|accessdate=2020-11-29|archive-date=2018-07-12|archive-url=https://web.archive.org/web/20180712225051/https://www.mail-archive.com/python-committers@python.org/msg05628.html|dead-url=no}}</ref>。他在2019年1月至11月于参与了一个五人掌控委员会继续领导项目发展<ref>{{cite web |title=PEP 8100 |url=https://www.python.org/dev/peps/pep-8100/ |website=python |publisher=Python Software Foundation |accessdate=2019-05-04 |archive-date=2020-06-04 |archive-url=https://web.archive.org/web/20200604235027/https://www.python.org/dev/peps/pep-8100/ |dead-url=no }}</ref><ref>{{Cite web|url=https://discuss.python.org/t/steering-council-nomination-guido-van-rossum-2020-term/2657/9|title=Steering Council nomination: Guido van Rossum (2020 term)|accessdate=2020-10-11|archive-date=2019-12-29|archive-url=https://web.archive.org/web/20191229140536/https://discuss.python.org/t/steering-council-nomination-guido-van-rossum-2020-term/2657/9|dead-url=no}}</ref>。

在1991年2月，范羅蘇姆发布了最初代码（标记为版本0.9.0）于alt.sources<ref name="svn-history">{{cite web |url=https://raw.githubusercontent.com/python/cpython/master/Misc/HISTORY |title=HISTORY |publisher=Python Foundation |work=Python source distribution |accessdate=2017-11-23 |archive-date=2017-12-01 |archive-url=https://web.archive.org/web/20171201033011/https://raw.githubusercontent.com/python/cpython/master/Misc/HISTORY |dead-url=no }}</ref>，这时就已经存在了[[继承_(计算机科学)|带继承的]][[类_(计算机科学)|类]]、[[异常处理|异常处理]]、[[函数_(计算机科学)|函数]]和核心[[数据类型|数据类型]]<code>list</code>、<code>dict</code>、<code>str</code>等。在这个最初发行中就有了从[[Modula-3|Modula-3]]引进的[[模块化编程|模块系统]]<ref name="venners-interview-pt-1">{{cite web |url=http://www.artima.com/intv/pythonP.html |title=The Making of Python |accessdate=2007-03-22 |publisher=Artima Developer |archive-date=2016-09-01 |archive-url=https://web.archive.org/web/20160901183332/http://www.artima.com/intv/pythonP.html |dead-url=no }}</ref>，它的异常模型也类似于Modula-3<ref name="faq-created" />。在1994年1月Python达到了版本1.0。这个发行版主要新特征是包括了Amrit Prem提供的函数式编程工具<code>[[匿名函数#Python|lambda]]</code>、<code>[[Map_(高阶函数)|map]]</code>、<code>[[Filter_(高阶函数)|filter]]</code>和<code>[[Fold_(高阶函数)|reduce]]</code><ref name="reduce-fate">{{cite web |url=http://www.artima.com/weblogs/viewpost.jsp?thread=98196 |title=The fate of reduce() in Python 3000 |first=Guido |last=van Rossum |accessdate=2007-03-22 |publisher=Artima Developer |archive-date=2007-04-07 |archive-url=https://web.archive.org/web/20070407034617/http://www.artima.com/weblogs/viewpost.jsp?thread=98196 |dead-url=no }}</ref>。Python 1.4增加了受Modula-3启发的{{en-link|命名参数|Named parameter|关键字参数}}，和对[[複數_(數學)|复数]]的内建支持，还包含了采取[[名字修饰|名字修饰]]的一种基本形式的{{en-link|信息隐藏 (编程)|Information hiding|数据隐藏}}<ref>{{cite web |url=http://www.amk.ca/python/writing/12-14 |title=LJ #37: Python 1.4 Update |accessdate=2007-04-29 |archiveurl=https://web.archive.org/web/20070501080219/http://www.amk.ca/python/writing/12-14 |archivedate=2007-05-01 |dead-url=yes }}</ref>。

Python 2.0於2000年10月16日發布，介入了[[列表推导式|列表推导式]]，这是从[[函数式编程|函数式编程]]语言[[SETL|SETL]]和[[Haskell|Haskell]]中引入的。它还向[[垃圾回收_(計算機科學)|垃圾收集系统]]增加了[[环_(图论)|环]]检测算法，并且支持[[Unicode|Unicode]]<ref name="newin-2.0">{{cite web |url=https://docs.python.org/whatsnew/2.0.html |title=What's New in Python 2.0 |last1=Kuchling |first1=A. M. |last2=Zadka |first2=Moshe |date=2000-10-16 |publisher=Python Software Foundation |accessdate=2012-02-11 |archive-date=2012-10-23 |archive-url=https://web.archive.org/web/20121023112045/http://docs.python.org/whatsnew/2.0.html |dead-url=no }}</ref>。Python 2.1支持了嵌套作用域，就像其他静态[[作用域|作用域]]语言一样<ref name="pep-0227">{{cite web |url=https://www.python.org/dev/peps/pep-0227/ |title=PEP 227 -- Statically Nested Scopes |last=Hylton |first=Jeremy |date=2000-11-01 |accessdate=2007-03-22 |archive-date=2007-03-29 |archive-url=https://web.archive.org/web/20070329062039/http://www.python.org/dev/peps/pep-0227/ |dead-url=no }}</ref>。Python 2.2的重大革新是将Python的[[类型系统|类型]]（用C写成）和[[类_(计算机科学)|类]]（用Python写成）统一入一个层级，使得Python的对象模型成为纯粹和一致的面向对象的模型<ref name="unify" />；还增加了[[迭代器|迭代器]]<ref>{{cite web|url=https://docs.python.org/3/whatsnew/2.2.html#pep-234-iterators|title=What’s New in Python 2.2 － PEP 234: Iterators|accessdate=2020-10-21|archive-date=2021-02-07|archive-url=https://web.archive.org/web/20210207193626/https://docs.python.org/3/whatsnew/2.2.html#pep-234-iterators|dead-url=no}}</ref>，受[[CLU|CLU]]和[[Icon_(编程语言)|Icon]]启发的[[生成器_(计算机编程)|生成器]]<ref name="pep-0255">{{cite web |url=https://docs.python.org/3/whatsnew/2.2.html#pep-255-simple-generators |title=What’s New in Python 2.2 － PEP 255: Simple Generators |access-date=2020-10-21 |archive-date=2021-02-07 |archive-url=https://web.archive.org/web/20210207193626/https://docs.python.org/3/whatsnew/2.2.html#pep-255-simple-generators }}</ref>，和描述器[[协议_(面向对象编程)|协议]]<ref name="#1">{{cite web|url=https://docs.python.org/3/whatsnew/2.2.html#descriptors|title=What’s New in Python 2.2 － Descriptors|accessdate=2020-10-21|archive-date=2021-02-07|archive-url=https://web.archive.org/web/20210207193626/https://docs.python.org/3/whatsnew/2.2.html#descriptors|dead-url=no}}</ref>。Python 2.4加入了{{en-link|集合 (抽象数据类型)|Set (abstract data type)|集合}}数据类型，和函数修饰器<ref>{{cite web|url=https://docs.python.org/3/whatsnew/2.4.html#pep-318-decorators-for-functions-and-methods|title=What’s New in Python 2.4 － PEP 318: Decorators for Functions and Methods|accessdate=2020-10-21|archive-date=2021-02-07|archive-url=https://web.archive.org/web/20210207193539/https://docs.python.org/3/whatsnew/2.4.html#pep-318-decorators-for-functions-and-methods|dead-url=no}}</ref>。Python 2.5加入了<code>with</code>语句<ref>{{cite web|url=https://docs.python.org/3/whatsnew/2.5.html#pep-343-the-with-statement|title=What’s New in Python 2.5 － PEP 343: The ‘with’ statement|accessdate=2020-10-21|archive-date=2021-02-07|archive-url=https://web.archive.org/web/20210207161900/https://docs.python.org/3/whatsnew/2.5.html#pep-343-the-with-statement|dead-url=no}}</ref>。

Python 3.0於2008年12月3日發布，它对语言做了较大修订而不能完全[[向下兼容|后向兼容]]<ref name="3.0-release">{{cite web |url=https://www.python.org/download/releases/3.0/ |title=Python 3.0 Release |publisher=Python Software Foundation |accessdate=2009-07-08 |archive-date=2020-06-14 |archive-url=https://web.archive.org/web/20200614153714/https://www.python.org/download/releases/3.0/ |dead-url=yes }}</ref>。Python 3发行包括了<code>2to3</code>实用工具，它（至少部份的）自动将Python 2代码转换成Python 3代码<ref>{{cite web |url=https://docs.python.org/3/library/2to3.html |title=Automated Python 2 to 3 code translation — Python Documentation |accessdate=2018-02-11 |archive-date=2020-06-04 |archive-url=https://web.archive.org/web/20200604232823/https://docs.python.org/3/library/2to3.html |dead-url=no }}</ref>。Python 3的很多新特性後來也被移植到舊的Python 2.6/2.7版本中<ref name="pep-3000">{{cite web |url=https://www.python.org/dev/peps/pep-3000/ |title=PEP 3000 – Python 3000 |last=van Rossum |first=Guido |date=2006-04-05 |work=Python Enhancement Proposals |publisher=Python Software Foundation |accessdate=2009-06-27 |archive-date=2016-03-03 |archive-url=https://web.archive.org/web/20160303231513/https://www.python.org/dev/peps/pep-3000/ |dead-url=no }}</ref>。

Python 2.7的[[产品寿命结束|产品寿命结束]]日期最初设定为2015年，出于对大量的现存代码不能前向移植到Python 3的关切，而将对它的支持延期至2020年<ref>{{cite web |url=https://legacy.python.org/dev/peps/pep-0373/ |title=PEP 373 -- Python 2.7 Release Schedule |work=python.org |accessdate=2017-01-09 |archive-date=2020-05-19 |archive-url=https://web.archive.org/web/20200519075520/https://legacy.python.org/dev/peps/pep-0373/ |dead-url=no }}</ref><ref>{{cite web |url=https://www.python.org/dev/peps/pep-0466/ |title=PEP 466 -- Network Security Enhancements for Python 2.7.x |work=python.org |accessdate=2017-01-09 |archive-date=2020-06-04 |archive-url=https://web.archive.org/web/20200604232833/https://www.python.org/dev/peps/pep-0466/ |dead-url=no }}</ref>。2022年3月14日发布的macOS 12.3 则彻底移除 Python 2<ref>{{Cite web|title=macOS Monterey 12.3 Release Notes|url=https://developer.apple.com/documentation/macos-release-notes/macos-12_3-release-notes#Python|access-date=2022-03-25|archive-date=2022-04-13|archive-url=https://web.archive.org/web/20220413184320/https://developer.apple.com/documentation/macos-release-notes/macos-12_3-release-notes#Python}}</ref>。随着Python 2的[[产品寿命结束|产品寿命结束]]，只有Python 3.9、3.10和后续版本正在被完全支持，但仍提供对3.7和3.8版本的安全性修正<ref>{{Cite web|url=https://devguide.python.org/#status-of-python-branches|title=Python Developer's Guide — Status of Python branches|website=devguide.python.org|access-date=2022-01-02|archive-date=2020-11-09|archive-url=https://web.archive.org/web/20201109032501/https://devguide.python.org/#status-of-python-branches}}</ref>。

在2021年12月，活跃的Python核心开发者选举Pablo Galindo Salgado、Petr Viktorin、Thomas Wouters、Gregory P. Smith和Brett Cannon为2022年度“掌控委员会”的五位成员来领导这个项目<ref>{{cite web |title=PEP 8103 -- 2022 Term steering council election |url=https://www.python.org/dev/peps/pep-8103/ |publisher=Python Software Foundation |accessdate=2021-12-20 |dead-url=no |archive-date=2022-02-22 |archive-url=https://web.archive.org/web/20220222060746/https://www.python.org/dev/peps/pep-8103/ }}</ref>。

== 特徵與設計哲學 ==
Python是[[编程范式|多范型]]编程语言。它完全支持[[结构化编程|结构化编程]]和[[面向对象编程|面向对象编程]]，还有很多特征支持[[函数式编程|函数式编程]]和[[元编程|元编程]]比如[[元对象|元对象]][[协议_(面向对象编程)|协议]]（[[元类|元类]]和魔术方法<ref name="special-method-names"/>）。通过扩展还可以支持很多范型，包括[[面向切面编程|面向切面编程]]<ref>{{cite web|url=http://python-aspectlib.readthedocs.org/en/latest/|title=aspectlib|quote=aspectlib is an aspect-oriented programming, monkey-patch and decorators library. It is useful when changing behavior in existing code is desired.|access-date=2020-09-28|archive-date=2014-11-05|archive-url=https://web.archive.org/web/20141105061010/http://python-aspectlib.readthedocs.org/en/latest/}}</ref>、[[契约式设计|契约式设计]]<ref name="AutoNT-15~16">{{cite web|url=https://www.python.org/dev/peps/pep-0316/|title=PEP 316 -- Programming by Contract for Python|accessdate=2021-01-17|archive-date=2021-01-22|archive-url=https://web.archive.org/web/20210122044926/https://www.python.org/dev/peps/pep-0316/|dead-url=no}}
* {{cite web|url=https://deal.readthedocs.io/|title=Deal|quote=python library for design by contract (DbC) and checking values, exceptions, and side-effects.|access-date=2021-06-20|archive-date=2021-07-16|archive-url=https://web.archive.org/web/20210716090059/https://deal.readthedocs.io/}}
*{{cite web|url=https://pypi.org/project/icontract/|title=icontract|quote=icontract provides design-by-contract to Python3 with informative violation messages and inheritance.|accessdate=2021-01-17|archive-date=2021-01-21|archive-url=https://web.archive.org/web/20210121042908/https://pypi.org/project/icontract/|dead-url=no}}
*{{cite web|url=https://pypi.org/project/PyContracts/|title=PyContracts|quote=PyContracts is a Python package that allows to declare constraints on function parameters and return values.|accessdate=2021-01-17|archive-date=2021-01-22|archive-url=https://web.archive.org/web/20210122045232/https://pypi.org/project/PyContracts/|dead-url=no}}
*{{cite web|url=https://pypi.org/project/dpcontracts/|title=dpcontracts|quote=This module provides a collection of decorators that makes it easy to write software using contracts.|accessdate=2021-01-17|archive-date=2021-01-22|archive-url=https://web.archive.org/web/20210122011715/https://pypi.org/project/dpcontracts/|dead-url=no}}</ref>和[[逻辑编程|逻辑编程]]<ref name="AutoNT-17">{{cite web |url=https://sites.google.com/site/pydatalog/ |title=PyDatalog |accessdate=2012-07-22 |archive-date=2020-06-13 |archive-url=https://web.archive.org/web/20200613160231/https://sites.google.com/site/pydatalog/ |dead-url=no }}</ref>。

Python使用[[类型系统|动态类型]]，在[[内存管理|内存管理]]上采用[[引用计数|引用计数]]和环检测相结合的垃圾收集器<ref name="Reference_counting">{{Cite web| url=https://docs.python.org/extending/extending.html#reference-counts| title=Extending and Embedding the Python Interpreter: Reference Counts| publisher=Docs.python.org| language=en| access-date=2020-06-05| quote=Since Python makes heavy use of <code>malloc()</code> and <code>free()</code>, it needs a strategy to avoid memory leaks as well as the use of freed memory. The chosen method is called ''reference counting''.| archive-date=2012-10-18| archive-url=https://web.archive.org/web/20121018063230/http://docs.python.org/extending/extending.html#reference-counts| dead-url=no}}</ref>。它的特征还有动态[[名字解析_(程序设计)|名字解析]]（{{en-link|后期绑定|late binding}}），即在程序执行期间绑定方法和变量的名字。

Python對遵循[[LISP|LISP]]傳統的[[函数式编程|函数式编程]]提供了有限的支持<ref>{{cite web|url=https://docs.python.org/3/howto/functional.html|title=Functional Programming HOWTO|accessdate=2020-09-26|archive-date=2012-10-24|archive-url=https://web.archive.org/web/20121024163217/http://docs.python.org/howto/functional.html|dead-url=no}}</ref>，它提供了 <code>[[Map_(高阶函数)|map]]</code>、<code>[[Filter_(高阶函数)|filter]]</code>和<code>[[Fold_(高阶函数)|reduce]]</code>函数；[[列表推导式|列表推导式]]、[[关联数组|字典]]、{{en-link|集合 (抽象数据类型)|Set (abstract data type)|集合}}和[[生成器_(计算机编程)#生成器表达式|生成器表达式]]<ref name="AutoNT-59" />。標準庫中的模組<code>functools</code>和<code>itertools</code>，实现了从[[Haskell|Haskell]]和[[Standard_ML|Standard ML]]借鉴来的函數式工具<ref name="AutoNT-18">{{cite web|url=https://docs.python.org/3/library/functional.html|title=Functional Programming Modules|publisher=Docs.python.org|accessdate=2020-09-26|archive-date=2020-09-20|archive-url=https://web.archive.org/web/20200920200745/https://docs.python.org/3/library/functional.html|dead-url=no}}</ref>。

Python的設計哲學是“優雅”、“明確”、“簡單”。它的重要準則被稱為「[[Python之禅|Python之禅]]」。在Python解釋器内運行<code>import this</code>可以獲得完整的列表，下面是其中首要：
<!-- Note this isn't a full list, just some of the more significant aphorisms -->
*优美优于丑陋。明瞭优于隐晦。
*简单优于复杂。复杂优于凌乱。
*扁平优于嵌套。稀疏优于稠密。
*可读性很重要。 

Python開發者的哲學是“用一種方法，最好是只有一種方法來做一件事”，显著不同于擁有“[[不止一种方法去做一件事|不止一种方法去做一件事]]”風格的語言例如[[Perl|Perl]]。在設計Python語言時，如果面臨多種選擇，Python開發者一般會拒绝花俏的語法，而選擇明確没有或者很少有歧義的語法。

范羅蘇姆认为ABC語言非常優美和强大，并没有成功的原因是非開放造成的<ref name="python_history">{{cite web | language = en | title = Foreword for "Programming Python" (1st ed.) | url = https://www.python.org/doc/essays/foreword/ | author = Guido van Rossum | date = 1996-05-01 | accessdate = 2020-09-12 | archive-date = 2014-07-24 | archive-url = https://web.archive.org/web/20140724173913/https://www.python.org/doc/essays/foreword/ | dead-url = no }}</ref>，故而将Python本身設計為可擴充的。Python並不把所有的特性和功能都集成到語言核心，而是提供了豐富的[[API|API]]和工具，以便程式設計師能够輕鬆地使用[[C语言|C]]、[[Cython|Cython]]來編寫擴充模組，还可以通过{{en-link|外界函数接口|Foreign function interface}}如标准库中的ctypes等，来访问[[动态链接库|动态链接库]]或[[共享库|共享库]]中C兼容数据类型并调用其中函数<ref>{{cite web|url=https://docs.python.org/3/library/ctypes.html|title=ctypes — A foreign function library for Python|access-date=2022-01-14|archive-date=2022-04-27|archive-url=https://web.archive.org/web/20220427182117/https://docs.python.org/3/library/ctypes.html}}</ref>，因此很多人使用Python將其他語言編寫的程式進行集成和封裝。Python編譯器本身也可以被集成到其它需要腳本語言的程式内。

Python開發人員盡量避開不成熟或者不重要的優化。一些針對非重要部位的加快運行速度的補丁通常不會被合併到Python的官方实现[[CPython|CPython]]中。在某些對運行速度要求很高的情況，Python設計師可以使用[[即時編譯|JIT]]技术的[[PyPy|PyPy]]，或者是将Python脚本翻译成C的[[Cython|Cython]]，还可以将时间关键的函数迁移至用C語言编写的扩展模块中。

== 語法 ==
{{main|Python語法及語義}}

Python的設計目標之一是讓程式碼具備高度的可閱讀性。它設計時盡量使用其它語言經常使用的標點符號和英文單字，讓程式碼看起来整潔美觀。Python语句之后的分号是可选的，作为动态语言不需要書寫“聲明”語句，不同於其他的靜態語言如[[C语言|C]]、[[Pascal_(程式語言)|Pascal]]。

=== 縮排 ===
Python語言利用縮排表示語句塊的開始和結束（[[越位規則|越位規則]]），而非使用大括號或者某種[[關鍵字|關鍵字]]。增加縮排表示語句塊的開始，而減少縮排則表示語句塊的結束。根據PEP 8的規定<ref>{{cite web|url=https://www.python.org/dev/peps/pep-0008/#indentation|title=Style Guide for Python Code: indentation|accessdate=2020-09-26|archive-date=2018-07-13|archive-url=https://web.archive.org/web/20180713002451/https://www.python.org/dev/peps/pep-0008/#indentation|dead-url=no}}</ref>，使用4個空格來表示每級縮排。{{efn|縮排示例：

<syntaxhighlight lang="Python">
def print_something(age):
    if age < 21:
        print("你不能買酒")  #美國法律規定21歲以下的人不能購買酒
    else:
        print("你能買酒")
    print("你能買口香糖")

# 参数比后续部份多一层缩进
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    # 可选的圆括号内后续行多一层缩进
    if (this_is_first_thing
            and that_is_second_thing):
        do_something()
    # 可选的圆括号内后续行不额外缩进
    elif (this_is_third_thing and
          that_is_fourth_thing):
        do_something_different()
# 参数相对行首缩进一层
spam = long_function_name(
    arg_one, arg_two,
    arg_three, arg_four)
# 参数按开括号界定垂直对齐
eggs = long_function_name(arg_one, arg_two,
                          arg_three, arg_four)
# 可选的闭括号位置
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
# 可选的闭括号位置
my_set = {
    1, 2, 3,
    4, 5, 6,
}
</syntaxhighlight>}}

使用Tab字符和其它數目的空格雖然都可以被解釋器識別，但不符合編碼規範，偏向使用Tab字符的程序員可以設置文本編輯器將Tab鍵轉換為4個空格。縮排成為了語法的一部分，並且Python開發者有意讓違反了「縮排規則」的程序不能通過解釋。

=== 关键字 ===

Python有如下35个关键字或“[[保留字|保留字]]”；它们不能用作标识符<ref>{{cite web |url=https://docs.python.org/3/reference/lexical_analysis.html#keywords |title=2. Lexical analysis |work=Python v3.8.6 documentation |publisher=Docs.python.org |date= |accessdate=2020-09-26 |archive-date=2018-01-09 |archive-url=https://web.archive.org/web/20180109063410/https://docs.python.org/3/reference/lexical_analysis.html#keywords |dead-url=no }}</ref><ref>{{cite web |url=https://docs.python.org/2.7/reference/lexical_analysis.html#keywords |title=2. Lexical analysis |work=Python v2.7.18 documentation |publisher=Docs.python.org |date= |accessdate=2020-09-26 |archive-date=2019-05-08 |archive-url=https://web.archive.org/web/20190508020150/https://docs.python.org/2.7/reference/lexical_analysis.html#keywords |dead-url=no }}</ref>：
{{Div col|colwidth=15em}}
*<code>and</code>
*<code>as</code>
*<code>assert</code>
*<code>async</code>{{refn|group=注|name=keywordIn35|从Python 3.5开始，介入了<code>async</code>和<code>await</code><ref>{{cite web |url=https://docs.python.org/3/whatsnew/3.5.html#new-keywords |title=New Keywords |work=Python v3.5 documentation |publisher=Docs.python.org |date= |accessdate=2016-06-01 |archive-url=https://web.archive.org/web/20160618215313/https://docs.python.org/3//whatsnew/3.5.html#new-keywords |archive-date=2016-06-18 |dead-url=no }}</ref>。
}}
*<code>await</code>{{refn|group=注|name=keywordIn35}}
*<code>break</code>
*<code>class</code>
*<code>continue</code>
*<code>def</code>
*<code>del</code>
*<code>elif</code>
*<code>else</code>
*<code>except</code>
*<code>False</code>{{refn|group=注|name=keywordIn30|从Python 3开始，介入了关键字<code>True</code>、<code>False</code>和<code>nonlocal</code>。}}
*<code>finally</code>
*<code>for</code>
*<code>from</code>
*<code>global</code>
*<code>if</code>
*<code>import</code>
*<code>in</code>
*<code>is</code>
*<code>lambda</code>
*<code>None</code>
*<code>nonlocal</code>{{refn|group=注|name=keywordIn30}}
*<code>not</code>
*<code>or</code>
*<code>pass</code>
*<code>raise</code>
*<code>return</code>
*<code>True</code>{{refn|group=注|name=keywordIn30}}
*<code>try</code>
*<code>while</code>
*<code>with</code>
*<code>yield</code>
{{div col end}}
;注释
{{reflist|group=注}}

=== 标识符 ===
标识符就是名字，在[[ASCII|ASCII]]范围内（U+0001..U+007F），可用于标识符的字符为：大写字母<code>A</code>至<code>Z</code>和小写字母<code>a</code>至<code>z</code>，下划线<code>_</code>以及数字<code>0</code>至<code>9</code>，但首字不可以用数字。有如下[[命名规则_(程序设计)|命名约定]]<ref>{{cite web|url=https://www.python.org/dev/peps/pep-0008/#naming-conventions|title=Naming Conventions|accessdate=2017-10-06|archive-date=2018-07-13|archive-url=https://web.archive.org/web/20180713002451/https://www.python.org/dev/peps/pep-0008/#naming-conventions|dead-url=no}}</ref>：
* <code>_spam</code>（单下划线开头）：弱“内部使用”标识。对于<code>from M import *</code>，将不导入所有以下划线开头的对象。
* <code>spam_</code>（单下划线结尾）：为了避免与python关键字的命名冲突。
* <code>__spam</code>（双下划线开头）：在命名一个类[[特性_(计算机科学)|特性]]的时候，采用[[名字修饰|名字修饰]]，比如在类<code>SpamEggs</code>内，<code>__spam</code>将变成<code>_SpamEggs__spam</code><ref name="private-var" />。
* <code>__spam__</code>（双下划线开头双下划线结尾）：指那些包含在用户控制的[[命名空间|命名空间]]中的“魔术”对象或[[特性_(计算机科学)|特性]]，比如<code>__name__</code>、<code>__doc__</code>、<code>__init__</code>、<code>__import__</code>、<code>__file__</code>等。建议永远不要将这样的命名方式应用于自己的变量或函数。
在Python文献中经常使用的{{en-link|元语法变量|metasyntactic variable}}是{{en-link|肉罐头 (巨蟒剧团)|Spam (Monty Python)|spam和eggs}}而非传统的[[foobar|foo和bar]]<ref name="private-var">{{cite web |url=https://docs.python.org/3/tutorial/classes.html#private-variables |title=9.6. Private Variables |accessdate=2020-09-27 |archive-date=2012-10-23 |archive-url=https://web.archive.org/web/20121023030209/http://docs.python.org/tutorial/classes.html#private-variables |dead-url=no }}</ref>。

=== 語句和控制流 ===
Python的[[語句_(程式設計)|语句]]包括：
* [[赋值语句|赋值]]语句，记号为等号<code>=</code>。Python支持并行赋值，可以同时给多个变量赋值，还可以交换两个变量的值。{{efn|采用了并行赋值的[[斐波那契数列|斐波那契数列]]函数示例：
<syntaxhighlight lang="Python">
def fib(n):  # 写出从第0项到第n项的Fibonacci系列
    a, b, i = 0, 1, 0 
    while i <= n:
        print(a, end=' ')
        a, b, i = b, a+b, i+1
    print()
</syntaxhighlight>}}
* <code>del</code>语句，递归的进行删除。
* <code>pass</code>語句，充当[[NOP|NOP]]，表示此行為空，不執行任何操作。
* <code>[[斷言_(程式)|assert]]</code>語句，用於程式調適階段時測試執行條件是否滿足。
* <code>[[條件運算式|if]]</code>語句，當條件成立時執行語句塊。經常與<code>elif</code>、<code>else</code>配合使用。
* <code>[[Foreach循环|for]]</code>語句，遍历列表、字符串、字典、集合等[[迭代器|迭代器]]，依次處理迭代器中的每個元素。
* <code>[[While迴圈|while]]</code>語句，當條件為真時，循環執行語句塊。
* <code>break</code>语句，从循环中跳出。
* <code>continue</code>语句，越过这次迭代并继续进行下个项目。
* <code>{{en-link|异常处理语法|Exception handling syntax|try}}</code>語句，與<code>except</code>、<code>else</code>、<code>finally</code>配合使用，處理在程式執行中出现的異常情況。
* <code>raise</code>语句，抛出一个异常。
* <code>class</code>語句，用於定義[[类_(计算机科学)|類]]，它执行一块代码并将它的局部[[命名空间|命名空间]]附属至一个类。
* <code>def</code>語句，用於定義[[子程序|函數]]和[[方法_(计算机科学)|方法]]。
* <code>return</code>语句，用来从函数返回值。
* <code>yield</code>语句，使用它从一个[[生成器_(计算机编程)#Python|生成器]]中返回一个值。{{efn|产生素数的惰性生成器的示例：

<syntaxhighlight lang="python">
from itertools import count

def generate_primes(stop_at=0):
    if stop_at != 1:
        primes = [2]
        yield 2
    for n in count(3, 2):
        if 0 < stop_at < n:
            return # 引发StopIteration异常
        composite = False
        for p in primes:
            if not n % p:
                composite = True
                break
            elif p ** 2 > n:
                break
        if not composite:
            primes.append(n)
            yield n
</syntaxhighlight>

上述函数的隐式迭代用例：

<syntaxhighlight lang="python">
for i in generate_primes():  # 迭代于100以内所有素数上
    if i > 100:
        break
    print(i)
</syntaxhighlight>
在生成器表达式中使用上述函数，定义了一个惰性的、巨大而并非无限的搜集的示例： 
<syntaxhighlight lang="python">
from itertools import islice

primes_under_million = (i for i in generate_primes() if i < 1000000)
two_thousandth_prime = islice(primes_under_million, 1999, 2000) 
print(next(two_thousandth_prime))
</syntaxhighlight>
}}在版本2.5之前，生成器是[[求值策略|惰性]][[迭代器|迭代器]]，信息是单向的从生成器传递出来的。自从版本2.5，<code>yield</code>也是一个有返回值的运算符，能够将信息传递回到生成器函数中<ref name="AutoNT-57" />。自从版本3.3，信息可以传递通过多个堆栈层级<ref name="AutoNT-58">{{Cite web |url=https://www.python.org/dev/peps/pep-0380/ |title=PEP 380 -- Syntax for Delegating to a Subgenerator |accessdate=2019-11-21 |archive-date=2020-06-04 |archive-url=https://web.archive.org/web/20200604233821/https://www.python.org/dev/peps/pep-0380/ |dead-url=no }}</ref>。
* <code>with</code>語句，把一块代码包裹在一个上下文管理器之内。例如，在一块代码执行之前获取一个[[锁_(计算机科学)|锁]]并且在此后释放这个锁，或打开一个[[计算机文件|文件]]并且在此后关闭它。它允许了[[RAII|资源获取即初始化]]（RAII）式行为并可替代常见的<code>try</code>/<code>finally</code>惯用法<ref>{{Cite web |url=https://www.python.org/download/releases/2.5/highlights/ |title=Highlights: Python 2.5 |website=Python.org |accessdate=2020-09-21 |archive-date=2019-08-04 |archive-url=https://web.archive.org/web/20190804120408/https://www.python.org/download/releases/2.5/highlights/ |dead-url=no }}</ref>。
* <code>import</code>语句，导入一个模块或包。有三种用法：<code>import <<small>模块名字</small>> [as <<small>别名</small>>]</code>，<code>from <<small>模块名字</small>> import *</code>，<code>from <<small>模块名字</small>> import <<small>定义1</small>> [as <<small>别名1</small>>], <<small>定义2</small>> [as <<small>别名2</small>>], ...</code>。

在Python中赋值语句所进行的操作是将一个名字绑定为到一个分立的、动态分配的[[对象_(计算机科学)|对象]]的一个[[指针_(计算机编程)|引用]]。因为名字的存储位置不“包含”这个指示的值，称它为“变量”是不准确的。这个名字可以随后在任何时候重新绑定到极大不同的各种类型的对象上，包括字符串、过程、具有数据和方法的复杂对象等等。因为名字是通用的引用持有者，给它关联一个固定的[[类型系统|数据类型]]是不合理的。但是在给定时间一个名字总是被[[名字绑定|绑定]]到有一个类型的某个对象上，因此这是[[类型系统|动态类型]]。接连的把一个共同的值赋值给多个名字，比如<code>x = 2; y = 2; z = 2</code>，导致给3个名字和1个数对象分配存储，这3个名字都绑定到这1个数对象上。Python赋值语句的这种基础机制，不同于传统[[指令式编程|指令式编程]]语言比如[[C语言|C]]中的赋值，在这里右手侧的值被复制到给这个变量[[内存管理|分配的存储位置]]之中，等号左手侧的[[变量_(程序设计)|变量名字]]是其符号地址，对为它声明的[[类型系统|类型]]而言分配给它的内存是足够大的。

Python支持并广泛使用[[异常处理|异常处理]]作为检测错误状况和程序中其他“异常”事件的方式。Python风格提倡在可能出现错误状况的任何时候都使用异常。在Python中习惯上不在使用之前对访问一个文件或资源进行测试，而是先行尝试使用它，再捕获访问被拒绝引发的异常。{{efn|遵循EAFP风格的异常处理示例：

<syntaxhighlight lang="python">
f = None
try:
    f = open("aFileName", mode="w")
    f.write(could_make_error()) # 不存在could_make_error()则产生错误
except IOError as error:
    print(error)
    print("不能打开文件")
except:  # 捕获所有异常
    print("未预期的错误")
else:  # 在没有出现异常时执行
    print("文件写入完全成功")
finally:  # 清除行动，总是执行
    if f:
        f.close()
</syntaxhighlight>}}
经常为此援引的格言是[[葛麗絲·霍普|葛麗絲·霍普]]贡献的EAFP<ref>{{cite web |archiveurl= https://web.archive.org/web/20090114165606/http://www.chips.navy.mil/archives/86_jul/interview.html |archivedate= 2009-01-14 |url= http://www.chips.navy.mil/archives/86_jul/interview.html |title= Only the Limits of Our Imagination: An exclusive interview with RADM Grace M. Hopper |publisher= Department of the Navy Information Technology Magazine |first= Diane |last= Hamblen |accessdate= 2007-01-31 |dead-url= no }}</ref>：“请求原谅比许可更容易”<ref>"It is Easier to Ask for Forgiveness than Permission" [https://docs.python.org/glossary.html#term-eafp EAFP] {{Wayback|url=https://docs.python.org/glossary.html#term-eafp |date=20121026064048 }}, Python Glossary</ref><ref name="nutshell">{{cite book|title=Python in a nutshell|author=[[Alex_Martelli|Alex Martelli]]|url=https://books.google.com/books?id=JnR9hQA3SncC&pg=PA134|page=134|access-date=2020-09-26|archive-date=2022-05-13|archive-url=https://web.archive.org/web/20220513235141/https://books.google.com/books?id=JnR9hQA3SncC&pg=PA134}}</ref>。Python使用<code>with</code>语句处理资源<ref>{{Cite web |url=https://www.python.org/dev/peps/pep-0343/ |title=The "with" Statement |access-date=2020-09-26 |archive-date=2014-12-14 |archive-url=https://web.archive.org/web/20141214110002/https://www.python.org/dev/peps/pep-0343/ |dead-url=no }}</ref>，在进入一个作用域的时候调用一个函数而在离开它的时候调用另一个函数。这能防止忘记移除资源并且还可处理更复杂的状况比如异常。{{efn|使用<code>with</code>将文件作为资源来管理的示例：

<syntaxhighlight lang="python">
from contextlib import contextmanager
@contextmanager
def opened(filename, mode="r"):
    try:
        f = open(filename, mode)
    except IOError as error:
         print(error)
         yield None
    else:
        try:
            yield f
        finally:
            f.close()

with opened("aFileName", mode="w") as f:
    try:
        f.write(could_make_error()) # 不存在could_make_error()则产生错误
    except AttributeError:
        print("不能打开文件")
    except:  # 捕获所有异常
        print("未预期的错误")
    else:  # 在没有出现异常时执行
        print("文件写入完全成功")
</syntaxhighlight>}}

Python官方实现不提供[[尾调用|尾调用]]优化或[[计算续体|头等续体]]，吉多·范罗苏姆曾声称永远都不会加以支持<ref name="AutoNT-55">{{cite web |last=van Rossum |first=Guido |url=http://neopythonic.blogspot.be/2009/04/tail-recursion-elimination.html |title=Tail Recursion Elimination |publisher=Neopythonic.blogspot.be |date=2009-04-22 |accessdate=2012-12-03 |archive-date=2018-05-19 |archive-url=https://web.archive.org/web/20180519225253/http://neopythonic.blogspot.be/2009/04/tail-recursion-elimination.html |dead-url=no }}<br />{{cite web |title=Language Design Is Not Just Solving Puzzles |url=http://www.artima.com/weblogs/viewpost.jsp?thread=147358 |first=Guido |last=van Rossum |date=2006-02-09 |accessdate=2007-03-21 |work=Artima forums |publisher=Artima |archive-date=2020-01-17 |archive-url=https://web.archive.org/web/20200117182525/https://www.artima.com/weblogs/viewpost.jsp?thread=147358 |dead-url=no }}</ref>，目前只有第三方库支持<ref>{{cite web|author=Thomas Baruchel|title=tco－Tail Call Optimization for Python|url=https://github.com/baruchel/tco|quote=The module allows a coder to write tail-recursive functions as well as using continuation-passing style in his/her code without having the size of the execution stack increasing.|access-date=2021-10-14|archive-date=2022-04-15|archive-url=https://web.archive.org/web/20220415045535/https://github.com/baruchel/tco}}</ref>。Python在版本2.5中通过扩展[[生成器_(计算机编程)|生成器]]，提供了对[[协程|协程]]式功能的更好支持<ref name="AutoNT-57">{{Cite web |url=https://www.python.org/dev/peps/pep-0342/ |title=PEP 342 -- Coroutines via Enhanced Generators |accessdate=2019-11-21 |archive-date=2020-05-29 |archive-url=https://web.archive.org/web/20200529003739/https://www.python.org/dev/peps/pep-0342/ |dead-url=no }}</ref>。{{efn|用生成器模拟协程示例：
<syntaxhighlight lang="Python">
def produce(n):
    try:
        for item in range(n):
            print('producing item {} ->'.format(item)) 
            yield item
    except GeneratorExit:
        return

def consume():
    item = None
    try:
        while True:
            item = yield item
            print('consuming item {} <-'.format(item))
    except GeneratorExit:
        return

t1 = produce(10)
t2 = consume()
next(t2)
try:
    while True:
        a = t1.send(None)
        b = t2.send(a)
except StopIteration:
    pass
</syntaxhighlight>
}}版本3.4介入了综合性的[[异步I/O|异步I/O]]框架标准化，在其中扩展了利用子生成器委托的协程<ref>{{Cite web |url=https://www.python.org/dev/peps/pep-3156/#coroutines |title=PEP 3156 -- Asynchronous IO Support Rebooted: the "asyncio" Module |accessdate=2019-11-21 |archive-date=2019-11-14 |archive-url=https://web.archive.org/web/20191114154241/https://www.python.org/dev/peps/pep-3156/#coroutines |dead-url=no }}</ref>，这个扩展自从Python 3.8被弃用<ref>{{cite web|url=https://docs.python.org/3/library/asyncio-task.html#generator-based-coroutines|title=Generator-based Coroutines|quote=Support for generator-based coroutines is deprecated and is scheduled for removal in Python 3.10.|accessdate=2020-10-29|archive-date=2018-12-31|archive-url=https://web.archive.org/web/20181231143720/https://docs.python.org/3/library/asyncio-task.html#generator-based-coroutines|dead-url=no}}</ref>。Python 3.5通过[[async/await|async/await]]语法介入了对协程的显式支持<ref>{{Cite web |url=https://www.python.org/dev/peps/pep-0492/ |title=PEP 492 -- Coroutines with async and await syntax |accessdate=2019-11-21 |archive-date=2019-01-05 |archive-url=https://web.archive.org/web/20190105061843/https://www.python.org/dev/peps/pep-0492/ |dead-url=no }}</ref>。从版本3.7开始async/await成为保留关键字<ref>{{Cite web |url=https://docs.python.org/3/whatsnew/3.7.html#summary-release-highlights |title=What’s New In Python 3.7 |accessdate=2019-11-21 |archive-date=2019-11-28 |archive-url=https://web.archive.org/web/20191128153844/https://docs.python.org/3/whatsnew/3.7.html#summary-release-highlights |dead-url=no }}</ref>。{{efn|原生的协程示例：
<syntaxhighlight lang="Python">
import asyncio
import random

async def produce(queue, n):
    for item in range(n):
        # 生产一个项目，使用sleep模拟I/O操作
        print('producing item {} ->'.format(item)) 
        await asyncio.sleep(random.random())
        # 将项目放入队列
        await queue.put(item)
    # 指示生产完毕
    await queue.put(None)

async def consume(queue):
    while True:
        # 等待来自生产者的项目
        item = await queue.get()
        if item is None:
            break
        # 消费这个项目，使用sleep模拟I/O操作
        print('consuming item {} <-'.format(item))
        await asyncio.sleep(random.random()) 

async def main():
    queue = asyncio.Queue()
    task1 = asyncio.create_task(produce(queue, 10))
    task2 = asyncio.create_task(consume(queue))
    await task1
    await task2

asyncio.run(main())
</syntaxhighlight>}}

[[模块化编程|模块]]是定义可以被导入并重用于其他Python程序中的函数和类的Python正规<code>.py</code>文件<ref name="modules">{{Cite web |url=https://docs.python.org/3/tutorial/modules.html |title=Python.org: Modules |accessdate=2020-10-30 |archive-date=2021-02-06 |archive-url=https://web.archive.org/web/20210206205133/https://docs.python.org/3/tutorial/modules.html |dead-url=no }}</ref>。<code>import</code>语句找到一个模块，装载它，如果有需要的话初始化它，并且定义用来引用这个模块中代码的一个名字或一些名字<ref name="import">{{Cite web |url=https://docs.python.org/3/reference/simple_stmts.html#import |title=Python.org: The import Statement |accessdate=2020-10-30 |archive-date=2021-02-07 |archive-url=https://web.archive.org/web/20210207193620/https://docs.python.org/3/reference/simple_stmts.html#import |dead-url=no }}</ref>。<code>from...import</code>语句，找到、装载、必需时初始化一个模块，接着增加模块引用到局部[[命名空间|命名空间]]，允许访问其中的函数和类而不采用模块引用<ref name="import" />。<code>from ... import</code>支持<code>*</code>选项来导入所有引用而非指名的特定函数或类<ref name="modules" />。当模块被导入的时候，<code>__name__</code>变量被设置成这个模块的名字。在Python解释器直接运行一个模块的时候，<code>__name__</code>变量被设置为<code>"__main__"</code>。这允许被设计用于导入的模块增加只在模块被直接运行时候执行的代码<ref name="modules" /><ref>{{Cite web |url=https://docs.python.org/3/library/__main__.html |title=Python.org: __main__ |accessdate=2020-10-30 |archive-date=2021-02-07 |archive-url=https://web.archive.org/web/20210207193551/https://docs.python.org/3/library/__main__.html |dead-url=no }}</ref>。<code>dir()</code>函数返回在当前局部作用域中或参数指定的对象中的名字的列表<ref>{{Cite web |url=https://docs.python.org/3/library/functions.html#dir |title=Python.org: Dir() |accessdate=2020-09-25 |archive-date=2018-10-26 |archive-url=https://web.archive.org/web/20181026035007/https://docs.python.org/3/library/functions.html#dir |dead-url=no }}</ref>。

=== 表达式 ===
Python中很多表达式与[[C语言|C]]和[[java|java]]类似，而另一些则与之不同。

*在Python中，[[算术|算术]]运算的加法<code>+</code>、减法<code>-</code>、乘法<code>*</code>和[[模除|取模]]<code>%</code>是与[[C语言|C]]和[[java|java]]相同的，但是除法的行为不同。在Python中有两种除法，它们是[[取整函数|下取整]]除法（或整数除法）<code>//</code>和浮点除法<code>/</code><ref>{{cite web|title=division|url=https://docs.python.org|website=python.org|accessdate=2014-10-17|archive-date=2006-07-20|archive-url=https://web.archive.org/web/20060720033244/http://docs.python.org/|dead-url=no}}</ref> 。Python增加了指数算符<code>**</code>。Python有如下必须用于整数的[[位操作|位]]运算：<code>&</code>与（AND），<code>|</code>或（OR），<code>~</code>非（NOT），<code>^</code>异或（XOR），<code>>></code>右移, <code><<</code>左移。自从Python 3.5<ref name=Python3.5Changelog>{{cite web |title=Python 3.5.1 Release and Changelog |url=https://www.python.org/downloads/release/python-351/ |website=python.org |accessdate=2016-01-01 |archive-date=2020-05-14 |archive-url=https://web.archive.org/web/20200514034938/https://www.python.org/downloads/release/python-351/ |dead-url=no }}</ref>，介入了新的<code>@</code>中缀[[矩阵乘法|矩阵乘法]]算符<ref name=PEP465>{{cite web |title=PEP 0465 -- A dedicated infix operator for matrix multiplication |url=https://www.python.org/dev/peps/pep-0465/ |website=python.org |accessdate=2016-01-01 |archive-date=2020-06-04 |archive-url=https://web.archive.org/web/20200604224255/https://www.python.org/dev/peps/pep-0465/ |dead-url=no }}</ref>，它已经用于了[[NumPy|NumPy]]库<ref>{{cite web|url=https://numpy.org/doc/stable/reference/generated/numpy.matmul.html|title=numpy.matmul|access-date=2022-01-18|archive-date=2022-04-10|archive-url=https://web.archive.org/web/20220410040855/https://numpy.org/doc/stable/reference/generated/numpy.matmul.html}}</ref>。

*在Python中，有如下[[关系运算子|比较]]运算：大于<code>></code>，小于<code><</code>，等于<code>==</code>，不等于<code>!=</code>，小于等于<code><=</code>，大于等于 <code>>=</code>。<code>==</code>按值比较，对比于Java，它按值比较数<ref>{{cite web |url=https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.21.1 |title=Chapter 15. Expressions - 15.21.1. Numerical Equality Operators == and != |publisher=[[Oracle_Corporation|Oracle Corporation]] |accessdate=2016-08-28 |archive-date=2020-06-07 |archive-url=https://web.archive.org/web/20200607025322/https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.21.1 |dead-url=no }}</ref>而按引用比较对象<ref>{{cite web |url=https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.21.3 |title=Chapter 15. Expressions - 15.21.3. Reference Equality Operators == and != |publisher=Oracle Corporation |accessdate=2016-08-28 |archive-date=2020-06-07 |archive-url=https://web.archive.org/web/20200607025322/https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.21.3 |dead-url=no }}</ref>（在Java中比较对象的值可以采用<code>equals()</code>方法）。Python的<code>is</code>、<code>is not</code>算符可以用来比较对象的同一性（按引用比较），也就是比较两个变量是否引用了同一个对象。而<code>in</code>、<code>not in</code>用于判断一个对象是否属于另外一个对象。在Python中，比较是可以链接起来的，比如<code>a <= b <= c</code>。

* Python使用<code>and</code>、<code>or</code>、<code>not</code>表示[[逻辑代数|逻辑]]运算与、或、非，不采用Java和C中所用的符号<code>&&</code>、<code>||</code>、<code>!</code>。

* 自从Python 3.8，介入了“赋值表达式”语法<code>:=</code>。它也叫做“命名表达式”或“海象”，它将一个表达式赋值给一个标识符，同时还返回这个表达式的值，常用作更大的表达式的一部份<ref name=Python3.8Changelog>{{cite web |title=What’s New in Python 3.8 － Assignment expressions |url=https://docs.python.org/3.8/whatsnew/3.8.html#assignment-expressions |accessdate=2019-10-14 |archive-date=2020-06-08 |archive-url=https://web.archive.org/web/20200608124345/https://docs.python.org/3.8/whatsnew/3.8.html#assignment-expressions |dead-url=no }}</ref>。

*自从Python 3.9，介入了字典归并算符<code>|</code>和更新算符<code>|=</code><ref name=Python3.9Changelog>{{cite web |title=What’s New in Python 3.9 － Dictionary Merge & Update Operators |url=https://docs.python.org/3/whatsnew/3.9.html#dictionary-merge-update-operators |accessdate=2021-06-12 |dead-url=no |archive-date=2020-10-07 |archive-url=https://web.archive.org/web/20201007172936/https://docs.python.org/3/whatsnew/3.9.html#dictionary-merge-update-operators }}</ref>。

* Python支持[[列表推导式|列表推导式]]。{{efn|列表的推导式示例。比如：

<syntaxhighlight lang="Pycon">
>>> [x + 3 for x in range(4)]
[3, 4, 5, 6]
</syntaxhighlight>

[[快速排序|快速排序]]算法可以优雅的（尽管不高效的）使用列表推导式表达为：

<syntaxhighlight lang="python">
def qsort(L):
    if L == []:
        return []
    pivot = L[0]
    return (qsort([x for x in L[1:] if x < pivot]) +
            [pivot] +
            qsort([x for x in L[1:] if x >= pivot]))
</syntaxhighlight>
}}Python 2.4将列表推导式扩展至更一般性的[[生成器_(计算机编程)#Python|生成器表达式]]<ref name="AutoNT-59">{{cite web |url=https://www.python.org/dev/peps/pep-0289/ |title=PEP 289 – Generator Expressions |last=Hettinger |first=Raymond |date=2002-01-30 |work=Python Enhancement Proposals |publisher=Python Software Foundation |accessdate=2012-02-19 |archive-date=2020-06-14 |archive-url=https://web.archive.org/web/20200614153717/https://www.python.org/dev/peps/pep-0289/ |dead-url=no }}</ref>。{{efn|生成器表达式示例。比如：

<syntaxhighlight lang="Pycon">
>>> sum(x * x for x in range(10))
285
>>> dict((n, n*n) for n in range(5))
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
>>> set(n*n for n in range(5))
{0, 1, 4, 9, 16}
</syntaxhighlight>
}}Python 3.0和2.7又补全了[[列表推导式#字典推导式|字典推导式]]和[[列表推导式#集合推导式|集合推导式]]。{{efn|字典推导式<code>{expr1: expr2 for k, v in d}</code>，等价于：
<syntaxhighlight lang="Python">
result={}
for k, v in d.items():
    result[expr1]=expr2
return result
</syntaxhighlight>

<syntaxhighlight lang="Pycon">
>>> {x: x + 3 for x in range(4)}
{0: 3, 1: 4, 2: 5, 3: 6}
</syntaxhighlight>

集合推导式<code>{expr1 for x in stuff}</code>，等价于：
<syntaxhighlight lang="python">
result = set()
for x in stuff:
    result.add(expr1)
return result
</syntaxhighlight>

<syntaxhighlight lang="Pycon">
>>> {x + 3 for x in range(4)}
{3, 4, 5, 6}
</syntaxhighlight>}}

* Python的[[匿名函数|匿名函数]]实现为<code>lambda</code>表达式。匿名函数体只能是一个表达式。{{efn|匿名函数示例：
<syntaxhighlight lang="Pycon">
>>> from functools import reduce
>>> reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) 
15
>>> fac = lambda n: (1 if n<2 else n*fac(n-1))
>>> fac(5)
120
>>> [*map(fac, [1, 2, 3, 4, 5])]
[1, 2, 6, 24, 120]
</syntaxhighlight>
[[不动点组合子|不动点组合子]]示例：
<syntaxhighlight lang="Pycon">
>>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))
>>> fac = lambda f: lambda n: (1 if n<2 else n*f(n-1))
>>> Y(fac)(5)
120
>>> fib = lambda f: lambda n: 0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2))
>>> Y(fib)(6)
8
>>> [*map((lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args))))(lambda f: lambda n: (1 if n<2 else n*f(n-1))), [1, 2, 3, 4, 5])]
[1, 2, 6, 24, 120]
</syntaxhighlight>
上述Y组合子代码源出自{{cite web|url=https://rosettacode.org/wiki/Y_combinator#Python|title=Rosetta Code|accessdate=2020-10-21|archive-date=2021-01-11|archive-url=https://web.archive.org/web/20210111053401/http://www.rosettacode.org/wiki/Y_combinator#Python|dead-url=no}}其原理可参见{{cite web|url=http://matt.might.net/articles/python-church-y-combinator/|title=Equational derivations of the Y combinator and Church encodings in Python|accessdate=2020-10-21|archive-date=2020-11-12|archive-url=https://web.archive.org/web/20201112034237/http://matt.might.net/articles/python-church-y-combinator/|dead-url=no}}}}
* Python的[[条件运算符|条件表达式]]表示为<code>x if c else y</code>。意思是当<code>c</code>为真时，表达式的值为<code>x</code>，否则表达式的值为<code>y</code>。 在运算数的次序上不同于很多其他语言中常见的<code>c ? x : y</code>。

* Python区分列表（list）和元组（tuple）两种类型。列表的写法是<code>[1,2,3]</code>，而元组的写法是<code>(1,2,3)</code>。在没有歧义的情况下，元组的圆括号是可选的，一个元素的元组向这个元素尾随一个逗号例如<code>(1,)</code><ref>{{cite web|title=4. Built-in Types — Python 3.6.3rc1 documentation|url=https://docs.python.org/3/library/stdtypes.html#tuple|website=python.org|accessdate=2017-10-01|archive-date=2020-06-14|archive-url=https://web.archive.org/web/20200614194325/https://docs.python.org/3/library/stdtypes.html#tuple|dead-url=no}}</ref>。列表是可变的，并且不能用作字典的键（Python中字典的键必须是[[不可变对象|不可变]]的）。元组是不可变的，因而可以用作字典的键，假定这个元组的所有元素都是不可变的话。可以使用<code>+</code>算符来串接二个元组，这不会直接修改它们的内容，而是产生包含给定元组二者的元素的一个新元组。因此，给定变量<code>t</code>初始时等于<code>(1, 2, 3)</code>，执行<code>t = t + (4, 5)</code>时，首先求值<code>t + (4, 5)</code>，它产生<code>(1, 2, 3, 4, 5)</code>，接着赋值回到<code>t</code>，这在效果上“修改了”<code>t</code>的内容，尽管这还是遵守了元组对象的不可变本性。

*Python有“序列解包”特征，多个表达式，其中每个都可求值成能被赋值的东西（变量、可写的属性等），以与形成元组文字（literal）相同的方式，关联起来作为一个整体，放置在赋值语句等号的左手侧。这个语句预期在等号的右手侧有一个“可迭代”对象，在迭代它的时候产生同左手侧给出的可写表达式相同数目的值，这个语句对它进行迭代并把每个产生的值赋值给左手侧对应的表达式<ref>{{cite web|title=5.3. Tuples and Sequences — Python 3.7.1rc2 documentation|url=https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences|website=python.org|accessdate=2018-10-17|archive-date=2020-06-10|archive-url=https://web.archive.org/web/20200610050047/https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences|dead-url=no}}</ref>。这个特征允许从一个单一函数返回多个值。自从Python 3.5，增加了在表达式列表中的“可迭代解包”<code>*</code>和在字典显示中的“字典解包”<code>**</code>。{{efn|序列解包、可迭代解包和字典解包示例：
<syntaxhighlight lang="Pycon">
>>> a = [1, 2, 3]; b = [4, 5]
>>> i, j, k = a
>>> print(i, j, k)
1 2 3
>>> c = [*a, b]
>>> c
[1, 2, 3, [4, 5]]
>>> d = {*a, *b}
>>> d
{1, 2, 3, 4, 5}
>>> e = (*a, *b)
>>> e
(1, 2, 3, 4, 5)
>>> f = {"as":1, "bs":2 }; g = {"cs":3, "ds":4}
>>> h = {**f, **g}
>>> h
{'as': 1, 'bs': 2, 'cs': 3, 'ds': 4}
</syntaxhighlight>}}
* Python拥有“字符串格式”算符<code>%</code>。这个功能类同于[[C语言|C]]中的<code>printf</code>[[格式化字符串|格式化字符串]]，比如<code>"spam=%s eggs=%d" % ("blah", 2)</code>求值成<code>"spam=blah eggs=2"</code>。在Python 3和2.6+中，这通过<code>str</code>类的<code>format()</code>方法来提供，比如<code>"spam={0} eggs={1}".format("blah", 2)</code>。Python 3.6增加了“f-字符串”<ref name="pep-0498">{{cite web |title=PEP 498 -- Literal String Interpolation |url=https://www.python.org/dev/peps/pep-0498/ |website=python.org |accessdate=2017-03-08 |archive-date=2020-06-15 |archive-url=https://web.archive.org/web/20200615184141/https://www.python.org/dev/peps/pep-0498/ |dead-url=no }}</ref>：<code>blah = "blah"; eggs = 2; f'spam={blah} eggs={eggs}'</code>。{{efn|格式化字符串的示例，例如下列命令行<code>echo</code>命令：
<syntaxhighlight lang="bash">
num="3"; printer="HP Laserjet"
echo "I just printed ${num} pages to the printer ${printer}"
</syntaxhighlight>

等价于如下Python中的任何一种<code>print</code>函数调用：
<syntaxhighlight lang="python">
num = 3; printer="HP Laserjet"
print(f"I just printed {num} pages to the printer {printer}")

print("I just printed {} pages to the printer {}".format(num, printer))
print("I just printed {0} pages to the printer {1}".format(num, printer))
print("I just printed {num} pages to the printer {printer}".format(num=num, printer=printer))

print("I just printed %s pages to the printer %s" % (num, printer))
print("I just printed %(num)s pages to the printer %(printer)s" % {"num": num, "printer": printer})

</syntaxhighlight>}}
* Python拥有各种{{en-link|字符串文字|string literal}}:
** 由单引号<code>'</code>或双引号<code>"</code>界定的字符串。不同于[[Unix_shell|Unix shell]]、[[Perl|Perl]]和受Perl影响的语言，单引号和双引号功能相同。这二种字符串都使用反斜杠<code>\</code>作为[[转义字符|转义字符]]。在Python 3.6中{{en-link|字符串插值|String interpolation}}可作为“格式化字符串”而获得到<ref name="pep-0498"/>。
** 三引号字符串，开始和结束于三个单引号或双引号的序列。它们可以跨越多行，其功能就像shell、Perl和[[Ruby|Ruby]]中的[[here文档|here文档]]。{{efn|多行字符串文字带有{{en-link|字符串插值|String interpolation}}（使用了<code>format</code>方法）的示例：
<syntaxhighlight lang="python">
print("""亲爱的{recipient},

我希望你离开Sunnydale并永不返回.

不是很爱你的,
{sender}
""".format(sender="吸血鬼猎人Buffy", recipient="Spike"))
</syntaxhighlight>}}
** {{en-link|字符串文字#原始字符串|String literal#Raw strings|原始字符串}}变体，用给字符串文字前导一个<code>r</code>来指示。转义序列不被解释，因此在文字反斜杠常见的地方很有用，比如[[正则表达式|正则表达式]]和[[Microsoft_Windows|Windows]]风格的路径。{{efn|原始字符串的示例：
<syntaxhighlight lang="pycon">
>>> # Windows路径，即使是原始字符串也不能结束于反斜杠
>>> r"C:\Spam\Eggs\Ham\"
  File "<stdin>", line 1
    r"C:\Spam\Eggs\Ham\"
                       ^
SyntaxError: EOL while scanning string literal
>>> dos_path = r"C:\Spam\Eggs\Ham\ " # 通过增加尾随的空格
>>> dos_path.rstrip()              # 并接着移除它来避免错误
'C:\\Spam\\Eggs\\Ham\\'
>>> quoted_dos_path = r'"{}"'.format(dos_path)
>>> quoted_dos_path
'"C:\\Spam\\Eggs\\Ham\\ "'
>>> # 匹配具有可能的反斜杠引用的引用字符串的正则表达式
>>> import re
>>> re.match(r'"(([^"\\]|\\.)*)"', quoted_dos_path).group(1).rstrip()
'C:\\Spam\\Eggs\\Ham\\'
>>> code = 'spam(2, eggs)'
>>> # 反转有二个参数的函数调用的两个实际参数
>>> re.sub(r'\(([^,]*),\s*([^,]*)\)', r'(\2, \1)', code)
'spam(eggs, 2)'
>>> # 注意如果实际参数中有圆括号或逗号则上例无效。
</syntaxhighlight>}}可比较于[[C_Sharp|C#]]中的“<code>@</code>-引用”。
*Python允许连续出现和只用空白分隔（包括换行）的字符串文字（可能使用了不同的引用约定），它们被聚合成一个单一的更长的字符串<ref>{{cite web |url=https://docs.python.org/reference/lexical_analysis.html#string-literal-concatenation |title=2. Lexical analysis |work=Python v2.7.5 documentation |publisher=Docs.python.org |date= |accessdate=2013-08-16 |archive-url=https://web.archive.org/web/20121023010739/http://docs.python.org/reference/lexical_analysis.html#string-literal-concatenation |archive-date=2012-10-23 |dead-url=no }}</ref>。{{efn|字符串文字串接示例：

<syntaxhighlight lang="pycon">
>>> title = "SICP in Python"" － " \
...         'CS61A: Online Textbook'
</syntaxhighlight>
等价于：
<syntaxhighlight lang="pycon">
>>> title = "SICP in Python － CS61A: Online Textbook"
</syntaxhighlight>}}

* Python拥有在列表上的[[数组|数组索引]]和{{en-link|数组分片|array slicing}}表达式，表示为<code>a[key]</code>、<code>a[start:stop]</code>或<code>a[start:stop:step]</code>。索引是[[從零開始的編號|基于零]]的，负数是相对于结尾的。分片从“开始”（start）索引直到但不包括“停止”（stop）索引。分片的第三个参数叫做“步长”（step）或“间隔”（stride），允许元素被跳过和用负数指示反向。分片索引可以省略，例如<code>a[:]</code>，这返回整个列表的一个复本。{{efn|下面几个判断语句为真，表示列表分片结果符合预期：
<syntaxhighlight lang="Pycon">
>>> nums = [1, 3, 5, 7, 8, 13, 20]
>>> nums[2:5] == [5, 7, 8] #从下标为2的元素切割到下标为5的元素，但不包含下标为5的元素。
True
>>> nums[1:] == [3, 5, 7, 8, 13, 20] #切割到最后一个元素。
True
>>> nums[:-3] == [1, 3, 5, 7] #从最开始的元素一直切割到倒数第3个元素。
True
>>> nums[:] == [1, 3, 5, 7, 8, 13, 20] #返回所有元素。改变新的列表不会影响到nums。
True
>>> nums[1:5:2] == [3, 7] #从下标为1的元素切割到下标为5的元素，但不包含下标为5的元素，且步长为2。
True
</syntaxhighlight>}}分片的每个元素都是{{en-link|对象复制|Object copying|浅层复制}}的。

在Python中，在表达式和语句之间的区别是严格强制性的，对比于语言如[[Common_Lisp|Common Lisp]]、[[Scheme|Scheme]]或[[Ruby|Ruby]]。这导致重复了某些功能。比如：[[列表推导式|列表推导式]]对当<code>for</code>循环。[[条件运算式|条件]]表达式对当<code>if</code>块。<code>eval()</code>对当<code>exec()</code>内建函数（在Python 2中，<code>exec</code>是语句）；前者用于表达式，后者用于语句。

语句不能成为表达式的一部份，所以列表和其他推导式或[[匿名函数|lambda表达式]]，都是表达式，不能包含语句。这个限制的一个特定情况是赋值语句比如<code>a = 1</code>，不能形成条件语句的条件表达式的一部份。这能够避免一个经典的C错误，即在条件中把等于算符<code>==</code>误写为赋值算符<code>=</code>，<code>if (c = 1) { ... }</code>在语法上是有效（但可能非预期）的C代码，而<code>if c = 1: ...</code>在Python中导致一个语法错误。

=== 函数 ===
Python的函数支持[[递归|递归]]和[[闭包_(计算机科学)|闭包]]{{efn|词法闭包的例子：
<syntaxhighlight lang="python">
def f(x):
    def g(y):
        return x + y
    return g  # 返回一个闭包。

h = lambda x: lambda y: x + y

# 将指定闭包赋值给变量。
a = f(1)
b = h(1)
c = f(2)
# 使用存储在变量中的闭包。
assert a(5) == 6
assert b(5) == 6
assert c(5) == 7
# 使用闭包而不事先把它们绑定到变量。
assert f(1)(5) == 6  # f(1)是个闭包。
assert h(1)(5) == 6  # h(1)是个闭包。
assert f(2)(5) == 7  # f(2)是个闭包。
</syntaxhighlight>}}及其他[[头等函数|头等函数]]特征，但不支持[[函数重载|函数重载]]。Python的函数作为[[头等对象|头等对象]]，具有和普通对象平等的地位。Python的函数实际参数与形式参数之间的结合是传递“对象的引用”，就是把形式参数名字绑定到实际参数名字所引用的对象上。如果形式参数绑定到一个可变的对象，则通过形式参数对此对象内容的修改，在函数外也是可见的。如果形式参数绑定到一个不可变的对象，则通过形式参数是不能修改此对象内容，但可以把形式参数重新绑定到其它对象上，这并不影响函数外的对象的值。{{efn|函数的形实参数二者结合示例。例如：
<syntaxhighlight lang="pycon">
>>> def spam(a):
...     a.append('LovelySpam')
...     
>>> def eggs(b):
...     b=100 #实际上是重新绑定了另一个整型对象100
... 
>>> a=[]
>>> b=10
>>> spam(a)
>>> eggs(b)
>>> print(a)
['LovelySpam']
>>> print(b)
10
</syntaxhighlight>}}
 
Python的变量有函数作用域、模块作用域和全局作用域。简单访问（不赋值）一个变量的时候，名字解析服从窄到宽的LEGB（局部、包围、全局、内建）顺位规则。在函数中赋值一个变量将导致它成为这个函数的局部变量，就是说它的作用域在整个函数中，而不是在这个赋值之后至这个函数结束，因此在这个赋值之前引用它，不再于这个函数之外查找同名变量而是引发一个错误。缺省的名字解析规则可以用<code>global</code>或<code>nonlocal</code>关键字来覆盖。<code>global</code>声明的变量是全局变量。{{efn|局部变量和全局变量示例：
<syntaxhighlight lang="pycon">
>>> def spam():
...     print(b)
...
>>> b=10
>>> spam()
10
>>> def spam():
...     print(b)
...     b=100 
...
>>> b=10
>>> spam()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in spam
UnboundLocalError: local variable 'b' referenced before assignment
>>> def spam():
...     print(b)
...     global b
...     b=100
... 
  File "<stdin>", line 3
SyntaxError: name 'b' is used prior to global declaration
>>> def spam():
...     global b
...     print(b)
...     b=100
... 
>>> b=10
>>> spam()
10
>>> b
100
</syntaxhighlight>}}
<code>global</code>可以用于嵌套的函数中。嵌套函数中还可以使用<code>nonlocal</code>声明，用于赋值到给{{en-link|非局部变量|Non-local variable}}。{{efn|非局部变量示例：
<syntaxhighlight lang="pycon">
>>> def spam():
...     def eggs():
...         global b
...         print(b)
...         b=1000
...     b=100 # 对eggs()而言是非局部变量
...     eggs()
...
>>> b=10
>>> spam()
10
>>> b
1000
>>> def spam():
...     def eggs():
...         nonlocal b 
...         b=1000
...     b=100 # 对eggs()而言是非局部变量
...     eggs()
...     print(b)
...
>>> b=10
>>> spam()
1000
>>> b
10
</syntaxhighlight>}}

Python可以指定形式参数的缺省值，在函数定义时于形式参数序列中以<code>param=value</code>样式进行一次性初始化。形式参数在初始化之后保持既有绑定，函数的后续调用可继续对它进行访问或变更。{{efn|函数的形式参数缺省值的持久性示例：
<syntaxhighlight lang="pycon">
>>> def f(a, L=[]):
...     L.append(a)
...     return L
... 
>>> print(f(1))
[1]
>>> print(f(2))
[1, 2]
>>> print(f(3))
[1, 2, 3]
</syntaxhighlight>
}}在函数调用时为有缺省值的形式参数提供实际参数是可选的。Python支持位置实际参数和关键字实际参数。函数调用时，实际参数可以如同C语言那样按照位置与形式参数匹配；也可以采用{{le|命名参数|Named parameter}}（或称为关键字实际参数），即<code>kwarg=value</code>样式的实际参数。使用不对应实际参数的特殊形式参数<code>/</code>和<code>*</code>，可以将参数序列分为唯位置参数<ref>{{cite web|url=https://docs.python.org/3.8/whatsnew/3.8.html#positional-only-parameters|title=Positional-only parameters|access-date=2020-09-24|archive-date=2020-06-08|archive-url=https://web.archive.org/web/20200608124345/https://docs.python.org/3.8/whatsnew/3.8.html#positional-only-parameters}}</ref>、可位置可关键字参数和唯关键字参数三部份。有缺省值的形式参数之后不能跟随无缺省值的可位置形式参数。{{efn|函数的形式参数缺省值的定义示例：
<syntaxhighlight lang="pycon">
>>> from inspect import getfullargspec
>>> def func(p1, /, p2, p3="x", *, p4): pass
... 
>>> getfullargspec(func)
FullArgSpec(args=['p1', 'p2', 'p3'], varargs=None, varkw=None, defaults=('x',), kwonlyargs=['p4'], kwonlydefaults=None, annotations={})
</syntaxhighlight>}}在一个函数调用的实际参数序列中，关键字实际参数必须出现在位置实际参数之后。

在位置和关键字形式参数序列末尾可以分别有<code>*args</code>或<code>**kwargs</code>这样的形式参数，它们对应于在函数调用时提供的，超出形式参数序列规定而无所对应的多个实际参数；在形式参数名字前加一个<code>*</code>号，该形式参数<code>args</code>是<code>tuple</code>类型，对应可变数目的位置实际参数；在形式参数名字前加<code>**</code>号，该形式参数<code>kwargs</code>是<code>dict</code>类型，对应可变数目的关键字实际参数。{{efn|函数的可变参数的定义示例：
<syntaxhighlight lang="pycon">
>>> from inspect import getfullargspec
>>> def func(p1, /, p2, *args, p3, **kwargs): pass
... 
>>> getfullargspec(func)
FullArgSpec(args=['p1', 'p2'], varargs='args', varkw='kwargs', defaults=None, kwonlyargs=['p3'], kwonlydefaults=None, annotations={})
</syntaxhighlight>
}}在位置实际参数已经在一个序列类型如列表或元组的对象中的情况下，在引用它的变量前加一个<code>*</code>号传递给函数，则其中所有元素解包为多个位置实际参数，关键字实际参数在字典中则加<code>**</code>号来传递给函数。

修饰器（decorator）是用来修改一个函数、方法或类定义的任何可调用Python对象。将正被定义的最初对象传递给修饰器，它返回一个修改后的对象，接着把它绑定到在定义中那个名字。Python修饰器部份受到[[Java注解|Java注解]]的影响，而有类似的语法；修饰器语法是纯粹的[[语法糖|语法糖]]，使用<code>@</code>作为关键字形成修饰符。修饰器是一种形式的[[元编程|元编程]]，它们增强它们所修饰的函数或方法的行动。{{efn|定义修饰器的示例：

<syntaxhighlight lang="python">
def viking_chorus(myfunc):
    def inner_func(*args, **kwargs):
        for i in range(3):
            myfunc(*args, **kwargs)
    return inner_func
</syntaxhighlight>

调用修饰器的示例：

<syntaxhighlight lang="python">
@viking_chorus    
def menu_item(*args):
    print(", ".join(args)+", and spam")
</syntaxhighlight>

等价于：

<syntaxhighlight lang="python">
def menu_item(*args):
    print(", ".join(args)+", and spam")

menu_item = viking_chorus(menu_item)
</syntaxhighlight>
<code>[[維京人|viking]]_[[副歌|chorus]]</code>修饰后的<code>menu_item</code>将原来定义运行3次：
<syntaxhighlight lang="pycon">
>>> menu_item("egg","bacon")
egg, bacon, and spam
egg, bacon, and spam
egg, bacon, and spam
</syntaxhighlight>}}
多个修饰器可以链接起来，通过在毗连的行上放置多个修饰符，或者使用中间变量。{{efn|修饰器[[工厂方法|工厂]]示例，这里的<code>favourite_colour</code>接受一个实际参数，并返回一个修饰器：

<syntaxhighlight lang="python">
def favourite_colour(colour):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(f"My favourite colour is {colour}.")
            func(*args, **kwargs)
        return wrapper
    return decorator

def invincible(func):
    def wrapper(*args, **kwargs):
        print("I'm invincible!")
        func(*args, **kwargs)
    return wrapper
</syntaxhighlight>

使用毗连的修饰符链接修饰器示例：

<syntaxhighlight lang="python">
@invincible
@favourite_colour("blue")
def black_knight():
    print("None shall pass.")
</syntaxhighlight>

使用中间变量链接修饰器示例：

<syntaxhighlight lang="python">
blue_decorator = favourite_colour("blue")
decorated_by_blue = blue_decorator(black_knight)
black_knight = invincible(decorated_by_blue)
</syntaxhighlight>

它们等价于：

<syntaxhighlight lang="python">
black_knight = invincible(favourite_colour("blue")(black_knight))
</syntaxhighlight>

{{en-link|黑骑士 (巨蟒剧团)|Black Knight (Monty Python)|black_knight}}()结果为：

<syntaxhighlight lang="pycon">
>>> black_knight()
I'm invincible!
My favourite colour is blue.
None shall pass.
</syntaxhighlight>}}
函数修饰器的正规用法包括：用来建立[[类方法|类方法]]或[[静态方法|静态方法]]<ref name="#1"/>，实现[[多分派#Python|多方法]]，增加函数特性，{{en-link|跟踪 (软件)|Tracing (software)|跟踪}}，设置[[先决条件|先决条件]]和[[后置条件|后置条件]]，[[同步|同步]]<ref>{{cite web
|url=http://www.ddj.com/184406073#l11
|title=Python 2.4 Decorators: Reducing code duplication and consolidating knowledge
|work=Dr. Dobb's
|date=2005-05-01
|accessdate=2007-02-08
|archive-url=https://web.archive.org/web/20070206063944/http://www.ddj.com/184406073#l11
|archive-date=2007-02-06
|dead-url=no
}}</ref>；此外更远大的用法包括：[[尾调用|尾调用消除]]<ref>{{cite web
|url=http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/496691
|title=New Tail Recursion Decorator
|work=ASPN: Python Cookbook
|date=2006-11-14
|accessdate=2007-02-08
|archive-url=https://web.archive.org/web/20070209010200/http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/496691
|archive-date=2007-02-09
|dead-url=no
}}</ref>，[[记忆化|记忆化]]甚至改进修饰器的写作<ref>{{cite web
|url=http://www.phyast.pitt.edu/~micheles/python/documentation.html
|title=The decorator module
|accessdate=2007-02-08
|archive-url=https://web.archive.org/web/20070210000956/http://www.phyast.pitt.edu/%7Emicheles/python/documentation.html
|archive-date=2007-02-10
|dead-url=no
}}</ref>。

为了增强代码的可读性，可以在函数后书写“文档字符串”（简称docstrings），用于解释函数的作用、参数的类型与意义、返回值类型与取值范围等。可以使用内置函数<code>help()</code>打印出函数的使用帮助。{{efn|调用函数使用帮助信息示例。比如：

<syntaxhighlight lang="Pycon">
>>> def randint(a, b):
...     "Return random integer in range [a, b], including both end points."
...
>>> help(randint)
Help on function randint in module __main__:   

randint(a, b)
    Return random integer in range [a, b], including both end points.
</syntaxhighlight>}}自从Python 3.5，开始支持类型提示<ref>{{cite web|url=https://www.python.org/dev/peps/pep-0484/|title=PEP 484 -- Type Hints|access-date=2021-03-01|archive-date=2021-02-09|archive-url=https://web.archive.org/web/20210209180311/https://www.python.org/dev/peps/pep-0484/}}</ref>，可以标注函数的参数与返回值<ref>{{cite web|url=https://www.python.org/dev/peps/pep-3107/|title=PEP 3107 -- Function Annotations|access-date=2021-03-01|archive-date=2015-01-06|archive-url=https://web.archive.org/web/20150106050429/https://www.python.org/dev/peps/pep-3107/}}</ref>。此特性可方便IDE对源代码进行更深入的分析。{{efn|如下这样给参数增加类型标注的提示信息：
<syntaxhighlight lang="Python">
def send_mail(from: str, to: str, title: str, body: str) -> bool:
    pass
</syntaxhighlight>}}

=== 对象及其方法 ===
Python支持大多数[[面向对象编程|面向对象编程]]技术。在Python中所有东西都是对象，包括[[类_(计算机科学)|类]]、函数、数和[[模块化编程|模块]]。它允许[[多态_(计算机科学)|多态性]]，不只是在{{en-link|类层级|Class hierarchy}}之内而且通过采用[[鸭子类型|鸭子类型]]的方式。任何[[对象_(计算机科学)|对象]]可以用于任何[[类型系统|类型]]，只要它有适当的[[方法_(计算机科学)|方法]]和[[特性_(计算机科学)|特性]]（attribute）就能工作。Python天然支持[[类_(计算机科学)|类]]的[[继承_(计算机科学)|继承]]包括[[多重继承|多重继承]]，为此采用[[C3线性化|C3线性化]]或方法解析次序（MRO）算法，还支持[[mixin|mixin]]。Python支持[[元类|元类]]<ref name="AutoNT-13">{{cite web |url=https://www.python.org/community/pycon/dc2004/papers/24/metaclasses-pycon.pdf |archiveurl=https://web.archive.org/web/20090530030205/http://www.python.org/community/pycon/dc2004/papers/24/metaclasses-pycon.pdf |archivedate=2009-05-30 |title=Python Metaclasses: Who? Why? When? |last=The Cain Gang Ltd. |accessdate=2009-06-27 |dead-url=yes }}</ref>，它是增进类的功能的高级工具。

Python使用[[名字修饰|名字修饰]]有限的支持私有变量。对象的特性可以被提取为一个字典<ref>{{cite web|url=https://docs.python.org/3/library/stdtypes.html#special-attributes|title=Special Attributes|accessdate=2020-09-12|archive-date=2020-06-14|archive-url=https://web.archive.org/web/20200614194325/https://docs.python.org/3/library/stdtypes.html#special-attributes|dead-url=no}}</ref>。在Python中不强制使用[[变异子与访问子|访问子]]与[[变异子与访问子|变异子]]方法来访问[[字段|数据成员]]的面向对象编程信条。就像Python提供函数式编程构造但不尝试要求{{en-link|参照透明性|referential transparency}}（无[[副作用_(计算机科学)|副作用]]）一样，它提供对象系统但不要求面向对象编程行为。

[[对象_(计算机科学)|对象]]的[[方法_(计算机科学)|方法]]是附属于这个对象的[[类_(计算机科学)|类]]的函数。对于正常的方法和函数，语法<code>instance.method(arguments)</code>，是<code>Class.method(instance, arguments)</code>的[[语法糖|语法糖]]。Python的方法有显式的<code>{{en-link|this (计算机编程)|this (computer programming)|self}}</code>形式参数用来访问[[字段|实例数据]]，对比于在其他一些面向对象编程语言（比如[[C++|C++]]、[[Java|Java]]、[[Objective-C|Objective-C]]或[[Ruby|Ruby]]）中隐式的<code>self</code>或<code>{{en-link|this (计算机编程)|this (computer programming)|this}}</code>关键字<ref name="AutoNT-61">{{cite web |url=https://docs.python.org/faq/design.html#why-must-self-be-used-explicitly-in-method-definitions-and-calls |title=Why must 'self' be used explicitly in method definitions and calls? |work=Design and History FAQ |publisher=Python Software Foundation |accessdate=2012-02-19 |archive-date=2012-10-24 |archive-url=https://web.archive.org/web/20121024164243/http://docs.python.org/faq/design.html#why-must-self-be-used-explicitly-in-method-definitions-and-calls |dead-url=no }}</ref>。在Python中，<code>self</code>可以被看作是一个习惯用法，它可以被换为任何其它合法的参数名。{{efn|对象的方法示例：

<syntaxhighlight lang="Pycon">
>>> class Fish(object):
...     hungry = True
...     def eat(self, food):
...         if food is not None:
...             self.hungry=False
... 
>>> def status(self):
...     print("Hungray!" if self.hungry else "Not hungray!")
... 
>>> e = Fish()
>>> status(e)
Hungray!
>>> Fish.hungry = False
>>> from types import MethodType
>>> e.status = MethodType(status, e)
>>> e.status()
Not hungray!
>>> Fish.hungry = True
>>> Fish.status = status
>>> f = Fish()
>>> Fish.status(f)
Hungray!
>>> f.eat("earthworm")
>>> f.status()
Not hungray!
</syntaxhighlight>}}

Python支持一些以<code>__</code>开始和结束的特殊方法名，它们用于实现[[运算符重载|运算符重载]]和实现多种特殊功能<ref name="special-method-names">{{cite web |title=The Python Language Reference, section 3.3. Special method names|accessdate=2020-09-25 |url=https://docs.python.org/3/reference/datamodel.html#special-method-names |archive-date=2012-10-26 |archive-url=https://web.archive.org/web/20121026063834/http://docs.python.org/reference/datamodel.html#special-method-names |dead-url=no }}</ref>。在Python中，可以通过定义特殊方法来重载运算符，比如在一个类上定义<code>__add__()</code>将允许在这个类的实例上使用<code>+</code>算符。在Python中，当一个[[子类|子类]]的方法{{en-link|方法覆盖|Method overriding|覆盖}}了[[超类|超类]]方法的时候，通过调用<code>super().method</code>来调用与子类的<code>self.method</code>方法同名超类方法<ref name="python-3-super">{{cite web |title=super().method, in Python 3 |url=https://docs.python.org/3/library/functions.html#super |accessdate=2020-09-25 |archive-date=2018-10-26 |archive-url=https://web.archive.org/web/20181026035007/https://docs.python.org/3/library/functions.html#super |dead-url=no }}</ref>。{{efn|特殊方法和子类调用超类方法的例子： 

<syntaxhighlight lang="pycon">
>>> class Thought(object):
...     cls_name = "类型Thought"
...     def __init_subclass__(cls):
...         cls.cls_name = "类型Thought的子类型"
...     def __init__(self, *args, **kwargs):
...         print(f"我是{type(self).cls_name}的新对象!")
...         if len(args) != 0 or len(kwargs) !=0:
...             print(f"init: nargs={len(args)}, nkwargs={len(kwargs)}")
...         self.notion = "我觉得我在平行宇宙中把车停歪了."
...     def message(self, *args):
...         print(self.notion)
...         if len(args) != 0:
...             print("\n".join(args))
... 
>>> class Advice(Thought):
...     def message(self):
...         super(Advice, self).message("警告: 日历里的日期比它们看起来更近!")
... 
>>> t = Thought()   
我是类型Thought的新对象!
>>> t.message()
我觉得我在平行宇宙中把车停歪了.
>>> a = Advice()
我是类型Thought的子类型的新对象!
>>> a.message()
我觉得我在平行宇宙中把车停歪了.
警告: 日历里的日期比它们看起来更近!
>>> # 内省一下:
>>> [*super.__dict__]
['__repr__', '__getattribute__', '__get__', '__init__', '__new__', '__thisclass__', '__self__', '__self_class__', '__doc__']
>>> [*super(Advice).__thisclass__.__dict__]
['__module__', 'message', '__doc__', 'cls_name']
>>> super(Advice).__thisclass__.__dict__['cls_name']
'类型Thought的子类型'
>>> [*super(Advice, a).__self__.__dict__]
['notion']
>>> super(Advice, a).__self_class__.__dict__['cls_name']
'类型Thought的子类型'
>>> super(Advice, a).message()
我觉得我在平行宇宙中把车停歪了.
>>> super(Advice).__get__(a).message()
我觉得我在平行宇宙中把车停歪了.
</syntaxhighlight>}}

Python允许通过使用<code>@classmethod</code>和<code>@staticmethod</code>修饰符来分别建立[[类方法|类方法]]和[[静态方法|静态方法]]。给类方法的第一个实际参数是类对象而非对实例的<code>self</code>引用。静态方法没有特定的第一个实际参数，实例或类对象都不固定的传递给静态方法。{{efn|特殊方法、类方法和静态方法（<code>__new__()</code>）示例：
<syntaxhighlight lang="pycon">
>>> from weakref import WeakValueDictionary
>>> class D:
...     _template = {}
...     _obj_dict = WeakValueDictionary()
...     def __new__(cls, *args, **kwargs):
...         obj = super(D, cls).__new__(cls)
...         cls._obj_dict[id(obj)] = obj
...         return obj
...     @classmethod
...     def load(cls, dict):
...         cls._template.update(dict)
...     @classmethod
...     def create(cls, *args, **kwargs):
...         return cls(cls._template, *args, **kwargs)
...     @classmethod
...     def count(cls):
...         return len(cls._obj_dict)
...     def __init__(self, dict={}, /, *args, **kwargs):
...         self.__dict__.update(dict)
...         self.__dict__.update(kwargs)
...     def __call__(self, *args, **kwargs):
...         self.__dict__.update(kwargs)
...         return self.__dict__.copy()
...     def __len__(self):
...         return len(self.__dict__)
...     def __getitem__(self, key):
...         return self.__dict__[key]
...     def __setitem__(self, key, value):
...         self.__dict__[key] = value
... 
>>> a = {"ak": 1, "bk": 2, "ck": 3}
>>> d = D(a, dk=4)
>>> d()
{'ak': 1, 'bk': 2, 'ck': 3, 'dk': 4}
>>> D.load(a)
>>> e = D.create(ck=4)
>>> e()
{'ak': 1, 'bk': 2, 'ck': 4}
>>> f = D(ak=1, bk=2)
>>> f(ck=3)
{'ak': 1, 'bk': 2, 'ck': 3}
>>> f['ak']
1
>>> f['ak'] = 5
>>> f()
{'ak': 5, 'bk': 2, 'ck': 3}
>>> len(f)
3
>>> D.count()
3
>>> del f
>>> D.count()
2
>>> d.__weakref__ in D._obj_dict.valuerefs()
True
</syntaxhighlight>
}}

在Python中定义了一个或多个特殊方法<code>__get__()</code>、<code>__set__()</code>、<code>__delete__()</code>的类可以用作描述器（descriptor）<ref>{{cite web|url=https://docs.python.org/3/howto/descriptor.html|title=Descriptor HowTo Guide|accessdate=2020-09-26|archive-date=2020-09-18|archive-url=https://web.archive.org/web/20200918160150/https://docs.python.org/3/howto/descriptor.html|dead-url=no}}</ref>。如此建立一个描述器的实例作为另一个类的一个类成员，使得这个实例成为此另一个类的[[属性_(编程)|属性]]（property）。使用与[[特性_(计算机科学)|特性]]（attribute）访问相同的语法，访问一个实例对象中的这个成员属性。{{efn|在类中采用数据描述器的示例：
<syntaxhighlight lang="pycon">
>>> class RevealAccess:
...     """正常的设置和返回值的数据描述器，
...        它还打印记录这次访问的一个消息。
...     """
...     def __init__(self, initval=None, name='var'):
...         self.val = initval
...         self.name = name
...     def __get__(self, obj, objtype):
...         print('Retrieving', self.name)
...         return self.val
...     def __set__(self, obj, val):
...         print('Updating', self.name)
...         self.val = val
... 
>>> class MyClass:
...     x = RevealAccess(10, 'var "x"')
...     y = 5
...
>>> m = MyClass()
>>> m.x
Retrieving var "x"
10
>>> vars(m)
{}
>>> MyClass.__dict__['x'].val
10
>>> m.x = 20
Updating var "x"
>>> vars(m)
{}
>>> MyClass.__dict__['x'].val
20
>>> m.y
5
>>> vars(m)
{}
>>> m.y = 5
>>> vars(m)
{'y': 5}
</syntaxhighlight>}}
Python的<code>property</code>内建函数，将一个类中特殊定义的访问一个特性的那些方法包装成的这个类的一个属性<ref>{{cite web|url=https://docs.python.org/3/library/functions.html#property|title=Built-in Functions: property|accessdate=2020-09-25|archive-date=2018-10-26|archive-url=https://web.archive.org/web/20181026035007/https://docs.python.org/3/library/functions.html#property|dead-url=no}}</ref>。{{efn|在类中调用<code>property()</code>的例子：
<syntaxhighlight lang="pycon">
>>> class C:
...     def __init__(self):
...         self.__x = None
...     def getx(self):
...         return self.__x
...     def setx(self, value):
...         self.__x = value
...     def delx(self):
...         del self.__x
...     x = property(getx, setx, delx, "I'm the 'x' property.")
... 
>>> c = C()
>>> vars(c)
{'_C__x': None}
>>> {*C.__dict__}
{'__init__', 'setx', '__weakref__', 'delx', 'x', 'getx', '__doc__', '__module__', '__dict__'}
</syntaxhighlight>

上述代码可以采用修饰符进一步的书写为：

<syntaxhighlight lang="pycon">
>>> class C:
...     def __init__(self):
...         self.__x = None
...     @property
...     def x(self):
...         """I'm the 'x' property."""
...         return self.__x
...     @x.setter
...     def x(self, value):
...         self.__x = value
...     @x.deleter
...     def x(self):
...         del self.__x
... 
>>> c = C()
>>> vars(c)
{'_C__x': None}
>>> {*C.__dict__}
{'__init__', '__weakref__', 'x', '__doc__', '__module__', '__dict__'}
</syntaxhighlight>
}}

=== 类型 ===
[[File:Python_3._The_standard_type_hierarchy-en.svg|thumb]]
Python使用[[鸭子类型|鸭子类型]]并拥有有类型的对象和无类型的变量名字。在[[编译期|编译期]]不检查类型约束，而宁愿在一个对象上的操作出现可能的失败，表现出这个给定对象不具有适合的类型。尽管是[[类型系统|动态类型]]系统，Python却是[[类型系统|强类型]]的，禁止没有明确定义的操作（比如加一个数到一个字符串），而不是默默的去尝试转换使其有意义。Python支持广泛的类型和类的[[内省_(计算机科学)|内省]]。类型是<code>type</code>的实例，可以被读取和比较。

Python有着范围广泛的基本数据类型。同时具备常规的整数和[[浮点数|浮点]]算术，它透明的支持[[高精度计算|任意精度算术]]、[[复数_(数学)|复数]]和{{en-link|十进制浮点|Decimal floating point|十进制浮点数}}。Python支持种类繁多的字符串操作。在Python中字符串是[[不可变对象|不可变]]的，所以在其他编程语言中可能就地改变字符串的字符串操作比如字符替换，在Python中返回新的字符串。

Python的一个非常有用方面就是[[集合_(计算机科学)|搜集]]（或称[[容器_(数据类型)|容器]]）类型的概念。一般的说，搜集是以一种易于引用或索引的方式包含其他对象的对象。Python对建立容器类型的对象有着语法上的支持。{{efn|
建立列表的特殊语法示例：
<syntaxhighlight lang="python">
a_list = [1, 2, 3, "a dog"]
</syntaxhighlight>
采用正常的对象创建方式的示例：
<syntaxhighlight lang="python">
a_second_list = list()
a_second_list.append(4)
a_second_list.append(5)
</syntaxhighlight>
建立元组的特殊语法示例：
<syntaxhighlight lang="python">
a_tuple = 1, 2, 3, "four"
</syntaxhighlight>
建立集合的特殊语法示例：
<syntaxhighlight lang="python">
some_set = {0, (), False}
</syntaxhighlight>
建立字典的特殊语法示例：
<syntaxhighlight lang="python">
a_dictionary = {"key 1": "value 1", 2: 3, 4: []}
</syntaxhighlight>}}搜集有二种基本形式：序列和映射。有次序的序列类型是列表（动态{{en-link|数组数据类型|array data type|数组}}）、[[多元组|元组]]和字符串。所有序列类型都是位置索引的（从0到长度−1），并且除了字符串，都可以包含任意类型的对象，在同一个序列中包括多种类型的对象。字符串和元组是不可变的，使得它们成为字典的键的完美候选者。在另一方面，列表是可变的，元素可以被插入、删除、修改、添加或[[原地算法|就地]]排序。

在另一方面，映射是以“字典”形式实现的无次序的类型，它将一组[[不可变对象|不可变]]的键映射到相应的元素上（非常像数学函数）。在字典中的键必须是不可变的Python类型，比如整数或字符串，因为在底层它们是通过[[散列函数|散列函数]]实现的。字典还是语言内部的中心，因为它们居于所有Python对象和类的核心：在变量名字（字符串）和这个名字所引用的值之间的映射就存储为字典，而这些字典可以通过对象的<code>__dict__</code>特性直接访问。

{{en-link|集合 (抽象数据类型)|Set (abstract data type)|集合}}搜集类型是在版本2.4中增加入语言核心的。集合是不包含重复项的无索引、无次序的搜集，并且实现了[[朴素集合论|集合论]]运算比如[[并集|并集]]、[[交集|交集]]、[[补集|相对补集]]、[[对称差|对称差]]和[[子集|子集]]测试。有二种类型的集合：可变的<code>set</code>和不可变的<code>frozenset</code>。集合中元素必须是可散列的，比如说，<code>frozenset</code>可以是正规<code>set</code>的元素而反之不行。Python还提供了广泛的搜集操纵能力比如内建的包含元素检查和通用迭代[[协议_(面向对象编程)|协议]]。

Python允许编程者使用[[类_(计算机科学)|类]]定义自己的类型<ref name="unify" />，类在[[面向对象编程|面向对象编程]]中是最经常使用的。类的新[[对象_(计算机科学)|实例]]是通过调用这个类的[[构造器|构造器]]而创建的，而类都是[[元类|元类]]<code>type</code>的实例，<code>type</code>是<code>type</code>元类自身的实例，{{efn|1=<nowiki />
两个类及元类等的实例关系（蓝色连接）与继承关系（绿色连接）示意图：
{{{!}} border=0 cellpadding=0 cellspacing=0 
{{!}}- 
{{!}} {{!}}{{!}} style="width:4ex" {{!}} {{!}}{{!}} 
{{!}}- style="vertical-align:top"
{{!}}
<syntaxhighlight lang="python">
r = object
c = type
class M(c): pass

class A(metaclass=M): pass

class B(A): pass

b = B()
</syntaxhighlight>
{{!}}{{!}} {{!}}{{!}}[[File:Eigenclass-model-sample-pr.svg|x240px]]
{{!}}}

<syntaxhighlight lang="pycon">
>>> type(b)
<class '__main__.B'>
>>> print(type(B), B.__bases__)
<class '__main__.M'> (<class '__main__.A'>,)
>>> print(type(A), A.__bases__)
<class '__main__.M'> (<class 'object'>,)
>>> print(type(M), M.__bases__)
<class 'type'> (<class 'type'>,)
>>> print(type(c), c.__bases__)
<class 'type'> (<class 'object'>,)
>>> print(type(r), r.__bases__)
<class 'type'> ()
</syntaxhighlight>
}}这允许了[[元编程|元编程]]和[[反射式编程|反射]]。

在版本3.0之前，Python有两种类：旧式的和新式的<ref name="classy">{{cite web |title=The Python Language Reference, section 3.3. New-style and classic classes, for release 2.7.18 |accessdate=2020-09-25 |url=https://docs.python.org/2.7/reference/datamodel.html#new-style-and-classic-classes |archive-date=2020-05-05 |archive-url=https://web.archive.org/web/20200505193709/https://docs.python.org/2.7/reference/datamodel.html#new-style-and-classic-classes |dead-url=no }}</ref>。二种样式的语法是一样的，不同在于是否直接或间接的继承自类<code>object</code>，所有新式类都从<code>object</code>继承并且是<code>type</code>的实例。在Python 2系列2.2以上，二种类都可以使用<ref name="unify">{{cite web|url=https://www.python.org/download/releases/2.2.3/descrintro/|title=Unifying types and classes in Python 2.2|author=Guido van Rossum|accessdate=2020-09-26|archive-date=2019-09-28|archive-url=https://web.archive.org/web/20190928044604/https://www.python.org/download/releases/2.2.3/descrintro/|dead-url=no}}</ref>。在Python 3.0中淘汰了旧式类。

长期规划是支持{{en-link|渐进类型|gradual typing}}<ref>{{cite web |url=https://lwn.net/Articles/627418/ |title=Type hinting for Python |publisher=LWN.net |date=2014-12-24 |accessdate=2015-05-05 |archive-date=2019-06-20 |archive-url=https://web.archive.org/web/20190620000057/https://lwn.net/Articles/627418/ |dead-url=no }}</ref>，并且自从Python 3.5，语言的语法允许指定静态类型，但在缺省实现CPython中不检查它们。有实验的叫做“mypy”的可选的静态类型检查器支持编译期类型检查<ref>{{cite web |url=http://mypy-lang.org/ |title=mypy - Optional Static Typing for Python |accessdate=2017-01-28 |archive-date=2020-06-06 |archive-url=https://web.archive.org/web/20200606192012/http://mypy-lang.org/ |dead-url=no }}</ref>。

{|class="wikitable"
|+Python 3内置类型总结
|-
! 类型
! [[不可变对象|可变性]]
! 描述
! style="width: 23em;" | 语法例子
|-
| <code>bool</code>
| 不可变
| [[布尔值|布尔值]]
| {{code|lang=python|True}}<br>{{code|lang=python|False}}
|-
| <code>int</code>
| 不可变
| 理论上无限制大小的[[整数_(计算机科学)|整数]]<ref name="pep0237">。实际受限于机器的内存大小{{cite web |url=https://www.python.org/dev/peps/pep-0237/ |title=PEP 237 – Unifying Long Integers and Integers |last1=Zadka |first1=Moshe |last2=van Rossum |first2=Guido |date=2001-03-11 |work=Python Enhancement Proposals |publisher=Python Software Foundation |accessdate=2011-09-24 |archive-date=2020-05-28 |archive-url=https://web.archive.org/web/20200528063237/https://www.python.org/dev/peps/pep-0237/ |dead-url=no }}</ref>
| {{code|lang=python|42}}
|-
| <code>float</code>
| 不可变
| [[双精度浮点数|双精度]][[浮点数|浮点]]数。精度是机器依赖的但实际上一般实现为64位[[IEEE_754|IEEE 754]]数而带有53位的精度<ref>{{Cite web
  |title=15. Floating Point Arithmetic: Issues and Limitations — Python 3.8.3 documentation
  |url=https://docs.python.org/3.8/tutorial/floatingpoint.html#representation-error
  |access-date=2020-06-06
  |website=docs.python.org
  |quote=almost all platforms map Python floats to IEEE-754 double precision
  |archive-date=2020-06-06
  |archive-url=https://web.archive.org/web/20200606113842/https://docs.python.org/3.8/tutorial/floatingpoint.html#representation-error
  |dead-url=no
  }}</ref>
|
{{code|lang=python|1.414}}
|-
| <code>complex</code>
| 不可变
| [[複數_(數學)|複數]]，具有实部和虚部
| {{code|lang=python|3+2.7j}}
|-
| <code>range</code>
| 不可变
| 通常用在循环中的数的序列，规定在<code>for</code>循环中的次数<ref>{{cite web |title=Built-in Types |url=https://docs.python.org/3/library/stdtypes.html#typesseq-range |accessdate=2019-10-03 |archive-date=2020-06-14 |archive-url=https://web.archive.org/web/20200614194325/https://docs.python.org/3/library/stdtypes.html#typesseq-range |dead-url=no }}</ref>
| {{code|lang=python|range(1, 10)}}<br>{{code|lang=python|range(10, -5, -2)}}
|-
| <code>str</code>
| 不可变
| [[字符串|字符串]]，Unicode代码点序列
| {{code|lang=python|'Wikipedia'}}<br>{{code|lang=python|"Wikipedia"}}<br><syntaxhighlight lang="python">"""Spanning
multiple
lines"""</syntaxhighlight>
|-
| <code>bytes</code>
| 不可变
| [[字节|字节]]序列
| {{code|lang=python|b'Some ASCII'}}<br>{{code|lang=python|b"Some ASCII"}}<br>{{code|lang=python|bytes([119, 105, 107, 105])}}
|-
| <code>bytearray</code>
| 可变
| 字节序列
| {{code|lang=python|bytearray(b'Some ASCII')}}<br>{{code|lang=python|bytearray(b"Some ASCII")}}<br>{{code|lang=python|bytearray([119, 105, 107, 105])}}
|-
| <code>list</code>
| 可变
| [[串列_(抽象资料型别)|列表]]，可以包含混合的类型
| {{code|lang=python|[4.0, 'string', True]}}<br>{{code|lang=python|[]}}
|-
| <code>tuple</code>
| 不可变
| [[元组|元组]]，可以包含混合的类型
| {{code|lang=python|(4.0, 'string', True)}}<br>{{code|lang=python|('single element',)}}<br>{{code|lang=python|()}}
|-
| <code>dict</code>
| 可变
| 键-值对的[[关联数组|关联数组]]（或称字典）；可以包含混合的类型（键和值），键必须是可散列的类型
| {{code|lang=python|{'key1': 1.0, 3: False} }}<br>{{code|lang=python|{} }}
|-
| <code>set</code>
| 可变
| 无序{{en-link|集合 (抽象数据类型)|Set (abstract data type)|集合}}，不包含重复项；可以包含混合的类型，如果可散列的话
| {{code|lang=python|{4.0, 'string', True} }}<br>{{code|lang=python|set()}}
|-
| <code>frozenset</code>
| 不可变
| 无序{{en-link|集合 (抽象数据类型)|Set (abstract data type)|集合}}，不包含重复项；可以包含混合的类型，如果可散列的话
| {{code|lang=python|frozenset([4.0, 'string', True])}}
|-
| <code>types.EllipsisType</code>
| 不可变
| {{en-link|省略号 (编程运算符)|Ellipsis (programming operator)|省略号}}占位符，用作[[NumPy|NumPy]]数组的索引
| {{code|lang=python|...}}<br>{{code|lang=python|Ellipsis}}
|-
| <code>types.NoneType</code>
| 不可变
| 表示值缺席的对象，在其他语言中经常叫做[[空指针|null]]
| {{code|lang=python|None}}
|-
| <code>types.NotImplementedType</code>
| 不可变
| 可从[[运算符重载|重载运算符]]返回的占位符，用来指示未支持的运算数（operand）类型
| {{code|lang=python|NotImplemented}}
|}

除了各种数据类型，Python解释器内建了还有很多其他类型，比如上下文管理器类型，模块、方法、代码对象、类型对象、内部对象等类型。

=== 数学 ===
Python的算术运算使用平常的符号<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，[[取整函数|下取整]]除法算符<code>//</code>和[[模除|模除]]<code>%</code>（这里的余数可以是负数<!--unlike in C language depending on compiler,<ref>{{Cite web|url=https://stackoverflow.com/questions/11720656/modulo-operation-with-negative-numbers/42131603|title=c - Modulo operation with negative numbers|quote=Note that, in C89, whether the result round upward or downward is implementation-defined.|website=Stack Overflow|access-date=2019-09-25}}</ref>-->，比如<code>4 % -3 == -2</code>）。它还有[[指数|指数]]算符<code>**</code>，比如<code>5**3 == 125</code>及<code>9**0.5 == 3.0</code>，和[[矩阵乘法|矩阵乘法]]算符<code>@</code><ref name=PEP465 />。这些算符就像在传统数学中一样运算，具有同样的[[运算次序|优先级规则]]，[[中缀表示法|中缀]]算符<code>+</code>、<code>-</code>还可以分别表示取原数和取[[相反数|相反数]]的[[一元运算|一元]]算符。

在整数之间的除法<code>/</code>产生浮点数结果。除法<code>/</code>的表现随着版本不同而有着显著变化<ref name="pep0238">{{cite web |url=https://www.python.org/dev/peps/pep-0238/ |title=PEP 238 – Changing the Division Operator |first1=Moshe |last1=Zadka |first2=Guido |last2=van Rossum |date=2001-03-11 |work=Python Enhancement Proposals |publisher=Python Software Foundation |accessdate=2013-10-23 |archive-date=2020-05-28 |archive-url=https://web.archive.org/web/20200528115550/https://www.python.org/dev/peps/pep-0238/ |dead-url=no }}</ref>。

Python提供了<code>round()</code>函数用于把一个浮点数[[数值修约|修约]]成最近的整数<ref name="AutoNT-64">{{citation |url=https://docs.python.org/py3k/library/functions.html#round |accessdate=2011-08-14 |title=round |work=The Python standard library, release 3.2, §2: Built-in functions |archive-date=2012-10-25 |archive-url=https://web.archive.org/web/20121025141808/http://docs.python.org/py3k/library/functions.html#round |dead-url=no }}</ref>。

Python允许由比较运算链接起来的布尔表达式表现得如在数学中常用的一样。比如，表达式<code>a < b < c</code>测试<code>a</code>小于<code>b</code>并且<code>b</code>小于<code>c</code><ref name="AutoNT-65">{{cite book | title=Python Essential Reference | url=https://archive.org/details/pythonessentialr00beaz_036 | first1=David M. |last1=Beazley | edition=4th | year = 2009 | page =[https://archive.org/details/pythonessentialr00beaz_036/page/n90 66] }}</ref>。C派生语言不一样的解释这个表达式：在C中，这个表达式将首先求值<code>a < b</code>，结果为<code>0</code>或<code>1</code>，接着把这个结果比较于<code>c</code><ref name="CPL">{{cite book | title=The C Programming Language | first1=Brian W. | last1=Kernighan | first2=Dennis M. | last2=Ritchie |titlelink=The C Programming Language | edition=2nd | year=1988 | page=[https://archive.org/details/cprogramminglang00bria/page/206 206] }}</ref>。

Python对所有整数运算使用[[高精度计算|任意精度算术]]。在<code>decimal</code>模块中的<code>Decimal</code>类型/类提供十进制浮点数到预定义的任意精度并有多种修约模式<ref>{{cite web|title = PEP 0327 -- Decimal Data Type|url = https://www.python.org/dev/peps/pep-0327/|website = Python.org|accessdate = 2015-09-26|last = Batista|first = Facundo|archive-date = 2020-06-04|archive-url = https://web.archive.org/web/20200604234830/https://www.python.org/dev/peps/pep-0327/|dead-url = no}}</ref>。在<code>fractions</code>模块中的<code>Fraction</code>类提供任意精度的[[有理数|有理数]]<ref>{{cite web|title = What's New in Python 2.6 — Python v2.6.9 documentation|url = https://docs.python.org/2.6/whatsnew/2.6.html|website = docs.python.org|accessdate = 2015-09-26|archive-date = 2019-12-23|archive-url = https://web.archive.org/web/20191223213856/https://docs.python.org/2.6/whatsnew/2.6.html|dead-url = no}}</ref>。

由于Python有着广泛的数学库，除了求绝对值函数<code>abs()</code>列入内建函数之外，大多数数学函数处于<code>math</code>和<code>cmath</code>模块内。前者用于实数运算，而后者用于复数运算。{{efn|数学运算示例。比如：

<syntaxhighlight lang="Pycon">
>>> def mean(seq):
...     return sum(seq) / len(seq)
... 
>>> mean([3, 4])
3.5
>>> import math
>>> print(math.sin(math.pi/2))
1.0
</syntaxhighlight>}}特别是，第三方库[[NumPy|NumPy]]进一步扩展了固有能力，Python经常被用作科学脚本语言来处理如数值数据处理和操纵等问题<ref>{{Cite web|url=https://www.stat.washington.edu/~hoytak/blog/whypython.html|title=10 Reasons Python Rocks for Research (And a Few Reasons it Doesn't) – Hoyt Koepke|website=www.stat.washington.edu|access-date=2019-02-03|archive-date=2020-05-31|archive-url=https://web.archive.org/web/20200531211840/https://www.stat.washington.edu/~hoytak/blog/whypython.html|dead-url=no}}</ref><ref>{{Cite web|url=https://engineering.ucsb.edu/~shell/che210d/python.pdf|title=An introduction to Python for scientific computing|last=Shell|first=Scott|date=2014-06-17|access-date=2019-02-03|archive-date=2019-02-04|archive-url=https://web.archive.org/web/20190204014642/https://engineering.ucsb.edu/~shell/che210d/python.pdf|dead-url=no}}</ref>。

== 标准库 ==
Python拥有一个强大的标准库<ref>Przemyslaw Piotrowski, [http://www.oracle.com/technology/pub/articles/piotrowski-pythoncore.html Build a Rapid Web Development Environment for Python Server Pages and Oracle] {{Wayback|url=http://www.oracle.com/technology/pub/articles/piotrowski-pythoncore.html |date=20080724065140 }}, Oracle Technology Network, July 2006. Accessed October 21, 2008.</ref>。Python语言的核心只包含数值、字符串、列表、字典、文件等常见类型和函数，而由Python标准库提供了系统管理、网络通信、文本处理、数据库接口、图形系统、XML处理等额外的功能。

Python标准库的主要功能有：
* {{en-link|文本处理|Text processing}}，包含文本格式化、正则表达式、文本差异计算与合并、Unicode支援，二进制数据处理等功能。
* [[文件系统|文件系统]]功能，包含文件和目录操作、建立临时文件、文件压缩与归档、操作配置文件等功能。
* [[操作系统|操作系统]]功能，包含线程与进程支持、IO复用、日期与时间处理、调用系统函数、日志（logging）等功能。
* [[计算机网络|网络]][[网络传输协议|通信]]，包含网络套接字，SSL加密通信、异步网络通信等功能。支持HTTP，FTP，SMTP，POP，IMAP，NNTP，XMLRPC等多种网络协议，并提供了编写网络服务器的框架。
* [[W3C|W3C]][[文档格式|格式]]支持，包含HTML，SGML，XML的处理。
* 其它功能，包括国际化支持、数学运算、HASH、Tkinter等。

== 程序代码实例 ==
一個在標準輸出設備上輸出[[Hello_World|Hello World]]的簡單程式，這種程式通常作為開始學習程式語言時的第一個程式，可将如下代码录入纯文本文件并随意命名比如<code>program01.py</code>，然后执行这个程序<code>python3 program01.py</code>：

<syntaxhighlight lang="Python">
print("Hello, world!")
</syntaxhighlight>

Python也可以單步直譯執行。執行Python直譯器進入互動式命令列的環境，你可以在提示符號<code>>>></code>旁輸入<code>print("Hello, world!")</code>，按Enter鍵輸出結果：

<syntaxhighlight lang="Pycon">
>>> print('Hello, world!')
Hello, world!
</syntaxhighlight>

计算正数的[[阶乘|阶乘]]的程序代码：
<syntaxhighlight lang="python">
n = int(input('键入一个数，就会打印它的阶乘: '))
if n < 0:
    raise ValueError('错误，输入不正确!请输入一个非负数')
fact = 1
for i in range(2, n + 1):
    fact *= i
print(fact)
</syntaxhighlight>
注意，在Python 3.0及以上版本中，<code>print</code>是个函数，需要在要打印的字符串前后加上圆括号；在Python 2.6以下版本中，<code>print</code>是一个关键字和命令而不加圆括号。
<!--

请不要增加更多的例子

-->

== 实现 ==
Python是一门跨平台的脚本语言，Python规定了一个Python语法规则，根据该规则可编写Python[[直譯器|直譯器]]。Python属于[[动态语言|动态语言]]，将Python程序编译成中间形式的[[字节码|字节码]]<ref name="AutoNT-67">{{cite web |url=https://docs.python.org/3/library/dis.html#python-bytecode-instructions |title=CPython byte code |publisher=Docs.python.org |accessdate=2016-02-16 |archive-date=2020-06-05 |archive-url=https://web.archive.org/web/20200605151542/https://docs.python.org/3/library/dis.html#python-bytecode-instructions |dead-url=no }}</ref>，并接着在它的[[虚拟机|虚拟机]]上执行<ref name="AutoNT-68">{{cite web |url=http://www.troeger.eu/teaching/pythonvm08.pdf |title=Python 2.5 internals |accessdate=2011-04-19 |archive-date=2012-08-06 |archive-url=https://web.archive.org/web/20120806094951/http://www.troeger.eu/teaching/pythonvm08.pdf |dead-url=no }}</ref>，相较于C/C++等编译成[[机器码|机器码]]的[[编译语言|编译语言]]而言运行速度较慢<ref>{{cite web|title=The Computer Language Benchmarks Game|url=https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/python.html|access-date=2020-04-30|archive-date=2020-06-14|archive-url=https://web.archive.org/web/20200614210246/https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/python.html|dead-url=no}}</ref>。
{{Div col|2}}
* [[CPython|CPython]]<ref>http://www.Python.org {{Wayback|url=http://www.python.org/ |date=20180417023815 }} CPython</ref>，官方的直譯器，需要区别于其他直譯器的时候才以CPython称呼。这是最常用的Python版本。
*[[MicroPython|MicroPython]]和{{en-link|CircuitPython|CircuitPython}}，是为[[微控制器|微控制器]]而优化的Python 3变体。
* [[PyPy|PyPy]]，RPython实现的Python，是快速的规矩的Python 2.7和3.7解释器<ref name="AutoNT-70">{{cite web |url=http://pypy.org/compat.html |title=PyPy – Python compatibility |access-date=2020-12-15 |website=pypy.org |archive-date=2021-06-07 |archive-url=https://web.archive.org/web/20210607150220/https://www.pypy.org/compat.html }}</ref>。它的[[即时编译|即时编译器]]带来了超过CPython的显著速度提升，但是它不能使用一些用C写的库<ref name="AutoNT-71">{{cite web |url=http://speed.pypy.org/ |title=speed comparison between CPython and Pypy |publisher=Speed.pypy.org |accessdate=2012-12-03 |archive-date=2020-06-01 |archive-url=https://web.archive.org/web/20200601015529/https://speed.pypy.org/ |dead-url=no }}</ref><ref>{{cite web|url=https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b|title=Which is the fastest version of Python?|first=Anthony|last=Shaw|publisher=Hacker Noon|date=2018-03-30|accessdate=2019-12-20|archive-date=2020-06-14|archive-url=https://web.archive.org/web/20200614160416/https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b|dead-url=no}}</ref>。
* [[Stackless_Python|Stackless Python]]， 是实现{{en-link|微线程|microthread}}的CPython的重要分叉；它不使用C内存堆栈，因而允许大规模并发程序。PyPy也有无堆栈版本<ref name="AutoNT-73">{{cite web |url=http://doc.pypy.org/en/latest/stackless.html |title=Application-level Stackless features — PyPy 2.0.2 documentation |publisher=Doc.pypy.org |accessdate=2013-07-17 |archive-date=2020-06-04 |archive-url=https://web.archive.org/web/20200604231513/https://doc.pypy.org/en/latest/stackless.html |dead-url=no }}</ref>。
* [[Jython|Jython]]，Java实现的Python。Jython可以直接调用Java的各种函数库。
* [[IronPython|IronPython]]，面向[[.NET|.NET]]和[[ECMA_CLI|ECMA CLI]]的Python实现。IronPython能够直接调用.net平台的各种函数库。可以将Python程序编译成.net程序。
{{div col end}}
=== 到其他语言的交叉编译器 ===
{{Div col|2}}
* [[Numba|Numba]]，使用[[LLVM|LLVM]]把Python的[[子集|子集]]和[[NumPy|NumPy]]编译成机器码。
* [[RPython|RPython]]，将Python的受限[[子集|子集]]编译成[[C语言|C]]，并被用来建造Python的PyPy解释器。
* [[Cython|Cython]]，把Python的[[超集|超集]]编译成[[C语言|C]]和[[C++|C++]]。
* {{en-link|Nuitka|Nuitka}}，把Python编译成C++<ref>{{cite web|url=http://nuitka.net/|title=Nuitka Home {{!}} Nuitka Home|website=nuitka.net|language=en|access-date=2017-08-18|archive-date=2020-05-30|archive-url=https://web.archive.org/web/20200530211233/https://nuitka.net/|dead-url=no}}</ref>。
* {{en-link|MyHDL|MyHDL}}，把Python编译成[[VHDL|VHDL]]。
* Pythran，把Python编译成[[C++|C++]]<ref>{{Cite web|url=https://medium.com/@olivier.borderies/pythran-python-at-c-speed-518f26af60e8|title=Pythran: Python at C++ speed !|first=Olivier|last=Borderies|date=2019-01-24|website=Medium|accessdate=2020-09-12|archive-date=2020-03-25|archive-url=https://web.archive.org/web/20200325171400/https://medium.com/@olivier.borderies/pythran-python-at-c-speed-518f26af60e8|dead-url=no}}</ref><ref>{{Cite web|url=https://pythran.readthedocs.io/en/latest/|title=Pythran — Pythran 0.9.5 documentation|website=pythran.readthedocs.io|accessdate=2020-09-12|archive-date=2020-02-19|archive-url=https://web.archive.org/web/20200219081337/https://pythran.readthedocs.io/en/latest/|dead-url=no}}</ref>。
* Google的Grumpy（最近发行于2017年），把Python 2编译成[[Go|Go]]<ref>{{Cite web|url=https://github.com/google/grumpy|title=google/grumpy|date=2020-04-10|via=GitHub|accessdate=2020-09-12|archive-date=2020-04-15|archive-url=https://web.archive.org/web/20200415054919/https://github.com/google/grumpy|dead-url=no}}</ref>。
{{div col end}}

== 开发环境 ==
=== 通用IDE/文本编辑器 ===
很多并非集成开发环境软件的[[文本编辑器|文本编辑器]]，也对Python有不同程度的支持，并且加上专门为Python设计的编辑器[[插件|插件]]也会有很高的可用性。
{{Div col|colwidth=15em}}
* {{en-link|Python Tools for Visual Studio|}}
* [[Visual_Studio_Code|Visual Studio Code]]
* [[Atom_(文字編輯器)|Atom]]
* [[Eclipse|Eclipse]]
* [[IntelliJ_IDEA|IntelliJ IDEA]]
* [[emacs|emacs]]
* [[NetBeans|NetBeans]]
* [[SlickEdit|SlickEdit]]
* [[TextMate|TextMate]]
* [[Vim|Vim]]
* [[Sublime_Text|Sublime Text]]
* [[EditPlus|EditPlus]]
* [[UltraEdit|UltraEdit]]
* [[PSPad|PSPad]]
* [[Notepad++|Notepad++]]
{{div col end}}

=== 专用Python开发环境 ===
适用于Python的[[集成开发环境|集成开发环境]]（IDE）软件，除了标准二进制发布包所附的IDLE之外，还有许多其他选择。其中有些软件设计有语法着色、语法检查、运行[[调试|调试]]、自动补全、智能感知等便利功能。由于Python的[[跨平台|跨平台]]出身，这些软件往往也具备各种操作系统的版本或一定的移植性。此外还有[[IPython|IPython]]，它是最初为Python开发的交互式计算的[[壳层|命令shell]]。
{{Div col|2}}
* {{en-link|IDLE (Python)|IDLE|IDLE}}：Python“标准”IDE。一般随Python而安装，支持较少的编辑功能，调试功能也比较弱。
* [[Eric_Python_IDE|Eric]]：基于[[PyQt|PyQt]]的自由软件。支持自动补全、智能感知、自动语法检查、工程管理、svn/mercurial集成、自动单元测试等功能，具有可扩展的插件系统，通过可选插件支持[[Git|Git]]集成。调试功能与Visual Studio和Eclipse类似。
* [[PyCharm|PyCharm]]：由[[JetBrains|JetBrains]]打造，PyCharm具备一般IDE的功能，比如，调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制等等，另外，PyCharm还提供了一些很好的功能用于Django开发，同时支持[[Google_App_Engine|Google App Engine]]，PyCharm也支持IronPython。PyCharm是商业软件，但也具有社区版和教育版。
* [[Spyder|Spyder]]：开源的跨平台科学计算IDE。 
* {{en-link|Komodo IDE|Komodo IDE|Komodo}}和{{en-link|Komodo Edit|}}：后者是前者的免费精简版。
* {{en-link|PyScripter|}}：功能较全的开源IDE，使用Delphi开发。
* {{en-link|WingIDE|}}：商业软件，有免費的功能有限的Wing IDE 101，適用於入門者教學。
{{div col end}}

== 應用 ==
[[File:Python_Powered.png|thumb]]
{{main|{{le|Python软件列表|List of Python software}}}}
在很多作業系統裡，Python是標準的系统元件。大多數[[Linux發行版|Linux發行版]]和[[Mac_OS_X|Mac OS X]]都集成了Python，可以在終端機下直接執行Python。雖然Python可被粗略地分類為[[腳本語言|腳本語言]]，Python的支持者較喜歡稱它為一種高階[[動態語言|動態語言]]，常像“胶水”一样被用来连接[[基于组件的软件工程|软件组件]]，已经显著的区别于其他僅作簡單程式設計任務的語言，如[[Unix_shell|Unix shell]]、[[Windows|Windows]] [[PowerShell|PowerShell]]等。

Python社群提供了大量的第三方模組，使用方式与标准库类似。它们的功能覆盖科学计算、Web开发、数据库接口、图形系统多个领域。第三方模块可以使用Python或者[[C|C语言]]编写。[[SWIG|SWIG]]和{{le|SIP (软件)|SIP (software)|SIP}}常用于将C语言编写的程序库转化为Python模块。

=== 網絡應用程式 ===
{{see also|网络应用程式}}
Python定義了[[WSGI|WSGI]]標準應用接口来協調Http伺服器與基於Python的Web程式之間的溝通。比如，通過{{link-en|mod_wsgi|mod_wsgi}}模組，[[Apache|Apache]]可以運行用Python編寫的Web程式。[[Zope|Zope]]是著名的用Python编写的开源的Web[[应用服务器|应用服务器]]。[[Tornado|Tornado]]是用Python语言写成的非阻塞式web服务器，也是轻量级的Web框架。

Python對於各种網路協定的支援很完善，因此經常被用於編寫伺服器軟體、網路爬蟲等Web開發。用Python编写的一些Web框架，可以讓程式設計師輕鬆地開發和管理複雜的Web程式。著名的第三方[[Web应用框架|Web框架]]和函数库：
{{Div col|2}}
*[[Django|Django]]：开源Web开发框架，它鼓励快速开发，并遵循MVT设计，开发周期短。
*[[web2py|web2py]]：MVC架构的全栈Web框架，虽然简单但是功能强大。
*[[TurboGears|TurboGears]]：MVC架构的Web应用程序框架。
*[[Pylons#Pyramid|Pyramid]]：轻量同時也可以規模化的Web框架，是[[Pylons|Pylons]]计划的一部分。
*[[CherryPy|CherryPy]]：Web应用程序开发框架。
*[[Quixote_(web框架)|Quixote]]：简单的Web开发框架。
*[[Flask|Flask]]：微Web框架。
*[[Bottle|Bottle]]：微Web框架。
*aiohttp：轻量级的Web框架，采用的是Python3的asyncio异步特性<ref>{{cite web|url=https://docs.aiohttp.org/en/stable/|title=Asynchronous HTTP Client/Server for asyncio and Python|accessdate=2021-01-14|archive-date=2021-01-15|archive-url=https://web.archive.org/web/20210115205648/https://docs.aiohttp.org/en/stable/|dead-url=no}}</ref>。
*[[Twisted|Twisted]]：[[事件驱动|事件驱动]]的网络编程框架。它支援多數標準的網路協定（包含客户端和伺服器），並且提供了多種工具，被廣泛用於編寫高性能的伺服器軟體。
*[[Requests|Requests]]：适合于常人使用的HTTP库，封装了许多繁琐的HTTP功能，极大地简化了HTTP请求所需要的代码量。
*[[Beautiful_Soup|Beautiful Soup]]：用来解析HTML/XML的一个简单易用Python包。
*gevent：是基于[[协程|协程]]的高性能[[并发计算|并发]]网络编程库，使用greenlet在[[libev|libev]]或[[libuv|libuv]]之上提供了高层的同步式API<ref>{{cite web|url=http://www.gevent.org/index.html|title=gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev or libuv event loop|access-date=2021-03-13|archive-date=2021-06-07|archive-url=https://web.archive.org/web/20210607150331/http://www.gevent.org/index.html}}</ref>。
{{div col end}}

=== GUI开发 ===
{{see also|GUI}}
Python本身包含了[[Tkinter|Tkinter]]库，它是Python的业界标准[[图形用户界面|GUI]]并被集成进入了{{en-link|IDLE (Python)|IDLE|IDLE}}。Tkinter基于了[[Tcl|Tcl]]命令工具，能够支持简单的[[GUI|GUI]]开发。但是越来越多的Python程序员选择第三方GUI套件来开发跨平台的桌面软件，使用它们开发的桌面软件运行速度快，与用户的桌面环境相契合。著名的第三方GUI库：
{{Div col|2}}
* PyGObject：替代了[[PyGTK|PyGTK]]，为Python程序访问基于[[GObject|GObject]]的库提供了[[包装库|包装库]]，GObject是[[GTK|GTK]]、{{en-link|GIO (软件)|GIO (software)|GIO}}和[[GStreamer|GStreamer]]等库使用的对象系统。
* [[PyQt|PyQt]]：用于Python的QT[[包装库|包装库]]，在GPL许可证或商业许可证下发行。
* [[PySide|PySide]]：针对PyQt的替代库，在LGPL许可证下发行。
* {{en-link|appJar|appJar}}：跨平台开源的Python的GUI库。提供对多数Tkinter内容的易用包装函数并带有额外的内建功能。
* [[Kivy|Kivy]]：用于开发多点触控应用软件的开源Python库，采用了[[自然用户界面|自然用户界面]]（NUI）。
* [[WxPython|WxPython]]：GUI编程框架[[wxWidgets|wxWidgets]]的Python[[包装库|包装库]]，它与[[MFC_(微軟)|MFC]]的架构相似。
{{div col end}}

=== 科學計算 ===
通过第三方科学计算库可以讓Python程式設計師編寫科学計算程式。著名的第三方科学计算库：
{{Div col|2}}
*[[NumPy|NumPy]]：Python的基础性的科学计算第三方库，提供了矩阵、线性代数、傅立叶变换等等的解决方案。
*[[SciPy|SciPy]]：使用[[NumPy|NumPy]]的多维数组作为基本数据结构，用Python实现了[[MATLAB|MATLAB]]所有功能的第三方库。
*[[matplotlib|matplotlib]]：用Python实现类似[[MATLAB|MATLAB]]绘图功能的第三方库，用以绘制一些高质量的数学二维图形。
*[[pandas|pandas]]：用于数据分析、数据建模、数据可视化的第三方库。
*[[SymPy|SymPy]]：支持数学符号运算的第三方库，用于提供[[计算机代数系统|计算机代数系统]]。
*[[scikit-learn|scikit-learn]]：基于[[SciPy|SciPy]]的[[機器學習|機器學習]]第三方库，實現許多知名的機器學習演算法。
*[[PyMC3|PyMC3]]：用于贝叶斯统计建模和概率机器学习，它聚焦于高级马尔可夫链蒙特卡洛法和变分拟合算法。
*PyOpenCL：提供对[[OpenCL|OpenCL]] [[API|API]]的集成<ref>{{cite-web|url=https://documen.tician.de/pyopencl/|title=OpenCL integration for Python, plus shiny features|access-date=2021-07-29|archive-date=2022-03-08|archive-url=https://web.archive.org/web/20220308163333/https://documen.tician.de/pyopencl/}}</ref>。
*PyCUDA：提供对[[Nvidia|Nvidia]]的[[CUDA|CUDA]]并行计算API的访问<ref>{{cite web|title=PyCUDA|url=https://documen.tician.de/pycuda/}}</ref>。
*[[TensorFlow|TensorFlow]]：[[Google|Google]]开发维护的[[开源|开源]]的[[机器学习|机器学习]]和[[深度学习|深度学习]]库，提供了Python [[API|API]]。
*[[Keras|Keras]]：提供到[[TensorFlow|TensorFlow]]、[[Theano|Theano]]與[[CNTK|CNTK]]等[[深度神经网络|深度神经网络]]的接口的Python [[API|API]]。
*[[PyTorch|PyTorch]]：[[Facebook|Facebook]]基于{{tsl|en|Torch (machine_learning)|Torch (机器学习)|Torch}}开发的[[开源|开源]]的[[机器学习|机器学习]]和[[深度学习|深度学习]][[库|库]]，提供了Python [[API|API]]。
{{div col end}}

=== 其它种类的第三方库 ===
{{Div col|2}}
*Boost.Python：[[Boost_C++_Libraries|Boost C++ Libraries]]包含了一組函式庫，使得以Python或C++編寫的程式能互相调用。
*[[SQLAlchemy|SQLAlchemy]]：[[关系型数据库|关系型数据库]]的[[对象关系映射|对象关系映射]]（ORM）工具。
*{{en-link|Python图像库|Python Imaging Library|Pillow}}：分叉自已终止维护的PIL，是基于Python的图像处理库，对图形文件的格式支持广泛<ref>{{cite web |title=Pillow: a modern fork of PIL |url=http://pillow.readthedocs.org/en/latest/ |accessdate=December 8, 2013 |archive-date=2016-04-27 |archive-url=https://web.archive.org/web/20160427040442/http://pillow.readthedocs.org/en/latest/ }}</ref>。
*PyOpenGL：到[[OpenGL|OpenGL]] 1.1-4.4和有关API的常用跨平台Python绑定<ref>{{Cite web |url=http://pyopengl.sourceforge.net/ |title=PyOpenGL |access-date=2022-01-07 |archive-date=2011-06-15 |archive-url=https://web.archive.org/web/20110615075139/http://pyopengl.sourceforge.net/ }}</ref>。
*ModernGL：在[[OpenGL|OpenGL]] 3.3+核心上的Python包装器<ref>{{Cite web |url=https://github.com/moderngl/moderngl |title=ModernGL |access-date=2022-01-07 |archive-date=2022-04-15 |archive-url=https://web.archive.org/web/20220415045537/https://github.com/moderngl/moderngl }}</ref>。
*[[pygame|pygame]]：Python的[[视频游戏|视频游戏]]开发模块，基于了[[SDL|SDL]]库<ref>{{cite web|url=https://www.libsdl.org/languages.php|title=SDL Language Bindings|access-date=2022-02-16|archive-date=2019-03-12|archive-url=https://web.archive.org/web/20190312130817/http://libsdl.org/languages.php}}</ref>。
*[[pyglet|pyglet]]：Python编写的面向对象的游戏和[[多媒体|多媒体]]库，利用了[[FFmpeg|FFmpeg]]库。
*PyInstaller：能将程序发布为独立的安装程序包<ref>{{cite web|url=https://www.pyinstaller.org/|title=PyInstaller|access-date=2021-03-13|archive-date=2021-06-07|archive-url=https://web.archive.org/web/20210607150432/https://www.pyinstaller.org/}}</ref>。
*pywin32：通過這個第三方軟體包，Python能夠訪問Windows的COM服務及其它Windows API<ref>{{cite web|url=https://github.com/mhammond/pywin32|title=pywin32|access-date=2021-03-13|archive-date=2021-06-07|archive-url=https://web.archive.org/web/20210607150355/https://github.com/mhammond/pywin32}}</ref>。
*{{en-link|py2exe}}：将python脚本转换为windows上可以独立运行的可执行程序。
{{div col end}}

=== 普及流行 ===
自从2003年，Python始终排行于{{en-link|TIOBE编程社区索引|TIOBE Programming Community Index}}前十最流行编程语言，在2021年10月它首次达到了第一名最流行语言（居于[[C语言|C]]和[[Java|Java]]之前）<ref name="tiobe-index">{{cite web |url=http://www.tiobe.com/tiobe-index/ |title=TIOBE Index |publisher=TIOBE - The Software Quality Company |accessdate=2021-10-06 |archive-date=2020-06-14 |archive-url=https://web.archive.org/web/20200614043624/https://www.tiobe.com/tiobe-index/ |dead-url=no }}</ref>，并被选为2007年、2010年、2018年、2020年和2021年的年度编程语言<ref name="tiobe-index" />。

有一些Linux發行版的安裝器使用Python語言編寫。在RPM系列Linux发行版中，有一些系统组件就是用Python编写的。一些著名的互联网公司在内部大量地使用Python<ref>{{cite web|quote=這很難講，不過，2004年，Python已在Google內部使用，Google召募許多Python高手，但在這之前就已決定使用Python。他們的目的是尽量使用Python，在不得已时改用C++；在操控硬體的場合使用C++，在快速開發時候使用Python。|url=http://stackoverflow.com/questions/2560310/heavy-usage-of-python-at-google|title=Heavy usage of Python at Google|author=《Python技术手册》的作者马特利（Alex Martelli）|accessdate=2012-11-30|archive-date=2012-10-06|archive-url=https://web.archive.org/web/20121006215241/http://stackoverflow.com/questions/2560310/heavy-usage-of-python-at-google|dead-url=no}}</ref>。很多遊戲比如[[EVE|EVE]]，使用Python編寫遊戲的邏輯、伺服器。使用Python编写了如下著名应用：
{{Div col|2}}
* [[SCons|SCons]]：软件建造工具，有些公司会使用它代替make构建编译程序。
* [[Ubiquity_(软件)|Ubiquity]]：[[Ubuntu|Ubuntu]]的安裝器。
* [[Anaconda|Anaconda]]：[[Red_Hat_Linux|Red Hat Linux]]和[[Fedora_(作業系統)|Fedora]]的安裝器。
* [[Portage|Portage]]：[[Gentoo_Linux|Gentoo Linux]]使用Python編寫的[[軟件包管理系统|軟件包管理系统]]。
* {{en-link|Gunicorn|}}：使用Python语言编写的[[WSGI|WSGI]] [[Web服务器|Web服务器]]。
* [[Plone|Plone]]：基于[[Zope|Zope]]的内容管理系统。
* {{en-link|Mezzanine (CMS)|Mezzanine (CMS)|Mezzanine}}：基于[[Django|Django]]框架的[[内容管理系统|内容管理系统]]。
* Fabric：用于管理成百上千台Linux主机的程序库<ref>{{cite web|url=http://fabfile.org/|title=Fabric: Pythonic remote execution|archive-url=https://web.archive.org/web/20140411140705/http://fabfile.org/|archive-date=2014-04-11|accessdate=2013-04-08|dead-url=no}}</ref>。
* [[:en:mw:Manual:Pywikibot|Pywikibot framework]]：MediaWiki的機器人程式。
* {{en-link|MoinMoin|}}：Python寫成的[[Wiki|Wiki]]程序。
* [[trac|trac]]：使用Python编写的BUG管理系统。
* [[GNU_Mailman|GNU Mailman]]：使用Python编写的邮件列表软件。
* [[Blender|Blender]]：使用Python作為建模工具與GUI語言的開源3D繪圖軟體。
* [[Inkscape|Inkscape]]：一个开源的SVG矢量图形编辑器，使用Python用于插件。
* [[Sugar_(用戶界面)|Sugar]]：作業系统項目[[OLPC|OLPC]]的[[圖形用戶界面|圖形用戶界面]]，其大多數軟體都是使用Python編寫。
* [[Odoo|Odoo]]：仍在持续发展壮大且最受欢迎的ERP软件。
* [[SageMath|SageMath]]：一个覆盖许多[[数学|数学]]功能的应用软件。
* {{en-link|Veusz}}，用Python、[[PyQt|PyQt]]和[[NumPy|NumPy]]写成的科学绘图软件。 
{{div col end}}
形成了如下社群：
{{Div col|2}}
* [[PyCon|PyCon]]：各地社群舉辦的會議，通常每年舉辦。各社群在會議中討論Python相關的議題。
* Python Discord：参与者众多的Python社区<ref>{{cite web|url=https://pythondiscord.com/|title=Python Discord is a large community focused around the Python programming language|accessdate=2021-01-13|archive-date=2021-02-01|archive-url=https://web.archive.org/web/20210201213730/https://pythondiscord.com/|dead-url=no}}</ref>。
* {{link-en|PyLadies}}：由女性社群發起的社群，主要注重於發展Python的女性程式設計社群。
* {{en-link|Django Girls|Django Girls}}：使用[[Django|Django]]網頁設計框架，推廣使用Python進行網頁設計的技術。
{{div col end}}

== 影響的语言 ==
Python的设计和哲学已经影响了很多其他编程语言：
{{Div col|2}}
* [[Boo|Boo]]：使用了缩进、类似的语法和类似的对象模型<ref name="AutoNT-90">{{cite web |url=http://boo.codehaus.org/Gotchas+for+Python+Users |title=Gotchas for Python Users |work=boo.codehaus.org |publisher=Codehaus Foundation |accessdate=2008-11-24 |archiveurl=https://web.archive.org/web/20081211062108/http://boo.codehaus.org/Gotchas+for+Python+Users |archivedate=2008-12-11 |dead-url=yes }}</ref>。
* {{en-link|Cobra (编程语言)|Cobra (programming language)|Cobra}}：使用了缩进和类似的语言，而且它的致谢文档将Python列为影响它的首要语言<ref name="AutoNT-91">{{cite web |url=http://cobra-language.com/docs/acknowledgements/ |title=Acknowledgements |last=Esterbrook |first=Charles |work=cobra-language.com |publisher=Cobra Language |accessdate=2010-04-07 |archive-date=2008-02-08 |archive-url=https://web.archive.org/web/20080208141002/http://cobra-language.com/docs/acknowledgements/ |dead-url=no }}</ref>。
* [[CoffeeScript|CoffeeScript]]：是交叉编译至JavaScript的编程语言，有受Python启发的语法。
* [[ECMAScript|ECMAScript]]/[[JavaScript|JavaScript]]：从Python借鉴了[[迭代器|迭代器]]和[[生成器_(计算机编程)|生成器]]<ref name="AutoNT-93">{{cite web |url=http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators |archive-url=https://web.archive.org/web/20071020082650/http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators |archive-date=2007-10-20 |title=Proposals: iterators and generators [ES4 Wiki] |publisher=wiki.ecmascript.org |accessdate=2008-11-24 |dead-url=yes }}</ref>。
* GDScript：是非常类似Python的脚本语言，内置入了[[Godot|Godot]]游戏引擎<ref>{{cite web |url=http://docs.godotengine.org/en/latest/about/faq.html#what-is-gdscript-and-why-should-i-use-it |title=FAQ: What is GDScript and why should I use it? |accessdate=2020-09-13 |archive-date=2020-05-19 |archive-url=https://web.archive.org/web/20200519082017/https://docs.godotengine.org/en/latest/about/faq.html#what-is-gdscript-and-why-should-i-use-it |dead-url=no }}</ref>。
* [[Go|Go]]：设计为“有动态语言如Python的工作速度”<ref name="AutoNT-94">{{cite news |url=https://techcrunch.com/2009/11/10/google-go-language/ |title=Google's Go: A New Programming Language That's Python Meets C++ |last=Kincaid |first=Jason |date=2009-11-10 |work=TechCrunch |accessdate=2010-01-29 |archive-date=2010-01-18 |archive-url=https://web.archive.org/web/20100118014358/http://www.techcrunch.com/2009/11/10/google-go-language/ |dead-url=no }}</ref>，并共享了相同的分片数组的语法。
* [[Groovy|Groovy]]：动机是将Python的设计哲学带到[[Java|Java]]<ref name="AutoNT-95">{{cite web |last=Strachan |first=James |date=2003-08-29 |title=Groovy – the birth of a new dynamic language for the Java platform |url=http://radio.weblogs.com/0112098/2003/08/29.html |access-date=2007-06-11 |archive-url=https://web.archive.org/web/20070405085722/http://radio.weblogs.com/0112098/2003/08/29.html |archive-date=2007-04-05 |dead-url=yes }}</ref>。
* [[Nim|Nim]]：使用缩进和类似的语法<ref>{{cite web |url=https://www.infoworld.com/article/3157745/application-development/nim-language-draws-from-best-of-python-rust-go-and-lisp.html |title=Nim language draws from best of Python, Rust, Go, and Lisp |first=Serdar |last=Yegulalp |date=2017-01-16 |website=InfoWorld |quote=Nim's syntax is strongly reminiscent of Python's, as it uses indented code blocks and some of the same syntax (such as the way if/elif/then/else blocks are constructed). |accessdate=2020-09-13 |archive-date=2018-10-13 |archive-url=https://web.archive.org/web/20181013211847/https://www.infoworld.com/article/3157745/application-development/nim-language-draws-from-best-of-python-rust-go-and-lisp.html |dead-url=no }}</ref>。
* [[Swift_(程式語言)|Swift]]：是Apple开发的编程语言，有受Python启发的语法<ref>{{cite web |url=http://nondot.org/sabre |title=Chris Lattner's Homepage |publisher=Chris Lattner |first=Chris |last=Lattner |authorlink=Chris Lattner |date=2014-06-03 |accessdate=2014-06-03 |quote=I started work on the Swift Programming Language in July of 2010. I implemented much of the basic language structure, with only a few people knowing of its existence. A few other (amazing) people started contributing in earnest late in 2011, and it became a major focus for the Apple Developer Tools group in July 2013 [...] drawing ideas from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list. |archive-date=2015-12-22 |archive-url=https://web.archive.org/web/20151222150510/http://nondot.org/sabre/ |dead-url=no }}</ref>。
{{div col end}}
此外，[[Julia_(编程语言)|Julia]]设计原则中有一条是：“像Python一样可用于通用编程”<ref name=Julia>{{cite web| title= Why We Created Julia| date= February 2012| website= Julia website| url= https://julialang.org/blog/2012/02/why-we-created-julia| accessdate= 2014-06-05| quote= We want something as usable for general programming as Python [...]| archive-date= 2020-05-02| archive-url= https://web.archive.org/web/20200502144010/https://julialang.org/blog/2012/02/why-we-created-julia/| dead-url= no}}</ref>；[[Ruby|Ruby]]的创建者[[松本行弘|松本行弘]]曾说过：“我想要一种脚本语言，比Perl更加强力而且比Python更加面向对象，因此我决定设计自己的语言”<ref name="linuxdevcenter">{{cite web |url=http://www.linuxdevcenter.com/pub/a/linux/2001/11/29/ruby.html |title=An Interview with the Creator of Ruby |publisher=Linuxdevcenter.com |accessdate=2012-12-03 |archive-date=2018-04-28 |archive-url=https://web.archive.org/web/20180428150410/http://www.linuxdevcenter.com/pub/a/linux/2001/11/29/ruby.html |dead-url=yes }}</ref>。

== 代码示例 ==
{{Div col|2}}
{{notelist}}
{{div col end}}

== 版本3相对版本2的主要变化 ==
{{Div col|1}}
Python3相较于Python2的变化主要在以下几个方面<ref name="py3k_whatsnew">{{cite web| language= en| publisher= Python Software Foundation| title= What’s New in Python 3.0| url= http://docs.python.org/release/3.0.1/whatsnew/3.0.html| author= Guido van Rossum| date= 2009-02-14| accessdate= 2011-02-22| archive-date= 2010-12-24| archive-url= https://web.archive.org/web/20101224201106/http://docs.python.org/release/3.0.1/whatsnew/3.0.html| dead-url= no}}</ref>：
{{div col end}}{{Div col|small=yes|2}}
* 除法运算符<code>/</code>在Python 3.x内总是返回浮点数。而在Python 2.6内会判断被除数与除数是否是整数。如果是整数会返回整数值，相当于整除；浮点数则返回浮点数值。要让Python 2.6统一返回浮点数值，可以<code>from __future__ import division</code>。

* <code>print</code>语句没有了，取而代之的是<code>print()</code>函数。可以使用<code>2to3</code>工具来自动转换。Python 2.6与Python 2.7部分地支持这种形式的<code>print</code>语法。Python 2.6要支持完全新的<code>print()</code>语法，可以<code>from __future__ import print_function</code>。

* 取消了<code>exec</code>语句，只剩下<code>exec()</code>函数。Python 2.6已经支持<code>exec()</code>函数。

* 移除Python 2的<code>input</code>函数，并将<code>raw_input</code>函数重命名为<code>input</code>。Python 3的<code>input</code>函数表现得如同Python 2的<code>raw_input</code>函数，在其中输入总是作为字符串返回而非作为表达式求值。

* 捕获异常的语法由<code>except exc, var</code>改为<code>except exc as var</code>。使用语法<code>except (exc1, exc2) as var</code>可以同时捕获多种类型的异常。Python 2.6已经支持这两种语法。

*  如果两个对象之间没有定义明确的有意义的顺序。使用<code><, >, <=, >=</code>比较它们会抛出异常。比如<code>1 < ""</code>在Python 2.6里面会返回<code>True</code>，而在Python 3.0里面会抛出异常。现在<code>cmp(), instance.__cmp__()</code>函数已经被删除。

* 集合（set）的新写法：<code>{1,2,3,4}</code>。注意<code>{}</code>仍然表示空的字典（dict）。

* 将<code>long</code>类型重命名为<code>int</code>类型，就是说只有一种整数类型，叫做<code>int</code>而表现得更像老式的<code>long</code>。

* 新的<code>str</code>类型表示一个[[Unicode|Unicode]]字符串，相当于Python 2.x版本的<code>unicode</code>类型。而字节序列则用类似<code>b"abc"</code>的语法表示，用<code>bytes</code>类表示，相当于Python 2.x的<code>str</code>类型。现在两种类型不能再隐式地自动转换，因此在Python 3.x里<code>"fish" + b"panda"</code>是错误的。正确的写法是<code>"fish" + b"panda".decode("utf-8")</code>。Python 2.6可以自动地将字节序列识别为Unicode字符串，方法是<code>from __future__ import unicode_literals</code>。

* 八进制数必须写成<code>0o777</code>，原来的形式<code>0777</code>不能用了；二进制必须写成<code>0b111</code>。新增了一个<code>bin()</code>函数用于将一个整数转换成二进制字符串。Python 2.6已经支持这两种语法。

* <code>dict.keys(), dict.values(), dict.items(), map(), filter(), range(), zip()</code>不再返回列表，而是迭代器。

*将<code>reduce</code>（不涉及<code>map</code>或<code>filter</code>）从内建名字空间移动至<code>functools</code>，理由是使用<code>reduce</code>的代码不如使用循环和累加器变量的代码好读<ref>{{cite web |url=http://www.artima.com/weblogs/viewpost.jsp?thread=211200 |title=Python 3000 FAQ |first=Guido |last=van Rossum |work=artima.com |accessdate=2016-12-27 |archive-date=2020-11-09 |archive-url=https://web.archive.org/web/20201109015427/https://www.artima.com/weblogs/viewpost.jsp?thread=211200 |dead-url=no }}</ref>。

* 多个模块被改名（根据PEP8）：_winreg → winreg，ConfigParser → configparser，copy_reg → copyreg，Queue → queue，SocketServer → socketserver，repr → reprlib。

* <code>StringIO</code>模块现在被合并到新的<code>io</code>模块内。<code>new, md5, gopherlib</code>等模块被删除。Python 2.6已经支持新的<code>io</code>模块。

* <code>httplib, BaseHTTPServer, CGIHTTPServer, SimpleHTTPServer, Cookie, cookielib</code>被合并到<code>http</code>包内。
{{div col end}}

==註釋==
{{Reflist|2}}

== 延伸閱讀 ==
{{refbegin|2}}
<!-- THIS IS *NOT* A LIST OF ALL PYTHON BOOKS
According to [[Wikipedia:Further_reading|Wikipedia:Further reading]], criteria for inclusion includes:
1. Should clearly qualify as WP:RS, as indicated by reviews and citations to it.
...
5. There should be guidelines on limiting the number of sources.
6. To avoid spam, any book included should have received more than one good review in RS: newspapers and scholarly journals being the norm, and the clear balance of RS reviews should be positive. This would avoid self-publish spamming, POV pushing, and attempts by publishers to get books promoted through inclusion on Wikipedia. At the moment "editorial recommendations" as described in the manual smacks of OR.
7. Neutrality on the part of editors is essential. In terms of major debates, items representing all major positions should be included, with annotations indicating the specific POV of each. We may have to work out rules where topic disputes are irreconcilable.
-->
*{{cite web|url=https://www-inst.eecs.berkeley.edu//~cs61a/sp12/book/|title=SICP in Python － CS61A: Online Textbook|author=John Denero|date=2012-03-21|access-date=2020-10-09|archive-date=2020-05-30|archive-url=https://web.archive.org/web/20200530144211/http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/|dead-url=no}}{{cite web|url=https://wizardforcel.gitbooks.io/sicp-py/content/|title=SICP Python 描述 中文版|translator=飞龙|access-date=2020-10-09|archive-date=2020-04-21|archive-url=https://web.archive.org/web/20200421233602/https://wizardforcel.gitbooks.io/sicp-py/content/|dead-url=no}}
*{{cite web|url=https://composingprograms.com/|title=Composing Programs, a free online introduction to programming and computer science|author=John DeNero|access-date=2020-10-09|archive-date=2021-01-28|archive-url=https://web.archive.org/web/20210128225757/https://composingprograms.com/|dead-url=no}}
* {{cite book |last=Downey |first=Allen B. |title = Think Python: How to Think Like a Computer Scientist |edition=Version 1.6.6 |date=May 2012 |isbn=978-0-521-72596-5 }}
* {{cite book |last=Lutz |first=Mark |title=Learning Python |publisher=O'Reilly Media |year=2013 |edition=5th |isbn=978-0-596-15806-4 }}
{{refend}}

== 参閲 ==
{{Portal|電腦程式設計|自由軟體}}
{{div col|2}}
* [[编程语言列表|编程语言列表]]
* [[Python語法及語義|Python語法及語義]]
* [[pip_(軟件包管理系統)|pip (軟件包管理系統)]]
* [[PyPI|PyPI]]，正式第三方[[软件包|軟件包]]的[[軟件存儲庫|軟件存儲庫]]
* [[IPython|IPython]]
{{div col end}}

== 外部連接 ==
{{Sister project links |wikt=no |commons = Category:Python (programming language) |b=Python |n=no |q=Python |s=no |v= Subject:Python |voy=no |species=no |d=no }}
{{div col|2}}
* {{Official website}}
* {{Curlie|Computers/Programming/Languages/Python|Python}}
* [https://github.com/vinta/awesome-python Awesome Python] {{Wayback|url=https://github.com/vinta/awesome-python |date=20210205024420 }}
* [https://realpython.com/ Real Python Tutorials] {{Wayback|url=https://realpython.com/ |date=20210207194322 }}
* [https://www.programiz.com/python-programming programingz － Learn Python Programming] {{Wayback|url=https://www.programiz.com/python-programming |date=20210208142230 }}
* [https://www.w3schools.com/python/ w3schools － Python Tutorial] {{Wayback|url=https://www.w3schools.com/python/ |date=20210204202552 }}
* [https://itsmycode.com/category/python/ ItsMyCode － Learn Python Programming] {{Wayback|url=https://itsmycode.com/category/python/ |date=20211026192003}}
* [https://codecary.com/category/python/ Codecary － Learn Python Programming] {{Wayback|url=https://codecary.com/category/python/ |date=20211026192003}}
* [https://dainikchorcha.com dainikchorcha － Learn Python Programming]{{Wayback|url=https://dainikchorcha.com/ |date=20220306124159 }}
* [https://www.tutlane.com/tutorial/python Tutlane - Learn Python Online] {{Wayback|url=https://www.tutlane.com/tutorial/python |date=20210616043552 }}
* [https://www.scaler.com/topics/python/ Scaler Topics - Learn Python Programming] {{Wayback|url=https://www.scaler.com/topics/python/ |date=20210616043552 }}
{{div col end}}
{{-}}
{{Python|state=collapsed}}
{{程序设计语言|Python|state=collapsed}}
{{Python web frameworks|state=collapsed}}
{{Differentiable computing|state=collapsed}}
{{Package management systems|state=collapsed}}
{{FOSS|state=collapsed}}

[[Category:Python|]]
[[Category:腳本語言|Category:腳本語言]]
[[Category:面向对象的编程语言|Category:面向对象的编程语言]]
[[Category:面向文本编程语言|Category:面向文本编程语言]]
[[Category:基于类的编程语言|Category:基于类的编程语言]]
[[Category:LAMP|Category:LAMP]]
[[Category:荷兰发明|Category:荷兰发明]]
[[Category:1991年建立的程式語言|Category:1991年建立的程式語言]]