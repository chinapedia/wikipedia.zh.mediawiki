'''卢恩算法'''（{{lang-en|Luhn algorithm}}），也称为“'''模10'''”（Mod 10）[[算法|算法]]，是一种简单的[[校验和|校验和]]算法，一般用于验证身份识别码，例如[[发卡行识别码|发卡行识别码]]、[[国际移动设备识别码|国际移动设备识别码]]，美国{{link-en|国家提供商标识|National Provider Identifier}}号码，或是{{link-en|加拿大社会保险号码|Social Insurance Number}}。该算法由[[IBM|IBM]]科学家{{link-en|漢斯·彼得·盧恩|Hans Peter Luhn}}创造，专利于1954年1月6日申请，1960年8月23日颁证，美国专利号2950048<ref>[http://www.google.com/patents?id=Y7leAAAAEBAJ 专利 US2950048 - COMPUTER FOR VERIFYING NUMBERS  -  Google 专利]</ref>。

该算法现已属于[[公有领域|公有领域]]并得到了广泛的应用，例如[[ISO/IEC_7812|ISO/IEC 7812]]-1<ref>{{Cite web |url=http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=39698 |title=ISO/IEC 7812-1:2006 Identification cards -- Identification of issuers -- Part 1: Numbering system |accessdate=2013-10-19 |archive-date=2016-06-29 |archive-url=https://web.archive.org/web/20160629031816/http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=39698 |dead-url=no }}</ref>。它不是一种安全的加密[[哈希函数|哈希函数]]，设计它的目的只是防止意外出错而不是恶意攻击。

== 描述 ==
卢恩算法会通过[[校验码|校验码]]对一串数字进行验证，校验码通常会被加到这串数字的末尾处，从而得到一个完整的身份识别码。

我们以数字“7992739871”为例，计算其校验位，设校验位为X并添加至数列末位，即7992739871X：

#从校验位开始，从右往左，偶数位乘2（例如，7*2=14），然后将两位数字的个位与十位相加（例如，10：1+0=1，14：1+4=5）；
#把得到的数字加在一起（本例中得到67）；
#将数字的和取模10（本例中得到7），再用10去减（本例中得到3），得到校验位。

{| class="wikitable" style="text-align:center"
! 原始数字
| style="width:1.5em" | 7
| style="width:1.5em" | 9
| style="width:1.5em" | 9
| style="width:1.5em" | 2
| style="width:1.5em" | 7
| style="width:1.5em" | 3
| style="width:1.5em" | 9
| style="width:1.5em" | 8
| style="width:1.5em" | 7
| style="width:1.5em" | 1
| style="width:1.5em" | x
|-
! 偶数位乘2
| 7
| style="background: #FFA;" | 18
| 9
| style="background: #FFA;" | 4
| 7
| style="background: #FFA;" | 6
| 9
| style="background: #FFA;" | 16
| 7
| style="background: #FFA;" | 2
| x
|-
! 将数字相加
|7
|9
|9
|4
|7
|6
|9
|7
|7
|2
|=6'''7'''
|-
! 再用10去减得到校验位
|
|
|
|
|
|
|
|
|
|
|'''3'''
|}

另一种方法是：
#从校验位开始，从右往左，偶数位乘2，然后将两位数字的个位与十位相加；
#计算所有数字的和（67）；
#乘以9（603）；
#取其个位数字（3），得到校验位。

== 优缺点 ==

卢恩算法可以发现某一位的错误。
卢恩算法几乎可以发现所有由于邻位上数字被交换产生的错误。
但是，它只能发现数字交换产生的错误中的7/10，不会发现22 ↔ 55, 33 ↔ 66 或 44 ↔ 77。

==参考文献==
{{reflist}}

[[Category:同余|Category:同余]]
[[Category:校验和算法|Category:校验和算法]]
[[Category:错误检测与校正|Category:错误检测与校正]]