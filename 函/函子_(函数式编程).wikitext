{{for|[[范畴论|范畴论]]中的概念|函子}}
{{NoteTA|G1=IT}}
在[[函数式编程|函数式编程]]中，'''函子'''（functor）是受到[[范畴论|范畴论]][[函子|函子]]启发的一种[[设计模式|设计模式]]，它允许[[泛型编程|泛化类型]]在内部应用一个[[函数|函数]]而不改变泛化类型的结构。函子形成了更复杂的抽象如[[应用式函子|应用式]]、[[单子_(函数式编程)|单子]]、[[单子_(函数式编程)#IO_monad|Comonad]]的基础。

==概述==
这个想法在[[Haskell|Haskell]]中使用[[类型类|类型类]]来编码实现：

<syntaxhighlight lang="haskell">
class Functor f where
  fmap :: (a -> b) -> f a -> f b
</syntaxhighlight>

具有叫做“函子定律”的条件：

<syntaxhighlight lang="haskell">
fmap id = id
fmap (g . h) = (fmap g) . (fmap h)
</syntaxhighlight>

在[[Scala|Scala]]中使用高{{en-link|种类 (类型论)|Kind (type theory)|种类}}类型：

<syntaxhighlight lang="scala">
trait Functor[F[_]] {
  def map[A,B](a: F[A])(f: A => B): F[B]
}
</syntaxhighlight>

其简单的例子是[[可选类型|可选类型]]和[[集合_(计算机科学)|搜集类型]]。函子可用于建模“函数作用”来向仍未完成的计算应用一个函数。

在C++中，名字“函子”指称的是[[函数对象|函数对象]]而非这里的定义。

==参见==
*[[类型类|类型类]]
*[[map_(高阶函数)|map (高阶函数)]]
*[[单子_(函数式编程)|单子]]
*[[应用式函子|应用式函子]]

== 外部链接 ==
{{Wikibooks|en:Haskell/The Functor class|函子类}}
* [https://wiki.haskell.org/Typeclassopedia#Functor section about Functor in Haskell Typeclassopedia] {{Wayback|url=https://wiki.haskell.org/Typeclassopedia#Functor |date=20210213113437 }}
* [http://learnyouahaskell.com/functors-applicative-functors-and-monoids chapter 11 Functors, Applicative Functors and Monoids in Learn You a Haskell for Great Good!] {{Wayback|url=http://learnyouahaskell.com/functors-applicative-functors-and-monoids |date=20110521062557 }}
* [https://typelevel.org/cats/typeclasses/functor.html documentation for Functor in Cats library] {{Wayback|url=https://typelevel.org/cats/typeclasses/functor.html |date=20201120085910 }} (in scala)
* [https://github.com/lemastero/scala_typeclassopedia#functor section about Functor in lemastero/scala_typeclassopedia] {{Wayback|url=https://github.com/lemastero/scala_typeclassopedia#functor |date=20201009111953 }}

{{软件设计模式}}

{{Software-stub}}
[[Category:函数式编程|Category:函数式编程]]
[[Category:软件设计模式|Category:软件设计模式]]