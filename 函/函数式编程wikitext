{{noteTA
|G1 = IT
}}
{{编程范式}}

'''函数式编程'''，或称'''函数程序设计'''、'''泛函编程'''（{{lang-en|Functional programming}}），是一种[[编程范式|编程范式]]，它将[[电脑运算|电脑运算]]视为[[函数|函数]]运算，并且避免使用程式{{en-link|状态 (计算机科学)|State (computer science)|状态}}以及[[不可变物件|易变物件]]。其中，[[λ演算|λ演算]]为该语言最重要的基础。而且，λ演算的函数可以接受函数作为输入參數和输出返回值。

比起[[指令式編程|指令式編程]]，函數式編程更加強調程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。

在函数式编程中，函数是[[头等对象|头等对象]]，意思是说一个函数，既可以作为其它函数的输入参数值，也可以从函数中返回值，被修改或者被分配给一个变量。

== 歷史 ==
[[阿隆佐·邱奇|阿隆佐·邱奇]]在1930年代开发的[[λ演算|λ演算]]<ref>{{cite web|url=https://www.semanticscholar.org/paper/The-calculi-of-lambda-conversion-Church/9c6e618fe404c84ecb2fcca1dba505e040460f51|title=The calculi of lambda-conversion|author=[[Alonzo_Church|Alonzo Church]]|year=1941|publisher=Annals of Mathematics studies, no. 6. Lithoprinted. Princeton University Press, Princeton|access-date=2021-09-24|archive-date=2022-05-19|archive-url=https://web.archive.org/web/20220519064303/https://www.semanticscholar.org/paper/The-calculi-of-lambda-conversion-Church/9c6e618fe404c84ecb2fcca1dba505e040460f51}}</ref>，是建造自{{en-link|函数应用|Function application}}的一种[[计算模型_(数学)|计算]]的[[形式系统|形式系统]]。在1937年，[[艾伦·图灵|艾伦·图灵]]证明了λ演算和[[图灵机|图灵机]]是等价的计算模型<ref>{{cite journal|first=A. M.|last=Turing|doi=10.2307/2268280|title=Computability and λ-definability|year=1937|url=http://gtts.ehu.es/German/Docencia/2021/MTBYC/pdf/Computaility%20and%20lambda-definability.pdf|journal=The Journal of Symbolic Logic|pages=153–163|volume=2|issue=4|publisher=Cambridge University Press|jstor=2268280|access-date=2021-09-24|archive-date=2021-09-24|archive-url=https://web.archive.org/web/20210924064355/http://gtts.ehu.es/German/Docencia/2021/MTBYC/pdf/Computaility%20and%20lambda-definability.pdf}}</ref>，展示了λ演算是[[图灵完备性|图灵完备性]]的。λ演算形成了所有函数式编程语言的基础。另一种等价的理论公式化是[[组合子逻辑|组合子逻辑]]，它由{{en-link|Moses Schönfinkel}}和[[哈斯凯尔·柯里|哈斯凯尔·柯里]]在1920年代和1930年代开发。<ref>{{cite book|author1=[[Haskell_Curry|Haskell Brooks Curry]]|author2={{en-link|Robert Feys}}|title=Combinatory Logic|url=https://archive.org/details/combinatorylogic0002curr|access-date=10 February 2013|year=1958|publisher=North-Holland Publishing Company}}</ref>

邱奇后来又开发了[[简单类型λ演算|简单类型λ演算]]，它通过向所有的项指定一个[[数据类型|类型]]而扩展了λ演算。<ref>{{cite journal | last1 = Church | author-link = Alonzo Church | first1 = A. | year = 1940 | title = A Formulation of the Simple Theory of Types | url = https://www.classes.cs.uchicago.edu/archive/2007/spring/32001-1/papers/church-1940.pdf | journal = Journal of Symbolic Logic | volume = 5 | issue = 2 | pages = 56–68 | doi = 10.2307/2266170 | jstor = 2266170 | access-date = 2021-09-24 | archive-date = 2021-05-07 | archive-url = https://web.archive.org/web/20210507012514/https://www.classes.cs.uchicago.edu/archive/2007/spring/32001-1/papers/church-1940.pdf }}</ref>这个系统形成了静态类型函数式编程的基础。

于20世纪50年代后期，[[John_McCarthy_(computer_scientist)|John McCarthy]]在[[麻省理工学院|麻省理工学院]]，开发了早期的函数式语言[[LISP|LISP]]，运行在大型IBM主机（{{en-link|IBM700/7000系列|IBM 700/7000 series}}）上。<ref>{{cite web | first = John | last = McCarthy | authorlink = John McCarthy (computer scientist) | title = History of Lisp | publisher = Artificial Intelligence Laboratory, Stanford University | date = 12 February 1979 | url = http://jmc.stanford.edu/articles/lisp/lisp.pdf | quote = There were two motivations for developing a language for the [[IBM_704|IBM 704]]. First, IBM was generously establishing a New England Computation Center at M.I.T. …… Second, IBM was undertaking to develop a program for proving theorems in plane geometry (based on an idea of Marvin Minsky’s), ……. ……<br />In connection with IBM’s plane geometry project, [[Nathaniel_Rochester|Nathaniel Rochester]] and {{en-link|Herbert Gelernter}} (on the advice of McCarthy) decided to implement a list processing language within FORTRAN, ……. This work was undertaken by Herbert Gelernter and Carl Gerberich at IBM and led to FLPL, standing for FORTRAN List Processing Language. ……<br />I spent the summer of 1958 at the IBM Information Research Department at the invitation of Nathaniel Rochester and chose differentiating algebraic expressions as a sample problem. It led to the following innovations beyond FLPL:<br />a. Writing recursive function definitions using conditional expressions. …… b. The maplist function that forms a list of applications of a functional argument to the elements of a list. …… c. To use functions as arguments, one needs a notation for functions, and it seemed natural to use the λ-notation of Church (1941). I didn’t understand the rest of his book, so I wasn’t tempted to try to implement his more general mechanism for defining functions. Church used higher order functionals instead of using conditional expressions. Conditional expressions are much more readily implemented on computers. d. The recursive definition of differentiation made no provision for erasure of abandoned list structure. ……<br />The implementation of LISP began in Fall 1958. …… The programs to be hand-compiled were written in an informal notation called {{en-link|M-表达式|M-expression|M-expressions}} intended to resemble FORTRAN as much as possible. | access-date = 2021-09-23 | archive-date = 2020-11-07 | archive-url = https://web.archive.org/web/20201107223933/http://jmc.stanford.edu/articles/lisp/lisp.pdf }}</ref>
LISP的函数定义借鉴了邱奇的λ表示法<ref>{{cite web|author={{en-link|David Turner|David Turner (computer scientist)|David Turner}}|title=Some History of Functional Programming Languages|url=https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf|quote=LISP was not based on the lambda calculus, despite using the word “LAMBDA” to denote functions. At the time he invented LISP, McCarthy was aware of (Church 1941) but had not studied it. The theoretical model behind LISP was Kleene’s theory of first order recursive functions. (McCarthy made these statements, or very similar ones, in a contribution from the floor at the 1982 ACM symposium on LISP and functional programming in Pittsburgh. No written version of this exists, as far as know.)|access-date=2021-09-23|archive-date=2020-04-15|archive-url=https://web.archive.org/web/20200415053847/https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf}}<br />{{cite web|url=http://www.cs.yale.edu/homes/fischer/pubs/lambda.pdf|author={{en-link|Michael J. Fischer}}|title=Lambda-Calculus Schemata|year=1993|publisher=LISP AND SYMBOLIC COMPUTATION: An International Journal, 6, 259–288|quote=Pure LISP allows the definition and evaluation of functions over S-expressions. The lambda notation for functional abstraction is borrowed from Church’s lambda calculus, but otherwise there is little similarity between the two systems. Pure LISP has no higher-order functions, and call-by-value evaluation order is implicitly assumed. Two special constructs, conditional expressions and the label operator, allow recursive functions to be defined. Limited as it is, pure LISP is nevertheless powerful enough to express all partial recursive functions and hence provides an adequate basis for a theory of computation.|access-date=2021-09-23|archive-date=2022-03-02|archive-url=https://web.archive.org/web/20220302172407/http://www.cs.yale.edu/homes/fischer/pubs/lambda.pdf}}</ref>，并扩展了标签构造来允许[[递归_(计算机科学)|递归]]函数。<ref>{{cite journal|author=John McCarthy|author-link=John McCarthy (computer scientist)|title=Recursive functions of symbolic expressions and their computation by machine, Part I.|journal=Communications of the ACM|volume=3|issue=4|year=1960|pages=184–195|url=http://jmc.stanford.edu/articles/recursive/recursive.pdf|publisher=ACM New York, NY, USA|doi=10.1145/367177.367199|access-date=2021-02-24|archive-date=2021-02-19|archive-url=https://web.archive.org/web/20210219160021/http://jmc.stanford.edu/articles/recursive/recursive.pdf}}<br />
{{Cite book | url = http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf | title = LISP 1.5 Programmer's Manual | publisher = [[MIT_Press|MIT Press]] | author = [[John_McCarthy|John McCarthy]], Paul W. Abrahams, Daniel J. Edwards, Timothy P. Hart, Michael I. Levin | isbn = 0-262-13011-4 | orig-year = 1962 | edition = 2nd | year = 1985 | quote = A function can be simply a name. In this case its meaning must be previously understood. A function may be defined by using the lambda notation and establishing a correspondence between the arguments and the variables used in a form. If the function is recursive, it must be given a name by using a label. ……<br /> When a symbol stands for a function, the situation is similar to that in which a symbol stands for an argument. When a function is recursive, it must be given a name. This is done by means of the form LABEL, which pairs the name with the function definition on the a-list. The name is then bound to the function definition, just as a variable is bound to its value.<br />In actual practice, LABEL is seldom used. It is usually more convenient to attach the name to the definition in a uniform manner. This is done by putting on the property list of the name, the symbol EXPR followed by the function definition. The pseudo-function <code>define</code> used at the beginning of this section accomplishes this. When <code>apply</code> interprets a function represented by an atomic symbol, it searches the p-list of the atomic symbol before searching the current a-list. Thus a <code>define</code> will override a LABEL. | access-date = 2021-09-23 | archive-date = 2021-03-02 | archive-url = https://web.archive.org/web/20210302065612/http://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf }}</ref>最开始的LISP是多[[编程范型|范型]]语言，并且随着新的范型的发展，越来越多的编程风格得到了支持。后来发展出来的方言比如[[Scheme|Scheme]]、[[Clojure|Clojure]]，和分支语言比如[[Dylan_(编程语言)|Dylan]]和[[Julia_(编程语言)|Julia]]等，试图简化LISP，使它围绕一个函数式核心，而[[Common_Lisp|Common Lisp]]旨在保留并更新它所替代的各种更早先LISP方言的那些范型特征。<ref>{{cite journal|author1=Guy L. Steele |author2=Richard P. Gabriel |title=The Evolution of Lisp |journal=In ACM/SIGPLAN Second History of Programming Languages |pages=233–330 |date=February 1996 |url=http://dreamsongs.com/Files/HOPL2-Uncut.pdf |doi=10.1145/234286.1057818 |isbn=978-0-201-89502-5 |access-date=2019-05-12 |archive-date=2020-11-12 |archive-url=https://web.archive.org/web/20201112011710/https://dreamsongs.com/Files/HOPL2-Uncut.pdf |dead-url=no }}</ref>

而于1956年发明的[[信息处理语言|IPL]]语言，一般被认为是第一个基于计算机的函数式编程语言。<ref>The memoir of Herbert A. Simon (1991), ''Models of My Life'' pp.189-190 {{ISBN|0-465-04640-1}} claims that he, Al Newell, and Cliff Shaw are "...commonly adjudged to be the parents of [the] artificial intelligence [field]," for writing Logic Theorist, a program that proved theorems from ''Principia Mathematica'' automatically. To accomplish this, they had to invent a language and a paradigm that, viewed retrospectively, embeds functional programming.</ref> 它是一种用于操纵符号列表的汇编式语言。它有一个生成器的概念，相当于一个接受函数作为参数的函数，并且，由于它是汇编级语言，代码可以是数据，因此IPL可以被视为具有[[高阶函数|高阶函数]]。但是，它在很大程度上依赖于改变列表的结构和类似的指令式编程特征。

在1960年代早期，[[Kenneth_E._Iverson|Kenneth E. Iverson]]开发了[[APL语言|APL]]语言，在他1962年出版的《A Programming Language》一书中对其有所介绍。<ref>{{cite web|author=[[Kenneth_E._Iverson|Kenneth E. Iverson]]|title=A Programming Language|url=https://www.jsoftware.com/papers/APL.htm|publisher=Wiley|year=1962|access-date=2021-09-24|archive-date=2019-04-01|archive-url=https://web.archive.org/web/20190401145403/http://www.jsoftware.com/papers/APL.htm}}</ref>APL对John Backus的[[FP_(编程语言)|FP]]语言施加了巨大的影响。在20世纪90年代早期，Iverson和{{en-link|Roger Hui}}创造了[[J语言|J]]语言。在20世纪90年代中期，以前曾与Iverson合作过的{{en-link|Arthur Whitney|Arthur Whitney (computer scientist)|Arthur Whitney}}创建了[[K_(编程语言)|K]]语言，后者在金融行业中与其衍生出来的{{en-link|Q (阵列编程语言)|Q (programming language from Kx Systems)|Q}}语言一起被商业化使用。

1977年[[John_Backus|John Backus]]在他的图灵奖颁奖演讲《编程可以从冯·诺依曼式风格中解放出来吗？一种函数式风格及其程序代数》中，展示了他提出的[[FP_(编程语言)|FP]]<ref>{{cite web|url=http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf|title=Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs|accessdate=2019-05-12|archive-date=2020-11-08|archive-url=https://web.archive.org/web/20201108100553/http://worrydream.com/refs/Backus-CanProgrammingBeLiberated.pdf|dead-url=no}}</ref>。他将函数式编程定义为通过“组合形式”以分层方式构建，允许“程序代数”; 在现代语言中，这意味着函数式程序应遵循[[复合性原理|复合性原理]]。Backus的论文推广了函数式编程的研究，虽然它强调的是[[函数级编程|函数级编程]]而不是现在所说的λ演算风格。

1973年[[爱丁堡大学|爱丁堡大学]]的[[Robin_Milner|Robin Milner]]发明了[[ML语言|ML]]语言，它的语法受到了[[ISWIM|ISWIM]]的启发。同年，{{en-link|David Turner|David Turner (computer scientist)|David Turner}}在[[圣安德鲁斯大学|圣安德鲁斯大学]]开发了[[SASL_(编程语言)|SASL]]语言，它基于了[[ISWIM|ISWIM]]的应用式子集<ref>{{cite journal |last=Turner|first=D.A.|title=An Implementation of SASL|journal=University of St. Andrews, Department of Computer Science Technical Report|volume=TR/75/4}}</ref>。在1976年，Turner重新设计并重新实现它为[[惰性求值|惰性求值]]语言<ref>{{cite web|author=D.A. Turner|title=A New Implementation Technique for Applicative Languages|url=https://courses.engr.illinois.edu/cs421/sp2012/project/turner-implementation.pdf|access-date=2021-09-24|archive-date=2021-09-06|archive-url=https://web.archive.org/web/20210906184039/https://courses.engr.illinois.edu/cs421/sp2012/project/turner-implementation.pdf}}</ref>。在20世纪70年代的爱丁堡，{{en-link|Rod Burstall}}和John Darlington开发了[[NPL_(编程语言)|NPL]]语言。<ref>R.M. Burstall. Design considerations for a functional programming language. Invited paper, Proc. Infotech State of the Art Conf. "The Software Revolution", Copenhagen, 45–57 (1977)</ref> NPL基于[[Stephen_Kleene|Kleene]]的[[递归关系|递归方程]]，并在他们的程序转换工作中首次引入。<ref>{{cite web|author=R.M. Burstall, J. Darlington|title=A transformation system for developing recursive programs|url=https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.645&rep=rep1&type=pdf|publisher=Journal of the Association for Computing Machinery|page=24(1):44–67|year=1977|access-date=2021-09-24|archive-date=2020-01-28|archive-url=https://web.archive.org/web/20200128085329/http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.645&rep=rep1&type=pdf}}</ref> 然后Rod Burstall、David MacQueen和{{en-link|Don Sannella}}结合了来自ML的多态类型检查，从[[NPL_(编程语言)|NPL]]派生出了[[Hope_(编程语言)|Hope]]语言。<ref>{{cite web|url=https://homepages.inf.ed.ac.uk/dts/pub/hope.pdf|author={{en-link|Rod Burstall}}, D.B. MacQueen, D.T. Sannella.|year=1980|title=Hope: An Experimental Applicative Language|access-date=2021-09-24|archive-date=2022-01-28|archive-url=https://web.archive.org/web/20220128115243/https://homepages.inf.ed.ac.uk/dts/pub/hope.pdf}} Conference Record of the 1980 LISP Conference, Stanford University, pp. 136-143.</ref>ML最终发展成几种语言，其中最常见的是[[OCaml|OCaml]]和[[Standard_ML|Standard ML]]。

在1970年代，[[Guy_L._Steele|Guy L. Steele]]和[[Gerald_Jay_Sussman|Gerald Jay Sussman]]开发了[[Scheme|Scheme]]，如有影响力的“Lambda论文集”和经典的1985年教科书《[[计算机程序的构造和解释|计算机程序的构造和解释]]》中所描述的那样。[[Scheme|Scheme]]是使用[[词法作用域|词法作用域]]和[[尾调用|尾调用优化]]的第一个Lisp方言，将函数式编程的影响力提升到更广泛的范围，让更多的编程语言社区接触到它们。

在1980年代，[[佩尔·马丁-洛夫|佩尔·马丁-洛夫]]开发了[[直觉类型论|直觉类型论]]（也称为构造类型论），它将函数式编程与表现为[[依赖类型|依赖类型]]的数学证明联系起来。这导致了{{en-link|交互式定理证明|Proof assistant}}的新方法的产生，并影响了后续的函数式编程语言的发展。

在1985年{{en-link|David Turner|David Turner (computer scientist)|David Turner}}开发的惰性求值函数式语言[[Miranda_(编程语言)|Miranda]]出现，它採用了來自[[ML语言|ML]]與[[Hope_(编程语言)|Hope]]语言的概念，作為他先前所設計的[[SASL_(编程语言)|SASL]]和[[肯特递归计算器|KRC]]语言的後繼者。Miranda对后来的[[Haskell|Haskell]]有很强的影响，由于它当时是专有软件，所以Haskell社区于1987年开始达成共识，以形成函数式编程研究的开放标准，对标准的实现自1990年以来一直在进行中。

最近，它在基于CSG几何框架构建的OpenSCAD语言的参数CAD中得到了应用，虽然在重新赋值上的限制（所有值都被当作常量），导致了不熟悉函数式编程的用户混淆。<ref>{{cite web|url = http://forum.openscad.org/Make-discovering-assign-easier-td10964.html|website = OpenSCAD|title = Make discovering assign() easier!|accessdate = 2019-05-12|archive-date = 2020-09-28|archive-url = https://web.archive.org/web/20200928173701/http://forum.openscad.org/Make-discovering-assign-easier-td10964.html|dead-url = no}}</ref>

==应用==
=== 工业 ===
函数式编程长期以来在学术界流行，但几乎没有工业应用。造成这种局面的主因是函數式編程常被認為嚴重耗費CPU和記憶體資源<ref>{{cite book|author=Larry C. Paulson|title=ML for the Working Programmer|url=https://books.google.com/books?id=XppZdaDs7e0C|accessdate=10 February 2013|date=28 June 1996|publisher=Cambridge University Press|isbn=978-0-521-56543-1|archive-date=2020-04-09|archive-url=https://web.archive.org/web/20200409030643/https://books.google.com/books?id=XppZdaDs7e0C|dead-url=no}}</ref> <!-- Paulson mentions the reputation for inefficiency in Sec. 1.5; perhaps a more in-depth discussion could be found. -->，这是由于在早期實現函數式編程語言時並沒有考慮過效率問題，而且面向函数式编程特性，如保证{{en-link|参照透明性|Referential transparency}}等，要求独特的数据结构和算法。<ref name='programmingScala'>{{cite book | first1 = Martin | last1 = Odersky | first2 = Lex | last2 = Spoon | first3 = Bill | last3 = Venners | date = December 13, 2010 | title = Programming in Scala: A Comprehensive Step-by-step Guide | publisher = Artima | edition = 2nd | pages = 883/852 | isbn = 978-0-9815316-4-9 | url = http://www.artima.com/shop/programming_in_scala_2ed | access-date = 2019-05-12 | archive-date = 2016-04-30 | archive-url = https://web.archive.org/web/20160430190354/http://www.artima.com/shop/programming_in_scala_2ed | dead-url = no }}</ref>

然而，最近几种函数式编程语言已经在商业或工业系统中使用<ref>{{Cite journal|last=Ray|first=Baishakhi|last2=Posnett|first2=Daryl|last3=Devanbu|first3=Premkumar|last4=Filkov|first4=Vladimir|date=2017-09-25|title=A large-scale study of programming languages and code quality in GitHub|url=http://dl.acm.org/citation.cfm?doid=3144574.3126905|journal=Communications of the ACM|language=en|volume=60|issue=10|page=92|doi=10.1145/3126905|via=}}</ref>，例如：
*[[Erlang|Erlang]]，它由瑞典公司[[爱立信|爱立信]]在20世纪80年代后期开发，最初用于实现容错电信系统。此后，它已在[[北电网络|Nortel]]、[[Facebook|Facebook]]、[[法国电力公司|Électricité de France]]和[[WhatsApp|WhatsApp]]等公司作为流行语言建立一系列应用程序。<ref>{{cite conference | last = Piro | first = Christopher | title = Functional Programming at Facebook | url = http://cufp.galois.com/2009/abstracts.html#ChristopherPiroEugeneLetuchy | year = 2009 | conference = CUFP 2009 | accessdate = 2009-08-29 | archive-url = https://web.archive.org/web/20091017070140/http://cufp.galois.com/2009/abstracts.html#ChristopherPiroEugeneLetuchy | archive-date = 2009-10-17 | dead-url = yes }}</ref><ref name="whatsapp.blog.2012">[http://blog.whatsapp.com/index.php/2012/01/1-million-is-so-2011/ 1 million is so 2011] {{Wayback|url=http://blog.whatsapp.com/index.php/2012/01/1-million-is-so-2011/ |date=20140219234031 }} // WhatsApp blog, 2012-01-06: "the last important piece of our infrastracture is Erlang"</ref>
*[[Scheme|Scheme]]，它被用作早期[[苹果公司|Apple]] [[Macintosh|Macintosh]]计算机上的几个应用程序的基础，并且最近已应用于诸如训练模拟软件和望远镜控制等方向。
*[[OCaml|OCaml]]，它于20世纪90年代中期推出，已经在金融分析，驱动程序验证，工业机器人编程和嵌入式软件静态分析等领域得到了商业应用。
*[[Haskell|Haskell]]，它虽然最初是作为一种研究语言，也已被一系列公司应用于航空航天系统，硬件设计和网络编程等领域。

其他在工业中使用的函数式编程语言包括多范型的[[Scala|Scala]]<ref>{{cite conference | last = Momtahan | first = Lee | title = Scala at EDF Trading: Implementing a Domain-Specific Language for Derivative Pricing with Scala | url = http://cufp.galois.com/2009/abstracts.html#LeeMomtahan | year = 2009 | conference = CUFP 2009 | accessdate = 2009-08-29 | archive-url = https://web.archive.org/web/20091017070140/http://cufp.galois.com/2009/abstracts.html#LeeMomtahan | archive-date = 2009-10-17 | dead-url = yes }}</ref>、[[F＃|F#]]，还有[[Wolfram语言|Wolfram语言]]、[[Common_Lisp|Common Lisp]]、[[Standard_ML|Standard ML]]和[[Clojure|Clojure]]等。

=== 教育 ===
教育方面，函数式编程一直受到了很大的重视，很多学校使用函数式编程来教授算法和几何的相关概念<ref name="bootstrapworld">{{Triangulation|196|Emmanuel Schanzer of Bootstrap}}</ref>。

== 典型的函数式编程语言 ==

[[純函数式编程|純函数式编程]]语言通常不允许直接使用程式{{en-link|状态 (计算机科学)|State (computer science)|状态}}以及[[不可变对象|可变对象]]，典型语言有：[[Miranda_(编程语言)|Miranda]]、[[Haskell|Haskell]]和[[Idris|Idris]]等。

非純函数式编程语言可按类型系统分为两类：
*[[靜態類型|靜態類型]]语言：[[ML语言|ML]]家族的[[Standard_ML|Standard ML]]、[[OCaml|OCaml]]、[[F♯|F#]]，还有[[Scala|Scala]]、Typed Racket<ref>[http://docs.racket-lang.org/ts-guide/ Typed Racket] {{Wayback|url=http://docs.racket-lang.org/ts-guide/ |date=20201111220723 }}</ref>等。
*[[動態類型|動態類型]]语言：[[Lisp|Lisp]]家族的[[Scheme|Scheme]]、[[Common_Lisp|Common Lisp]]、[[Clojure|Clojure]]、[[Racket|Racket]]，还有[[Logo_(程序语言)|LOGO]]、[[Erlang|Erlang]]、[[Wolfram语言|Wolfram语言]]和[[R語言|R]]等。

其他特殊风格的函数式编程语言有：[[APL語言|APL]]/[[J语言|J]]和[[XSL_Transformations|XSLT]]等。

== 参考文献 ==
{{Reflist|2}}

== 外部連結 ==
* [http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html Why Functional Programming Matters] {{Wayback|url=http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html |date=20201112023406 }}

{{-}}

{{编程语言类别}}
{{Computer Science}}

[[Category:編程典範|Category:編程典範]]
[[Category:函數式編程|]]
[[Category:函数式编程语言|]]