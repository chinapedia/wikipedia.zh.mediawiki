{{noteTA
|T=zh-hans:头等对象;zh-hant:頭等物件;
|1=zh-hans:程序; zh-hant:程式;
|2=zh-hans:头等对象;zh-hant:頭等物件;
}}
'''頭等物件'''（{{lang-en|First-class object}}），在[[電腦科學|電腦科學]]中，指称支持其他实体通常能获得的所有运算的实体。这些运算典型的包括：在[[執行期|執行期]]創造，作為參數傳遞給其他函數，或存入一個[[變數|變數]]等<ref>{{cite book |title= Programming Language Pragmatics |last= Scott |first= Michael |authorlink= |coauthors= |year= 2006 |publisher= Morgan Kaufmann Publishers |location= San Francisco, CA |isbn= |oclc= |page= [https://archive.org/details/programminglangu00scot_812/page/n172 140] |pages= |url=https://archive.org/details/programminglangu00scot_812|accessdate=}}</ref>。將一個實體變為頭等物件的過程叫做「[[物件化|物件化]]」（Reification）<ref>{{cite web |url=http://www2.parc.com/csl/groups/sda/projects/reflection96/docs/malenfant/ref96/ref96.html |author=J. Malenfant, M. Jacques and F.-N. Demers |title=A Tutorial on Behavioral Reflection and its Implementation |publisher=parc.com |date= |accessdate=2010-10-09 |deadurl=yes |archiveurl=https://web.archive.org/web/20100528214857/http://www2.parc.com/csl/groups/sda/projects/reflection96/docs/malenfant/ref96/ref96.html |archivedate=2010-05-28 }}</ref>。

「頭等物件」這一名稱最早由[[克里斯托弗·斯特雷奇|克里斯托弗·斯特雷奇]]在1960年代發明，原稱「頭等公民」（First-class citizen），意指函數可作為電腦語言中的頭等公民。英文中也稱「First-class entity」或「First-class value」。

==历史==
头等对象和二等对象的概念，在1960年由[[克里斯托弗·斯特雷奇|克里斯托弗·斯特雷奇]]引入。<ref>Rod Burstall, "Christopher Strachey—Understanding Programming Languages", ''Higher-Order and Symbolic Computation'' '''13''':52 (2000)</ref><ref>{{cite book |url=http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#footnote_Temp_121 |author1=[[哈尔·阿伯尔森|Harold Abelson]] |author2=[[杰拉德·杰伊·萨斯曼|Gerald Jay Sussman]] |title=''Structure and Interpretation of Computer Programs'' |trans_title=计算机程序的构造和解释 |edition=2 |section=章节1.3.4 脚注64 |language=en |year= |accessdate=2015-03-03 |archiveurl=https://web.archive.org/web/20150309062836/http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#footnote_Temp_121 |archivedate=2015-03-09 |deadurl=yes }}</ref> 实际上他并没有给出严格的术语定义，而是给出了[[ALGOL|ALGOL]]语言中实数和过程的对比：

<blockquote>'''头等对象和二等对象'''。在Algol程序语言中，一个“实数”可能会出现在一个表达式中或被赋给一个变量，并可能在过程调用中作为实际参数出现。而“过程”只可能会出现在另一个过程调用中，最常见的是作为操作符，有时候也作为实参。除此之外，没有表达式会涉及到过程，或者将过程作为计算结果。因此在某种意义上，在Algol程序语言中的过程是二等公民，它们总是会单独出现，不可能被一个表达式或一个变量表示（形式参数除外）…<ref>Christopher Strachey, "Fundamental Concepts in Programming Languages" in ''Higher-Order and Symbolic Computation'' '''13''':11 (2000); though published in 2000, these are notes from lectures Strachey delivered in August, 1967</ref></blockquote>

在1990年代，{{en-link|拉斐尔·芬克尔|Raphael Finkel}}提出了二等值和三等值的定义<ref>{{cite book |author=R. Finkel |title=''Advanced Programming language Design'' |publisher= |isbn= |page=73 |language=en |year=}}</ref>，但这些定义尚未被广泛采用。<ref>{{cite web|title=About first-,second- and third-class value|author=Norman Ramsey|url=http://stackoverflow.com/a/2582804|website=[[Stackoverflow|Stackoverflow]]|language=en|date=|accessdate=14 September 2013}}</ref>

==定義==
頭等物件不一定是[[物件導向程式設計|物件導向程式設計]]所指的物件，而可以指任何程式中的實體。{{en-link|Robin Popplestone}}给出如下定义：
#所有项目都有特定的基本权力。
#所有项目都可以作为函数的实际参数。
#所有项目都可以作为函数的结果返回。
#所有项目都可以是赋值语句的主体。
#所有项目都可以等式测试。<ref>R. J. Popplestone: The Design Philosophy of [[POP-2|POP-2]]. in: D. Michie: Machine Intelligence 3, Edinburgh at the University Press, 1968</ref>

==範例==
最简单的[[标量|标量]]数据类型，比如整数和浮点数，几乎总是头等的。在很多较早的语言中，[[数组|数组]]和字符串不是头等的：它们不能被作为赋值的对象，或作为形式参数传递给子例程。例如，[[Fortran#FORTRAN_IV|FORTRAN IV]]和[[C语言|C]]都不支持数组赋值，并且它们在作为形式参数传递的时候，实际上只有它们的第一个元素的位置被传递了，它们的大小失去了。C看起来支持数组[[指针|指针]]的复制，但实际上它们只是到数组的第一个元素的指针，仍然不承载这个数组的大小。

不同語言中對函數的區別很大，例如[[C語言|C語言]]與[[C++|C++]]中的函數不是頭等物件，因為在這些語言中函數不能在[[執行期|執行期]]創造，而必須在設計時全部寫好。相比之下，[[Scheme|Scheme]]中的函數是頭等物件，因為可以用<code>lambda</code>表达式來創造[[匿名函數|匿名函數]]並作為頭等物件來操作。

{| class=wikitable
! 概念 !! 描述 !! 语言
|-
| [[头等函数|头等函数]] || [[闭包_(计算机科学)|闭包]]和[[匿名函数|匿名函数]] || [[Dart|Dart]], [[Scheme|Scheme]], [[ML语言|ML]], [[Haskell|Haskell]], [[F♯|F#]], [[Kotlin|Kotlin]], [[Scala|Scala]], [[Swift_(程式語言)|Swift]], [[Perl|Perl]], [[PHP|PHP]], [[Python|Python]], [[Raku|Raku]], [[JavaScript|JavaScript]], [[Delphi|Delphi]], [[Rust|Rust]]
|-
| 头等控制 || [[计算续体|续体]] || [[Scheme|Scheme]], [[ML语言|ML]], [[F♯|F#]]
|-
| 头等类型 || [[依赖类型|依赖类型]] || [[Coq|Coq]], [[Idris|Idris]], [[Agda|Agda]]
|-
| 头等数据类型 || || Generic Haskell, C++11
|-
| 头等多态 || [[参数多态#直谓与非直谓|非直谓多态]] || 
|-
| {{en-link|头等消息|first-class message}} || 动态[[消息传递|消息]]（方法调用）|| [[Smalltalk|Smalltalk]],<ref name="shroff-smith">Paritosh Shroff, Scott F. Smith. ''[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.114.4468&rep=rep1&type=pdf Type Inference for First-Class Messages with Match-Functions] {{Wayback|url=http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.114.4468&rep=rep1&type=pdf |date=20210816115958 }}''</ref> [[Objective-C|Objective-C]]<ref name="shroff-smith" />
|-
| 头等类 || [[元类|元类]] || [[Smalltalk|Smalltalk]], [[Objective-C|Objective-C]], [[Ruby|Ruby]], [[Python|Python]], [[Delphi|Delphi]]
|-
| 头等证明 <!-- proofs are first-class in IIT according to "Dependent Types at Work" --> || 证明对象<ref>{{cite journal|last2=Dybjer|first2=Peter|date=2009|title=Dependent Types at Work|url=http://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf|journal=Language Engineering and Rigorous Software Development|volume=5520|pages=57–99|doi=10.1007/978-3-642-03153-3_2|last1=Bove|first1=Ana|access-date=8 June 2015|url-status=live|archive-url=https://web.archive.org/web/20140402095457/http://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf|archive-date=April 2, 2014}} <!-- add back if original becomes obsolete | archiveurl = https://web.archive.org/web/20140402095457/http://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf | archivedate = 2014-04-02}} --> (also [http://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf archived] {{Wayback|url=http://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf |date=20140402095457 }})</ref> || [[Coq|Coq]], [[Agda|Agda]]
|}

== 参考文献 ==
{{Reflist|30em}}

[[Category:程序架構|Category:程序架構]]
[[Category:程序设计语言理论|Category:程序设计语言理论]]