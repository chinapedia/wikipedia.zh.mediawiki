'''自适应滤波器'''是能够根据输入信号自动调整性能进行[[数字信号处理|数字信号处理]]的[[数字滤波器|数字滤波器]]。作为对比，非自适应滤波器有静态的滤波器系数，这些静态系数一起组成[[传递函数|传递函数]]。

对于一些应用来说，由于事先并不知道所需要进行操作的参数，例如一些噪声信号的特性，所以要求使用自适应的系数进行处理。在这种情况下，通常使用自适应滤波器，自适应滤波器使用反馈来调整滤波器系数以及频率响应。

总的来说，自适应的过程涉及到将[[代价函数|代价函数]]用于确定如何更改滤波器系数从而减小下一次迭代过程成本的算法。价值函数是滤波器最佳性能的判断准则，比如减小输入信号中的噪声成分的能力。

随着[[数字信号处理器|数字信号处理器]]性能的增强，自适应滤波器的应用越来越常见，时至今日它们已经广泛地用于手机以及其它通信设备、数码录像机和数码照相机以及医疗监测设备中。

==结构框图==
下面图示的框图是[[最小均方滤波器|最小均方滤波器]]（LMS）和{{tsl|en|Recursive least squares filter|递归最小平方}}（RLS）这些特殊自适应滤波器实现的基础。框图的理论基础是可变滤波器能够得到所要信号的估计。
:[[File:AdaptiveFilter_C.png|500px]]
在开始讨论结构框图之前，我们做以下假设：
* 输入信号是所要信号 <math> d(n)</math> 和干扰噪声 <math> v(n)</math> 之和
:<math> x(n) = d(n)+v(n)</math>
* 可变滤波器有[[有限脉冲响应|有限脉冲响应]]结构，这样结构的脉冲响应等于滤波器系数。<math> p</math> 阶滤波器的系数定义为
:<math>\mathbf{w}_{n}=\left[w_{n}(0),\,w_{n}(1),\, ...,\,w_{n}(p)\right]^{T}</math>.  
* 误差信号或者叫作[[代价函数|代价函数]]，是所要信号与估计信号之差
:<math> e(n) = d(n)-\hat{d}(n)</math>

可变滤波器通过将输入信号与脉冲响应作卷积估计所要信号，用向量表示为
:<math> \hat{d}(n) = \mathbf{w}_{n}^{T}*\mathbf{x}(n)</math>
其中
:<math> \mathbf{x}(n)=\left[x(n),\,x(n-1),\,...,\,x(n-p)\right]^{T}</math>
是输入信号向量。另外，可变滤波器每次都会马上改变滤波器系数
:<math> \mathbf{w}_{n+1} = \mathbf{w}_{n}+\Delta\mathbf{w}_{n}</math>
其中 <math>\Delta\mathbf{w}_{n}</math> 是滤波器系数的校正因子。自适应算法根据输入信号与误差信号生成这个校正因子，LMS 和 RLS 是两种不同的系数更新算法。

==例子==

假设医院正在监测一个患者的心脏跳动，即[[心电图|心电图]]，这个信号受到 50 [[赫兹|Hz]] （许多国家供电所用频率）噪声的干扰

剔除这个噪声的方法之一就是使用 50Hz 的[[带阻滤波器|点阻滤波器]]对信号进行滤波。但是，由于医院的电力供应会有少许波动，所以我们假设真正的电力供应可能会在 47Hz 到 53Hz 之间波动。为了剔除 47 到 53Hz 之间的频率的静态滤波器将会大幅度地降低[[心电图|心电图]]的质量，这是因为在这个阻带之内很有可能就有心脏跳动的频率分量。

为了避免这种可能的信息丢失，可以使用自适应滤波器。自适应滤波器将患者的信号与电力供应信号直接作为输入信号，动态地跟踪噪声波动的频率。这样的自适应滤波器通常阻带宽度更小，这就意味着这种情况下用于医疗诊断的输出信号就更加准确。

==自适应滤波器的应用==
* [[通道均衡|通道均衡]]
* [[通道辨识|通道辨识]]（Channel identification）
* [[主动降噪|主动降噪]]
* [[信号预测|信号预测]]
* [[自适应反馈消除|自适应反馈消除]]（Adaptive Feedback Cancellation）

== 伪代码 ==
以下伪代码利用二阶自适应横向滤波器对一个加上噪声的正弦讯号进行滤波，可以用 Python 或 Matlab 实现。
'''
    t ← (0 TO 1 BY 0.0001)
    # 生成sin訊號
    s ← sin(t)
    size_s = LEN(s)
    # 生成雜訊
    n ← randn(size_s)
    # 將雜訊疊加至原sin訊號上
    x ← s + n
    w ← [0, 0.5]
    u ← 0.00026
    for i (1 TO 9999):
        y(i + 1) ← n(i: i+1) * w'
        e(i + 1) ← x(i + 1) - y(i + 1)
        w ← w + 2 * u * e(i + 1) * n(i: i + 1)
    ENDFOR
    plt.subplot(3, 1, 1)
    plt.plot(t, x)
    plt.title("sin + noise")
    plt.subplot(3, 1, 1)
    plt.plot(t, x)
    plt.title("sin")
    plt.subplot(3, 1, 1)
    plt.plot(t, x)
    plt.title("Filtered result")
    plt.show()
'''

==滤波器实现==
*[[最小均方滤波器|最小均方滤波器]]
*{{Tsl|en|Recursive least squares filter|递归最小平方滤波器}}

==参考文献==

* Monson H. Hayes ''Statistical Digital Signal Processing and Modeling,'' Wiley, 1996, ISBN 0-471-59431-8
* Simon Haykin ''Adaptive Filter Theory,'' Prentice Hall, 2002, ISBN 0-13-048434-2

==参见==
*[[卡尔曼滤波器|卡尔曼滤波器]]
*[[维纳滤波|维纳滤波]]
*[[线性预测|线性预测]]
*[[电子滤波器|电子滤波器]]

[[Category:数字信号处理|Category:数字信号处理]]
[[Category:非线性滤波器|Category:非线性滤波器]]