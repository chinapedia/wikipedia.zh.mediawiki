{{noteTA
|G1 = IT
}}

{{Infobox programming language
 | name                   = Haskell
 | title                  =
 | logo                   = File:Haskell-Logo.svg
 | logo caption           = 
 | screenshot             = 
 | screenshot caption     = 
 | paradigm               = [[纯函数式编程|纯函数式]]
 | family                 = 
| released = {{start date and age|df=yes|1990}}{{sfn|Hudak|Hughes|Peyton Jones|Wadler|2007}}
| designer = {{en-link|Lennart Augustsson|}}, Dave Barton, Brian Boutel, Warren Burton, Joseph Fasel, Kevin Hammond, Ralf Hinze, [[保罗·胡达客|保罗·胡达客]], {{en-link|John Hughes|John Hughes (computer scientist)|John Hughes}}, Thomas Johnsson, Mark Jones, [[西蒙·佩頓·瓊斯|西蒙·佩頓·瓊斯]], {{en-link|John Launchbury|}}, {{en-link|Erik Meijer|Erik Meijer (computer scientist)|Erik Meijer}}, John Peterson, Alastair Reid, Colin Runciman, [[菲利普·瓦德勒|菲利普·瓦德勒]]
| developer = 
| latest release version = <!-- Of language specification, not [[Haskell_Platform|Haskell Platform]]! -->Haskell 2010<ref name="2010ann">{{cite mailing list |url=http://www.haskell.org/pipermail/haskell/2009-November/021750.html |title=Announcing Haskell 2010 |date=24 November 2009 |access-date=12 March 2011 |mailing-list=Haskell |last=Marlow |first=Simon |archive-date=2015-02-13 |archive-url=https://web.archive.org/web/20150213025809/https://www.haskell.org/pipermail/haskell/2009-November/021750.html }}</ref>
| latest release date = {{start date and age|df=yes|2010|07}}
| latest test version = Haskell 2020 announced<ref name="2020committee">{{cite mailing list |url=https://mail.haskell.org/pipermail/haskell-prime/2016-April/004050.html |title=ANN: Haskell Prime 2020 committee has formed |date=28 April 2016 |access-date=6 May 2017 |mailing-list=Haskell-prime |last=Riedel |first=Herbert |archive-date=2016-06-11 |archive-url=https://web.archive.org/web/20160611031104/https://mail.haskell.org/pipermail/haskell-prime/2016-April/004050.html }}</ref>
| latest test date = 
 
 | typing = [[类型推论|推论]], [[静态类型|静态]], [[强类型|强类型]]
| frequently updated     = <!-- yes/no -->
 | scope                  = 
 | implementations        = {{tsl|en|Glasgow Haskell Compiler||GHC}}, {{tsl|en|Hugs||Hugs}}, [http://www.cs.york.ac.uk/fp/nhc98/ NHC], [http://repetae.net/john/computer/jhc/ JHC], [http://www.cs.york.ac.uk/~ndm/yhc/ Yhc]
 | dialects               = 
| influenced by = [[Clean_(编程语言)|Clean]],<ref name="haskell-report-influences">{{harvnb|Peyton Jones|2003|p=xi}}</ref> [[FP_(编程语言)|FP]],<ref name="haskell-report-influences"/> {{en-link|Gofer (编程语言)|Gofer (programming language)|Gofer}},<ref name="haskell-report-influences"/> [[Hope_(编程语言)|Hope]]和Hope<sup>+</sup>,<ref name="haskell-report-influences"/> {{en-link|Id (编程语言)|Id (programming language)|Id}},<ref name="haskell-report-influences"/> [[ISWIM|ISWIM]],<ref name="haskell-report-influences"/> [[肯特递归计算器|KRC]],<ref name="haskell-report-influences"/> [[Lisp|Lisp]],<ref name="haskell-report-influences"/> [[Miranda_(编程语言)|Miranda]],<ref name="haskell-report-influences"/> [[ML语言|ML]]和[[Standard_ML|Standard ML]],<ref name="haskell-report-influences"/> {{en-link|Orwell (编程语言)|Orwell (programming language)|Orwell}}, [[SASL_(编程语言)|SASL]],<ref name="haskell-report-influences"/> [[Scheme|Scheme]],<ref name="haskell-report-influences"/> [[SISAL|SISAL]]<ref name="haskell-report-influences"/>
| influenced = [[Agda|Agda]],<ref>{{cite web|url=http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf|title=Dependently Typed Programming in Agda|last=Norell|first=Ulf|year=2008|publisher=Chalmers University|access-date=9 February 2012|location=Gothenburg|archive-date=2014-04-01|archive-url=https://web.archive.org/web/20140401144502/http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf}}</ref> {{en-link|Bluespec}},{{sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp=12–38, 43}} [[C++11|C++11]]/[[概念_(C++)|Concepts]],<ref>{{cite journal|title=Design of Concept Libraries for C++ |first1=Bjarne |last1=Stroustrup |author-link1=Bjarne Stroustrup |first2=Andrew |last2=Sutton |url=http://www2.research.att.com/~bs/sle2011-concepts.pdf |year=2011 |archive-url=https://web.archive.org/web/20120210041742/http://www2.research.att.com/~bs/sle2011-concepts.pdf |archive-date=10 February 2012 }}</ref> [[C♯|C#]]/[[语言集成查询|LINQ]],{{sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp=12-45–46}}<ref name="meijer2012"/><ref>{{cite web|url=http://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/|title=C9 Lectures: Dr. Erik Meijer – Functional Programming Fundamentals, Chapter 1 of 13|last=Meijer|first=Erik|date=1 October 2009|work=[[Channel_9_(discussion_forum)|Channel 9]]|publisher=Microsoft|access-date=9 February 2012|archive-date=2012-06-16|archive-url=https://web.archive.org/web/20120616051226/http://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/}}</ref><ref>{{cite news|url=http://www.infoq.com/interviews/LINQ-Erik-Meijer|title=Erik Meijer on LINQ|last=Drobi|first=Sadek|date=4 March 2009|work=InfoQ|publisher=C4Media Inc.|access-date=9 February 2012|location=QCon [[San_Francisco|SF]] 2008|archive-date=2021-01-26|archive-url=https://web.archive.org/web/20210126191443/https://www.infoq.com/interviews/LINQ-Erik-Meijer/}}</ref> Cayenne,{{sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp=12-45–46}} [[Clean_(编程语言)|Clean]],{{sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp=12-45–46}} [[Clojure|Clojure]],<ref>{{cite web |url=https://www.amazon.com/gp/richpub/listmania/fullview/R3LG3ZBZS4GCTH |archive-url=https://web.archive.org/web/20171003001051/https://www.amazon.com/gp/richpub/listmania/fullview/R3LG3ZBZS4GCTH |archive-date=3 October 2017 |title=Clojure Bookshelf |last=Hickey |first=Rich |work=Listmania! |access-date=3 October 2017}}</ref> [[CoffeeScript|CoffeeScript]],<ref>{{cite news |last1=Heller |first1=Martin |date=2011-10-18 |url=https://www.infoworld.com/article/2078452/turn-up-your-nose-at-dart-and-smell-the-coffeescript.html |title=Turn up your nose at Dart and smell the CoffeeScript |work=[[InfoWorld|InfoWorld]] |access-date=2020-07-15 |archive-date=2021-01-25 |archive-url=https://web.archive.org/web/20210125073315/https://www.infoworld.com/article/2078452/turn-up-your-nose-at-dart-and-smell-the-coffeescript.html }}</ref> [[Curry_(程式语言)|Curry]],{{sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp=12-45–46}} [[Elm_(编程语言)|Elm]], {{en-link|Escher (编程语言)|Escher (programming language)|Escher}},<ref>{{cite web|url=http://www.cs.bris.ac.uk/Publications/Papers/1000073.pdf|title=Declarative programming in Escher|access-date=7 October 2015|archive-date=2016-03-03|archive-url=https://web.archive.org/web/20160303194047/http://www.cs.bris.ac.uk/Publications/Papers/1000073.pdf}}</ref> [[F♯|F#]],<ref>{{cite book|last1=Syme|first1=Don|author-link1=Don Syme|last2=Granicz|first2=Adam|last3=Cisternino|first3=Antonio|title=Expert F#|year=2007|publisher=[[Apress|Apress]]|page=2 |quote=F# also draws from Haskell particularly with regard to two advanced language features called ''sequence expressions'' and ''workflows''.}}</ref> Frege,<ref>{{cite web|last=Wechsung|first=Ingo|title=The Frege Programming Language|url=http://www.frege-lang.org/doc/Language.pdf|access-date=26 February 2014|archive-date=2021-02-13|archive-url=https://web.archive.org/web/20210213010641/http://www.frege-lang.org/doc/Language.pdf}}</ref> [[Hack_(程式语言)|Hack]],<ref>{{cite journal|url=https://www.wired.com/2014/03/facebook-hack/|title=Facebook Introduces 'Hack,' the Programming Language of the Future|date=20 March 2014|journal=WIRED|access-date=2021-02-28|archive-date=2014-03-28|archive-url=https://web.archive.org/web/20140328124125/http://www.wired.com/wiredenterprise/2014/03/facebook-hack}}</ref> [[Idris|Idris]],<ref>{{cite web|title=Idris, a dependently typed language|url=http://www.idris-lang.org/|access-date=26 October 2014|archive-date=2021-05-11|archive-url=https://web.archive.org/web/20210511212437/https://www.idris-lang.org/}}</ref> [[Isabelle|Isabelle]],{{sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp=12-45–46}} [[Java|Java]]/{{en-link|Generics in Java|Generics in Java|Generics}},{{sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp=12-45–46}} {{en-link|LiveScript}},<ref>{{cite web|url=http://livescript.net/#inspiration|title=LiveScript Inspiration|access-date=4 February 2014|archive-date=2021-05-21|archive-url=https://web.archive.org/web/20210521025244/http://livescript.net/#inspiration}}</ref> [[Mercury_(编程语言)|Mercury]],{{sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp=12-45–46}} [[PureScript|PureScript]],<ref>{{cite web|url=https://leanpub.com/purescript/read|title=PureScript by Example|last=Freeman|first=Phil|year=2016|publisher=Leanpub|access-date=23 April 2017|archive-date=2020-11-29|archive-url=https://web.archive.org/web/20201129082048/https://leanpub.com/purescript/read}}</ref> [[Python|Python]],{{sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp=12-45–46}}<ref>{{cite web|url=https://docs.python.org/howto/functional.html|title=Functional Programming HOWTO|last=Kuchling|first=A. M.|work=Python v2.7.2 documentation|publisher=Python Software Foundation|access-date=9 February 2012|archive-date=2012-10-24|archive-url=https://web.archive.org/web/20121024163217/http://docs.python.org/howto/functional.html}}</ref> [[Raku|Raku]],<ref>{{cite web|url=http://www.perlfoundation.org/perl6/index.cgi?glossary_of_terms_and_jargon|title=Glossary of Terms and Jargon|work=Perl Foundation Perl 6 Wiki|publisher=[[The_Perl_Foundation|The Perl Foundation]]|access-date=9 February 2012|archive-url=https://web.archive.org/web/20120121145808/http://www.perlfoundation.org/perl6/index.cgi?glossary_of_terms_and_jargon|archive-date=21 January 2012}}</ref> [[Rust|Rust]],<ref>{{cite web|url=https://doc.rust-lang.org/reference/influences.html|access-date=3 February 2016|title=The Rust Reference: Appendix: Influences|archive-date=2019-01-26|archive-url=https://web.archive.org/web/20190126051127/https://doc.rust-lang.org/reference/influences.html}}</ref> [[Scala|Scala]],{{sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp=12-45–46}}<ref>{{cite web|url=http://blog.fogus.me/2010/08/06/martinodersky-take5-tolist/|title=MartinOdersky take(5) toList|last=Fogus|first=Michael|date=6 August 2010|work=Send More Paramedics|access-date=9 February 2012|archive-date=2012-02-14|archive-url=https://web.archive.org/web/20120214225555/http://blog.fogus.me/2010/08/06/martinodersky-take5-tolist/}}</ref> [[Swift_(程式语言)|Swift]],<ref name="lattner2014">{{cite web|url=http://nondot.org/sabre/|title=Chris Lattner's Homepage|last=Lattner|first=Chris|date=3 June 2014|access-date=3 June 2014|publisher=Chris Lattner|quote=The Swift language is the product of tireless effort from a team of language experts, documentation gurus, compiler optimization ninjas, and an incredibly important internal dogfooding group who provided feedback to help refine and battle-test ideas. Of course, it also greatly benefited from the experiences hard-won by many other languages in the field, drawing ideas from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list.|archive-date=2018-12-25|archive-url=https://web.archive.org/web/20181225131628/http://nondot.org/sabre/}}</ref> Timber,<ref>{{cite web|url=http://www.timber-lang.org/index_histcred.html|title=Timber/History|access-date=7 October 2015|archive-date=2020-10-31|archive-url=https://web.archive.org/web/20201031165644/http://www.timber-lang.org/index_histcred.html}}</ref> [[Visual_Basic_.NET|Visual Basic 9.0]]{{sfn|Hudak|Hughes|Peyton Jones|Wadler|2007|pp=12-45–46}}<ref name="meijer2012">{{cite journal|author-link=Erik Meijer (computer scientist)|first=Erik|last=Meijer|title=Confessions of a Used Programming Language Salesman: Getting the Masses Hooked on Haskell|journal=Oopsla 2007|year=2006}}</ref>
 | programming language   = 
 | platform               = 
 | operating system       = 
 | license                = 
 | file ext               = <code>.hs</code>, <code>.lhs</code>
 | fileformat             = 
 | website                = {{url|www.haskell.org}}
 | wikibooks              = 
}}

'''Haskell'''（{{pron-en|ˈhæskəl}}）<ref>{{cite mailing list |url=http://www.haskell.org/pipermail/haskell-cafe/2008-January/038756.html |title=anybody can tell me the pronuncation of "haskell"? |date=28 January 2008 |accessdate=12 March 2011 |mailinglist=Haskell-cafe |last=Chevalier |first=Tim |archive-date=2012-03-06 |archive-url=https://web.archive.org/web/20120306192821/http://www.haskell.org/pipermail/haskell-cafe/2008-January/038756.html |dead-url=yes }}</ref>是一种标准化的，通用的[[纯函數式編程語言|纯函數式編程語言]]，有[[惰性求值|惰性求值]]和[[强类型|强]][[类型系统|静态]]类型<ref>Haskell Report</ref>。它的命名源自美国[[逻辑学家|逻辑学家]][[哈斯凱爾·加里|哈斯凱爾·加里]]，他在数理逻辑方面上的工作使得函数式编程语言有了广泛的基础。在Haskell中，“函数是[[頭等物件|頭等物件]]”<ref>{{cite journal |last=Burstall|first=Rod |year=2000 |title=Christopher Strachey—Understanding Programming Languages |journal=Higher-Order and Symbolic Computation|volume=13|issue = 52 }}</ref>。作为一门[[函數程式語言|函數程式語言]]，主要控制结构是[[函数|函数]]。Haskell语言是1990年在编程语言Miranda的基础上标准化的，并且以[[λ演算|λ演算]]为基础发展而来。这也是为什么Haskell语言以[[希腊字母|希腊字母]]「λ」（Lambda）作为自己的标志。Haskell具有“[[柯里-霍华德同构|证明即程序、命题为类型]]”的特征<ref>{{cite book |last1=Curry | first1 = Haskell | title=Proceedings of the National Academy of Sciences | chapter=Functionality in Combinatory Logic | year=1934  | volume=20 | pages = 584–590 }}</ref><ref name="CurryFeys_paragraph9E">{{cite book | last1=Curry | first1=Haskell B. | last2=Feys | first2=Robert |title=Combinatory Logic Vol. I | publisher=North-Holland | location=Amsterdam | year=1958 | editor1-last=Craig | editor1-first=William}}, with 2 sections by William Craig, see paragraph 9E</ref><ref>{{cite journal |last=De Bruijn |first=Nicolaas|year=1968|title=Automath, a language for mathematics|journal=TH-report 68-WSK-05 |publisher=Department of Mathematics, Eindhoven University of Technology}} Reprinted in revised form, with two pages commentary, in: {{Cite book|title=Automation and Reasoning |volume=2 |year=1983|publisher=Springer Verlag|pages=159–200|chapter=Classical papers on computational logic 1967-1970 }}</ref><ref>{{Cite book | last1=Howard | first1=William A.
 | chapter=The formulae-as-types notion of construction
 | pages=479–490
 | editor1-last=Seldin | editor1-first=Jonathan P.
 | editor1-link=Jonathan P. Seldin
 | editor2-last=Hindley | editor2-first=J. Roger
 | editor2-link=J. Roger Hindley
 | title=To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism
 | origyear=original paper manuscript from 1969
 | publisher={{tsl|en|Academic Press||Academic Press}} | location=Boston, MA |ISBN = 978-0-12-349050-6  |date = 1980年9月 }}.</ref>。

==历史==
1985年，[[Miranda_(编程语言)|Miranda]]发行后，[[惰性求值|惰性]][[函数式语言|函数式语言]]的关注度增长。到1987年前，出现了十多种[[非限定性|非限定性]]、纯函数式语言。其中，Miranda使用的最为广泛，但还没有出现在公共领域。在[[俄勒冈|俄勒冈]][[波特兰|波特兰]]的函数式编程语言与计算机结构大会（FPCA '87）上，参加者一致同意形成一个委员会来为这样的语言定义一种[[开放性标准|开放性标准]]。该委员会旨在整合已有[[函数式语言|函数式语言]]，作为将来的函数式语言设计研究工作的基础。<ref name="Pref98">{{cite book|url=http://haskell.org/onlinereport/preface-jfp.html|title=Haskell 98 Language and Libraries: The Revised Report|chapter=Preface|date=December 2002|access-date=2012-08-26|archive-date=2012-08-23|archive-url=https://web.archive.org/web/20120823182159/http://www.haskell.org/onlinereport/preface-jfp.html|dead-url=yes}}</ref>

===Haskell 1.0至1.4===
能够确使[[类型安全|类型安全]]的[[运算符重载|运算符重载]]的[[类型类|类型类]]，是由[[Philip_Wadler|Philip Wadler]]和Stephen Blott最初为[[Standard_ML|Standard ML]]提议的，但首先在Haskell中于1987年至版本1.0期间实现<ref>"Type classes, first proposed during the design of the Haskell programming language, ..." —[https://jgbm.github.io/pubs/morris-dissertation.pdf John Garrett Morris (2013), "Type Classes and Instance Chains: A Relational Approach"] {{Wayback|url=https://jgbm.github.io/pubs/morris-dissertation.pdf |date=20201104014848 }}</ref><ref>{{Cite web|url=https://www.researchgate.net/publication/2710954|title=How to make ad-hoc polymorphism less ad hoc|last=Wadler|first=Philip|date=October 1988}}</ref>。

1990年定义了Haskell的第一个版本（“Haskell 1.0”）。<ref>{{cite journal
| first1 = Paul
| last1 = Hudak
| authorlink1 = Paul Hudak
| first2 = John
| last2 = Hughes
| authorlink2 = John Hughes（computer scientist）
| first3 = Simon
| last3 = Peyton Jones
| authorlink3 = Simon Peyton Jones
| first4 = Philip
| last4 = Wadler
| authorlink4 = Philip Wadler
| title = A history of Haskell: being lazy with class
| url = https://archive.org/details/historyprogrammi03ryde
| doi = 10.1145/1238844.1238856
| year = 2007
| journal = Proceedings of the third ACM SIGPLAN conference on History of programming languages（HOPL III）
| pages = [https://archive.org/details/historyprogrammi03ryde/page/n384 12]–1–12–55
| isbn = 978-1-59593-766-7
}}</ref>委员会形成了一系列的语言定义（1.0，1.1，1.2，1.3，1.4）。

[[File:Base-classes.svg|thumb]]层级。包括了Foldable和Traversable（相应的改变了一些函数的类型签名），和作为[[函子_(函数式编程)|Functor]]与[[单子_(函数式编程)|Monad]]中介的[[应用式函子|Applicative]]，它们出自Haskell 2010标准。]]

===Haskell 98===
1997年底，该系列形成了'''Haskell 98'''，旨在定义一个稳定、最小化、可移植的语言版本以及相应的标准库，以用于教学和作为将来扩展的基础。委员会明确欢迎创建各种增加或集成实验性特性的Haskell 98的扩展和变种。<ref name=Pref98/>

1999年2月，Haskell 98语言标准公布，名为《The Haskell 98 Report》。<ref name=Pref98/>2003年1月，《Haskell 98 Language and Libraries: The Revised Report》公布。<ref name="RevisedReport">{{cite web|url=http://haskell.org/onlinereport/|title=Haskell 98 Language and Libraries: The Revised Report|author=Simon Peyton Jones (editor)|authorlink=Simon Peyton Jones|date=December 2002|accessdate=2012-08-26|archive-date=2012-05-18|archive-url=https://web.archive.org/web/20120518173132/http://www.haskell.org/onlinereport/|dead-url=no}}</ref>接着，{{tsl|en|Glasgow Haskell Compiler||Glasgow Haskell Compiler (GHC)}}实现了当时的事实标准，Haskell快速发展。

===Haskell Prime===
2006年早期，开始了定义Haskell 98标准后续的进程，非正式命名为'''Haskell Prime'''。<ref>{{cite web|url=http://hackage.haskell.org/trac/haskell-prime|title=Welcome to Haskell'|work=The Haskell' Wiki|deadurl=yes|archiveurl=https://web.archive.org/web/20090423011944/http://hackage.haskell.org/trac/haskell-prime/|archivedate=2009年4月23日|df=|accessdate=2012年8月26日}}</ref>这是个修订语言定义的不断增补的过程，每年产生一个新的修订版。第一个修订版于2009年11月完成、2010年7月发布，称作'''Haskell 2010'''。

===Haskell 2010===
Haskell 2010加入了外部函数接口（{{tsl|en|Foreign Function Interface||Foreign Function Interface}}，FFI）允许绑定到其它编程语言，修正了一些[[语法|语法]]问题（在正式语法中的改动）并废除了称为“n加k模式”（换言之，不再允许形如<code>fact (n+1) = (n+1) * fact n</code>的定义）。引入了语言级编译选项语法扩展（Language-Pragma-Syntax-Extension），使得在Haskell源代码中可以明确要求一些扩展功能。Haskell 2010引入的这些扩展的名字是DoAndIfThenElse、HierarchicalModules、EmptyDataDeclarations、FixityResolution、ForeignFunctionInterface、LineCommentSyntax、PatternGuards、RelaxedDependencyAnalysis、LanguagePragma、NoNPlusKPatterns。

==特性==
Haskell是现有的一门开放的、已发布标准的，且有多种实现的语言。<ref name=RevisedReport/>支持[[惰性求值|惰性求值]]、[[模式匹配|模式匹配]]、[[列表解析|列表解析]]、[[类型类|类型类]]和[[类型多态|类型多态]]。它是一门[[纯函数式编程语言|纯函数式编程语言]]，这意味着大体上，Haskell中的函数没有[[函数副作用|副作用]]。Haskell用特定的类型来表达副作用，该类型与函数类型相互独立。纯函数可以操作并返回可执行的副作用的类型，但不能够执行它们，只有用于表达副作用的类型才能执行这些副作用，Haskell以此表达其它语言中的非纯函数。

Haskell拥有一个基于Hindley-Milner[[类型推论|类型推论]]的[[类型系统|静态]]、[[强类型|强类型]]系统。Haskell在此领域的主要创新就是加入了[[类型类|类型类]]，原本设想作为重载的主要方式，<ref name="wadler89">{{cite journal|last1=Wadler|first1=P.|first2=S. |last2=Blott|year=1989|title=How to make ad-hoc polymorphism less ad hoc|journal=Proceedings of the 16th ACM {{tsl|en|SIGPLAN||SIGPLAN}}-{{tsl|en|SIGACT||SIGACT}} {{tsl|en|Symposium on Principles of Programming Languages||Symposium on Principles of Programming Languages}}|publisher=[[计算机协会|ACM]]|pages=60–76|doi=10.1145/75277.75283|isbn=0-89791-294-2}}</ref>在之后发现了更多用途。<ref name="hallgren01">{{cite journal|last=Hallgren|first=T.|date=January 2001|title=Fun with Functional Dependencies, or Types as Values in Static Computations in Haskell|journal=Proceedings of the Joint CS/CE Winter Meeting|location=Varberg, Sweden|url=http://www.cs.chalmers.se/~hallgren/Papers/wm01.html|access-date=2012-08-26|archive-date=2010-03-29|archive-url=https://web.archive.org/web/20100329041418/http://www.cs.chalmers.se/~hallgren/Papers/wm01.html|dead-url=no}}</ref>

Haskell的主要实现{{tsl|en|Glasgow Haskell Compiler||GHC}}是个[[解释器|解释器]]，也是个原生代码[[编译器|编译器]]。它可以在大多数平台运行，GHC在并发和并行上具有高性能的实现能力，<ref name="shootout">{{Cite web |url=http://shootout.alioth.debian.org/ |title=Computer Language Benchmarks Game |accessdate=2012-08-26 |archive-date=2018-05-29 |archive-url=https://web.archive.org/web/20180529203516/http://shootout.alioth.debian.org/ |dead-url=yes }}</ref>也有丰富的类型系统，如[[广义代数数据类型|广义代数数据类型]]和类型族（Type Families）。

[[单子_(函数式编程)|单子]]是一个[[抽象資料型別|抽象類型]]，可以表达不同种类的计算，包括[[异常处理|异常处理]]、[[非确定性|非确定性]]、[[语法分析|语法分析]]以及[[软件事务内存|软件事务内存]]，其中一个应用是用于表达副作用的类型。单子定义为普通的数据类型，同时Haskell也为其提供了几种[[语法糖|语法糖]]。

Haskell有一个活跃的社区，在线上包仓库Hackage上有豐富的第三方开源库或工具。<ref name="hackage-stats">{{cite web |url=http://hackage.haskell.org/cgi-bin/hackage-scripts/stats |title=存档副本 |accessdate=2013-06-26 |deadurl=yes |archiveurl=https://web.archive.org/web/20130503114836/http://hackage.haskell.org/cgi-bin/hackage-scripts/stats |archivedate=2013-05-03 }}</ref>

== 语法 ==
===数据类型===
Haskell是强类型语言。
Char的字面值用单引号围起；
字符串即[Char]类型，其字面值用双引号括起来。
Int通常为32位整型
Integer是无界整型
Float 表示单精度的浮点数
Double 表示双精度的浮点数
Bool 只有两种值：True 和 False。
====List====
使用[ ]与逗号分隔符，定义一个list的实例。其元素必须具有相同类型。字符串是list的特例。用:把元素与list、其他元素连接（cons）起来。:是右结合的运算符。[1,2,3] 实际上是 1:2:3:[] 的语法糖。两个 List 合并通过 ++ 运算子实现。按照索引取得 List 中的元素，可以使用 !! 运算子，索引的下标为 0。List 中的 List 可以是不同长度，但必须得是相同的型别。['K'..'Z']这样的Range方法快捷定义一个List。[2,4..20]用法给出了Range的第一、第二、最后一个元素。使用 > 和 >= 可以比较 List 的大小。它会先比较第一个元素，若它们的值相等，则比较下一个，以此类推。List常用的函数:
* head 返回一个 List 的头部，也就是 List 的首个元素。
* tail 返回一个 List 的尾部，也就是 List 除去头部之后的部分。
* last 返回一个 List 的最后一个元素。
* init 返回一个 List 除去最后一个元素的部分。
* length 返回一个 List 的长度。
* null 检查一个 List 是否为空。如果是，则返回 True，否则返回 False。
* reverse 将一个 List 反转
* take 返回一个 List 的前几个元素。例如take 24 [13,26..]取前24个13的倍数
* drop 删除一个 List 中的前几个元素
* maximum 返回一个 List 中最大的元素。
* minimun 返回最小的元素。
* sum 返回一个 List 中所有元素的和。
* product 返回一个 List 中所有元素的积。
* elem 判断一个元素是否在包含于一个 List，通常以中缀函数的形式调用
* replicate 得到包含相同元素的 List 。例如：replicate 3 10，得 [10,10,10]。
* repeat 产生一个元素的无限重复的List
* cycle 接受一个 List 做参数并返回一个无限 List 

list comprehension是指基于一个List，按照规则产生一个新List，例如：[x*2 | x <- [1..10], x*2 >= 12]
====Tuple====
使用( )与逗号分隔符，定义一个tuple的实例。其元素可以使不同类型，但个数是固定的。

Tuple的类型取决于其中项的数目与其各自元素的类型。单元素的 Tuple 被禁止。

*fst 返回一个序对的首项。
*snd 返回序对的尾项
*zip 取两个 List作为参数，然后将它们依次配对，形成一组序对的 List。

=== 运算符===
基本类似于C语言。但使用not表示逻辑非。
  +  -  *  /  ^    -- 加、減、乘、除、指數
  mod              -- 取餘數
  $                -- 也是表示函數作用的, 但它的優先級最低, 而且作用次序是從右向左的
  ++               -- 兩個List的連接
  .                 -- 函數的複合
  && ||  ==  /=     -- 與、或、等於、不等於
  <=  >=  <  >      -- 小於等於、大於等於、小於、大於
  : //  =  @        -- 一個元素連接List、
  ->               -- 函數類型描述，運算符左邊為參數類型，右邊為結果類型。為右结合。例如：addThree :: Int -> Int -> Int -> Int 
  =>               -- 運算符的左邊表示一個類型變量（通常為單個小寫字母）屬於一個類型類（Typeclass），相當於C++語言的模板參數類型
  ..               -- List的Range限定
  ::               -- 函數/表達式的類型特徵，左側為函數/表達式，右側為類型
  <-             -- List comprehension 的條件限定
  !!             -- 取List的第某個元素，下標從0開始

基本的 Typeclass：
* Eq 可判断相等性的type 
* Ord 可比较大小的type 
* Show 可表示为字符串的type 
* Read 可从字符串转换出值的type  
* Enum 连续的，也就是可枚举的type。每个值都有后继 (successer) 和前置 (predecesor)，分别可以通过 succ 函数和 pred 函数得到。 
* Bounded 有上限和下限。例如：maxBound :: Char   或者  maxBound :: Bool   
* Num 数字 
* Integral  
* Floating

=== 表达式 ===
* let表达式：格式为 let [bindings] in [expressions] 。let 也可以定义局部函数 。在一行中设定多个名字的值，可用分号隔开。List Comprehension 中 let绑定的名字在输出函数及限制条件中都可见；忽略了 let 绑定的 in 部分，因为名字的可见性已经预先定义好了。
* if then else是表达式
* Case表达式：
  case expression of pattern -> result  
       pattern -> result  
       pattern -> result  
       ...  
=== 控制结构 ===
if then else是分段函数定义时的语法糖。与C语言不同，要求必须有else部分。类似于C语言分支语句的情形，叫做pattern matching，例子如下：
<syntaxhighlight lang="Haskell" line="1">
pts :: Int -> Int
pts 1 = 10
pts 2 = 6
pts x
    | x <= 6    = 7 - x
    | otherwise = 0

(||) :: Bool -> Bool -> Bool  -- 或操作的类型与定义
True  || _ = True             -- 第二个参数是任何值都匹配。 
False || y = y
</syntaxhighlight>

=== 函数 ===
* 函数调用有最高运算顺序，例如<code>succ 9*10</code>表示<code>(succ 9)*10</code>。
* 函数的调用使用空格符而不是括号。
* 函数的复合调用是左结合
* 首字母大写的函数是不允许的
* 两个参数的函数的调用可以写成中缀形式： param1 `funcName` param2
* 运算符可以用括号围起来，作为前缀形式：(+) 2 3 的结果为5
* 在 ghci 下，我们可以使用 ``let`` 关键字来定义一个常量。在 ghci 下执行 ``let a=1`` 与在脚本中编写 ``a=1`` 是等价的。

<syntaxhighlight lang="Haskell" line="1">
--funcName arguments = expression  --定义函数的一般形式
area r = pi * r ^ 2 -- 定义了一个函数
area 101 -- 调用了函数
f1 f2 3.14 -- 函数调用是左结合，等效于(f1 f2) 3.14

--模式匹配方式定义
factorial :: (Integral a) => a -> a  
factorial 0 = 1  
factorial n = n * factorial (n - 1)   

--as模式，是将一个名字和 @ 置于模式前，可以在按模式分割参数值时仍保留对其整体的引用。如nameGlobal@(x:y:ys)，nameGlobal会匹配出与 x:y:ys 对应的东西。as模式在较大的模式中保留对整体的引用，从而减少重复性的工作。

heron a b c = sqrt (s * (s - a) * (s - b) * (s - c))
    where                     -- where在表达式中局部绑定了名字s与一个值。也可以在表达式之前用let ... in语法
    s = (a + b + c) / 2

absolute x                 -- 绝对值函数，使用了分段函数语法糖（称作Guards）
    | x < 0     = 0 - x
    | otherwise = x        -- 兜底条件

bmiTell :: (RealFloat a) => a -> a -> String  
bmiTell weight height  
    | bmi <= 18.5 = "You're underweight."  
    | bmi <= 25.0 = "You're normal. "  
    | bmi <= 30.0 = "You're fat."  
    | otherwise   = "You're overweight."  
    where bmi = weight / height ^ 2  -- 使用where定义多个名字来避免重复

--where也可以用模式匹配
initials :: String -> String -> String  
initials firstname lastname = [f] ++ ". " ++ [l] ++ "."  
    where (f:_) = firstname  
          (l:_) = lastname  

--where可以定义函数。在定义一个函数的时候也写几个辅助函数摆在 where 绑定中。 而每个辅助函数也可以透过 where 拥有各自的辅助函数。
calcBmis :: (RealFloat a) => [(a, a)] -> [a]  
calcBmis xs = [bmi w h | (w, h) <- xs] 
    where bmi weight height = weight / height ^ 2  

funcName :: type1 -> type2 -> type3 -- 其中，::表示类型特征(type signature)，->是右结合，这里等效于type1 -> (type2->type3)，给定一个type1的输入参数，返回一个函数(type2->type3)

f1 = (absolute .  area)   -- 函数复合运算符是 . (function composition operator)
</syntaxhighlight>

多态类型(Polymorphic types)类似于C++的模板。例如，算术加法：
<syntaxhighlight lang="Haskell" line="1">
 (+) :: (Num a) => a -> a -> a -- Num是typeclass。 =>表示signature restricts 
</syntaxhighlight>

===lambda函数===
lambda 就是匿名函数。写法是：一个 \ (因为它看起来像是[[希腊字母|希腊字母]][[Λ|λ]])，后面是用空格分隔的参数，-> 后面是函数体。通常用括号将括起lambda函数，否则它会占据整个右边部分。

例如：(\a b -> (a * 30 + 3) / b)

可以在 lambda 中使用模式匹配，但无法为一个参数设置多个模式，如 [] 和 (x:xs)并用。

使用 lambda 可以更明确地表现出值是个函数，可以用来传递给其他函数作参数。
===高阶函数===
Haskell的所有函数实际上是单参数函数。多参数函数的写法实际上是[[Curry化|Curry化]]的语法糖。即 func a b等价于(func a) b

point free style (也称作 pointless style) 的函数，即通过柯里化 (Currying)省略掉单参数。例如：
<syntaxhighlight lang="Haskell">
 sum' :: (Num a) => [a] -> a     
 sum' xs = foldl (+) 0 xs   --等号的两端都有个 xs。 
 sum'   = foldl (+) 0     --柯里化 (Currying)，可以省掉两端的 xs。
</syntaxhighlight>

中缀运算符可以加括号变为单参数函数。如 (*3) 5 的值为15。 但(-5)表示负值，所以单参数函数需要写为(subtract 5)。

中缀运算符 $，可用于改变函数的调用次序，使其右边的表达式先计算出来。这可以减少一对括号使用。例如 f (g (z x)) 与 f $ g $ z x 等价。其定义是：
<syntaxhighlight lang="Haskell">
 ($) :: (a -> b) -> a -> b  
 f $ x = f x  
</syntaxhighlight>
$ 还可以将数据作为函数使用。例如：
<syntaxhighlight lang="Haskell">
 map ($ 3) [(4+),(10*),(^2),sqrt]
</syntaxhighlight>

中缀运算符 . 用于函数的复合，其定义是：
<syntaxhighlight lang="Haskell">
 (.) :: (b -> c) -> (a -> b) -> a -> c  
 f . g = \x -> f (g x)
</syntaxhighlight>

===异常处理===
提供了处理异常的函数{{code|lang=Haskell|try}}、{{code|lang=Haskell|catch}}、{{code|lang=Haskell|finally}}/{{code|lang=Haskell|etc}}.  

<syntaxhighlight lang="haskell" line="1">
import Prelude hiding(catch)
import Control.Exception
instance Exception Int
instance Exception Double
main = do
  catch
    (catch
      (throw (42::Int))
      (\e-> print (0,e::Double)))
    (\e-> print (1,e::Int))
</syntaxhighlight>

输出结果

 (1,42)

类似于 C++

<syntaxhighlight lang="cpp" line="1">
#include <iostream>
using namespace std;
int main() {
    try {
        throw (int)42;
    } catch (double e) {
        cout << "(0," << e << ")" << endl;
    } catch (int e) {
        cout << "(1," << e << ")" << endl;
    }
}
</syntaxhighlight>

另外一个例子：

<syntaxhighlight lang="haskell" line="1">
do {
  -- Statements in which errors might be thrown
} `catch` \ex -> do {
  -- Statements that execute in the event of an exception, with 'ex' bound to the exception
}
</syntaxhighlight>

如果仅有一个错误条件，{{code|lang=Haskell|Maybe}} 类足够用了，确省是Haskell的 {{code|lang=Haskell|Monad}} {{tsl|en|class||class}}. 更复杂的出错处理用{{code|lang=Haskell|Error}} 或{{code|lang=Haskell|ErrorT}} monads, 类似功能可用{{code|lang=Haskell|`catch`}}。

== 示例 ==

=== Haskell的函数结构 ===
如下是Haskell语言的[[Hello_World|"Hello world"]]，注意其中除最后一行外皆可省略。
<syntaxhighlight lang="Haskell" line="1">
module Main where

main :: IO ()
main = putStrLn "Hello, World!"
</syntaxhighlight>

如下是[[阶乘|阶乘]]函数的Haskell实现：

<syntaxhighlight lang="Haskell" line="1">
fac :: Int -> Int
fac 0 = 1
fac n = n * fac (n - 1)
</syntaxhighlight>

它将阶乘描述成有一个基本终止情形的递归函数。这跟数学定义中对阶乘的描述很相似。事实上，Haskell中很多的代码的语法与功能都和数学一致。

上面的递归函数的第一行是可选的，它描述了这个函数的'''型態'''（'''types'''）。它可以读作'''函数fac的型態為整數至整數（function fac has a int-to-int type）'''。这就是说，它以一个整型为参数，并且返回另一个整型。

第二行依赖的[[模式匹配|模式匹配]]，是Haskell程序中一个重要的部分。注意函数的参数是用空格分隔而不是在括号中。当函数的参数是0时，它会返回整型1。对于其他的情况则尝试第三行。这是一个[[递归|递归]]，它会一直执行只到满足基本的情形。负参数会导致无限递归，一个{{tsl|en|guard (computing)||guard}}保证第三行不会执行负参数。

"Prelude"是一个类似C中标准库的小函数集合。使用Prelude，并用无指定参数的写法，它可以改成：

<syntaxhighlight lang="Haskell" line="1">
fac = product . enumFromTo 1
</syntaxhighlight>

上面的定义接近于数学中的定义：''f = g <small>o</small> h''（参见[[复合函数|复合函数]]），这并不是一个对变量赋值的语句。

=== Haskell的高阶函数 ===

Haskell中可以定义高阶函数（Higher-order Function），既将函数作为一个参数来使用，也可以将函数作为结果输出，例如：

<syntaxhighlight lang="Haskell" line="1">
f :: (Int -> Int) ->(Int -> Int)
f g = \x -> g x + 5
</syntaxhighlight>

这里f就是一个高阶函数，它取一个从Int到Int的函数g作为参数，输出一个从Int到Int的函数。高阶函数的使用在一些情况下将极大的简化代码。

== Haskell的编译器 ==

* [http://www.haskell.org/hugs/ Hugs]{{Wayback|url=http://www.haskell.org/hugs/ |date=20060203013111 }}
* [http://www.haskell.org/ghc/ ghc (Glasgow Haskell Compiler)]{{Wayback|url=http://www.haskell.org/ghc/ |date=20060208085900 }}
* [http://www-users.cs.york.ac.uk/~ndm/yhc/ yhc (York Haskell Compiler)]{{Wayback|url=http://www-users.cs.york.ac.uk/~ndm/yhc/ |date=20060203214652 }}
* [http://www.haskell.org/nhc98/ nhc98]{{Wayback|url=http://www.haskell.org/nhc98/ |date=20060203001010 }}

== 参考文献 ==
{{Reflist|30em}}

== 外部連結 ==
* {{en}} [http://www.Haskell.org '''Haskell'''的官方主页]{{Wayback|url=http://www.haskell.org/ |date=20061011005609 }}
* {{en}} [http://Haskell.org/ HaskellWiki：'''Haskell'''社群主網站]{{Wayback|url=http://haskell.org/ |date=20060127230539 }}
* {{en}} [http://www.cse.unsw.edu.au/~cs1011/05s2/ UNSW的Haskell教程]{{Wayback|url=http://www.cse.unsw.edu.au/~cs1011/05s2/ |date=20070717111830 }}
* {{en}} [http://Haskell.org/haskellwiki/Humor Haskell笑話]{{Wayback|url=http://haskell.org/haskellwiki/Humor |date=20140731081743 }}
* {{en}} [https://web.archive.org/web/20070708210042/http://haskell.org/hawiki/ Haskell舊的討論主題]
* {{en}} [https://web.archive.org/web/20100619145645/http://haskell.org/papers/NSWC/jfp.ps Haskell vs. Ada vs. C++ vs. Awk vs. ......一個實驗性的前衛語言]（PostScript檔案）
* {{en}} [http://www.willamette.edu/~fruehr/haskell/evolution.html Haskell編程的變革]{{Wayback|url=http://www.willamette.edu/~fruehr/haskell/evolution.html |date=20070101192126 }} -- 一個輕快的Haskell編程風格總纜
* {{en}} [https://web.archive.org/web/20080915054919/http://haskell.readscheme.org/ 一個Haskell研究者的線上介紹]
* {{en}} [http://epolyglot.sourceforge.net/ ePolyglot -- 將Haskell、Python與Eiffel結合的語言]{{Wayback|url=http://epolyglot.sourceforge.net/ |date=20070108044857 }}
* {{en}} [http://web.mit.edu/ghc/www/hslibs/ Haskell函式庫]{{Wayback|url=http://web.mit.edu/ghc/www/hslibs/ |date=20070208020342 }}

=== 教學手冊 ===
{{wikibooks|Haskell}}
* {{en}}[http://www.cs.nott.ac.uk/~gmh/book.html 用Haskell寫程式]{{Wayback|url=http://www.cs.nott.ac.uk/~gmh/book.html |date=20070110212407 }}，Graham Hutton撰寫
* {{en}}[http://darcs.haskell.org/yaht/yaht.pdf 另一個Haskell教學手冊]{{Wayback|url=http://darcs.haskell.org/yaht/yaht.pdf |date=20090915035309 }} -- 由Hal Daume III所寫的好手冊，需要比官方教學手冊少的先備知識
* {{en}}[http://haskell.org/tutorial/ A Gentle Introduction to Haskell 98]{{Wayback|url=http://haskell.org/tutorial/ |date=20061011005414 }}（較高階的教學手冊，有[http://www.haskell.org/tutorial/haskell-98-tutorial.pdf PDF]{{Wayback|url=http://www.haskell.org/tutorial/haskell-98-tutorial.pdf |date=20061012011607 }}檔案）
* {{en}}[https://web.archive.org/web/20061011005150/http://www.haskell.org/~pairwise/intro/intro.html Haskell Tutorial for C Programmers]，Eric Etheridge撰寫
* {{en}}[http://www.haskell.org/haskellwiki/Category:Tutorials 在Haskell.org的教學手冊列表]{{Wayback|url=http://www.haskell.org/haskellwiki/Category:Tutorials |date=20061011015031 }}
* {{en}}[http://www.haskell.org/haskellwiki/Category:Idioms Haskell編程典範]{{Wayback|url=http://www.haskell.org/haskellwiki/Category:Idioms |date=20060830114516 }}
* {{zh-tw}}[http://learnyouahaskell-zh-tw.csie.org/ Haskell趣學指南]{{Wayback|url=http://learnyouahaskell-zh-tw.csie.org/ |date=20120621064324 }}
* {{zh-cn}}[http://wiki.jikexueyuan.com/project/haskell-guide/ Haskell趣學指南]{{Wayback|url=http://wiki.jikexueyuan.com/project/haskell-guide/ |date=20180821160610 }}
{{程序设计语言|Haskell}}

[[Category:静态类型编程语言|Category:静态类型编程语言]]
[[Category:函数式编程语言|Category:函数式编程语言]]
[[Category:模式匹配编程语言|Category:模式匹配编程语言]]
[[Category:学术的编程语言|Category:学术的编程语言]]
[[Category:1990年建立的程式語言|Category:1990年建立的程式語言]]